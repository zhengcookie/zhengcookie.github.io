<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Solidity汇编 | zhengcookie</title><meta name="author" content="zhengcookie"><meta name="copyright" content="zhengcookie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Solidity汇编Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。 内联汇编为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity汇编">
<meta property="og:url" content="https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/index.html">
<meta property="og:site_name" content="zhengcookie">
<meta property="og:description" content="Solidity汇编Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。 内联汇编为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250416170645.jpg">
<meta property="article:published_time" content="2025-07-10T13:32:30.000Z">
<meta property="article:modified_time" content="2025-10-01T04:54:48.494Z">
<meta property="article:author" content="zhengcookie">
<meta property="article:tag" content="区块链智能合约语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250416170645.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Solidity汇编",
  "url": "https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/",
  "image": "https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/微信图片_20250416170645.jpg",
  "datePublished": "2025-07-10T13:32:30.000Z",
  "dateModified": "2025-10-01T04:54:48.494Z",
  "author": [
    {
      "@type": "Person",
      "name": "zhengcookie",
      "url": "https://www.zhengcookie.site/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-fVYv9VWvzQ"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solidity汇编',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="zhengcookie" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/微信图片_20250416170645.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">zhengcookie</span></a><a class="nav-page-title" href="/"><span class="site-name">Solidity汇编</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Solidity汇编</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T13:32:30.000Z" title="发表于 2025-07-10 21:32:30">2025-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-01T04:54:48.494Z" title="更新于 2025-10-01 12:54:48">2025-10-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/07/10/Solidity%E6%B1%87%E7%BC%96/" data-flag-title="Solidity汇编"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Solidity汇编"><a href="#Solidity汇编" class="headerlink" title="Solidity汇编"></a>Solidity汇编</h1><p>Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。 由于 EVM 是基于栈的虚拟机，因此通常很难准确地定位栈内插槽（存储位置）的地址，并为操作码提供正确的栈内位置来获取参数。 Solidity 的内联汇编试图通过提供以下特性来解决这个问题以及手工编写汇编代码时可能出现的问题：</p>
<ul>
<li>函数风格操作码： <code>mul(1, add(2, 3))</code> 而不是 <code>push1 3 push1 2 add push1 1 mul</code></li>
<li>汇编局部变量： <code>let x := add(2, 3) let y := mload(0x40) x := add(x, y)</code></li>
<li>可以访问外部变量： <code>function f(uint x) public &#123; assembly &#123; x := sub(x, 1) &#125; &#125;</code></li>
<li>标签： <code>let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li>
<li>循环： <code>for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123; y := mul(2, y) &#125;</code></li>
<li>if 语句： <code>if slt(x, 0) &#123; x := sub(0, x) &#125;</code></li>
<li>switch 语句： <code>switch x case 0 &#123; y := mul(x, 2) &#125; default &#123; y := 0 &#125;</code></li>
<li>函数调用： <code>function f(x) -&gt; y &#123; switch x case 0 &#123; y := 1 &#125; default &#123; y := mul(x, f(sub(x, 1))) &#125;  &#125;</code></li>
</ul>
<p>现在我们详细讲解内联汇编语言。</p>
<p>警告</p>
<p>内联汇编是一种在底层访问以太坊虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性。</p>
<p>注解</p>
<p>TODO：写出在内联汇编中作用域规则的细微差别，以及在使用库合约的内部函数时产生的复杂性。此外，还要编写有关编译器定义的符号。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面例子展示了一个库合约的代码，它可以取得另一个合约的代码，并将其加载到一个 <code>bytes</code> 变量中。 这对于“常规 Solidity”来说是根本不可能的，汇编库合约则可以通过这种方式来增强语言特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 获取代码大小，这需要汇编语言</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // 分配输出字节数组 – 这也可以不用汇编语言来实现</span><br><span class="line">            // 通过使用 o_code = new bytes（size）</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // 包括补位在内新的“memory end”</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // 把长度保存到内存中</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // 实际获取代码，这需要汇编语言</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在优化器无法生成高效代码的情况下，内联汇编也可能更有好处。请注意，由于编译器无法对汇编语句进行相关的检查，所以编写汇编代码肯定更加困难； 因此只有在处理一些相对复杂的问题时才需要使用它，并且你需要明确知道自己要做什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // 因为目前的优化器在访问数组时无法移除边界检查，</span><br><span class="line">    // 所以这个函数的执行效率比较低。</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们知道我们只能在数组范围内访问数组元素，所以我们可以在内联汇编中不做边界检查。</span><br><span class="line">    // 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，</span><br><span class="line">    // 所以我们在访问数组元素时需要加入 0x20 作为偏移量。</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 和上面一样，但在内联汇编内完成整个代码。</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // 取得数组长度（前 32 字节）</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // 略过长度字段。</span><br><span class="line">           //</span><br><span class="line">           // 保持临时变量以便它可以在原地增加。</span><br><span class="line">           //</span><br><span class="line">           // 注意：对 _data 数值的增加将导致 _data 在这个汇编语句块之后不再可用。</span><br><span class="line">           //      因为无法再基于 _data 来解析后续的数组数据。</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // 迭代到数组数据结束</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, mul(len, 0x20)) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>和 Solidity 一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 <code>//</code> 和 <code>/* */</code> 来进行注释。 内联汇编程序由 <code>assembly &#123; ... &#125;</code> 来标记，在这些大括号内可以使用以下内容（更多详细信息请参阅后面部分）。</p>
<blockquote>
<ul>
<li>字面常数，也就是 <code>0x123</code>、<code>42</code> 或 <code>&quot;abc&quot;</code> （不超过 32 个字符的字符串）</li>
<li>操作码（在“instruction style”内），比如 <code>mload sload dup1 sstore</code>，操作码列表请看后面</li>
<li>函数风格操作码，比如 <code>add(1，mlod(0))</code></li>
<li>标签，比如 <code>name:</code></li>
<li>变量声明，比如 <code>let x := 7</code>、<code>let x := add(y, 3)</code> 或者 <code>let x</code> （初始值将被置为 empty(0)）</li>
<li>标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 <code>jump(name)</code>、<code>3 x add</code></li>
<li>赋值（在“instruction style”内），比如 <code>3 =: x</code></li>
<li>函数风格赋值，比如 <code>x := add(y，3)</code></li>
<li>一些控制局部变量作用域的语句块，比如 <code>&#123;let x := 3 &#123; let y := add(x，1) &#125;&#125;</code></li>
</ul>
</blockquote>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不是以太坊虚拟机的详细描述，但下边的列表可以作为操作码参考。</p>
<p>如果一个操作码需要参数（总是来自堆栈顶部），它们会在括号中给出。请注意：参数顺序可以看作是在非函数风格中逆序（下面会解释）。 标有 <code>-</code> 的操作码不会向栈中压入（push）数据，标有 <code>*</code> 的操作码有特殊操作，而所有其他操作码都只会将一个数据压入（push）栈中。 用 <code>F</code>、<code>H</code>、<code>B</code> 或 <code>C</code> 标记的操作码代表它们从 Frontier、Homestead、Byzantium 或 Constantinople 开始被引入。 Constantinople 目前仍在计划中，所以标记为 <code>C</code> 的指令目前都会导致一个非法指令异常。</p>
<p>在下表中，<code>mem[a...b)</code> 表示从位置 <code>a</code> 开始至（不包括）位置 <code>b</code> 的内存字节数，<code>storage[p]</code> 表示位置 <code>p</code> 处的存储内容。</p>
<p><code>pushi</code> 和 <code>jumpdest</code> 这两个操作码不能直接用。</p>
<p>在语法表中，操作码是作为预定义标识符提供的。</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th></th>
<th></th>
<th>Explanation</th>
</tr>
</thead>
<tbody><tr>
<td>stop</td>
<td>-</td>
<td>F</td>
<td>停止执行，与 return(0,0) 等价</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td>x + y</td>
</tr>
<tr>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td>x - y</td>
</tr>
<tr>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td>x * y</td>
</tr>
<tr>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x2F; y</td>
</tr>
<tr>
<td>sdiv(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x2F; y，以二进制补码作为符号</td>
</tr>
<tr>
<td>mod(x, y)</td>
<td></td>
<td>F</td>
<td>x % y</td>
</tr>
<tr>
<td>smod(x, y)</td>
<td></td>
<td>F</td>
<td>x % y，以二进制补码作为符号</td>
</tr>
<tr>
<td>exp(x, y)</td>
<td></td>
<td>F</td>
<td>x 的 y 次幂</td>
</tr>
<tr>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>~x，对 x 按位取反</td>
</tr>
<tr>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 x &lt; y 为 1，否则为 0</td>
</tr>
<tr>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 x &gt; y 为 1，否则为 0</td>
</tr>
<tr>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 x &lt; y 为 1，否则为 0，以二进制补码作为符号</td>
</tr>
<tr>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>如果 x &gt; y 为 1，否则为 0，以二进制补码作为符号</td>
</tr>
<tr>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>如果 x &#x3D;&#x3D; y 为 1，否则为 0</td>
</tr>
<tr>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>如果 x &#x3D;&#x3D; 0 为 1，否则为 0</td>
</tr>
<tr>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位与</td>
</tr>
<tr>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位或</td>
</tr>
<tr>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x 和 y 的按位异或</td>
</tr>
<tr>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x 的第 n 个字节，这个索引是从 0 开始的</td>
</tr>
<tr>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>将 y 逻辑左移 x 位</td>
</tr>
<tr>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>将 y 逻辑右移 x 位</td>
</tr>
<tr>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>将 y 算术右移 x 位</td>
</tr>
<tr>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>任意精度的 (x + y) % m</td>
</tr>
<tr>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>任意精度的 (x * y) % m</td>
</tr>
<tr>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>对 x 的最低位到第 (i * 8 + 7) 进行符号扩展</td>
</tr>
<tr>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td>keccak(mem[p…(p + n)))</td>
</tr>
<tr>
<td>jump(label)</td>
<td>-</td>
<td>F</td>
<td>跳转到标签 &#x2F; 代码位置</td>
</tr>
<tr>
<td>jumpi(label, cond)</td>
<td>-</td>
<td>F</td>
<td>如果条件为非零，跳转到标签</td>
</tr>
<tr>
<td>pc</td>
<td></td>
<td>F</td>
<td>当前代码位置</td>
</tr>
<tr>
<td>pop(x)</td>
<td>-</td>
<td>F</td>
<td>删除（弹出）栈顶的 x 个元素</td>
</tr>
<tr>
<td>dup1 … dup16</td>
<td></td>
<td>F</td>
<td>将栈内第 i 个元素（从栈顶算起）复制到栈顶</td>
</tr>
<tr>
<td>swap1 … swap16</td>
<td>*</td>
<td>F</td>
<td>将栈顶元素和其下第 i 个元素互换</td>
</tr>
<tr>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td>mem[p…(p + 32))</td>
</tr>
<tr>
<td>mstore(p, v)</td>
<td>-</td>
<td>F</td>
<td>mem[p…(p + 32)) :&#x3D; v</td>
</tr>
<tr>
<td>mstore8(p, v)</td>
<td>-</td>
<td>F</td>
<td>mem[p] :&#x3D; v &amp; 0xff （仅修改一个字节）</td>
</tr>
<tr>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p, v)</td>
<td>-</td>
<td>F</td>
<td>storage[p] :&#x3D; v</td>
</tr>
<tr>
<td>msize</td>
<td></td>
<td>F</td>
<td>内存大小，即最大可访问内存索引</td>
</tr>
<tr>
<td>gas</td>
<td></td>
<td>F</td>
<td>执行可用的 gas</td>
</tr>
<tr>
<td>address</td>
<td></td>
<td>F</td>
<td>当前合约 &#x2F; 执行上下文的地址</td>
</tr>
<tr>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>地址 a 的余额，以 wei 为单位</td>
</tr>
<tr>
<td>caller</td>
<td></td>
<td>F</td>
<td>调用发起者（不包括 <code>delegatecall</code>）</td>
</tr>
<tr>
<td>callvalue</td>
<td></td>
<td>F</td>
<td>随调用发送的 Wei 的数量</td>
</tr>
<tr>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>位置 p 的调用数据（32 字节）</td>
</tr>
<tr>
<td>calldatasize</td>
<td></td>
<td>F</td>
<td>调用数据的字节数大小</td>
</tr>
<tr>
<td>calldatacopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t</td>
</tr>
<tr>
<td>codesize</td>
<td></td>
<td>F</td>
<td>当前合约 &#x2F; 执行上下文地址的代码大小</td>
</tr>
<tr>
<td>codecopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从代码的位置 f 开始拷贝 s 个字节到内存的位置 t</td>
</tr>
<tr>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>地址 a 的代码大小</td>
</tr>
<tr>
<td>extcodecopy(a, t, f, s)</td>
<td>-</td>
<td>F</td>
<td>和 codecopy(t, f, s) 类似，但从地址 a 获取代码</td>
</tr>
<tr>
<td>returndatasize</td>
<td></td>
<td>B</td>
<td>最后一个 returndata 的大小</td>
</tr>
<tr>
<td>returndatacopy(t, f, s)</td>
<td>-</td>
<td>B</td>
<td>从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t</td>
</tr>
<tr>
<td>create(v, p, s)</td>
<td></td>
<td>F</td>
<td>用 mem[p…(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址</td>
</tr>
<tr>
<td>create2(v, n, p, s)</td>
<td></td>
<td>C</td>
<td>用 mem[p…(p + s)) 中的代码，在地址 keccak256(<address> . n . keccak256(mem[p…(p + s))) 上 创建新合约、发送 v wei 并返回新地址</td>
</tr>
<tr>
<td>call(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>使用 mem[in…(in + insize)) 作为输入数据， 提供 g gas 和 v wei 对地址 a 发起消息调用， 输出结果数据保存在 mem[out…(out + outsize))， 发生错误（比如 gas 不足）时返回 0，正确结束返回 1</td>
</tr>
<tr>
<td>callcode(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与 <code>call</code> 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文</td>
</tr>
<tr>
<td>delegatecall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与 <code>callcode</code> 等价且保留 <code>caller</code> 和 <code>callvalue</code></td>
</tr>
<tr>
<td>staticcall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与 <code>call(g, a, 0, in, insize, out, outsize)</code> 等价 但不允许状态修改</td>
</tr>
<tr>
<td>return(p, s)</td>
<td>-</td>
<td>F</td>
<td>终止运行，返回 mem[p…(p + s)) 的数据</td>
</tr>
<tr>
<td>revert(p, s)</td>
<td>-</td>
<td>B</td>
<td>终止运行，撤销状态变化，返回 mem[p…(p + s)) 的数据</td>
</tr>
<tr>
<td>selfdestruct(a)</td>
<td>-</td>
<td>F</td>
<td>终止运行，销毁当前合约并且把资金发送到地址 a</td>
</tr>
<tr>
<td>invalid</td>
<td>-</td>
<td>F</td>
<td>以无效指令终止运行</td>
</tr>
<tr>
<td>log0(p, s)</td>
<td>-</td>
<td>F</td>
<td>以 mem[p…(p + s)) 的数据产生不带 topic 的日志</td>
</tr>
<tr>
<td>log1(p, s, t1)</td>
<td>-</td>
<td>F</td>
<td>以 mem[p…(p + s)) 的数据和 topic t1 产生日志</td>
</tr>
<tr>
<td>log2(p, s, t1, t2)</td>
<td>-</td>
<td>F</td>
<td>以 mem[p…(p + s)) 的数据和 topic t1、t2 产生日志</td>
</tr>
<tr>
<td>log3(p, s, t1, t2, t3)</td>
<td>-</td>
<td>F</td>
<td>以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 产生日志</td>
</tr>
<tr>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td>-</td>
<td>F</td>
<td>以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志</td>
</tr>
<tr>
<td>origin</td>
<td></td>
<td>F</td>
<td>交易发起者地址</td>
</tr>
<tr>
<td>gasprice</td>
<td></td>
<td>F</td>
<td>交易所指定的 gas 价格</td>
</tr>
<tr>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块</td>
</tr>
<tr>
<td>coinbase</td>
<td></td>
<td>F</td>
<td>当前的挖矿收益者地址</td>
</tr>
<tr>
<td>timestamp</td>
<td></td>
<td>F</td>
<td>从当前 epoch 开始的当前区块时间戳（以秒为单位）</td>
</tr>
<tr>
<td>number</td>
<td></td>
<td>F</td>
<td>当前区块号</td>
</tr>
<tr>
<td>difficulty</td>
<td></td>
<td>F</td>
<td>当前区块难度</td>
</tr>
<tr>
<td>gaslimit</td>
<td></td>
<td>F</td>
<td>当前区块的 gas 上限</td>
</tr>
</tbody></table>
<h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 <code>PUSHi</code> 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>你可以像使用字节码那样在操作码之后键入操作码。例如，把 <code>3</code> 与内存位置 <code>0x80</code> 处的数据相加就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure>

<p>由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure>

<p>函数风格表达式内不能使用指令风格的写法，即 <code>1 2 mstore(0x80, add)</code> 是无效汇编语句， 它必须写成 <code>mstore(0x80, add(2, 1))</code> 这种形式。对于不带参数的操作码，括号可以省略。</p>
<p>注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。</p>
<h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p>通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 <code>x</code> 所使用的存储槽，你可以使用 <code>x_slot</code>，并用的 <code>x_offset</code> 获取其字节偏移量。</p>
<p>在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。</p>
<p>对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为：</p>
<blockquote>
<ul>
<li>调用者压入 <code>return label</code>、<code>arg1</code>、<code>arg2</code>、…、<code>argn</code></li>
<li>被调用方返回 <code>ret1</code>、<code>ret2</code>、…、<code>retm</code></li>
</ul>
</blockquote>
<p>这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解</p>
<p>如果你访问一个实际数据位数小于 256 位的数据类型（比如 <code>uint64</code>、<code>address</code>、<code>bytes16</code> 或 <code>byte</code>）， 不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。 安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要： <code>uint32 x = f(); assembly &#123; x := and(x, 0xffffffff) /* now use x */ &#125;</code> 要清空有符号类型，你可以使用 <code>signextend</code> 操作码。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>注解</p>
<p>标签已经不推荐使用。请使用函数、循环、if 或 switch 语句。</p>
<p>EVM 汇编的另一个问题是 jump 和 jumpi 函数使用绝对地址，这些绝对地址很容易改变。 Solidity 内联汇编提供了标签，以便更容易地使用 jump。注意，标签具有底层特征，使用循环、if 和 switch 指令（参见下文）而不使用标签也能写出高效汇编代码。 以下代码用来计算斐波那契数列中的一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意：只有汇编程序知道当前栈高度时，才能自动访问堆栈变量。如果 jump 源和目标的栈高度不同，访问将失败。 虽然我们可以这么使用 jump，但在这种情况下，你不应该去访问任何栈里的变量（即使是汇编变量）。</p>
<p>此外，栈高度分析器还可以通过操作码（而不是根据控制流）检查代码操作码，因此在下面的情况下，汇编程序对标签 <code>two</code> 处的堆栈高度会产生错误的印象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // 这里的栈高度是 2（因为我们压入了 x 和 7），</span><br><span class="line">        // 但因为汇编程序是按顺序读取代码的，</span><br><span class="line">        // 它会认为栈高度是 1。</span><br><span class="line">        // 在这里访问栈变量 x 会导致错误。</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // 把某个数据压入栈中</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汇编局部变量声明"><a href="#汇编局部变量声明" class="headerlink" title="汇编局部变量声明"></a>汇编局部变量声明</h3><p>你可以使用 <code>let</code> 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 <code>&#123;...&#125;</code> 块中可见。 下面发生的事情应该是：<code>let</code> 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 <code>0</code>，但它也可以是一个复杂的函数风格表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y 会在这里被“清除”</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v 会在这里被“清除”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。</p>
<p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>变量 := 值</code>），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（<code>=: 变量</code>），则仅从栈顶部获取数据。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // 作为变量声明的函数风格赋值</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解</p>
<p>指令风格的赋值已经不推荐。</p>
<h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><p>if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码主体的花括号是必需的。</p>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>作为“if&#x2F;else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 <code>default</code> 的默认情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Case 列表里面不需要大括号，但 case 主体需要。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。</p>
<p>下面例子是计算某个内存区域中的数值总和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。</p>
<p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 <code>return</code> 语句。</p>
<p>如果调用会返回多个值的函数，则必须使用 <code>a，b：= f(x)</code> 或 <code>let a，b：= f(x)</code> 的方式把它们赋值到一个元组。</p>
<p>下面例子通过平方和乘法实现了幂运算函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>内联汇编语言可能具有相当高级的外观，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。</p>
<h3 id="Solidity-惯例"><a href="#Solidity-惯例" class="headerlink" title="Solidity 惯例"></a>Solidity 惯例</h3><p>与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 <code>uint24</code>。为了提高效率，大多数算术运算只将它们视为 256 位数字， 仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。</p>
<p>Solidity 以一种非常简单的方式管理内存：在 <code>0x40</code> 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。</p>
<p>内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 <code>0x60</code> 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。</p>
<p>在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 <code>byte[]</code> 都是这样，只有 <code>bytes</code> 和 <code>string</code> 不是这样）。 多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。</p>
<p>警告</p>
<p>静态内存数组没有长度字段，但很快就会增加，这是为了可以更好地进行静态数组和动态数组之间的转换，所以请不要依赖这点。</p>
<h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作 Solidity 编译器的中间语言。在这种意义下，它试图实现以下几个目标：</p>
<p>1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。</p>
<p>为了实现第一个和最后一个目标，汇编提供了高级结构：如 <code>for</code> 循环、<code>if</code> 语句、<code>switch</code> 语句和函数调用。 应该可以编写不使用明确的 <code>SWAP</code>、<code>DUP</code>、<code>JUMP</code> 和 <code>JUMPI</code> 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 <code>mul(add(x, y), 7)</code> 的函数风格语句优于如 <code>7 y x add mul</code> 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。</p>
<p>第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、…）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。</p>
<p>作用域：在其中声明的标识符（标签、变量、函数、汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。 即使它们在作用范围内，越过函数边界访问局部变量也是非法的。阴影化是禁止的。在声明之前不能访问局部变量，但标签、函数和汇编是可以的。 汇编是特殊的语句块，例如用于返回运行时代码或创建合约等。在子汇编外部的汇编语句块中声明的标示符在子汇编中全都不可见。</p>
<p>如果控制流经过块尾部，则会插入与在当前语句块中声明的局部变量数量相匹配的 pop 指令。无论何时引用局部变量，代码生成器都需要知道在当前栈的相对位置， 因此，需要跟踪当前所谓的栈高度。由于所有在语句块内声明的局部变量都会在语句块结束时被清楚，所以语句块前后的栈高度应该相同。如果情况并非如此，则会发出警告。</p>
<p>使用 <code>switch</code>、<code>for</code> 和函数应该可以编写复杂的代码，而无需手工调用 <code>jump</code> 或 <code>jumpi</code>。这将允许改进的形式化验证和优化更简单地分析控制流程。</p>
<p>此外，如果允许手动跳转，计算栈高度将会更加复杂。栈中所有局部变量的位置都需要明确知晓，否则在语句块结束时就无法自动获得局部变量的引用从而正确地清除它们。</p>
<p>例子：</p>
<p>我们将参考一个从 Solidity 到汇编指令的实例。考虑以下 Solidity 程序的运行时字节码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会生成如下汇编指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // 保存“空闲内存指针”</span><br><span class="line">  // 函数选择器</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // 内存分配器</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // 合约函数</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汇编语法"><a href="#汇编语法" class="headerlink" title="汇编语法"></a>汇编语法</h3><p>解析器任务如下：</p>
<ul>
<li>将字节流转换为符号流，丢弃 C ++ 风格的注释（对源代码引用存在特殊注释，我们这里不解释它）。</li>
<li>根据下面的语法，将符号流转换为 AST。</li>
<li>注册语句块中定义的标识符（注释到 AST 节点），并注明变量从哪个地方开始可以访问。</li>
</ul>
<p>汇编词法分析器遵循由 Solidity 自己定义的规则。</p>
<p>空格用于分隔所有符号，它由空格字符、制表符和换行符组成。注释格式是常规的 JavaScript&#x2F;C++ 风格，并被解释为空格。</p>
<p>Grammar:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &#x27;&#123;&#x27; AssemblyItem* &#x27;&#125;&#x27;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &#x27;break&#x27; |</span><br><span class="line">    &#x27;continue&#x27; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &#x27;(&#x27; ( AssemblyExpression ( &#x27;,&#x27; AssemblyExpression )* )? &#x27;)&#x27;</span><br><span class="line">AssemblyLocalDefinition = &#x27;let&#x27; IdentifierOrList ( &#x27;:=&#x27; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &#x27;:=&#x27; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &#x27;(&#x27; IdentifierList &#x27;)&#x27;</span><br><span class="line">IdentifierList = Identifier ( &#x27;,&#x27; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &#x27;=:&#x27; Identifier</span><br><span class="line">LabelDefinition = Identifier &#x27;:&#x27;</span><br><span class="line">AssemblyIf = &#x27;if&#x27; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &#x27;switch&#x27; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &#x27;default&#x27; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &#x27;case&#x27; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &#x27;function&#x27; Identifier &#x27;(&#x27; IdentifierList? &#x27;)&#x27;</span><br><span class="line">    ( &#x27;-&gt;&#x27; &#x27;(&#x27; IdentifierList &#x27;)&#x27; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &#x27;for&#x27; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &#x27;assembly&#x27; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &#x27;hex&#x27; (&#x27;&quot;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;&quot;&#x27; | &#x27;\&#x27;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;\&#x27;&#x27;)</span><br><span class="line">StringLiteral = &#x27;&quot;&#x27; ([^&quot;\r\n\\] | &#x27;\\&#x27; .)* &#x27;&quot;&#x27;</span><br><span class="line">HexNumber = &#x27;0x&#x27; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://server.ethicalads.io/proxy/click/8844/0197f487-583b-7b92-8add-23c726895a6c/"><strong>Document Extraction for Developers</strong> Transform docs into structured data with Sensible. <strong>Try for free →</strong></a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.zhengcookie.site">zhengcookie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/">https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.zhengcookie.site" target="_blank">zhengcookie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/">区块链智能合约语法</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/微信图片_20250416170645.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/09/%E5%90%88%E7%BA%A6/" title="合约"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">合约</div></div><div class="info-2"><div class="info-item-1">合约Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 创建合约可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。 一些集成开发环境，例如 Remix, 通过使用一些用户界面元素使创建过程更加流畅。 在以太坊上编程创建合约最好使用 JavaScript API web3.js。 现在，我们已经有了一个叫做 web3.eth.Contract 的方法能够更容易的创建合约。 创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。 在内部，构造函数参数在合约代码之后通过 ABI 编码 传递，但是如果你使用 web3.js 则不必关心这个问题。 如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。...</div></div></div></a><a class="pagination-related" href="/2025/07/11/%E6%9D%82%E9%A1%B9/" title="杂项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">杂项</div></div><div class="info-2"><div class="info-item-1">杂项存储storage 中的状态变量储存结构静态大小的变量（除 映射mapping 和动态数组之外的所有类型）都从位置 0 开始连续放置在 存储storage 中。如果可能的话，存储需求少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：  存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。 基本类型仅使用存储它们所需的字节。 如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。 结构（struct）和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。  警告 使用小于 32 字节的元素时，你的合约的 gas 使用量可能高于使用 32 字节的元素时。这是因为 以太坊虚拟机Ethereum Virtual Machine(EVM) 每次会操作 32 个字节， 所以如果元素比 32 字节小，以太坊虚拟机Ethereum Virtual Machine(EVM)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="Solidity智能合约零基础入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-19</div><div class="info-item-2">Solidity智能合约零基础入门</div></div><div class="info-2"><div class="info-item-1">课程安排模块一：启程 - 区块链与智能合约概念比特币 vs 以太坊：为什么需要智能合约？ 比特币 vs...</div></div></div></a><a class="pagination-related" href="/2025/07/09/%E5%90%88%E7%BA%A6/" title="合约"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">合约</div></div><div class="info-2"><div class="info-item-1">合约Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 创建合约可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。 一些集成开发环境，例如 Remix, 通过使用一些用户界面元素使创建过程更加流畅。 在以太坊上编程创建合约最好使用 JavaScript API web3.js。 现在，我们已经有了一个叫做 web3.eth.Contract 的方法能够更容易的创建合约。 创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。 在内部，构造函数参数在合约代码之后通过 ABI 编码 传递，但是如果你使用 web3.js 则不必关心这个问题。 如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。...</div></div></div></a><a class="pagination-related" href="/2025/07/06/%E5%8D%95%E4%BD%8D%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/" title="单位与全局变量"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-06</div><div class="info-item-2">单位与全局变量</div></div><div class="info-2"><div class="info-item-1">以太币Ether 单位以太币Ether 单位之间的换算就是在数字后边加上 wei ， gwei 或 ether 来实现的，如果后面没有单位，缺省为 wei。 123assert(1 wei == 1);assert(1 gwei == 1e9);assert(1 ether == 1e18);  货币单位后缀的的效果相当于乘以10的幂。 注解 从0.7.0开始 finney 和 szabo 被移除了。 译者注：gwei 在solidity 0.6.11 中添加，因此在0.6.11之前的版本中不可用。 时间单位秒是缺省时间单位，在时间单位之间，数字后面带有 seconds、 minutes、 hours、 days 和 weeks 的可以进行换算，基本换算关系如下：  1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days  由于闰秒造成的每年不都是 365 天、每天不都是 24 小时 leap...</div></div></div></a><a class="pagination-related" href="/2025/07/05/%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%E8%AF%AD%E6%B3%95/" title="合约结构语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-05</div><div class="info-item-2">合约结构语法</div></div><div class="info-2"><div class="info-item-1">状态变量状态变量是永久地存储在合约存储中的值。 123456pragma solidity &gt;=0.4.0 &lt;0.9.0;contract TinyStorage &#123;    uint storedXlbData; // 状态变量    // ...&#125;  函数函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。 12345678910111213// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.1 &lt;0.9.0;contract TinyAuction &#123;    function Mybid() public payable &#123; // 定义函数        // ...    &#125;&#125;// Helper function defined outside of a contractfunction helper(uint x) pure returns (uint) &#123;    return x *...</div></div></div></a><a class="pagination-related" href="/2025/07/11/%E6%9D%82%E9%A1%B9/" title="杂项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">杂项</div></div><div class="info-2"><div class="info-item-1">杂项存储storage 中的状态变量储存结构静态大小的变量（除 映射mapping 和动态数组之外的所有类型）都从位置 0 开始连续放置在 存储storage 中。如果可能的话，存储需求少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：  存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。 基本类型仅使用存储它们所需的字节。 如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。 结构（struct）和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。  警告 使用小于 32 字节的元素时，你的合约的 gas 使用量可能高于使用 32 字节的元素时。这是因为 以太坊虚拟机Ethereum Virtual Machine(EVM) 每次会操作 32 个字节， 所以如果元素比 32 字节小，以太坊虚拟机Ethereum Virtual Machine(EVM)...</div></div></div></a><a class="pagination-related" href="/2025/07/06/%E7%B1%BB%E5%9E%8B/" title="类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-06</div><div class="info-item-2">类型</div></div><div class="info-2"><div class="info-item-1">类型Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型（或至少可以推导出变量类型——参考下文的 类型推断 ）。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。 除此之外，类型之间可以在包含运算符号的表达式中进行交互。 关于各种运算符号，可以参考 操作符优先级 。 值类型以下类型也称为值类型，因为这些类型的变量将始终按值来传递。 也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。 布尔类型bool ：可能的取值为字面常数值 true 和 false 。 运算符：  ! （逻辑非） &amp;&amp; （逻辑与， “and” ） || （逻辑或， “or” ） == （等于） != （不等于）  运算符 || 和 &amp;&amp; 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 f(x) || g(y) 中， 如果 f(x) 的值为 true ，那么 g(y) 就不会被执行，即使会出现一些副作用。 整型int &#x2F; uint...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/微信图片_20250416170645.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zhengcookie</div><div class="author-info-description">欢迎来到zhengcookie的个人博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhengcookie"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhengcookie" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/z2132085753@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E6%B1%87%E7%BC%96"><span class="toc-number">1.</span> <span class="toc-text">Solidity汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">1.1.</span> <span class="toc-text">内联汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">操作码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">字面常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.1.5.</span> <span class="toc-text">函数风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">访问外部变量和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">1.1.7.</span> <span class="toc-text">标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.8.</span> <span class="toc-text">汇编局部变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.9.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#If"><span class="toc-number">1.1.10.</span> <span class="toc-text">If</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch"><span class="toc-number">1.1.11.</span> <span class="toc-text">Switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.12.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.13.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.14.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-%E6%83%AF%E4%BE%8B"><span class="toc-number">1.1.15.</span> <span class="toc-text">Solidity 惯例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%B1%87%E7%BC%96"><span class="toc-number">1.2.</span> <span class="toc-text">独立汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">汇编语法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="Solidity智能合约零基础入门">Solidity智能合约零基础入门</a><time datetime="2025-10-19T14:17:53.000Z" title="发表于 2025-10-19 22:17:53">2025-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/13/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/" title="广州it工作第九周">广州it工作第九周</a><time datetime="2025-09-13T08:16:54.000Z" title="发表于 2025-09-13 16:16:54">2025-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/07/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/" title="广州it工作第八周">广州it工作第八周</a><time datetime="2025-09-07T12:22:49.000Z" title="发表于 2025-09-07 20:22:49">2025-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/30/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/" title="广州it工作第七周">广州it工作第七周</a><time datetime="2025-08-30T11:18:00.000Z" title="发表于 2025-08-30 19:18:00">2025-08-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/25/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/" title="广州it工作第六周">广州it工作第六周</a><time datetime="2025-08-25T15:01:50.000Z" title="发表于 2025-08-25 23:01:50">2025-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By zhengcookie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'sTZBx4mwQ0t3yfqJB5XmuIhz-gzGzoHsz',
      appKey: 'KJPXk2hOqDfll4hbw93yYmUc',
      avatar: 'https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/微信图片_20250416170645.jpg',
      serverURLs: 'https://stzbx4mw.lc-cn-n1-shared.com',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>