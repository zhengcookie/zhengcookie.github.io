

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="zhengcookie">
  <meta name="keywords" content="zhengcookie,blog,个人博客,技术分享">
  
    <meta name="description" content="合约Solidity中的合约类似于面向对象语言中的类。 它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。 在不同的合约（实例）上调用一个函数将执行一个EVM函数调用， 从而切换上下文，使调用合约中的状态变量无法访问。 任何事情的发生都需要调用合约及其函数。 在以太坊中没有 “定时（cron）” 的概念来在特定事件中自动调用函数。 创建合约可以通过以太坊交易 “从外部” 或从 Sol">
<meta property="og:type" content="article">
<meta property="og:title" content="合约">
<meta property="og:url" content="https://www.zhengcookie.site/2025/07/09/%E5%90%88%E7%BA%A6/index.html">
<meta property="og:site_name" content="zhengcookie">
<meta property="og:description" content="合约Solidity中的合约类似于面向对象语言中的类。 它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。 在不同的合约（实例）上调用一个函数将执行一个EVM函数调用， 从而切换上下文，使调用合约中的状态变量无法访问。 任何事情的发生都需要调用合约及其函数。 在以太坊中没有 “定时（cron）” 的概念来在特定事件中自动调用函数。 创建合约可以通过以太坊交易 “从外部” 或从 Sol">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-09T11:00:01.000Z">
<meta property="article:modified_time" content="2025-11-06T09:10:08.987Z">
<meta property="article:author" content="zhengcookie">
<meta property="article:tag" content="区块链智能合约语法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>合约 - zhengcookie</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.zhengcookie.site","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="zhengcookie" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>zhengcookie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                
                <span>archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                
                <span>categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                
                <span>tags</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="合约"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-09 19:00" pubdate>
          2025年7月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          155 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">合约</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts"></a></h1><p>Solidity中的合约类似于面向对象语言中的类。 它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。 在不同的合约（实例）上调用一个函数将执行一个EVM函数调用， 从而切换上下文，使调用合约中的状态变量无法访问。 任何事情的发生都需要调用合约及其函数。 在以太坊中没有 “定时（cron）” 的概念来在特定事件中自动调用函数。</p>
<h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-1"></a></h2><p>可以通过以太坊交易 “从外部” 或从 Solidity 合约内部创建合约。</p>
<p>集成开发环境，如 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix</a>，使用UI元素使创建过程无缝化。</p>
<p>在以太坊上以编程方式创建合约的一种方法是通过JavaScript API <a target="_blank" rel="noopener" href="https://github.com/web3/web3.js">web3.js</a>。 它有一个名为 <a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的函数， 以方便创建合约。</p>
<p>当一个合约被创建时，它的 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor">构造函数（constructor）</a> （一个用 <code>constructor</code> 关键字声明的函数）被执行一次。</p>
<p>构造函数是可选的。但是只允许有一个构造函数，这意味着不支持重写。</p>
<p>构造函数执行完毕后，合约的最终代码被存储在区块链上。 这段代码包括所有公开和外部函数，以及所有通过函数调用可从那里到达的函数。 部署的代码不包括构造函数代码或只从构造函数调用的内部函数。</p>
<p>在内部，构造函数参数在合约代码之后通过 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 传递， 但是如果您使用 <code>web3.js</code> 则不必关心这个问题。</p>
<p>如果一个合约想创建另一个合约，创建者必须知道所创建合约的源代码（和二进制）。 这意味着，循环的创建依赖是不可能的。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIOaYr+WmguS4i+WumuS5ieeahOWQiOe6puexu+Wei+OAggogICAgLy8g5LiN5Yib5bu65paw5ZCI57qm55qE6K+d77yM5Lmf5Y+v5Lul5byV55So5a6D44CCCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8g6L+Z5piv5rOo5YaMIGNyZWF0b3Ig5ZKM6K6+572u5ZCN56ew55qE5p6E6YCg5Ye95pWw44CCCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8g54q25oCB5Y+Y6YeP6YCa6L+H5YW25ZCN56ew6K6/6Zeu77yMCiAgICAgICAgLy8g6ICM5LiN5piv6YCa6L+H5L6L5aaCIGB0aGlzLm93bmVyYCDnmoTmlrnlvI/orr/pl67jgIIKICAgICAgICAvLyDlh73mlbDlj6/ku6Xnm7TmjqXmiJbpgJrov4cgYHRoaXMuZmAg6K6/6Zeu44CCCiAgICAgICAgLy8g5L2G5ZCO6ICF5o+Q5L6b5LqG5LiA5Liq5a+55Ye95pWw55qE5aSW6YOo5Y+v6KeG5pa55rOV44CCCiAgICAgICAgLy8g54m55Yir5piv5Zyo5p6E6YCg5Ye95pWw5Lit77yM5oKo5LiN5bqU6K+l5LuO5aSW6YOo6K6/6Zeu5Ye95pWw77yMCiAgICAgICAgLy8g5Zug5Li66K+l5Ye95pWw6L+Y5LiN5a2Y5Zyo44CCCiAgICAgICAgLy8g6K+m6KeB5LiL5LiA6IqC44CCCiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgICAgICAvLyDmiJHku6zov5vooYzkuobku44gYGFkZHJlc3NgIOWIsCBgVG9rZW5DcmVhdG9yYCDnmoTmmL7lvI/nsbvlnovovazmjaLvvIwKICAgICAgICAvLyDlubblgYflrprosIPnlKjlkIjnuqbnmoTnsbvlnovmmK8gYFRva2VuQ3JlYXRvcmDvvIwKICAgICAgICAvLyDmsqHmnInnnJ/mraPnmoTmlrnms5XmnaXpqozor4HvvIwKICAgICAgICAvLyDov5nlubbmsqHmnInliJvlu7rkuIDkuKrmlrDnmoTlkIjnuqbjgIIKICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyDlj6rmnInliJvlu7rogIXlj6/ku6XmlLnlj5jlkI3np7DjgIIKICAgICAgICAvLyDmiJHku6zmoLnmja7lkIjnuqbnmoTlnLDlnYDov5vooYzmr5TovoPvvIwKICAgICAgICAvLyDlroPlj6/ku6XpgJrov4fmmL7lvI/ovazmjaLkuLrlnLDlnYDmnaXmo4DntKLjgIIKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBhZGRyZXNzKGNyZWF0b3IpKQogICAgICAgICAgICBuYW1lID0gbmV3TmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgewogICAgICAgIC8vIOWPquacieW9k+WJjeaJgOacieiAheaJjeiDveWPkemAgSB0b2tlbuOAggogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIOaIkeS7rOmAmui/h+S9v+eUqOS4i+mdouWumuS5ieeahCBgVG9rZW5DcmVhdG9yYCDlkIjnuqbnmoTkuIDkuKrlh73mlbAKICAgICAgICAvLyDmnaXor6Lpl67liJvlu7rogIXlkIjnuqbmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICAvLyDlpoLmnpzosIPnlKjlpLHotKXvvIjkvovlpoLnlLHkuo7nh4PmlpnlgLzogJflsL3vvInvvIwKICAgICAgICAvLyDov5nph4znmoTmiafooYzkuZ/kvJrlpLHotKXjgIIKICAgICAgICBpZiAoY3JlYXRvci5pc1Rva2VuVHJhbnNmZXJPSyhvd25lciwgbmV3T3duZXIpKQogICAgICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9CgoKY29udHJhY3QgVG9rZW5DcmVhdG9yIHsKICAgIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGJ5dGVzMzIgbmFtZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChPd25lZFRva2VuIHRva2VuQWRkcmVzcykKICAgIHsKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgYFRva2VuYCDlkIjnuqblubbov5Tlm57lhbblnLDlnYDjgIIKICAgICAgICAvLyDku45KYXZhU2NyaXB05pa56Z2i5p2l55yL77yMCiAgICAgICAgLy8g6L+Z5Liq5Ye95pWw55qE6L+U5Zue57G75Z6L5pivIGBhZGRyZXNzYO+8jAogICAgICAgIC8vIOWboOS4uui/meaYr0FCSeS4reacgOaOpei/keeahOexu+Wei+OAggogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8g5ZCM5qC377yMYHRva2VuQWRkcmVzc2Ag55qE5aSW6YOo57G75Z6L5piv566A5Y2V55qEIGBhZGRyZXNzYOOAggogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIOaJp+ihjOajgOafpe+8jOS7peehruWumuaYr+WQpuW6lOivpeWwhuS7o+W4gei9rOenu+WIsCBgT3duZWRUb2tlbmAg5ZCI57qm5LiK44CCCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyDmo4Dmn6XkuIDkuKrku7vmhI/nmoTmnaHku7bvvIznnIvmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoY3VycmVudE93bmVyLCBuZXdPd25lcikpWzBdID09IDB4N2Y7CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br>contract OwnedToken &#123;<br>    <span class="hljs-comment">// `TokenCreator` 是如下定义的合约类型。</span><br>    <span class="hljs-comment">// 不创建新合约的话，也可以引用它。</span><br>    TokenCreator creator;<br>    address owner;<br>    bytes32 name;<br><br>    <span class="hljs-comment">// 这是注册 creator 和设置名称的构造函数。</span><br>    constructor(bytes32 name_) &#123;<br>        <span class="hljs-comment">// 状态变量通过其名称访问，</span><br>        <span class="hljs-comment">// 而不是通过例如 `this.owner` 的方式访问。</span><br>        <span class="hljs-comment">// 函数可以直接或通过 `this.f` 访问。</span><br>        <span class="hljs-comment">// 但后者提供了一个对函数的外部可视方法。</span><br>        <span class="hljs-comment">// 特别是在构造函数中，您不应该从外部访问函数，</span><br>        <span class="hljs-comment">// 因为该函数还不存在。</span><br>        <span class="hljs-comment">// 详见下一节。</span><br>        owner = msg.sender;<br><br>        <span class="hljs-comment">// 我们进行了从 `address` 到 `TokenCreator` 的显式类型转换，</span><br>        <span class="hljs-comment">// 并假定调用合约的类型是 `TokenCreator`，</span><br>        <span class="hljs-comment">// 没有真正的方法来验证，</span><br>        <span class="hljs-comment">// 这并没有创建一个新的合约。</span><br>        creator = TokenCreator(msg.sender);<br>        name = name_;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(bytes32 newName) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有创建者可以改变名称。</span><br>        <span class="hljs-comment">// 我们根据合约的地址进行比较，</span><br>        <span class="hljs-comment">// 它可以通过显式转换为地址来检索。</span><br>        <span class="hljs-keyword">if</span> (msg.sender == address(creator))<br>            name = newName;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> transfer(address newOwner) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有当前所有者才能发送 token。</span><br>        <span class="hljs-keyword">if</span> (msg.sender != owner) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 我们通过使用下面定义的 `TokenCreator` 合约的一个函数</span><br>        <span class="hljs-comment">// 来询问创建者合约是否应该进行转移。</span><br>        <span class="hljs-comment">// 如果调用失败（例如由于燃料值耗尽），</span><br>        <span class="hljs-comment">// 这里的执行也会失败。</span><br>        <span class="hljs-keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))<br>            owner = newOwner;<br>    &#125;<br>&#125;<br><br><br>contract TokenCreator &#123;<br>    <span class="hljs-built_in">function</span> createToken(bytes32 name)<br>        <span class="hljs-keyword">public</span><br>        returns (OwnedToken tokenAddress)<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的 `Token` 合约并返回其地址。</span><br>        <span class="hljs-comment">// 从JavaScript方面来看，</span><br>        <span class="hljs-comment">// 这个函数的返回类型是 `address`，</span><br>        <span class="hljs-comment">// 因为这是ABI中最接近的类型。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OwnedToken(name);<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(OwnedToken tokenAddress, bytes32 name) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 同样，`tokenAddress` 的外部类型是简单的 `address`。</span><br>        tokenAddress.changeName(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行检查，以确定是否应该将代币转移到 `OwnedToken` 合约上。</span><br>    <span class="hljs-built_in">function</span> isTokenTransferOK(address currentOwner, address newOwner)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">bool</span> ok)<br>    &#123;<br>        <span class="hljs-comment">// 检查一个任意的条件，看是否应该进行转移。</span><br>        <span class="hljs-keyword">return</span> keccak256(abi.encodePacked(currentOwner, newOwner))[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>x7f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="可见性和-getter-函数"><a href="#可见性和-getter-函数" class="headerlink" title="可见性和 getter 函数"></a>可见性和 getter 函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter"></a></h2><h3 id="状态变量的可见性"><a href="#状态变量的可见性" class="headerlink" title="状态变量的可见性"></a>状态变量的可见性<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id3"></a></h3><ul>
<li><p><code>public</code></p>
<p>公开状态变量与内部变量的不同之处在于，编译器会自动为它们生成 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions">getter函数</a>， 从而允许其他合约读取它们的值。当在同一个合约中使用时，外部访问（例如 <code>this.x</code>）会调用getter， 而内部访问（例如 <code>x</code>）会直接从存储中获取变量值。 Setter函数没有被生成，所以其他合约不能直接修改其值。</p>
</li>
<li><p><code>internal</code></p>
<p>内部状态变量只能从它们所定义的合约和派生合约中访问。 它们不能被外部访问。 这是状态变量的默认可见性。</p>
</li>
<li><p><code>private</code></p>
<p>私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p>
</li>
</ul>
<p>警告</p>
<p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
<h3 id="函数的可见性"><a href="#函数的可见性" class="headerlink" title="函数的可见性"></a>函数的可见性<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id4"></a></h3><p>Solidity 有两种函数调用：确实创建了实际 EVM 消息调用的外部函数和不创建 EVM 消息调用的内部函数。 此外，派生合约可能无法访问内部函数。 这就产生了四种类型的函数的可见性。</p>
<ul>
<li><p><code>external</code></p>
<p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用 （即 <code>f()</code> 不起作用，但 <code>this.f()</code> 可以）。</p>
</li>
<li><p><code>public</code></p>
<p>公开函数是合约接口的一部分，可以在内部或通过消息调用。</p>
</li>
<li><p><code>internal</code></p>
<p>内部函数只能从当前的合约或从它派生出来的合约中访问。 它们不能被外部访问。 由于它们没有通过合约的ABI暴露在外部，它们可以接受内部类型的参数，如映射或存储引用。</p>
</li>
<li><p><code>private</code></p>
<p>私有函数和内部函数一样，但它们在派生合约中是不可见的。</p>
</li>
</ul>
<p>警告</p>
<p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
<p>在状态变量的类型之后，以及在函数的参数列表和返回参数列表之间，都会给出可见性指定符。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a) <span class="hljs-keyword">private</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> b) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-built_in">function</span> setData(<span class="hljs-built_in">uint</span> a) internal &#123; data = a; &#125;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在下面的例子中，合约 <code>D</code>, 可以调用 <code>c.getData()</code> 来检索状态存储中 <code>data</code> 的值， 但不能调用 <code>f</code>。 合约 <code>E</code> 是从合约 <code>C</code> 派生出来的，因此可以调用 <code>compute</code>。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyDov5nlsIbkuI3kvJrnvJbor5EKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyDplJnor6/vvJrmiJDlkZggYGZgIOS4jeWPr+ingQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyDplJnor6/vvJrmiJDlkZggYGNvbXB1dGVgIOS4jeWPr+ingQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIOiuv+mXruWGhemDqOaIkOWRmO+8iOS7jue7p+aJv+WQiOe6puiuv+mXrueItuWQiOe6puaIkOWRmO+8iQogICAgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">private</span> data;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">private</span> pure <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> b</span>)</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">setData</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">public</span></span> &#123; data = a; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">getData</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">compute</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b</span>) <span class="hljs-keyword">internal</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;<br><br><span class="hljs-comment">// 这将不会编译</span><br>contract D &#123;<br>    <span class="hljs-function">function <span class="hljs-title">readData</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> local = c.f(<span class="hljs-number">7</span>); <span class="hljs-comment">// 错误：成员 `f` 不可见</span><br>        c.setData(<span class="hljs-number">3</span>);<br>        local = c.getData();<br>        local = c.compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 错误：成员 `compute` 不可见</span><br>    &#125;<br>&#125;<br><br>contract E <span class="hljs-keyword">is</span> C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> val = compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 访问内部成员（从继承合约访问父合约成员）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Getter-函数"><a href="#Getter-函数" class="headerlink" title="Getter 函数"></a>Getter 函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions"></a></h3><p>编译器会自动为所有 <strong>公开</strong> 状态变量创建getter函数。 对于下面给出的合约，编译器将生成一个名为 <code>data</code> 的函数， 它没有任何输入参数，并返回一个 <code>uint</code>， 即状态变量 <code>data</code> 的值。状态变量在声明时可以被初始化。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data = <span class="hljs-number">42</span>;<br>&#125;<br><br>contract Caller &#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> c.data();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>getter函数具有外部可见性。 如果该符号被内部访问（即没有 <code>this.</code>），它被评估为一个状态变量。 如果它被外部访问（即有 <code>this.</code>），它将被评价为一个函数。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIOWGhemDqOiuv+mXrgogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8g5aSW6YOo6K6/6ZeuCiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint <span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span>;<br>    function x() <span class="hljs-keyword">public</span> returns (uint) &#123;<br>        <span class="hljs-keyword">data</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 内部访问</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>(); <span class="hljs-comment">// 外部访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果您有一个数组类型的 <code>public</code> 状态变量， 那么您只能通过生成的getter函数检索数组的单个元素。 这种机制的存在是为了避免在返回整个数组时产生高额的燃料成本。 您可以使用参数来指定要返回的单个元素，例如 <code>myArray(0)</code>。 如果您想在一次调用中返回整个数组，那么您需要写一个函数，例如：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyDlhazlvIDnirbmgIHlj5jph48KICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyDnvJbor5HlmajnlJ/miJDnmoRnZXR0ZXLlh73mlbAKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyDov5Tlm57mlbTkuKrmlbDnu4TnmoTlh73mlbAKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract arrayExample &#123;<br>    <span class="hljs-comment">// 公开状态变量</span><br>    <span class="hljs-built_in">uint</span>[] <span class="hljs-keyword">public</span> myArray;<br><br>    <span class="hljs-comment">// 编译器生成的getter函数</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    function myArray(uint i) public view returns (uint) &#123;</span><br><span class="hljs-comment">        return myArray[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 返回整个数组的函数</span><br>    <span class="hljs-function">function <span class="hljs-title">getArray</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> myArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在您可以使用 <code>getArray()</code> 来检索整个数组， 而不是使用 <code>myArray(i)</code>，它每次调用只返回一个元素。</p>
<p>下一个例子稍微复杂一些：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcodWludCA9PiB1aW50KSBtYXA7CiAgICAgICAgdWludFszXSBjOwogICAgICAgIHVpbnRbXSBkOwogICAgICAgIGJ5dGVzIGU7CiAgICB9CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhib29sID0+IERhdGFbXSkpIHB1YmxpYyBkYXRhOwp9">open in Remix</a></p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Complex &#123;<br>    struct Data &#123;<br>        <span class="hljs-keyword">uint</span> a;<br>        bytes3 b;<br>        mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">uint</span>) map;<br>        <span class="hljs-keyword">uint</span>[<span class="hljs-number">3</span>] c;<br>        <span class="hljs-keyword">uint</span>[] d;<br>        bytes e;<br>    &#125;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; mapping(<span class="hljs-keyword">bool</span> =&gt; Data[])) <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它生成了一个如下形式的函数。结构中的映射和数组（字节数组除外）被省略了， 因为没有好的方法来选择单个结构成员或为映射提供一个键：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9">open in Remix</a></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">function</span> <span class="hljs-class"><span class="hljs-keyword">data</span>(<span class="hljs-title">uint</span> <span class="hljs-title">arg1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">arg2</span>, <span class="hljs-title">uint</span> <span class="hljs-title">arg3</span>)</span><br>    public<br>    returns (uint a, bytes3 b, bytes memory e)<br>&#123;<br>    a = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].a;</span><br>    b = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].b;</span><br>    e = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].e;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifiers"></a></h2><p>函数修饰器可以用来以声明的方式改变函数的行为。 例如，您可以使用修饰器在执行函数之前自动检查一个条件。</p>
<p>修饰器是合约的可继承属性，可以被派生合约重写， 但只有当它们被标记为 <code>virtual</code> 时，才能被重写。 详情请见 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding">修饰器重写</a>。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIOi/meS4quWQiOe6puWPquWumuS5ieS6huS4gOS4quS/rumlsOWZqO+8jOS9huayoeacieS9v+eUqOWug++8mgogICAgLy8g5a6D5bCG5Zyo5rS+55Sf5ZCI57qm5Lit5L2/55So44CCCiAgICAvLyDkv67ppbDlmajmiYDkv67ppbDnmoTlh73mlbDkvZPkvJrooqvmj5LlhaXliLDnibnmrornrKblj7cgYF87YCDnmoTkvY3nva7jgIIKICAgIC8vIOi/meaEj+WRs+edgO+8jOWmguaenOaJgOacieiAheiwg+eUqOi/meS4quWHveaVsO+8jOi/meS4quWHveaVsOWwseS8muiiq+aJp+ihjO+8jAogICAgLy8g5ZCm5YiZ5bCx5Lya5oqb5Ye65LiA5Liq5byC5bi444CCCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgZGVzdHJ1Y3RpYmxlIGlzIG93bmVkIHsKICAgIC8vIOi/meS4quWQiOe6puS7jiBgb3duZWRgIOWQiOe6pue7p+aJv+S6hiBgb25seU93bmVyYCDkv67ppbDlmajvvIwKICAgIC8vIOW5tuWwhuWFtuW6lOeUqOS6jiBgZGVzdHJveWAg5Ye95pWw77yMCiAgICAvLyDlj6rmnInlnKjlkIjnuqbph4zkv53lrZjnmoQgb3duZXIg6LCD55SoIGBkZXN0cm95YCDlh73mlbDvvIzmiY3kvJrnlJ/mlYjjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBzZWxmZGVzdHJ1Y3Qob3duZXIpOwogICAgfQp9Cgpjb250cmFjdCBwcmljZWQgewogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul5o6l5Y+X5Y+C5pWw77yaCiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHJlZ2lzdGVyZWRBZGRyZXNzZXM7CiAgICB1aW50IHByaWNlOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgaW5pdGlhbFByaWNlKSB7IHByaWNlID0gaW5pdGlhbFByaWNlOyB9CgogICAgLy8g5Zyo6L+Z6YeM5Lmf5L2/55So5YWz6ZSu5a2XIGBwYXlhYmxlYCDpnZ7luLjph43opoHvvIwKICAgIC8vIOWQpuWImeWHveaVsOS8muiHquWKqOaLkue7neaJgOacieWPkemAgee7meWug+eahOS7peWkquW4geOAggogICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSBwdWJsaWMgcGF5YWJsZSBjb3N0cyhwcmljZSkgewogICAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzZXNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZVByaWNlKHVpbnQgcHJpY2VfKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBwcmljZSA9IHByaWNlXzsKICAgIH0KfQoKY29udHJhY3QgTXV0ZXggewogICAgYm9vbCBsb2NrZWQ7CiAgICBtb2RpZmllciBub1JlZW50cmFuY3koKSB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIWxvY2tlZCwKICAgICAgICAgICAgIlJlZW50cmFudCBjYWxsLiIKICAgICAgICApOwogICAgICAgIGxvY2tlZCA9IHRydWU7CiAgICAgICAgXzsKICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICAvLy8g6L+Z5Liq5Ye95pWw5Y+X5LqS5pal6YeP5L+d5oqk77yM6L+Z5oSP5ZGz552AIGBtc2cuc2VuZGVyLmNhbGxgIOS4reeahOmHjeWFpeiwg+eUqOS4jeiDveWGjeasoeiwg+eUqCAgYGZg44CCCiAgICAvLy8gYHJldHVybiA3YCDor63lj6XmjIflrprov5Tlm57lgLzkuLogN++8jOS9huS/rumlsOWZqOS4reeahOivreWPpSBgbG9ja2VkID0gZmFsc2VgIOS7jeS8muaJp+ihjOOAggogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br><br>    <span class="hljs-comment">// 这个合约只定义了一个修饰器，但没有使用它：</span><br>    <span class="hljs-comment">// 它将在派生合约中使用。</span><br>    <span class="hljs-comment">// 修饰器所修饰的函数体会被插入到特殊符号 `_;` 的位置。</span><br>    <span class="hljs-comment">// 这意味着，如果所有者调用这个函数，这个函数就会被执行，</span><br>    <span class="hljs-comment">// 否则就会抛出一个异常。</span><br>    modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            <span class="hljs-string">&quot;Only owner can call this function.&quot;</span><br>        );<br>        _;<br>    &#125;<br>&#125;<br><br>contract destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-comment">// 这个合约从 `owned` 合约继承了 `onlyOwner` 修饰器，</span><br>    <span class="hljs-comment">// 并将其应用于 `destroy` 函数，</span><br>    <span class="hljs-comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract priced &#123;<br>    <span class="hljs-comment">// 修饰器可以接受参数：</span><br>    <span class="hljs-function">modifier <span class="hljs-title">costs</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-keyword">value</span> &gt;= price) &#123;<br>            _;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Register <span class="hljs-keyword">is</span> priced, destructible &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">bool</span>) registeredAddresses;<br>    <span class="hljs-built_in">uint</span> price;<br><br>    constructor(<span class="hljs-built_in">uint</span> initialPrice) &#123; price = initialPrice; &#125;<br><br>    <span class="hljs-comment">// 在这里也使用关键字 `payable` 非常重要，</span><br>    <span class="hljs-comment">// 否则函数会自动拒绝所有发送给它的以太币。</span><br>    <span class="hljs-function">function <span class="hljs-title">register</span>() <span class="hljs-keyword">public</span> payable <span class="hljs-title">costs</span>(<span class="hljs-params">price</span>)</span> &#123;<br>        registeredAddresses[msg.sender] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">changePrice</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price_</span>) <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        price = price_;<br>    &#125;<br>&#125;<br><br>contract Mutex &#123;<br>    <span class="hljs-built_in">bool</span> locked;<br>    <span class="hljs-function">modifier <span class="hljs-title">noReentrancy</span>()</span> &#123;<br>        require(<br>            !locked,<br>            <span class="hljs-string">&quot;Reentrant call.&quot;</span><br>        );<br>        locked = <span class="hljs-literal">true</span>;<br>        _;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> `return 7` 语句指定返回值为 7，但修饰器中的语句 `locked = false` 仍会执行。</span><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> noReentrancy <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        (<span class="hljs-built_in">bool</span> success,) = msg.sender.call(<span class="hljs-string">&quot;&quot;</span>);<br>        require(success);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果您想访问定义在合约 <code>C</code> 中的修饰器 <code>m</code>， 您可以使用 <code>C.m</code> 来引用它而不需要虚拟查询。 只能使用定义在当前合约或其基础合约中的修饰器。 修饰器也可以定义在库合约中，但其使用仅限于同一库合约的函数。</p>
<p>如果同一个函数有多个修饰器，它们之间以空格隔开，并按照所呈现的顺序进行评估运算。</p>
<p>修饰器不能隐式地访问或改变它们所修改的函数的参数和返回值。 它们的值只能在调用的时候明确地传递给它们。</p>
<p>在函数修改器中，有必要指定何时运行应用修改器的函数。 占位符语句（用单个下划线字符 <code>_</code> 表示）用于表示被修改的函数主体应该插入的位置。 请注意，占位符操作符与在变量名中使用下划线作为前导或尾随字符不同， 后者是一种风格上的选择。</p>
<p>修饰器或函数体的显式返回只离开当前修饰器或函数体。 返回变量会被赋值，但整个执行逻辑会从前一个修饰器中定义的 <code>_</code> 之后继续执行。</p>
<p>警告</p>
<p>在Solidity的早期版本中，具有修饰器的函数中的 <code>return</code> 语句会表现的不同。</p>
<p>用 <code>return;</code> 从修饰器显式返回并不影响函数返回的值。 然而，修饰器可以选择完全不执行函数主体，在这种情况下， 返回变量被设置为 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>，就像函数有一个空主体一样。</p>
<p><code>_</code> 符号可以在修饰器中多次出现。每次出现都会被替换成函数体。 该函数返回最后一次调用的返回值。</p>
<p>允许修饰器参数使用任意表达式，在这种情况下，所有从函数中可见的符号在修饰器中都是可见的。 修饰器中引入的符号在函数中是不可见的（因为它们可能因重写而改变）。</p>
<h2 id="常量和不可变状态变量"><a href="#常量和不可变状态变量" class="headerlink" title="常量和不可变状态变量"></a>常量和不可变状态变量<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constants"></a></h2><p>状态变量可以被声明为 <code>constant</code> 或 <code>immutable</code>。 在这两种情况下，变量在合约构建完成后不能被修改。 对于 <code>constant</code> 变量，其值必须在编译时固定， 而对于 <code>immutable</code> 变量，仍然可以在构造时分配。</p>
<p>也可以在文件级别定义 <code>constant</code> 变量。</p>
<p>编译器并没有为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式。</p>
<p>与普通的状态变量相比，常量变量（constant）和不可改变的变量（immutable）的燃料成本要低得多。 对于常量变量，分配给它的表达式被复制到所有访问它的地方，并且每次都要重新评估， 这使得局部优化成为可能。不可变的变量在构造时被评估一次，其值被复制到代码中所有被访问的地方。 对于这些值，要保留32个字节，即使它们可以装入更少的字节。由于这个原因，常量值有时会比不可变的值更便宜。</p>
<p>目前，并非所有的常量和不可变量的类型都已实现。 唯一支持的类型是 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#strings">字符串类型</a> （仅用于常量）和 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#value-types">值类型</a>。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjE7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzID0gMTg7CiAgICB1aW50IGltbXV0YWJsZSBtYXhCYWxhbmNlOwogICAgYWRkcmVzcyBpbW11dGFibGUgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgZGVjaW1hbHNfLCBhZGRyZXNzIHJlZikgewogICAgICAgIGlmIChkZWNpbWFsc18gIT0gMCkKICAgICAgICAgICAgLy8gaW1tdXRhYmxl5Y+Y6YeP5Y+q5pyJ5Zyo6YOo572y5pe25omN5piv5LiN5Y+v5Y+Y55qE44CCCiAgICAgICAgICAgIC8vIOWcqOaehOW7uuaXtu+8jOWug+S7rOWPr+S7peiiq+WIhumFjeS7u+aEj+asoeaVsOOAggogICAgICAgICAgICBkZWNpbWFscyA9IGRlY2ltYWxzXzsKCiAgICAgICAgLy8g5a+5aW1tdXRhYmxl5Y+Y6YeP55qE6LWL5YC855Sa6Iez5Y+v5Lul6K6/6Zeu546v5aKD5Y+Y6YeP44CCCiAgICAgICAgbWF4QmFsYW5jZSA9IHJlZi5iYWxhbmNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGlzQmFsYW5jZVRvb0hpZ2goYWRkcmVzcyBvdGhlcikgcHVibGljIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBvdGhlci5iYWxhbmNlID4gbWF4QmFsYW5jZTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.21</span>;<br><br><span class="hljs-built_in">uint</span> constant X = <span class="hljs-number">32</span>**<span class="hljs-number">22</span> + <span class="hljs-number">8</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">string</span> constant TEXT = <span class="hljs-string">&quot;abc&quot;</span>;<br>    bytes32 constant MY_HASH = keccak256(<span class="hljs-string">&quot;abc&quot;</span>);<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> decimals = <span class="hljs-number">18</span>;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> maxBalance;<br>    address <span class="hljs-keyword">immutable</span> owner = msg.sender;<br><br>    constructor(<span class="hljs-built_in">uint</span> decimals_, address <span class="hljs-keyword">ref</span>) &#123;<br>        <span class="hljs-keyword">if</span> (decimals_ != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// immutable变量只有在部署时才是不可变的。</span><br>            <span class="hljs-comment">// 在构建时，它们可以被分配任意次数。</span><br>            decimals = decimals_;<br><br>        <span class="hljs-comment">// 对immutable变量的赋值甚至可以访问环境变量。</span><br>        maxBalance = <span class="hljs-keyword">ref</span>.balance;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> isBalanceTooHigh(address other) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">bool</span>) &#123;<br>        <span class="hljs-keyword">return</span> other.balance &gt; maxBalance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constant"></a></h3><p>对于 <code>constant</code> 变量，其值在编译时必须是一个常量，并且必须在变量声明的地方分配。 任何访问存储、区块链数据（例如： <code>block.timestamp</code>, <code>address(this).balance</code> 或 <code>block.number</code>） 或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code>）或者调用外部合约的表达式都是不允许的。 但可能对内存分配产生副作用的表达式是允许的，但那些可能对其他内存对象产生副作用的表达式是不允许的。 内置函数 <code>keccak256</code>， <code>sha256</code>， <code>ripemd160</code>， <code>ecrecover</code>， <code>addmod</code> 和 <code>mulmod</code> 是允许的（尽管除了 <code>keccak256</code>，它们确实调用了外部合约）。</p>
<p>允许在内存分配器上产生副作用的原因是， 它应该可以构建复杂的对象，比如说查找表。 这个功能现在还不能完全使用。</p>
<h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#immutable"></a></h3><p>声明为 <code>immutable</code> 的变量比声明为 <code>constant</code> 的变量受到的限制要少一些： 不可变（immutable）变量可以在构造时赋值。 该值在部署前的任何时候都可以更改，然后成为永久值。</p>
<p>另外一个限制是，不可变变量只能分配给创建后不可能被执行的表达式内部。 这就排除了所有修改器定义和构造函数以外的函数。</p>
<p>读取不可变变量没有任何限制。 读取甚至可以在变量第一次被写入之前进行， 因为Solidity中的变量总是有一个定义明确的初始值。 因此，也允许永远不对不可变变量显式赋值。</p>
<p>警告</p>
<p>在构造时访问不可变变量时，请牢记 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#state-variable-initialization-order">初始化顺序</a>。 即使您提供了显式初始化器，某些表达式可能最终会在初始化器之前被求值， 尤其是当它们处于继承层次结构的不同层级时。</p>
<p>备注</p>
<p>在 Solidity 0.8.21 之前，不可变变量的初始化限制较多。 这些变量必须在构造时被初始化一次，而且在此之前不能被读取。</p>
<p>编译器生成的合约创建代码会在返回合约之前修改合约的运行时代码， 并用分配给它们的值替换所有对不可变变量的引用。 如果您要比较编译器生成的运行时代码和实际存储在区块链中的运行时代码，这一点非常重要。 编译器会在 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api">编译器JSON标准输出</a> 的 <code>immutableReferences</code> 字段中 输出这些不可变变量在部署字节码中的位置。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#functions"></a></h2><p>可以在合约内部和外部定义函数。</p>
<p>合约之外的函数，也称为 “自由函数”，总是隐含着 <code>internal</code> 的 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">可见性</a>。 它们的代码包含在所有调用它们的合约中，类似于内部库函数。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Zyo5YaF6YOo6LCD55So6Ieq55Sx5Ye95pWw44CCCiAgICAgICAgLy8g57yW6K+R5Zmo5Lya5bCG5YW25Luj56CB5re75Yqg5Yiw5ZCI57qm5Lit44CCCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)<br>        s += arr[i];<br>&#125;<br><br>contract ArrayExample &#123;<br>    <span class="hljs-keyword">bool</span> found;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这在内部调用自由函数。</span><br>        <span class="hljs-comment">// 编译器会将其代码添加到合约中。</span><br>        <span class="hljs-keyword">uint</span> s = sum(arr);<br>        <span class="hljs-keyword">require</span>(s &gt;= <span class="hljs-number">10</span>);<br>        found = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>备注</p>
<p>在合约之外定义的函数仍然总是在合约的范围内执行。 它们仍然可以调用其他合约，向它们发送以太，并销毁调用它们的合约，以及其他一些事情。 与合约内定义的函数的主要区别是，自由函数不能直接访问变量 <code>this</code>，存储变量和不在其范围内的函数。</p>
<h3 id="函数参数和返回变量"><a href="#函数参数和返回变量" class="headerlink" title="函数参数和返回变量"></a>函数参数和返回变量<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-parameters-return-variables"></a></h3><p>与许多其他语言不同, 函数接受类型化的参数作为输入， 也可以返回任意数量的值作为输出。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id10"></a></h4><p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。</p>
<p>例如，如果您想让您的合约接受一种带有两个整数的外部调用，您可以使用类似以下的方式：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">uint</span> sum;<br>    <span class="hljs-built_in">function</span> taker(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> &#123;<br>        sum = a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数参数可以像任何其他局部变量一样使用，它们也可以被赋值。</p>
<h4 id="返回的变量"><a href="#返回的变量" class="headerlink" title="返回的变量"></a>返回的变量<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8"></a></h4><p>函数的返回变量在 <code>returns</code> 关键字之后用同样的语法声明。</p>
<p>例如，假设您想返回两个结果：作为函数参数传递的两个整数的总和和乘积，那么您就使用类似的方法：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        sum = a + b;<br>        product = a * b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回变量的名字可以被省略。返回变量可以像其他本地变量一样使用， 它们被初始化为相应的 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>， 并且在它们被（重新）赋值之前拥有这个值。</p>
<p>您可以明确地赋值给返回变量，然后像上面那样结束函数， 或者您可以用 <code>return</code> 语句直接提供返回值（单个或 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return">多个返回值</a>）。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (a + b, a * b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果您过早使用 <code>return</code> 来结束一个有返回变量的函数，您必须在返回语句中同时提供返回值。</p>
<p>备注</p>
<p>您不能从非内部函数返回某些类型。 这包括下面列出的类型和任何递归地包含它们的复合类型：</p>
<ul>
<li>映射，</li>
<li>内部函数类型，</li>
<li>参考类型，位置设置为 <code>storage</code>，</li>
<li>多维数组（仅适用于 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>），</li>
<li>结构体（仅适用于 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>）。</li>
</ul>
<p>这个限制不适用于库函数，因为它们有不同的 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#library-selectors">内部 ABI</a>。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return"></a></h4><p>当一个函数有多个返回类型时，语句 <code>return (v0, v1, ..., vn)</code> 可以用来返回多个值。 声明的数量必须与返回变量的数量相同，并且它们的类型必须匹配， 有可能是经过 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#types-conversion-elementary-types">隐式转换</a>。</p>
<h3 id="状态可变性"><a href="#状态可变性" class="headerlink" title="状态可变性"></a>状态可变性<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#state-mutability"></a></h3><h4 id="View-函数"><a href="#View-函数" class="headerlink" title="View 函数"></a>View 函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#view"></a></h4><p>函数可以被声明为 <code>view</code>，在这种情况下，它们承诺不修改状态。</p>
<p>备注</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认）， 当调用 <code>view</code> 函数时，会使用操作码 <code>STATICCALL</code>，这使得状态作为EVM执行的一部分保持不被修改。 对于库合约的 <code>view</code> 函数，会使用 <code>DELEGATECALL</code>， 因为没有组合的 <code>DELEGATECALL</code> 和 <code>STATICCALL</code>。 这意味着库合约中的 <code>view</code> 函数没有防止状态修改的运行时的检查。 这应该不会对安全产生负面影响，因为库合约的代码通常在编译时就知道了， 而且静态检查器也会进行编译时检查。</p>
<p>以下声明被认为是修改状态：</p>
<ol>
<li>修改状态变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events">产生事件</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts">创建其它合约</a>。</li>
<li>使用 <code>selfdestruct</code>。</li>
<li>通过调用发送以太币。</li>
<li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li>
<li>使用低级调用。</li>
<li>使用包含特定操作码的内联汇编。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>) + block.timestamp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>备注</p>
<p>函数上的 <code>constant</code> 曾经是 <code>view</code> 的别名，但在0.5.0版本中被取消。</p>
<p>备注</p>
<p>Getter方法被自动标记为 <code>view</code>。</p>
<p>备注</p>
<p>在0.5.0版本之前，编译器没有为 <code>view</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得 <code>view</code> 函数通过使用无效的显式类型转换进行状态修改。 通过对 <code>view</code> 函数使用 <code>STATICCALL</code>，在EVM层面上防止了对状态的修改。</p>
<h4 id="Pure-函数"><a href="#Pure-函数" class="headerlink" title="Pure 函数"></a>Pure 函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#pure"></a></h4><p>函数可以被声明为 <code>pure</code>，在这种情况下，它们承诺不读取或修改状态。 特别是，应该可以在编译时评估一个 <code>pure</code> 函数，只给它的输入和 <code>msg.data</code>， 但不知道当前区块链状态。这意味着读取 <code>immutable</code> 的变量可以是一个非标准pure的操作。</p>
<p>备注</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认），则使用操作码 <code>STATICCALL</code>， 这并不能保证不读取状态，但至少不能修改。</p>
<p>除了上面解释的状态修改语句列表外，以下内容被认为是从状态中读取的：</p>
<ol>
<li>读取状态变量。</li>
<li>访问 <code>address(this).balance</code> 或者 <code>&lt;address&gt;.balance</code>。</li>
<li>访问 <code>block</code>， <code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li>
<li>调用任何未标记为 <code>pure</code> 的函数。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当一个 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">错误发生</a> 时， Pure 函数能够使用 <code>revert()</code> 和 <code>require()</code> 函数来恢复潜在的状态变化。</p>
<p>恢复一个状态变化不被认为是 “状态修改”， 因为只有之前在没有 <code>view</code> 或 <code>pure</code> 限制的代码中对状态的改变才会被恢复， 并且该代码可以选择捕捉 <code>revert</code> 而不传递给它。</p>
<p>这种行为也与 <code>STATICCALL</code> 操作码一致。</p>
<p>警告</p>
<p>在EVM层面不可能阻止函数读取状态，只可能阻止它们写入状态 （即只有 <code>view</code> 可以在EVM层面执行， <code>pure</code> 不可以）。</p>
<p>备注</p>
<p>在0.5.0版本之前，编译器没有为 <code>pure</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得在 <code>pure</code> 函数中通过使用无效的显式类型转换进行状态修改。 通过对 <code>pure</code> 函数使用 <code>STATICCALL</code>，在EVM层面防止了对状态的修改。</p>
<p>备注</p>
<p>在0.4.17版本之前，编译器并没有强制要求 <code>pure</code> 不读取状态。 这是一个编译时的类型检查，可以规避在合约类型之间做无效的显式转换， 因为编译器可以验证合约的类型不做改变状态的操作， 但它不能检查将在运行时被调用的合约是否真的属于该类型。</p>
<h3 id="特殊的函数"><a href="#特殊的函数" class="headerlink" title="特殊的函数"></a>特殊的函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#special-functions"></a></h3><h4 id="接收以太的函数"><a href="#接收以太的函数" class="headerlink" title="接收以太的函数"></a>接收以太的函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function"></a></h4><p>一个合约最多可以有一个 <code>receive</code> 函数， 使用 <code>receive() external payable &#123; ... &#125;</code> 来声明。（没有 <code>function</code> 关键字）。 这个函数不能有参数，不能返回任何东西，必须具有 <code>external</code> 的可见性和 <code>payable</code> 的状态可变性。 它可以是虚拟的，可以重写，也可以有修饰器。</p>
<p>receive 函数是在调用合约时执行的，并带有空的 calldata。 这是在纯以太传输（例如通过 <code>.send()</code> 或 <code>.transfer()</code> ）时执行的函数。 如果不存在这样的函数，但存在一个 payable 类型的 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function">fallback函数</a>， 这个 fallback 函数将在纯以太传输时被调用。 如果既没有直接接收以太（receive函数），也没有 payable 类型的 fallback 函数， 那么合约就不能通过不代表支付函数调用的交易接收以太币，还会抛出一个异常。</p>
<p>在最坏的情况下， <code>receive</code> 函数只有2300个燃料可用（例如当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基本的记录外，几乎没有空间来执行其他操作。以下操作的消耗燃料将超过2300燃料的规定：</p>
<ul>
<li>写入存储</li>
<li>创建合约</li>
<li>调用消耗大量燃料的外部函数</li>
<li>发送以太币</li>
</ul>
<p>警告</p>
<p>当以太被直接发送到一个合约（没有使用函数调用，即发送者使用 <code>send</code> 或 <code>transfer</code>）， 但接收合约没有定义一个接收以太的函数或一个 payable 类型的 fallback 函数，会抛出一个异常， 将以太送回（这在Solidity v0.4.0之前是不同的）。因此，如果您想让您的合约接收以太， 您必须实现一个 receive 函数（不建议使用 payable 类型的 fallback 函数来接收以太， 因为它不会因为接口混乱而失败）。</p>
<p>警告</p>
<p>没有接收以太币功能的合约可以作为 <em>coinbase交易</em> （又称 <em>矿工区块奖励</em>）的接收者 或作为 <code>selfdestruct</code> 的目的地接收以太币。</p>
<p>合约不能对这样的以太币转移做出反应，因此也不能拒绝它们。 这是EVM的一个设计选择，Solidity无法绕过它。</p>
<p>这也意味着 <code>address(this).balance</code> 可以高于合约中 实现的一些手工记帐的总和（即在接收以太函数中更新的累加器）。</p>
<p>下面您可以看到一个使用 <code>receive</code> 函数的Sink合约的例子。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g6L+Z5Liq5ZCI57qm5Lya5L+d55WZ5omA5pyJ5Y+R6YCB57uZ5a6D55qE5Lul5aSq5biB77yM5rKh5pyJ5Yqe5rOV6L+U6L+Y44CCCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span><br>contract Sink &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Received</span>(<span class="hljs-params">address, <span class="hljs-built_in">uint</span></span>)</span>;<br>    receive() external payable &#123;<br>        <span class="hljs-function">emit <span class="hljs-title">Received</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Fallback-函数"><a href="#Fallback-函数" class="headerlink" title="Fallback 函数"></a>Fallback 函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback"></a></h4><p>一个合约最多可以有一个 <code>fallback</code> 函数，使用 <code>fallback () external [payable]</code> 或 <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code> 来声明（都没有 <code>function</code> 关键字）。 这个函数必须具有 <code>external</code> 的函数可见性。 一个 fallback 函数可以被标记为 virtual，可以标记为 override，也可以有修饰器。</p>
<p>如果其他函数都不符合给定的函数签名，或者根本没有提供数据， 也没有 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太的函数</a>，那么fallback函数将在调用合约时执行。 fallback函数总是接收数据，但为了同时接收以太，它必须被标记为 <code>payable</code>。</p>
<p>如果使用带参数的版本， <code>input</code> 将包含发送给合约的全部数据（等于 <code>msg.data</code>）， 并可以在 <code>output</code> 中返回数据。返回的数据将不会被ABI编码。 相反，它将在没有修改的情况下返回（甚至没有填充）。</p>
<p>在最坏的情况下，如果一个可接收以太的fallback函数也被用来代替接收功能， 那么它只有2300燃料是可用的 （参见 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太函数</a> 对这一含义的简要描述）。</p>
<p>像任何函数一样，只要有足够的燃料传递给它，fallback函数就可以执行复杂的操作。</p>
<p>警告</p>
<p>如果没有 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">receive 函数</a> 的存在， 一个标记为 <code>payable</code> 的 fallback 函数也会在普通的以太传输时执行。 如果您已经定义了一个 payable 类型的 fallback 函数， 我们仍建议您也定义一个 receive 函数接收以太，以区分以太传输和接口混淆的情况。</p>
<p>备注</p>
<p>如果您想对输入数据进行解码，您可以检查前四个字节的函数选择器， 然后您可以使用 <code>abi.decode</code> 与数组切片语法一起对ABI编码的数据进行解码： <code>(c, d) = abi.decode(input[4:], (uint256, uint256));</code> 注意，这只能作为最后的手段，应该使用适当的函数来代替。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyDmiYDmnInlj5HpgIHliLDmraTlkIjnuqbnmoTmtojmga/pg73kvJrosIPnlKjmraTlh73mlbDvvIjmsqHmnInlhbbku5blh73mlbDvvInjgIIKICAgIC8vIOWQkeivpeWQiOe6puWPkemAgeS7peWkquW4geWwhuW8lei1t+W8guW4uO+8jAogICAgLy8g5Zug5Li6ZmFsbGJhY2vlh73mlbDmsqHmnIkgYHBheWFibGVgIOS/rumlsOWZqOOAggogICAgZmFsbGJhY2soKSBleHRlcm5hbCB7IHggPSAxOyB9Cn0KCmNvbnRyYWN0IFRlc3RQYXlhYmxlIHsKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIC8vIOaJgOacieWPkemAgeWIsOatpOWQiOe6pueahOa2iOaBr+mDveS8muiwg+eUqOi/meS4quWHveaVsO+8jAogICAgLy8g6Zmk5LqG5pmu6YCa55qE5Lul5aSq5Lyg6L6T77yI6Zmk5LqGcmVjZWl2ZeWHveaVsO+8jOayoeacieWFtuS7luWHveaVsO+8ieOAggogICAgLy8g5Lu75L2V5a+56K+l5ZCI57qm55qE6Z2e56m655qE6LCD55So6YO95bCG5omn6KGMZmFsbGJhY2vlh73mlbDvvIjljbPkvb/ku6XlpKrkuI7osIPnlKjkuIDotbfooqvlj5HpgIHvvInjgIIKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8g6L+Z5Liq5Ye95pWw5piv5Li657qv5Lul5aSq5Lyg6L6T6ICM6LCD55So55qE77yMCiAgICAvLyDljbPkuLrmr4/kuIDkuKrluKbmnInnqbpjYWxsZGF0YeeahOiwg+eUqOOAggogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgeyB4ID0gMjsgeSA9IG1zZy52YWx1ZTsgfQp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgZnVuY3Rpb24gY2FsbFRlc3QoVGVzdCB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMeOAggoKICAgICAgICAvLyBhZGRyZXNzKHRlc3Qp5bCG5LiN5YWB6K6455u05o6l6LCD55SoIGBgc2VuZGBg77yMCiAgICAgICAgLy8g5Zug5Li6IGBgdGVzdGBgIOayoeacieWPr+aOpeaUtuS7peWkqueahGZhbGxiYWNr5Ye95pWw44CCCiAgICAgICAgLy8g5a6D5b+F6aG76KKr6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5omN5YWB6K646LCD55SoIGBgc2VuZGBg44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIHRlc3RQYXlhYmxlID0gcGF5YWJsZShhZGRyZXNzKHRlc3QpKTsKCiAgICAgICAgLy8g5aaC5p6c5pyJ5Lq65ZCR6K+l5ZCI57qm5Y+R6YCB5Lul5aSq5biB77yM6L2s6LSm5bCG5aSx6LSl77yM5Y2z6L+Z6YeM6L+U5ZueZmFsc2XjgIIKICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIOe7k+aenOaYryB0ZXN0Lngg562J5LqOIDHvvIx0ZXN0Lnkg562J5LqOIDDjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMe+8jHRlc3QueSDnrYnkuo4gMeOAggoKICAgICAgICAvLyDlpoLmnpzmnInkurrlkJHor6XlkIjnuqblj5HpgIHku6XlpKrluIHvvIxUZXN0UGF5YWJsZeeahHJlY2VpdmXlh73mlbDlsIbooqvosIPnlKjjgIIKICAgICAgICAvLyDnlLHkuo7or6Xlh73mlbDkvJrlhpnlhaXlrZjlgqjnqbrpl7TvvIzlroPpnIDopoHnmoTnh4Pmlpnmr5TnroDljZXnmoQgYGBzZW5kYGAg5oiWIGBgdHJhbnNmZXJgYCDopoHlpJrjgIIKICAgICAgICAvLyDnlLHkuo7ov5nkuKrljp/lm6DvvIzmiJHku6zlv4XpobvopoHkvb/nlKjkuIDkuKrkvY7nuqfliKvnmoTosIPnlKjjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyDnu5PmnpzmmK8gdGVzdC54IOetieS6jiAx77yMdGVzdC55IOetieS6jiAyIOS4quS7peWkquOAggoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Test &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用此函数（没有其他函数）。</span><br>    <span class="hljs-comment">// 向该合约发送以太币将引起异常，</span><br>    <span class="hljs-comment">// 因为fallback函数没有 `payable` 修饰器。</span><br>    fallback() external &#123; x = <span class="hljs-number">1</span>; &#125;<br>&#125;<br><br>contract TestPayable &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-keyword">uint</span> y;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用这个函数，</span><br>    <span class="hljs-comment">// 除了普通的以太传输（除了receive函数，没有其他函数）。</span><br>    <span class="hljs-comment">// 任何对该合约的非空的调用都将执行fallback函数（即使以太与调用一起被发送）。</span><br>    fallback() external payable &#123; x = <span class="hljs-number">1</span>; y = msg.value; &#125;<br><br>    <span class="hljs-comment">// 这个函数是为纯以太传输而调用的，</span><br>    <span class="hljs-comment">// 即为每一个带有空calldata的调用。</span><br>    receive() external payable &#123; x = <span class="hljs-number">2</span>; y = msg.value; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTest</span><span class="hljs-params">(Test test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1。</span><br><br>        <span class="hljs-comment">// address(test)将不允许直接调用 ``send``，</span><br>        <span class="hljs-comment">// 因为 ``test`` 没有可接收以太的fallback函数。</span><br>        <span class="hljs-comment">// 它必须被转换为 ``address payable`` 类型，才允许调用 ``send``。</span><br>        address payable testPayable = payable(address(test));<br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，转账将失败，即这里返回false。</span><br>        <span class="hljs-keyword">return</span> testPayable.send(<span class="hljs-number">2</span> ether);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTestPayable</span><span class="hljs-params">(TestPayable test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 0。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">1</span>&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 1。</span><br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，TestPayable的receive函数将被调用。</span><br>        <span class="hljs-comment">// 由于该函数会写入存储空间，它需要的燃料比简单的 ``send`` 或 ``transfer`` 要多。</span><br>        <span class="hljs-comment">// 由于这个原因，我们必须要使用一个低级别的调用。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">2</span> ether&#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 2 个以太。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#overload-function"></a></h3><p>一个合约可以有多个同名的，但参数类型不同的函数。 这个过程被称为 “重写”，也适用于继承的函数。 下面的例子显示了在合约 <code>A</code> 范围内对函数 <code>f</code> 的重写。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value, <span class="hljs-built_in">bool</span> really) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">if</span> (really)<br>            <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重写函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIOi/meauteS7o+eggeS4jeS8mue8luivkQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这段代码不会编译</span><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(B value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (B <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(address value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (address <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上两个 <code>f</code> 函数重写最终都接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p>
<h4 id="重写解析和参数匹配"><a href="#重写解析和参数匹配" class="headerlink" title="重写解析和参数匹配"></a>重写解析和参数匹配<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id17"></a></h4><p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重写函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重写候选项。 如果一个候选都没有，解析失败。</p>
<p>备注</p>
<p>返回参数不作为重写解析的依据。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(uint8 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint8 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(uint256 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint256 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code> 也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为 <code>f(uint256)</code> 重写， 因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events"></a></h2><p>Solidity事件在EVM的日志功能之上给出了一个抽象。 应用程序可以通过Ethereum客户端的RPC接口订阅和监听这些事件。</p>
<p>事件是合约的可继承成员。当您调用它们时， 它们会导致参数被存储在交易的日志中–区块链中的一个特殊数据结构。 这些日志与合约的地址相关联，被纳入区块链， 只要有区块可以访问，就会留在那里（目前是永远，但 将来可能会改变）。 日志及其事件数据不能从合约内部访问（甚至不能从创建它们的合约访问）。</p>
<p>有可能要求为日志提供Merkle证明， 所以如果外部实体向合约提供这样的证明，它可以检查日志是否真的存在于区块链中。 由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p>
<p>您可以最多给三个参数添加 <code>indexed</code> 属性，将它们添加到一个特殊的数据结构中， 称为 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-events">“topics”</a>，而不是日志的数据部分。 一个topic只能容纳一个字（32字节），所以如果您为一个索引参数使用 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#reference-types">引用类型</a>， 该值的Keccak-256哈希值将被存储为一个topic中。</p>
<p>所有没有 <code>indexed</code> 属性的参数都会被 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI 编码</a> 到日志的数据部分。</p>
<p>Topics允许您用来搜索事件，例如为特定的事件来过滤一系列的区块。 您用来也可以通过发出事件的合约的地址来过滤事件。</p>
<p>例如，下面的代码使用web3.js <code>subscribe(&quot;logs&quot;)</code> <a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">方法</a> 来过滤与某一地址值相匹配的日志：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">fromBlock</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">address</span>: web3.eth.defaultAccount,<br>    <span class="hljs-attr">topics</span>: [<span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>&#125;;<br>web3.eth.subscribe(<span class="hljs-string">&#x27;logs&#x27;</span>, options, <span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;)<br>    .on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">log</span>);<br>    &#125;)<br>    .on(<span class="hljs-string">&quot;changed&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>除非您用 <code>anonymous</code> 指定符声明事件，否则事件的签名的哈希值是topic之一。 这意味着不可能通过名字来过滤特定的匿名事件， 您只能通过合约地址来过滤。匿名事件的优点是，它们的部署和调用都比较便宜。 它还允许您声明四个索引参数，而不是三个。</p>
<p>备注</p>
<p>由于交易日志只存储事件数据而不存储类型，因此您必须知道事件的类型， 包括哪个参数被索引以及事件是否是匿名的，以便正确解析数据。 特别的是，有可能用一个匿名事件 “伪造“ 另一个事件的签名。</p>
<h3 id="事件类型的成员方法"><a href="#事件类型的成员方法" class="headerlink" title="事件类型的成员方法"></a>事件类型的成员方法<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-15"></a></h3><ul>
<li><code>event.selector</code>： 对于非匿名事件，这是一个 <code>bytes32</code> 值， 包含事件签名的 <code>keccak256</code> 哈希值，在默认topic中使用。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id21"></a></h3><p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyDkuovku7bmmK/nlKggYGVtaXRgIOWPkeWHuueahO+8jOWQjumdouaYr+S6i+S7tueahOWQjeensOWSjOaLrOWPt+mHjOeahOWPguaVsO+8iOWmguaenOacie+8ieOAggogICAgICAgIC8vIOS7u+S9lei/meagt+eahOiwg+eUqO+8iOeUmuiHs+aYr+a3seW6puW1jOWll++8iemDveWPr+S7pemAmui/h+i/h+a7pCBgRGVwb3NpdGAKICAgICAgICAvLyDku45KYXZhU2NyaXB0IEFQSeS4reajgOa1i+WHuuadpeOAggogICAgICAgIGVtaXQgRGVwb3NpdChtc2cuc2VuZGVyLCBpZCwgbXNnLnZhbHVlKTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.21</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract ClientReceipt &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        address indexed <span class="hljs-keyword">from</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        bytes32 indexed id,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">uint</span> <span class="hljs-keyword">value</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>)</span>;<br><br>    <span class="hljs-function">function <span class="hljs-title">deposit</span>(<span class="hljs-params">bytes32 id</span>) <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// 事件是用 `emit` 发出的，后面是事件的名称和括号里的参数（如果有）。</span><br>        <span class="hljs-comment">// 任何这样的调用（甚至是深度嵌套）都可以通过过滤 `Deposit`</span><br>        <span class="hljs-comment">// 从JavaScript API中检测出来。</span><br>        <span class="hljs-function">emit <span class="hljs-title">Deposit</span>(<span class="hljs-params">msg.sender, id, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在JavaScript API中的使用方式如下：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> abi = <span class="hljs-comment">/* 由编译器产生的abi */</span>;<br><span class="hljs-keyword">var</span> ClientReceipt = web3.eth.contract(abi);<br><span class="hljs-keyword">var</span> clientReceipt = ClientReceipt.at(<span class="hljs-string">&quot;0x1234...ab67&quot;</span> <span class="hljs-comment">/* 地址 */</span>);<br><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit();<br><br><span class="hljs-comment">// 监视变化</span><br>depositEvent.watch(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>)&#123;<br>    <span class="hljs-comment">// 结果包含非索引的参数和给 `Deposit` 调用的 topics。</span><br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br><br><br><span class="hljs-comment">// 或者通过回调立即开始监视</span><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>上面的输出看起来像下面这样（经过修剪）:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   &quot;returnValues&quot;: &#123;<br>       &quot;<span class="hljs-selector-tag">from</span>&quot;: <span class="hljs-string">&quot;0x1111…FFFFCCCC&quot;</span>,<br>       <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;0x50…sd5adb20&quot;</span>,<br>       <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;0x420042&quot;</span><br>   &#125;,<br>   &quot;raw&quot;: &#123;<br>       &quot;data&quot;: <span class="hljs-string">&quot;0x7f…91385&quot;</span>,<br>       <span class="hljs-string">&quot;topics&quot;</span>: [<span class="hljs-string">&quot;0xfd4…b4ead7&quot;</span>, <span class="hljs-string">&quot;0x7f…1a91385&quot;</span>]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="了解事件类型的其他资料"><a href="#了解事件类型的其他资料" class="headerlink" title="了解事件类型的其他资料"></a>了解事件类型的其他资料<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id22"></a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/web3/web3.js/blob/1.x/docs/web3-eth-contract.rst#events">JavaScript 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的使用实例</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们</a></li>
</ul>
<h2 id="错误和恢复语句"><a href="#错误和恢复语句" class="headerlink" title="错误和恢复语句"></a>错误和恢复语句<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors"></a></h2><p>Solidity 中的错误提供了一种方便且省燃料的方式来向用户解释为什么一个操作会失败。 它们可以被定义在合约内部和外部（包括接口合约和库合约）。</p>
<p>它们必须与 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert-statement">恢复语句</a> 一起使用， 它导致当前调用中的所有变化被恢复，并将错误数据传回给调用者。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDovazotKbnmoTkvZnpop3kuI3otrPjgILpnIDopoEgYHJlcXVpcmVkYCDmlbDph4/kvYblj6rmnIkgYGF2YWlsYWJsZWAg5pWw6YeP5Y+v55So44CCCi8vLyBAcGFyYW0g5Y+v55So55qE5L2Z6aKd44CCCi8vLyBAcGFyYW0g6ZyA6KaB6KaB5rGC55qE6L2s5biQ6YeR6aKd44CCCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0=">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.4</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 转账的余额不足。需要 `required` 数量但只有 `available` 数量可用。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 可用的余额。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 需要要求的转帐金额。</span><br><span class="hljs-function">error <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">uint256 available, uint256 <span class="hljs-keyword">required</span></span>)</span>;<br><br>contract TestToken &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) balance;<br>    <span class="hljs-function">function <span class="hljs-title">transfer</span>(<span class="hljs-params">address to, uint256 amount</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; balance[msg.sender])<br>            <span class="hljs-function">revert <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                available: balance[msg.sender],</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">required</span>: amount</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span>)</span>;<br>        balance[msg.sender] -= amount;<br>        balance[to] += amount;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>错误不能被重写或覆盖，但是可以被继承。 只要作用域不同，同一个错误可以在多个地方定义。 错误的实例只能使用 <code>revert</code> 语句创建。</p>
<p>错误会创建数据，然后通过还原操作传递给调用者， 使其返回到链下组件或在 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#try-catch">try/catch 语句</a> 中捕获它。 需要注意的是，一个错误只能在来自外部调用时被捕获， 发生在内部调用或同一函数内的还原不能被捕获。</p>
<p>如果您不提供任何参数，错误只需要四个字节的数据， 您可以像上面一样使用 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/natspec-format.html#natspec">NatSpec 语法</a> 来进一步解释错误背后的原因， 这并不存储在链上。这使得这同时也是一个非常便宜和方便的错误报告功能。</p>
<p>更具体地说，一个错误实例在被ABI编码时， 其方式与对相同名称和类型的函数的调用相同， 然后作为 <code>revert</code> 操作码的返回数据。 这意味着数据由一个4字节的选择器和 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 数据组成。 选择器由错误类型的签名的keccak256-hash的前四个字节组成。</p>
<p>备注</p>
<p>一个合约有可能因为同名的不同错误而恢复， 甚至因为在不同地方定义的错误而使调用者无法区分。 对于外部来说，即ABI，只有错误的名称是相关的，而不是定义它的合约或文件。</p>
<p>如果您能定义 <code>error Error(string)</code>， 那么语句 <code>require(condition, &quot;description&quot;);</code> 将等同于 <code>if (!condition) revert Error(&quot;description&quot;)</code>。 但是请注意， <code>Error</code> 是一个内置类型，不能在用户提供的代码中定义。</p>
<p>同样，一个失败的 <code>assert</code> 或类似的条件将以一个内置的 <code>Panic(uint256)</code> 类型的错误来恢复。</p>
<p>备注</p>
<p>错误数据应该只被用来指示失败，而不是作为控制流的手段。 原因是内部调用的恢复数据默认是通过外部调用链传播回来的。 这意味着内部调用可以 ”伪造” 恢复数据，使它看起来像是来自调用它的合约。</p>
<h3 id="错误类型的成员"><a href="#错误类型的成员" class="headerlink" title="错误类型的成员"></a>错误类型的成员<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id25"></a></h3><ul>
<li><code>error.selector</code>： 一个包含错误类型的选择器的 <code>bytes4</code> 值。</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17"></a></h2><p>Solidity支持多重继承，包括多态性。</p>
<p>多态性意味着函数调用（内部和外部）总是执行继承层次结构中最新继承的合约中的同名函数（和参数类型）。 但必须使用 <code>virtual</code> 和 <code>override</code> 关键字在层次结构中的每个函数上明确启用。 参见 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 以了解更多细节。</p>
<p>通过使用 <code>ContractName.functionName()</code> 明确指定合约， 可以在内部调用继承层次结构中更高的函数。 或者如果您想在扁平化的继承层次中调用高一级的函数（见下文）， 可以使用 <code>super.functionName()</code>。</p>
<p>当一个合约继承自其他合约时，在区块链上只创建一个单一的合约， 所有基础合约的代码被编译到创建的合约中。 这意味着对基础合约的所有内部函数的调用也只是使用内部函数调用 （ <code>super.f(..)</code> 将使用 JUMP 而不是消息调用）。</p>
<p>状态变量的阴影被认为是一个错误。 一个派生合约只能声明一个状态变量 <code>x</code>， 如果在它的任何基类中没有相同名称的可见状态变量。</p>
<p>总的来说，Solidity 的继承系统与 <a target="_blank" rel="noopener" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a> 非常相似，特别是关于多重继承方面，但也有一些 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance">不同之处</a>。</p>
<p>详细情况见下面的例子。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIOS9v+eUqCBgaXNgIOS7juWPpuS4gOS4quWQiOe6pua0vueUn+OAgua0vueUn+WQiOe6puWPr+S7peiuv+mXruaJgOaciemdnuengeacieaIkOWRmO+8jAovLyDljIXmi6zlhoXpg6jlh73mlbDlkoznirbmgIHlj5jph4/vvIzkvYbml6Dms5XpgJrov4cgYHRoaXNgIOadpeWklumDqOiuv+mXruOAggpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8g5YWz6ZSu5a2XIGB2aXJ0dWFsYCDmhI/lkbPnnYDor6Xlh73mlbDlj6/ku6XlnKjmtL7nlJ/nsbvkuK3mlLnlj5jlhbbooYzkuLrvvIjigJzph43lhpnigJ3vvInjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB2aXJ0dWFsIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIHNlbGZkZXN0cnVjdChvd25lcik7CiAgICB9Cn0KCgovLyDov5nkupvmir3osaHlkIjnuqbku4XnlKjkuo7nu5nnvJbor5Hlmajmj5DkvpvmjqXlj6PjgIIKLy8g5rOo5oSP5Ye95pWw5rKh5pyJ5Ye95pWw5L2T44CCCi8vIOWmguaenOS4gOS4quWQiOe6puayoeacieWunueOsOaJgOacieWHveaVsO+8jOWImeWPquiDveeUqOS9nOaOpeWPo+OAggphYnN0cmFjdCBjb250cmFjdCBDb25maWcgewogICAgZnVuY3Rpb24gbG9va3VwKHVpbnQgaWQpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGFkZHJlc3MgYWRyKTsKfQoKCmFic3RyYWN0IGNvbnRyYWN0IE5hbWVSZWcgewogICAgZnVuY3Rpb24gcmVnaXN0ZXIoYnl0ZXMzMiBuYW1lKSBwdWJsaWMgdmlydHVhbDsKICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSBwdWJsaWMgdmlydHVhbDsKfQoKCi8vIOWkmumHjee7p+aJv+aYr+WPr+iDveeahOOAguivt+azqOaEj++8jCBgT3duZWRgIOS5n+aYryBgRGVzdHJ1Y3RpYmxlYCDnmoTln7rnsbvvvIwKLy8g5L2G5Y+q5pyJ5LiA5LiqIGBPd25lZGAg5a6e5L6L77yI5bCx5YOPIEMrKyDkuK3nmoTomZrmi5/nu6fmib/vvInjgIIKY29udHJhY3QgTmFtZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSB7CiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWUpIHsKICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS5yZWdpc3RlcihuYW1lKTsKICAgIH0KCiAgICAvLyDlh73mlbDlj6/ku6Xooqvlj6bkuIDkuKrlhbfmnInnm7jlkIzlkI3np7Dlkoznm7jlkIzmlbDph48v57G75Z6L6L6T5YWl55qE5Ye95pWw6YeN5YaZ44CCCiAgICAvLyDlpoLmnpzph43lhpnlh73mlbDmnInkuI3lkIznsbvlnovnmoTovpPlh7rlj4LmlbDvvIzkvJrlr7zoh7TplJnor6/jgIIKICAgIC8vIOacrOWcsOWSjOWfuuS6jua2iOaBr+eahOWHveaVsOiwg+eUqOmDveS8muiAg+iZkei/meS6m+mHjeWGmeOAggogICAgLy8g5aaC5p6c5oKo5oOz6YeN5YaZ6L+Z5Liq5Ye95pWw77yM5oKo6ZyA6KaB5L2/55SoIGBvdmVycmlkZWAg5YWz6ZSu5a2X44CCCiAgICAvLyDlpoLmnpzmgqjmg7Porqnov5nkuKrlh73mlbDlho3mrKHooqvph43lhpnvvIzmgqjpnIDopoHlho3mjIflrpogYHZpcnR1YWxgIOWFs+mUruWtl+OAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgICAgIE5hbWVSZWcoY29uZmlnLmxvb2t1cCgxKSkudW5yZWdpc3RlcigpOwogICAgICAgICAgICAvLyDku43nhLblj6/ku6XosIPnlKjnibnlrprnmoTph43lhpnlh73mlbDjgIIKICAgICAgICAgICAgRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsKICAgICAgICB9CiAgICB9Cn0KCgovLyDlpoLmnpzmnoTpgKDlh73mlbDmjqXlj5flj4LmlbDvvIwKLy8g5YiZ6ZyA6KaB5Zyo5aOw5piO77yI5ZCI57qm55qE5p6E6YCg5Ye95pWw77yJ5pe25o+Q5L6b77yMCi8vIOaIluWcqOa0vueUn+WQiOe6pueahOaehOmAoOWHveaVsOS9jee9ruS7peS/rumlsOWZqOiwg+eUqOmjjuagvOaPkOS+m++8iOingeS4i+aWh++8ieOAggpjb250cmFjdCBQcmljZUZlZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSwgTmFtZWQoIkdvbGRGZWVkIikgewogICAgZnVuY3Rpb24gdXBkYXRlSW5mbyh1aW50IG5ld0luZm8pIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIGluZm8gPSBuZXdJbmZvOwogICAgfQoKICAgIC8vIOWcqOi/memHjO+8jOaIkeS7rOWPquaMh+WumuS6hiBgb3ZlcnJpZGVgIOiAjOayoeaciSBgdmlydHVhbGDjgIIKICAgIC8vIOi/meaEj+WRs+edgOS7jiBgUHJpY2VGZWVkYCDmtL7nlJ/lh7rmnaXnmoTlkIjnuqbkuI3og73lho3mlLnlj5ggYGRlc3Ryb3lgIOeahOihjOS4uuOAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShEZXN0cnVjdGlibGUsIE5hbWVkKSB7IE5hbWVkLmRlc3Ryb3koKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KCiAgICB1aW50IGluZm87Cn0=">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br><br>contract Owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br><br><span class="hljs-comment">// 使用 `is` 从另一个合约派生。派生合约可以访问所有非私有成员，</span><br><span class="hljs-comment">// 包括内部函数和状态变量，但无法通过 `this` 来外部访问。</span><br>contract Destructible <span class="hljs-keyword">is</span> Owned &#123;<br>    <span class="hljs-comment">// 关键字 `virtual` 意味着该函数可以在派生类中改变其行为（“重写”）。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 这些抽象合约仅用于给编译器提供接口。</span><br><span class="hljs-comment">// 注意函数没有函数体。</span><br><span class="hljs-comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span><br><span class="hljs-keyword">abstract</span> contract Config &#123;<br>    <span class="hljs-function">function <span class="hljs-title">lookup</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> id</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">address adr</span>)</span>;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> contract NameReg &#123;<br>    <span class="hljs-function">function <span class="hljs-title">register</span>(<span class="hljs-params">bytes32 name</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>    <span class="hljs-function">function <span class="hljs-title">unregister</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">// 多重继承是可能的。请注意， `Owned` 也是 `Destructible` 的基类，</span><br><span class="hljs-comment">// 但只有一个 `Owned` 实例（就像 C++ 中的虚拟继承）。</span><br>contract Named <span class="hljs-keyword">is</span> Owned, Destructible &#123;<br>    constructor(bytes32 name) &#123;<br>        Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>        NameReg(config.lookup(<span class="hljs-number">1</span>)).register(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重写。</span><br>    <span class="hljs-comment">// 如果重写函数有不同类型的输出参数，会导致错误。</span><br>    <span class="hljs-comment">// 本地和基于消息的函数调用都会考虑这些重写。</span><br>    <span class="hljs-comment">// 如果您想重写这个函数，您需要使用 `override` 关键字。</span><br>    <span class="hljs-comment">// 如果您想让这个函数再次被重写，您需要再指定 `virtual` 关键字。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) &#123;<br>            Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>            NameReg(config.lookup(<span class="hljs-number">1</span>)).unregister();<br>            <span class="hljs-comment">// 仍然可以调用特定的重写函数。</span><br>            Destructible.destroy();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 如果构造函数接受参数，</span><br><span class="hljs-comment">// 则需要在声明（合约的构造函数）时提供，</span><br><span class="hljs-comment">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span><br>contract PriceFeed <span class="hljs-keyword">is</span> Owned, Destructible, Named(<span class="hljs-string">&quot;GoldFeed&quot;</span>) &#123;<br>    <span class="hljs-function">function <span class="hljs-title">updateInfo</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newInfo</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) info = newInfo;<br>    &#125;<br><br>    <span class="hljs-comment">// 在这里，我们只指定了 `override` 而没有 `virtual`。</span><br>    <span class="hljs-comment">// 这意味着从 `PriceFeed` 派生出来的合约不能再改变 `destroy` 的行为。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Destructible, Named</span>)</span> &#123; Named.destroy(); &#125;<br>    <span class="hljs-function">function <span class="hljs-title">get</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> r</span>)</span> &#123; <span class="hljs-keyword">return</span> info; &#125;<br><br>    <span class="hljs-built_in">uint</span> info;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，在上面，我们调用 <code>Destructible.destroy()</code> 来 “转发” 销毁请求。 这样做的方式是有问题的，从下面的例子中可以看出：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgRmluYWwgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7IEJhc2UyLmRlc3Ryb3koKTsgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; Base2.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用 <code>Final.destroy()</code> 时会调用最后的派生重写函数 <code>Base2.destroy</code>， 但是会绕过 <code>Base1.destroy</code>， 解决这个问题的方法是使用 <code>super</code>：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgc3VwZXIuZGVzdHJveSgpOyB9Cn0=">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> super.destroy(); &#125;<br>&#125;<br><br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> super.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; super.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 <code>Base2</code> 调用 <code>super</code> 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的上一个基类合约中调用这个函数， 所以它会调用 <code>Base1.destroy()</code> （注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, Destructible, ownerd）。 在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。</p>
<h3 id="函数重写-1"><a href="#函数重写-1" class="headerlink" title="函数重写"></a>函数重写<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding"></a></h3><p>如果基函数被标记为 <code>virtual</code>，则可以通过继承合约来改变其行为。 被重写的函数必须在函数头中使用 <code>override</code> 关键字。 重写函数只能将被重写函数的可见性从 <code>external</code> 改为 <code>public</code>。 可变性可以按照以下顺序改变为更严格的可变性。 <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 重写。 <code>view</code> 可以被 <code>pure</code> 重写。 <code>payable</code> 是一个例外，不能被改变为任何其他可变性。</p>
<p>下面的例子演示了改变函数可变性和可见性：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> external view</span> &#123;&#125;<br>&#125;<br><br>contract Middle <span class="hljs-keyword">is</span> Base &#123;&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Middle<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> pure</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于多重继承，必须在 <code>override</code> 关键字后明确指定定义同一函数的最多派生基类合约。 换句话说，您必须指定所有定义同一函数的基类合约， 并且还没有被另一个基类合约重写（在继承图的某个路径上）。 此外，如果一个合约从多个（不相关的）基类合约上继承了同一个函数，必须明确地重写它。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyDmtL7nlJ/oh6rlpJrkuKrlrprkuYkgZm9vKCkg5Ye95pWw55qE5Z+657G75ZCI57qm77yMCiAgICAvLyDmiYDku6XmiJHku6zlv4XpobvmmI7noa7lnLDph43lhpnlroMKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0=">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-comment">// 派生自多个定义 foo() 函数的基类合约，</span><br>    <span class="hljs-comment">// 所以我们必须明确地重写它</span><br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果函数被定义在一个共同的基类合约中， 或者在一个共同的基类合约中有一个独特的函数已经重写了所有其他的函数， 则不需要明确的函数重写指定符。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyDml6DpnIDmmI7noa7nmoTph43lhpkKY29udHJhY3QgRCBpcyBCLCBDIHt9">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123; <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span>&#123;&#125; &#125;<br>contract B <span class="hljs-keyword">is</span> A &#123;&#125;<br>contract C <span class="hljs-keyword">is</span> A &#123;&#125;<br><span class="hljs-comment">// 无需明确的重写</span><br>contract D <span class="hljs-keyword">is</span> B, C &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>更准确地说，如果有一个基类合约是该签名的所有重写路径的一部分， 并且（1）该基类合约实现了该函数，并且从当前合约到该基类合约的任何路径都没有提到具有该签名的函数， 或者（2）该基类合约没有实现该函数，并且从当前合约到该基类合约的所有路径中最多只有一个提到该函数， 那么就不需要重写从多个基类合约继承的函数（直接或间接）。</p>
<p>在这个意义上，一个签名的重写路径是一条继承图的路径， 它从所考虑的合约开始，到提到具有该签名的函数的合约结束， 而该签名没有重写。</p>
<p>如果您不把一个重写的函数标记为 <code>virtual</code>，派生合约就不能再改变该函数的行为。</p>
<p>备注</p>
<p>具有 <code>private</code> 可见性的函数不能是 <code>virtual</code>。</p>
<p>备注</p>
<p>在接口合约之外，没有实现的函数必须被标记为 <code>virtual</code>。 在接口合约中，所有的函数都被自动视为 <code>virtual</code>。</p>
<p>备注</p>
<p>从Solidity 0.8.8开始，当重写一个接口函数时， 不需要 <code>override</code> 关键字，除非该函数被定义在多个基础上。</p>
<p>如果函数的参数和返回类型与变量的getter函数匹配，公共状态变量可以重写为外部函数。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() external view <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br><br>contract B <span class="hljs-keyword">is</span> A<br>&#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> f;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>备注</p>
<p>虽然公共状态变量可以重写外部函数，但它们本身不能被重写。</p>
<h3 id="修饰器重写"><a href="#修饰器重写" class="headerlink" title="修饰器重写"></a>修饰器重写<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding"></a></h3><p>函数修改器可以相互重写。 这与 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 的工作方式相同（除了对修改器没有重写）。 <code>virtual</code> 关键字必须用在被重写的修改器上， <code>override</code> 关键字必须用在重写的修改器上：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span></span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在多重继承的情况下，必须明确指定所有的直接基类合约。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor"></a></h3><p>构造函数是一个用 <code>constructor</code> 关键字声明的可选函数， 它在合约创建时被执行，您可以在这里运行合约初始化代码。</p>
<p>在构造函数代码执行之前，如果您用内联编程的方式初始化状态变量，则将其初始化为指定的值； 如果您不用内联编程的方式来初始化，则将其初始化为 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>。</p>
<p>构造函数运行后，合约的最终代码被部署到区块链上。 部署代码的燃料花费与代码长度成线性关系。 这段代码包括属于公共接口的所有函数，以及所有通过函数调用可以到达的函数。 但不包括构造函数代码或只从构造函数中调用的内部函数。</p>
<p>如果没有构造函数，合约将假定默认的构造函数， 相当于 <code>constructor() &#123;&#125;</code>。比如说：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=">open in Remix</a></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract A &#123;<br>    uint <span class="hljs-keyword">public</span> a;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uint a_</span>) &#123;<br>        a = a_;<br>    &#125;<br>&#125;<br><br>contract B is <span class="hljs-title function_">A</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>您可以在构造函数中使用内部参数（例如，存储指针）。 在这种情况下，合约必须被标记为 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract">abstract</a>， 因为这些参数不能从外部分配有效的值，只能通过派生合约的构造函数来赋值。</p>
<p>警告</p>
<p>在0.4.22版本之前，构造函数被定义为与合约同名的函数。 这种语法已被废弃，在0.5.0版本中不再允许。</p>
<p>警告</p>
<p>在0.7.0版本之前，您必须指定构造函数的可见性为 <code>internal</code> 或 <code>public</code>。</p>
<h3 id="基本构造函数的参数"><a href="#基本构造函数的参数" class="headerlink" title="基本构造函数的参数"></a>基本构造函数的参数<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21"></a></h3><p>所有基类合约的构造函数将按照下面解释的线性化规则被调用。 如果基类合约构造函数有参数，派生合约需要指定所有的参数。 这可以通过两种方式实现：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyDopoHkuYjnm7TmjqXlnKjnu6fmib/liJfooajkuK3mjIflrpouLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaIluiAhemAmui/h+a0vueUn+aehOmAoOWHveaVsOeahOS4gOS4qiAi5L+u5pS55ZmoIuKApuKApgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgeSkgQmFzZSh5ICogeSkge30KfQoKLy8g5oiW6ICF5bCG5ZCI57qm5aOw5piO5Li6YWJzdHJhY3TnsbvlnovigKbigKYKYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIOW5tuiuqeS4i+S4gOS4quWFt+S9k+eahOa0vueUn+WQiOe6puWvueWFtui/m+ihjOWIneWni+WMluOAggpjb250cmFjdCBEZXJpdmVkRnJvbURlcml2ZWQgaXMgRGVyaXZlZDMgewogICAgY29uc3RydWN0b3IoKSBCYXNlKDEwICsgMTApIHt9Cn0=">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base &#123;<br>    <span class="hljs-built_in">uint</span> x;<br>    constructor(<span class="hljs-built_in">uint</span> x_) &#123; x = x_; &#125;<br>&#125;<br><br><span class="hljs-comment">// 要么直接在继承列表中指定...</span><br><span class="hljs-function">contract Derived1 <span class="hljs-keyword">is</span> <span class="hljs-title">Base</span>(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span> &#123;<br>    constructor() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者通过派生构造函数的一个 &quot;修改器&quot;……</span><br>contract Derived2 <span class="hljs-keyword">is</span> Base &#123;<br>    constructor(<span class="hljs-built_in">uint</span> y) Base(y * y) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者将合约声明为abstract类型……</span><br><span class="hljs-keyword">abstract</span> contract Derived3 <span class="hljs-keyword">is</span> Base &#123;<br>&#125;<br><br><span class="hljs-comment">// 并让下一个具体的派生合约对其进行初始化。</span><br>contract DerivedFromDerived <span class="hljs-keyword">is</span> Derived3 &#123;<br>    constructor() Base(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一种方式是直接在继承列表中给出（ <code>is Base(7)</code> ）。 另一种是通过修改器作为派生构造函数的一部分被调用的方式（ <code>Base(y * y)</code> ）。 如果构造函数参数是一个常量，并且定义了合约的行为或描述了它，那么第一种方式更方便。 如果基类合约的构造函数参数依赖于派生合约的参数，则必须使用第二种方式。 参数必须在继承列表中或在派生构造函数中以修饰器的形式给出。 在两个地方都指定参数是一个错误。</p>
<p>如果一个派生合约没有指定其所有基类合约的构造函数的参数，那么它必须被声明为 abstract 类型。在这种情况下， 当另一个合约从它派生时，其他合约的继承列表或构造函数必须为所有没有指定参数的基类合约提供必要的参数 （否则，其他合约也必须被声明为 abstract 类型）。例如，在上面的代码片段中， 可以查看合约 <code>Derived3</code> 和 <code>DerivedFromDerived</code>。</p>
<h3 id="多重继承与线性化"><a href="#多重继承与线性化" class="headerlink" title="多重继承与线性化"></a>多重继承与线性化<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance"></a></h3><p>编程语言实现多重继承需要解决几个问题。 一个问题是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a> 。 Solidity 借鉴了 Python 的方式并且使用 “<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>” 强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终实现我们所希望的唯一化的结果，但也使某些继承方式变为无效。 尤其是，基类在 <code>is</code> 后面的顺序很重要。 在下面的代码中， 您必须按照从 “最接近的基类”（most base-like）到 “最远的继承”（most derived）的顺序来指定所有的基类。 注意，这个顺序与Python中使用的顺序相反。</p>
<p>另一种简化的解释方式是，当一个函数被调用时， 它在不同的合约中被多次定义，给定的基类以深度优先的方式从右到左（Python中从左到右）进行搜索， 在第一个匹配处停止。如果一个基类合约已经被搜索过了，它就被跳过。</p>
<p>在下面的代码中，Solidity 会给出 “Linearization of inheritance graph impossible” 这样的错误。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8g6L+Z5q615Luj56CB5LiN5Lya57yW6K+RCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==">open in Remix</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>contract <span class="hljs-attribute">X</span> &#123;&#125;<br>contract <span class="hljs-selector-tag">A</span> is <span class="hljs-attribute">X</span> &#123;&#125;<br>// 这段代码不会编译<br>contract C is <span class="hljs-selector-tag">A</span>, <span class="hljs-attribute">X</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>代码编译出错的原因是 <code>C</code> 要求 <code>X</code> 重写 <code>A</code> （因为定义的顺序是 <code>A, X</code> ）， 但是 <code>A</code> 本身要求重写 <code>X</code>， 这是一种无法解决的冲突。</p>
<p>由于您必须明确地重写一个从多个基类合约继承的函数， 而没有唯一的重写，C3线性化在实践中不是太重要。</p>
<p>继承的线性化特别重要的一个领域是，当继承层次中存在多个构造函数时，也许不那么清楚。 构造函数将总是按照线性化的顺序执行，而不管它们的参数在继承合约的构造函数中是以何种顺序提供的。 比如说：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaehOmAoOWHveaVsOaMieS7peS4i+mhuuW6j+aJp+ihjO+8mgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8g5p6E6YCg5Ye95pWw5oyJ5Lul5LiL6aG65bqP5omn6KGM77yaCi8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyDmnoTpgKDlh73mlbDku43mjInku6XkuIvpobrluo/miafooYzvvJoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=">open in Remix</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br>contract <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base1</span><br><span class="hljs-comment">//  2 - Base2</span><br><span class="hljs-comment">//  3 - Derived1</span><br>contract <span class="hljs-title class_">Derived1</span> is <span class="hljs-title class_">Base1</span>, <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived2</span><br>contract <span class="hljs-title class_">Derived2</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base2</span>() <span class="hljs-title class_">Base1</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数仍按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived3</span><br>contract <span class="hljs-title class_">Derived3</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="继承有相同名字的不同类型成员"><a href="#继承有相同名字的不同类型成员" class="headerlink" title="继承有相同名字的不同类型成员"></a>继承有相同名字的不同类型成员<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id33"></a></h3><p>由于继承的关系，一个合约可能包含多个共享相同名称的定义，这种情况只有一种：</p>
<ul>
<li>函数重写。</li>
<li>重写virtual函数</li>
<li>通过状态变量获取器重写外部virtual函数。</li>
<li>重写virtual修饰符。</li>
<li>事件重写。</li>
</ul>
<h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract"></a></h2><p>当合约中至少有一个函数没有被实现，或者合约没有为其所有的基本合约构造函数提供参数时， 合约必须被标记为 abstract。 即使不是这种情况，合约仍然可以被标记为 abstract， 例如，当您不打算直接创建合约时。 抽象（abstract）合约类似于 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interfaces">接口（interface）合约</a>， 但是接口（interface）合约可以声明的内容更加有限。</p>
<p>如下例所示，使用 <code>abstract</code> 关键字来声明一个抽象合约。 注意，这个合约需要被定义为 abstract，因为函数 <code>utterance()</code> 被声明了， 但没有提供实现（没有给出实现体 <code>&#123; &#125;</code>）。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的抽象合约不能被直接实例化。如果一个抽象合约本身实现了所有定义的功能，这也是可以的。 抽象合约作为基类的用法在下面的例子中显示：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9">open in Remix</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br><br>contract Cat <span class="hljs-keyword">is</span> Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">override</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;miaow&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个合约继承自一个抽象合约，并且没有通过重写实现所有未实现的函数，那么它也需要被标记为抽象的。</p>
<p>注意，没有实现的函数与 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#function-types">函数类型</a> 不同，尽管它们的语法看起来非常相似。</p>
<p>没有实现内容的函数的例子（一个函数声明）：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==">open in Remix</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span>;<br></code></pre></td></tr></table></figure>
<p>类型为函数类型的变量的声明实例：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==">open in Remix</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span> <span class="hljs-title function_">foo</span>;<br></code></pre></td></tr></table></figure>
<p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自我记录， 促进了像 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a> 这样的模式， 并消除了代码的重复。抽象合约的作用与在接口中定义方法的作用相同。 它是抽象合约的设计者说 “我的任何孩子都必须实现这个方法” 的一种方式。</p>
<p>备注</p>
<p>抽象合约不能用一个未实现的virtual函数来重写一个已实现的virtual函数。</p>
<h2 id="接口（interface）合约"><a href="#接口（interface）合约" class="headerlink" title="接口（interface）合约"></a>接口（interface）合约<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interface"></a></h2><p>接口（interface）合约类似于抽象（abstract）合约，但是它们不能实现任何函数。并且还有进一步的限制：</p>
<ul>
<li>它们不能继承其他合约，但是它们可以继承其他接口合约。</li>
<li>在接口合约中所有声明的函数必须是 external 类型的，即使它们在合约中是 public 类型的。</li>
<li>它们不能声明构造函数。</li>
<li>它们不能声明状态变量。</li>
<li>它们不能声明修饰器。</li>
</ul>
<p>将来可能会解除这些里的某些限制。</p>
<p>接口合约基本上仅限于合约 ABI 可以表示的内容， 并且 ABI 和接口合约之间的转换应该不会丢失任何信息。</p>
<p>接口合约由它们自己的关键字表示：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9">open in Remix</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> Token &#123;<br>    <span class="hljs-keyword">enum</span> TokenType &#123; Fungible, NonFungible &#125;<br>    <span class="hljs-keyword">struct</span> Coin &#123; <span class="hljs-built_in">string</span> obverse; <span class="hljs-built_in">string</span> reverse; &#125;<br>    <span class="hljs-built_in">function</span> transfer(address recipient, <span class="hljs-built_in">uint</span> amount) external;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就像继承其他合约一样，合约可以继承接口合约。</p>
<p>所有在接口合约中声明的函数都是隐式的 <code>virtual</code> 的类型， 任何重写它们的函数都不需要 <code>override</code> 关键字。 这并不自动意味着一个重写的函数可以被再次重写–这只有在重写的函数被标记为 <code>virtual</code> 时才可能。</p>
<p>接口合约可以从其他接口合约继承。这与普通的继承有着相同的规则。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyDlv4Xpobvph43mlrDlrprkuYl0ZXN077yM5Lul5L6/5pat6KiA54i257G755qE5ZCr5LmJ5piv5YW85a6555qE44CCCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=">open in Remix</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentA</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentB</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SubInterface</span> <span class="hljs-keyword">is</span> ParentA, ParentB &#123;<br>    <span class="hljs-comment">// 必须重新定义test，以便断言父类的含义是兼容的。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">override</span><span class="hljs-params">(ParentA, ParentB)</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在接口合约和其他类似合约的结构中定义的类型可以从其他合约中访问： <code>Token.TokenType</code> 或 <code>Token.Coin</code>。</p>
<p>警告</p>
<p>接口合约从 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/050-breaking-changes.html">Solidity 0.5.0</a> 开始支持 <code>enum</code> 类型， 请确保pragma版本至少指定这个版本。</p>
<h2 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries"></a></h2><p>库合约与普通合约类似，但是它们只需要在特定的地址部署一次， 并且它们的代码可以通过 EVM 的 <code>DELEGATECALL</code> (Homestead 之前使用 <code>CALLCODE</code> 关键字)特性进行重用。 这意味着如果库函数被调用，它的代码在调用合约的上下文中执行， 即 <code>this</code> 指向调用合约，特别是可以访问调用合约的存储。 因为每个库合约都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。 如果库函数不修改状态（也就是说，如果它们是 <code>view</code> 或者 <code>pure</code> 函数）， 它们可以通过直接调用来使用（即不使用 <code>DELEGATECALL</code> 关键字）， 这是因为我们假定库合约是无状态的。 特别的是，销毁一个库合约是不可能的。</p>
<p>备注</p>
<p>在0.4.20版本之前，有可能通过规避Solidity的类型系统来破坏库合约。 从该版本开始，库合约包含一个 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection">保护机制</a>， 不允许直接调用修改状态的函数（即没有 <code>DELEGATECALL</code> ）。</p>
<p>库合约可以看作是使用他们的合约的隐式的基类合约。 虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似 （如果 <code>L</code> 是库合约的话，可以使用 <code>L.f()</code> 调用库函数）。 当然，需要使用内部调用约定来调用内部函数，这意味着所有的内部类型都可以被传递， 类型 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存</a> 将被引用传递而不是复制。 为了在EVM中实现这一点，从合约中调用的内部库函数的代码和其中调用的所有函数将在编译时包含在调用合约中， 并使用常规的 <code>JUMP</code> 调用，而不是 <code>DELEGATECALL</code>。</p>
<p>备注</p>
<p>当涉及到公共函数时，继承的类比就失效了。 用 <code>L.f()</code> 调用公共库函数的结果是一个外部调用（准确地说，是 <code>DELEGATECALL</code> ）。 相反，当 <code>A.f()</code> 是当前合约的基类合约时， <code>A.f()</code> 是一个内部调用。</p>
<p>下面的示例说明如何使用库（但也请务必看看 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for">using for</a> 有一个实现 set 更好的例子）。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOaIkeS7rOWumuS5ieS6huS4gOS4quaWsOeahOe7k+aehOS9k+aVsOaNruexu+Wei++8jOeUqOS6juWcqOiwg+eUqOWQiOe6puS4reS/neWtmOaVsOaNruOAggpzdHJ1Y3QgRGF0YSB7CiAgICBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7Cn0KCmxpYnJhcnkgU2V0IHsKICAgIC8vIOazqOaEj+esrOS4gOS4quWPguaVsOaYryDigJxzdG9yYWdlIHJlZmVyZW5jZeKAneexu+Wei++8jAogICAgLy8g5Zug5q2k5Zyo6LCD55So5Lit5Y+C5pWw5Lyg6YCS55qE5Y+q5piv5a6D55qE5a2Y5YKo5Zyw5Z2A6ICM5LiN5piv5YaF5a6544CCCiAgICAvLyDov5nmmK/lupPlh73mlbDnmoTkuIDkuKrnibnmgKfjgILlpoLmnpzor6Xlh73mlbDlj6/ku6Xooqvop4bkuLrlr7nosaHnmoTmlrnms5XvvIwKICAgIC8vIOWImeS5oOaDr+ensOesrOS4gOS4quWPguaVsOS4uiBgc2VsZmAg44CCCiAgICBmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5LiN5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDkuI3pnIDopoHlupPnmoTnibnlrprlrp7kvovlsLHlj6/ku6XosIPnlKjlupPlh73mlbDvvIwKICAgICAgICAvLyDlm6DkuLrlvZPliY3lkIjnuqblsLHmmK8g4oCcaW5zdGFuY2XigJ3jgIIKICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyDlpoLmnpzmiJHku6zmhL/mhI/vvIzmiJHku6zkuZ/lj6/ku6XlnKjov5nkuKrlkIjnuqbkuK3nm7TmjqXorr/pl64ga25vd25WYWx1ZXMuZmxhZ3PjgIIKfQ==">open in Remix</a></p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br><span class="hljs-comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span><br>struct Data &#123;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags;<br>&#125;<br><br>library Set &#123;<br>    <span class="hljs-comment">// 注意第一个参数是 “storage reference”类型，</span><br>    <span class="hljs-comment">// 因此在调用中参数传递的只是它的存储地址而不是内容。</span><br>    <span class="hljs-comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，</span><br>    <span class="hljs-comment">// 则习惯称第一个参数为 `self` 。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">view</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>    &#125;<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 不需要库的特定实例就可以调用库函数，</span><br>        <span class="hljs-comment">// 因为当前合约就是 “instance”。</span><br>        <span class="hljs-keyword">require</span>(Set.insert(knownValues, value));<br>    &#125;<br>    <span class="hljs-comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，您不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。 函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p>
<p>调用 <code>Set.contains</code>， <code>Set.insert</code> 和 <code>Set.remove</code> 都被编译为对外部合约/库的调用（ <code>DELEGATECALL</code> ）。 如果使用库，请注意实际执行的是外部函数调用。 <code>msg.sender</code>， <code>msg.value</code> 和 <code>this</code> 在调用中将保留它们的值， （在 Homestead 之前，因为使用了 <code>CALLCODE</code> ，改变了 <code>msg.sender</code> 和 <code>msg.value</code>)。</p>
<p>下面的例子显示了如何使用 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存中的类型</a> 和库合约中的内部函数， 以实现自定义类型，而没有外部函数调用的开销：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDns5/ns5XvvIzmiJHku6zlv4Xpobvlop7liqDkuIDkuKogbGltYgogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBhLCB1aW50IGluZGV4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gaW5kZXggPCBhLmxpbWJzLmxlbmd0aCA/IGEubGltYnNbaW5kZXhdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<br><br>struct <span class="hljs-type">bigint</span> &#123;<br>    uint[] limbs;<br>&#125;<br><br>library <span class="hljs-type">BigInt</span> &#123;<br>    <span class="hljs-keyword">function</span> fromUint(uint x) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](<span class="hljs-number">1</span>);<br>        r.limbs[<span class="hljs-number">0</span>] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">bigint</span> memory a, <span class="hljs-type">bigint</span> memory b) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](max(a.limbs.length, b.limbs.length));<br>        uint carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i) &#123;<br>            uint limbA = limb(a, i);<br>            uint limbB = limb(b, i);<br>            unchecked &#123;<br>                r.limbs[i] = limbA + limbB + carry;<br><br>                <span class="hljs-keyword">if</span> (limbA + limbB &lt; limbA || (limbA + limbB == <span class="hljs-keyword">type</span>(uint).max &amp;&amp; carry &gt; <span class="hljs-number">0</span>))<br>                    carry = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    carry = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            // 糟糕，我们必须增加一个 limb<br>            uint[] memory newLimbs = <span class="hljs-built_in">new</span> uint[](r.limbs.length + <span class="hljs-number">1</span>);<br>            uint i;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i)<br>                newLimbs[i] = r.limbs[i];<br>            newLimbs[i] = carry;<br>            r.limbs = newLimbs;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> limb(<span class="hljs-type">bigint</span> memory a, uint <span class="hljs-keyword">index</span>) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> &lt; a.limbs.length ? a.limbs[<span class="hljs-keyword">index</span>] : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> max(uint a, uint b) private pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">BigInt</span> <span class="hljs-keyword">for</span> <span class="hljs-type">bigint</span>;<br><br>    <span class="hljs-keyword">function</span> f() <span class="hljs-built_in">public</span> pure &#123;<br>        <span class="hljs-type">bigint</span> memory x = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-number">7</span>);<br>        <span class="hljs-type">bigint</span> memory y = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-keyword">type</span>(uint).max);<br>        <span class="hljs-type">bigint</span> memory z = x.<span class="hljs-keyword">add</span>(y);<br>        <span class="hljs-keyword">assert</span>(z.limb(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过将库合约的类型转换为 <code>address</code> 类型，即使用 <code>address(LibraryName)</code>，可以获得一个库的地址。</p>
<p>由于编译器不知道库合约的部署地址， 编译后的十六进制代码将包含 <code>__$30bbc0abd4d6364515865950d3e0d10953$__</code> 形式的占位符。 占位符是完全等同于库合约名的keccak256哈希值的34个字符的前缀，例如 <code>libraries/bigint.sol:BigInt</code>， 如果该库存储在 <code>libraries/</code> 目录下一个名为 <code>bigint.sol</code> 的文件中。 这样的字节码是不完整的，不应该被部署。占位符需要被替换成实际地址。 您可以在编译库的时候把它们传递给编译器，或者用链接器来更新已经编译好的二进制文件。 参见 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#library-linking">库链接</a>，了解如何使用命令行编译器进行链接。</p>
<p>与合约相比，库在以下方面受到限制：</p>
<ul>
<li>它们不能有状态变量</li>
<li>它们不能继承，也不能被继承</li>
<li>它们不能接收以太</li>
<li>它们不能被销毁</li>
</ul>
<p>(这些可能会在以后的时间里被解除)。</p>
<h3 id="库合约中的函数签名和选择器"><a href="#库合约中的函数签名和选择器" class="headerlink" title="库合约中的函数签名和选择器"></a>库合约中的函数签名和选择器<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-27"></a></h3><p>虽然对公共或外部库函数的外部调用是可能的，但这种调用的调用惯例被认为是 Solidity 内部的， 与常规 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">合约 ABI</a> 所指定的不一样。 外部库函数比外部合约函数支持更多的参数类型，例如递归结构和存储指针。 由于这个原因，用于计算4字节选择器的函数签名是按照内部命名模式计算的， 合约ABI中不支持的类型的参数使用内部编码。</p>
<p>签名中的类型使用了以下标识符：</p>
<ul>
<li>值类型、非存储的 <code>string</code> 和非存储的 <code>bytes</code> 使用与合约ABI中相同的标识符。</li>
<li>非存储数组类型遵循与合约ABI中相同的惯例，即 <code>&lt;type&gt;[]</code> 用于动态数组， <code>&lt;type&gt;[M]</code> 用于 <code>M</code> 元素的固定大小数组。</li>
<li>非存储结构体用其完全等同于的名称来指代，即 <code>C.S</code> 代表 <code>contract C &#123; struct S &#123; ... &#125; &#125;</code>。</li>
<li>存储指针映射使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code>， 其中 <code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 分别是映射的键和值类型的标识。</li>
<li>其他存储指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格，即 <code>storage</code>。</li>
</ul>
<p>参数的编码与普通合约ABI相同，除了存储指针， 它被编码为一个 <code>uint256</code> 值，指的是它们所指向的存储槽。</p>
<p>与合约ABI类似，选择器由签名的Keccak256-hash的前四个字节组成。 它的值可以通过使用 <code>.selector</code> 成员从 Solidity 获得，如下：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ada">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span>.<span class="hljs-number">14</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>library L &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(uint256) external &#123;&#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">g</span>() public pure returns (bytes4) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">L.f.selector</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection"></a></h3><p>正如介绍中提到的那样，如果库的代码是通过 <code>CALL</code> 来执行， 而不是 <code>DELEGATECALL</code> 或者 <code>CALLCODE</code>， 那么执行的结果会被恢复， 除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。</p>
<p>EVM没有提供一个直接的方法让合约检测它是否被使用 <code>CALL</code> 调用， 但是合约可以使用 <code>ADDRESS</code> 操作码来找出它当前运行的 “位置”。 生成的代码将这个地址与构造时使用的地址进行比较，以确定调用的模式。</p>
<p>更具体地说，一个库合约的运行时代码总是以 push 指令开始， 在编译时它是一个20字节的零。 当部署代码运行时，这个常数在内存中被当前地址所取代，这个修改后的代码被存储在合约中。 在运行时，这导致部署时的地址成为第一个被推入堆栈的常数， 对于任何非view和非pure函数，调度器代码会将当前地址与这个常数进行比较。</p>
<p>这意味着一个存储在链上的库合约的实际代码，与编译器报告的 <code>deployedBytecode</code> 的代码不同。</p>
<h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for"></a></h2><p>指令 <code>using A for B</code> 可以用来将函数（ <code>A</code>）作为操作符附加到用户定义的值类型， 或者作为任何类型（ <code>B</code>）的成员函数。 成员函数将它们被调用的对象作为第一个参数接收（像 Python 中的 <code>self</code> 变量）。 操作符函数将操作数作为参数接收。</p>
<p>它可以在文件级别或者在合约级别的合约内部有效。</p>
<p>第一部分， <code>A</code>，可以是以下之一：</p>
<ul>
<li>一个函数列表，可以选择性地分配操作符名称（例如 <code>using &#123;f, g as +, h, L.t&#125; for uint</code>）。 如果没有指定操作符，函数可以是库函数或自由函数，并作为成员函数附加到类型上。 否则，它必须是一个自由函数，并成为该类型上该操作符的定义。</li>
<li>一个库合约的名称（例如 <code>using L for uint</code> ）- 该库合约的所有非私有函数都作为成员函数附加在该类型上。</li>
</ul>
<p>在文件级别中，第二部分， <code>B</code>，必须是一个明确的类型（没有数据位置指定）。 在合约内部，您也可以用 <code>*</code> 代替类型（例如 <code>using L for *;</code> ）， 这样做的效果是，库合约 <code>L</code> 中所有的函数都会被附加到 <em>所有</em> 类型上。</p>
<p>如果您指定了一个库合约，那么该库合约中的 <em>所有</em> 非私有函数都会被附加到该类型上， 即使是那些第一个参数的类型与对象的类型不匹配的函数。 类型会在函数被调用的时候检查， 并执行函数重写解析。</p>
<p>如果您使用一个函数列表（例如 <code>using &#123;f, g, h, L.t&#125; for uint</code> ）， 那么类型（ <code>uint</code> ）必须可以隐式地转换为这些函数的第一个参数。 即使这些函数都没有被调用，也要进行这种检查。 请注意，只有当 <code>using for</code> 位于库合约内时，才能指定私有库函数。</p>
<p>如果您定义了一个操作符（例如 <code>using &#123;f as +&#125; for T</code>），那么类型（ <code>T</code>）必须是一个 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/types.html#user-defined-value-types">用户定义的值类型</a>，并且定义必须是一个 <code>pure</code> 函数。 操作符定义必须是全局的。 以下操作符可以用这种方式定义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Category</th>
<th>Operator</th>
<th>Possible signatures</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitwise</td>
<td><code>&amp;</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td><code>^</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td><code>~</code></td>
<td><code>function (T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>+</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td><code>function (T) pure returns (T)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>function (T, T) pure returns (T)</code></td>
<td></td>
</tr>
<tr>
<td>Comparison</td>
<td><code>==</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
<td></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
<td></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>function (T, T) pure returns (bool)</code></td>
</tr>
</tbody>
</table>
</div>
<p>注意，一元和二元的 <code>-</code> 需要单独定义。 编译器会根据操作符的调用方式选择正确的定义。</p>
<p><code>using A for B;</code> 指令只在当前作用域（合约或当前模块/源单元）内有效， 包括其中所有的函数，在使用它的合约或模块之外没有任何效果。</p>
<p>当在文件级别使用该指令并应用于在同一文件中用户定义类型时， 可以在末尾添加 <code>global</code> 关键字。 这将使函数和操作符附加到该类型的任何可用位置（包括其他文件）， 而不仅仅是在 using 语句的范围内。</p>
<p>下面我们将使用文件级函数来重写 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries">库合约</a> 部分中的 set 示例。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyDnjrDlnKjmiJHku6znu5nov5nkuKrnsbvlnovpmYTliqDkuIrlh73mlbDjgIIKLy8g6ZmE5Yqg55qE5Ye95pWw5Y+v5Lul5Zyo5qih5Z2X55qE5YW25LuW6YOo5YiG5L2/55So44CCCi8vIOWmguaenOaCqOWvvOWFpeS6huivpeaooeWdl++8jAovLyDmgqjlv4XpobvlnKjpgqPph4zph43lpI11c2luZ+aMh+S7pO+8jOS+i+WmggovLyAgIGltcG9ydCAiZmxhZ3Muc29sIiBhcyBGbGFnczsKLy8gICB1c2luZyB7RmxhZ3MuaW5zZXJ0LCBGbGFncy5yZW1vdmUsIEZsYWdzLmNvbnRhaW5zfQovLyAgICAgZm9yIEZsYWdzLkRhdGE7CnVzaW5nIHtpbnNlcnQsIHJlbW92ZSwgY29udGFpbnN9IGZvciBEYXRhOwoKZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOS4jeWtmOWcqAogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHZpZXcKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIHJldHVybiBzZWxmLmZsYWdzW3ZhbHVlXTsKfQoKCmNvbnRyYWN0IEMgewogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIOi/memHjO+8jCBEYXRhIOexu+Wei+eahOaJgOacieWPmOmHj+mDveacieS4juS5i+ebuOWvueW6lOeahOaIkOWRmOWHveaVsOOAggogICAgICAgIC8vIOS4i+mdoueahOWHveaVsOiwg+eUqOWSjCBgU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpYCDnmoTmlYjmnpzlrozlhajnm7jlkIzjgIIKICAgICAgICByZXF1aXJlKGtub3duVmFsdWVzLmluc2VydCh2YWx1ZSkpOwogICAgfQp9">open in Remix</a></p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>struct Data &#123; mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags; &#125;<br><span class="hljs-comment">// 现在我们给这个类型附加上函数。</span><br><span class="hljs-comment">// 附加的函数可以在模块的其他部分使用。</span><br><span class="hljs-comment">// 如果您导入了该模块，</span><br><span class="hljs-comment">// 您必须在那里重复using指令，例如</span><br><span class="hljs-comment">//   import &quot;flags.sol&quot; as Flags;</span><br><span class="hljs-comment">//   using &#123;Flags.insert, Flags.remove, Flags.contains&#125;</span><br><span class="hljs-comment">//     for Flags.Data;</span><br>using &#123;insert, remove, contains&#125; <span class="hljs-keyword">for</span> Data;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">view</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这里， Data 类型的所有变量都有与之相对应的成员函数。</span><br>        <span class="hljs-comment">// 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span><br>        <span class="hljs-keyword">require</span>(knownValues.insert(value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可以通过这种方式来扩展内置类型。 在这个例子中，我们将使用一个库合约。</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyDov5nlsIbmiafooYzlupPlkIjnuqbkuK3nmoTlh73mlbDosIPnlKgKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=">open in Remix</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>library <span class="hljs-keyword">Search</span> &#123;<br>    <span class="hljs-keyword">function</span> indexOf(uint[] <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>        <span class="hljs-built_in">public</span><br>        <span class="hljs-keyword">view</span><br>        <span class="hljs-keyword">returns</span> (uint)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; self.length; i++)<br>            <span class="hljs-keyword">if</span> (self[i] == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>(uint).max;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">Search</span> <span class="hljs-keyword">for</span> uint[];<br><br>contract C &#123;<br>    uint[] data;<br><br>    <span class="hljs-keyword">function</span> append(uint <span class="hljs-keyword">value</span>) <span class="hljs-built_in">public</span> &#123;<br>        data.push(<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> replace(uint <span class="hljs-keyword">from</span>, uint <span class="hljs-keyword">to</span>) <span class="hljs-built_in">public</span> &#123;<br>        // 这将执行库合约中的函数调用<br>        uint <span class="hljs-keyword">index</span> = data.indexOf(<span class="hljs-keyword">from</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == <span class="hljs-keyword">type</span>(uint).max)<br>            data.push(<span class="hljs-keyword">to</span>);<br>        <span class="hljs-keyword">else</span><br>            data[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">to</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，所有的外部库调用实际都是EVM函数调用。 这意味着，如果传递内存或值类型，即使是 <code>self</code> 变量，也会执行复制。 只有在使用存储引用变量或调用内部库函数时，才不会执行复制。</p>
<p>另一个展示了如何为用户定义的类型定义一个自定义操作符的例子：</p>
<p><a target="_blank" rel="noopener" href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTk7Cgp0eXBlIFVGaXhlZDE2eDIgaXMgdWludDE2OwoKdXNpbmcgewogICAgYWRkIGFzICssCiAgICBkaXYgYXMgLwp9IGZvciBVRml4ZWQxNngyIGdsb2JhbDsKCnVpbnQzMiBjb25zdGFudCBTQ0FMRSA9IDEwMDsKCmZ1bmN0aW9uIGFkZChVRml4ZWQxNngyIGEsIFVGaXhlZDE2eDIgYikgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICByZXR1cm4gVUZpeGVkMTZ4Mi53cmFwKFVGaXhlZDE2eDIudW53cmFwKGEpICsgVUZpeGVkMTZ4Mi51bndyYXAoYikpOwp9CgpmdW5jdGlvbiBkaXYoVUZpeGVkMTZ4MiBhLCBVRml4ZWQxNngyIGIpIHB1cmUgcmV0dXJucyAoVUZpeGVkMTZ4MikgewogICAgdWludDMyIGEzMiA9IFVGaXhlZDE2eDIudW53cmFwKGEpOwogICAgdWludDMyIGIzMiA9IFVGaXhlZDE2eDIudW53cmFwKGIpOwogICAgdWludDMyIHJlc3VsdDMyID0gYTMyICogU0NBTEUgLyBiMzI7CiAgICByZXF1aXJlKHJlc3VsdDMyIDw9IHR5cGUodWludDE2KS5tYXgsICJEaXZpZGUgb3ZlcmZsb3ciKTsKICAgIHJldHVybiBVRml4ZWQxNngyLndyYXAodWludDE2KGEzMiAqIFNDQUxFIC8gYjMyKSk7Cn0KCmNvbnRyYWN0IE1hdGggewogICAgZnVuY3Rpb24gYXZnKFVGaXhlZDE2eDIgYSwgVUZpeGVkMTZ4MiBiKSBwdWJsaWMgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICAgICAgcmV0dXJuIChhICsgYikgLyBVRml4ZWQxNngyLndyYXAoMjAwKTsKICAgIH0KfQ==">open in Remix</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.19</span>;<br><br><span class="hljs-keyword">type</span> UFixed16x2 <span class="hljs-keyword">is</span> uint16;<br><br><span class="hljs-keyword">using</span> &#123;<br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">as</span> +,<br>    div <span class="hljs-keyword">as</span> /<br>&#125; <span class="hljs-keyword">for</span> UFixed16x2 <span class="hljs-keyword">global</span>;<br><br>uint32 <span class="hljs-keyword">constant</span> SCALE = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));<br>&#125;<br><br><span class="hljs-keyword">function</span> div(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    uint32 a32 = UFixed16x2.unwrap(a);<br>    uint32 b32 = UFixed16x2.unwrap(b);<br>    uint32 result32 = a32 * SCALE / b32;<br>    require(result32 &lt;= <span class="hljs-keyword">type</span>(uint16).max, &quot;Divide overflow&quot;);<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(uint16(a32 * SCALE / b32));<br>&#125;<br><br>contract Math &#123;<br>    <span class="hljs-keyword">function</span> avg(UFixed16x2 a, UFixed16x2 b) <span class="hljs-built_in">public</span> pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>        <span class="hljs-keyword">return</span> (a + b) / UFixed16x2.wrap(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="category-chain-item">区块链</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/" class="print-no-link">#区块链智能合约语法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>合约</div>
      <div>https://www.zhengcookie.site/2025/07/09/合约/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zhengcookie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/12/javascript/" title="javascript">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javascript</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/08/vue/" title="vue">
                        <span class="hidden-mobile">vue</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sTZBx4mwQ0t3yfqJB5XmuIhz-gzGzoHsz","appKey":"KJPXk2hOqDfll4hbw93yYmUc","path":"window.location.pathname","placeholder":"请在这里写下你的评论","avatar":"/img/avatar.png","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"enable":true,"bg":null,"visitor":false,"option":null},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
