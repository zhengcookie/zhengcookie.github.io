<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengcookie</title>
  
  <subtitle>zhengcookie的个人博客</subtitle>
  <link href="https://www.zhengcookie.site/atom.xml" rel="self"/>
  
  <link href="https://www.zhengcookie.site/"/>
  <updated>2026-01-09T09:29:40.543Z</updated>
  <id>https://www.zhengcookie.site/</id>
  
  <author>
    <name>zhengcookie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ai大模型电子书</title>
    <link href="https://www.zhengcookie.site/zhengcookie/ai%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    <id>https://www.zhengcookie.site/zhengcookie/ai%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%94%B5%E5%AD%90%E4%B9%A6/</id>
    <published>2026-01-09T09:16:03.000Z</published>
    <updated>2026-01-09T09:29:40.543Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><p>大模型全套资料→夸克网盘文件链接：<a href="https://pan.quark.cn/s/ef4f66a5ec0a">https://pan.quark.cn/s/ef4f66a5ec0a</a><br>大模型全套资料→百度网盘文件链接：<a href="https://pan.baidu.com/s/1Bbnw5tsK1b50oo2QfUiDqg?pwd=izg3">https://pan.baidu.com/s/1Bbnw5tsK1b50oo2QfUiDqg?pwd=izg3</a></p><p><a href="https://pan.baidu.com/s/1XHTPipTFct8BJi7NAhV_3Q?dp-logid=78821300141927410002&amp;pwd=itns#/home/%2F%E5%A4%A7%E6%A8%A1%E5%9E%8B%2F3%E3%80%81B%E7%AB%99%E3%80%81%E8%A7%86%E9%A2%91%E5%8F%B7%E7%AD%89%E8%B5%84%E6%96%99/%2F%E8%87%AA%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BF%85%E7%9C%8B%E7%9A%846%E6%9C%AC%E4%B9%A6%E7%B1%8DPDF">https://pan.baidu.com/s/1XHTPipTFct8BJi7NAhV_3Q?dp-logid=78821300141927410002&amp;pwd=itns#/home/%2F%E5%A4%A7%E6%A8%A1%E5%9E%8B%2F3%E3%80%81B%E7%AB%99%E3%80%81%E8%A7%86%E9%A2%91%E5%8F%B7%E7%AD%89%E8%B5%84%E6%96%99/%2F%E8%87%AA%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BF%85%E7%9C%8B%E7%9A%846%E6%9C%AC%E4%B9%A6%E7%B1%8DPDF</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;video-container&quot;&gt;
[up主专用，视频内嵌代码贴在这]
&lt;/div&gt;

&lt;style&gt;
.video-container {
    position: relative;
    width: 100%;
    padding-top:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AI大模型学习</title>
    <link href="https://www.zhengcookie.site/zhengcookie/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.zhengcookie.site/zhengcookie/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-12-23T17:52:26.000Z</published>
    <updated>2026-01-08T17:26:56.440Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container">[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=115389581303333&bvid=BV1u9W7zCEmh&cid=33157548834&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h1><h2 id="从函数到神经网络"><a href="#从函数到神经网络" class="headerlink" title="从函数到神经网络"></a>从函数到神经网络</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在早期的人工智能研究中，有一种观点认为可以通过找到一个精确的数学函数来表达和解决所有问题。这种想法基于一种信念：即世界上的每一种现象或规律都可以通过某种形式的函数关系来描述。然而，随着研究的深入，人们逐渐认识到现实世界的复杂性远超最初的想象。</p><h4 id="符号主义"><a href="#符号主义" class="headerlink" title="符号主义"></a>符号主义</h4><p>符号主义是早期人工智能的一个重要流派，它试图通过逻辑推理、规则匹配等方法来模拟人类的思维过程。这种方法的核心在于寻找并利用那些能够准确描述问题本质的“规律”。然而，在面对极其复杂的现实情况时，符号主义遇到了难以克服的挑战——即如何全面而准确地捕捉到这些规律。</p><h4 id="转向近似解"><a href="#转向近似解" class="headerlink" title="转向近似解"></a>转向近似解</h4><p>由于直接找到完美匹配所有情况下的通用法则变得几乎不可能，研究人员开始转向另一种思路：即使不能得到完全正确的答案，但至少可以尝试获得一个足够接近真实结果的近似解。这种方法更加灵活，并且能够在一定程度上缓解了对绝对精度的要求。</p><h4 id="联结主义"><a href="#联结主义" class="headerlink" title="联结主义"></a>联结主义</h4><p>当传统的方法无法有效解决问题时，联结主义提供了一种全新的视角。联结主义主张模仿大脑神经元之间的连接方式来构建模型，通过训练让系统自动学习数据中的模式。这实际上是一种“猜测”加“简化”的策略，其中关键在于如何有效地估计权重（w）和偏置（b）参数值。</p><ul><li><strong>线性模型</strong>：最简单的形式就是线性方程 f(x) = wx + b，其中 w 表示输入 x 对输出的影响程度，b 则是一个常数项。</li><li><strong>激活函数</strong>：为了使模型能够处理非线性的关系，引入了激活函数 g()。例如，sigmoid 或 ReLU 等函数可以将线性组合的结果转换为更复杂的非线性映射。</li></ul><h4 id="通过组合构建复杂关系"><a href="#通过组合构建复杂关系" class="headerlink" title="通过组合构建复杂关系"></a>通过组合构建复杂关系</h4><p>通过不断地将线性和非线性激活函数相结合，可以创建出非常强大的模型来表示极为复杂的关系。尽管这种方式极大地增强了模型的表现力，但也带来了计算上的难度以及理解上的挑战。</p><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>神经网络是上述思想的具体实现之一。它由多个层次组成，每个层次包含若干个节点（类似于神经元），这些节点之间通过权重相连。整个网络的工作原理可以用公式 f(x) = g(wx+b) 来概括，其中 g() 是激活函数，wx+b 则是对输入进行线性变换后的结果。通过调整各层之间的权重和偏置，神经网络能够学习到从输入到输出之间复杂的映射关系，从而实现诸如图像识别、自然语言处理等多种任务。<br>总之，从最初的追求精确到后来接受近似，再到采用更加直观且灵活的联结主义方法，人工智能的发展历程体现了科学研究不断适应新挑战的过程。</p><p> 输入层  输出层</p><p>  x              y</p><p>复杂一点像下图这样 ↓</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766046923044-43b4b7f9-649d-4450-97d9-02ac0c46ca7f.png" alt="img"></p><h2 id="计算神经网络的参数"><a href="#计算神经网络的参数" class="headerlink" title="计算神经网络的参数"></a>计算神经网络的参数</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>如图</p><p>y为真实数据 y^为预测数据</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766048463141-dca6f4c9-66ba-4b3e-9c20-42d904dfa3c7.png" alt="img"></p><p>用于真实值与预测值的误差</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766048597312-7b3fde0d-4483-4d79-9b07-f7a5da1d3347.png" alt="img"></p><p>我们可以把所有真实值和预测值加起来，这样可以得到预测数据和真实数据之间的总的误差（拟合度）</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766048764193-ee7a1f24-ce5a-4692-a68b-0197fcea4314.png" alt="img"></p><h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差 (MSE)"></a>均方误差 (MSE)</h4><p>因为绝对值不平滑，我们用平方来代替，一来解决绝对值的误差，二来放大误差较大的值的影响，我们再根据样本的数量平均一下，消除样本数量大小的影响，我们把损失函数记成L，就得到下面的公式</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049113577-b909e089-68c0-4a60-9cff-6f119032dfcf.png" alt="img"></p><p>参数视角则为</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049190107-11cac79e-12f2-4cd5-8269-120a1ad236f2.png" alt="img"></p><h5 id="简单的线性函数"><a href="#简单的线性函数" class="headerlink" title="简单的线性函数"></a>简单的线性函数</h5><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049287600-270b12ad-c73d-423b-93b9-9a9a708dab2f.png" alt="img"></p><h6 id="演化过程"><a href="#演化过程" class="headerlink" title="演化过程"></a>演化过程</h6><p>展开损失函数</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049356850-8b1bb26b-e2dc-4a85-a6f4-41bf318e7928.png" alt="img"></p><p>把y^代入</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224194539575.png" alt="image-20251224194539575"></p><p>求和符号展开</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049425818-05035746-d163-49e0-9929-8f9d76f5a228.png" alt="img"></p><p>把上面这组数据带进来（视频里给的最后一个3-4w，大概率是写错了）</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049579943-2a76f1a7-80d7-4310-a4f2-c8b61bc94177.png" alt="img"></p><p>平方展开,代入公式是a^2 - 2ab +b^2</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049597461-db478700-4ca6-4be5-a3bd-dd573c4a1cd1.png" alt="img"></p><p>化简结果</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049618819-1b094465-59cb-4383-be26-d3914a812c5d.png" alt="img"></p><p>求导，怎么求呢</p><p>图一</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766051072389-10c9e01c-51b0-41bd-b8da-2303603eb12a.png" alt="img"></p><p> <strong>计算 w^x = x个 w</strong><br><strong>原题中</strong></p><p><strong>常数项为0，因为他不随w变化</strong></p><p><strong>一次项w 一个w在变 -&gt;变化算一次 所以乘以1</strong></p><p><strong>两次项 俩个w在变 → 变化算两次 → 乘 2</strong></p><p>所以：d/dw(7.5w^2) = 7.5 · 2w = 15</p><p>结果</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766049670250-5fc5a388-1cc2-4d39-9548-26769128fca8.png" alt="img"></p><p>要求最小值，带入进来就是</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766051756268-eb0d6c13-174d-4876-ab89-5b3c9e2e498b.png" alt="img"></p><p>导数等于0，就可以得到</p><p>带入为原直线函数，</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766051846313-8a1dec09-39b2-4728-846c-de0a958fb822.png" alt="img"></p><p> y 是模型的输出（预测值 ）这个 y 预测损失多少</p><p>此时y=x就是让损失函数最小，也就是最拟合真实数据的那条直线</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195437775.png" alt="image-20251224195437775"></p><p>所以它（损失函数）实际上就是一条开口向上的抛物线，我们刚刚就在寻找最低点，采用的办法就是导数=0</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766052825703-c42aaade-94d0-4656-97e6-b2a5c6ba1261.png" alt="img"></p><h5 id="复杂的线性函数"><a href="#复杂的线性函数" class="headerlink" title="复杂的线性函数"></a>复杂的线性函数</h5><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766053239598-a3a57817-f3ea-450d-bd56-5ee9f94a7606.png" alt="img"></p><p>图像来解释就是一个三维图像，一个开口向上的网状形状</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766053278114-96774c5b-499e-4249-87fd-cd3d8ce12213.png" alt="img"></p><p>我们要找到的就是这个二元函数最小值对应的w和b</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766053324153-f1563548-104f-45fb-b64d-010d3c9d15fb.png" alt="img"></p><p>那么就不再是计算导数，而是偏导数来求解</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766053390008-230d0d7f-30b5-4ca1-b0b0-5266148cc257.png" alt="img"></p><p>对w求偏导，就是把b当作常数，在三维图像就是这样的，相当于只看到这个切面</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054063306-184912ac-02cb-436a-8c3b-945fb2dc09f4.png" alt="img"></p><p>对于b也是如此，对b求偏导，就是把w当作常数，在三维图像就是这样的，相当于只看到这个切面</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054169528-bf94fd5c-cb96-4077-bf19-4224f582ec77.png" alt="img"></p><h6 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h6><p>通过寻找一个线性函数，来拟合x和y之间的关系，也就是机器学习中最基本的一种分析方法，我们叫他线性回归</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766053480429-1bf6184b-a68f-40e4-9c84-13910b9c2b4e.png" alt="img"></p><p>往往呢，我们不能通过像刚刚那样将导数=0来计算出最小值</p><p>解决办法呢，简单除暴一点就是一点点试</p><p>假如w为5，b为5，损失函数计算结果为10</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054347400-9463e8cc-2921-4e93-8176-281d26611ecb.png" alt="img"></p><p>我们调整了w为6，损失函数为9，这说明w增加让损失函数的值变小了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054454849-dfbee1f9-cc72-40f0-bfac-f979a9b4655b.png" alt="img"></p><p>再尝试b增加1，结果为11.损失函数增加2，说明b增加让损失函数的值变大了，误差变大了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054507666-6c5d1b49-36cd-4f40-b6c4-c6818468408f.png" alt="img"></p><p>我们就反过来对b进行减少，让损失函数继续变小</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195618519.png" alt="image-20251224195618519"></p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195719092.png" alt="image-20251224195719092"></p><p>w变化一点点，使得损失函数也发生变化。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195732171.png" alt="image-20251224195732171"></p><p>这其实是损失函数对w的偏导数</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054674741-e873d4ed-3659-45f5-93f0-4a1d8beeca6b.png" alt="img"></p><p>对b也是如此</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195744652.png" alt="image-20251224195744652"></p><p>我们要做的其实就是w和b不断网偏导数的反方向去变化</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195839067.png" alt="image-20251224195839067"></p><p>具体的变化快慢呢，我们用一个系数n来表示，我们叫他学习率</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224195856760.png" alt="image-20251224195856760"></p><h6 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h6><p>这些导数所构成的向量，我们就叫他梯度</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766054957460-4da50ce0-5e47-4c11-a4ab-dea821468a15.png" alt="img"></p><h6 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h6><p>不断变化w和b，让损失函数逐渐变小的一个过程，进而求出最终的w和b，这个过程我们叫他梯度下降。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224200007284.png" alt="image-20251224200007284"></p><p>偏导数如何求？</p><p>神经网络中，虽然函数本身是一个复杂到变态的非线性函数，直接求导不好求。</p><p>但是，层与层之间的关系，确实非常简单的，我们就用前面的这个神经网络结构来举例</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224200029670.png" alt="image-20251224200029670"></p><p>只有一个输入和输出，而且中间只有一个隐藏层。</p><p>我们通过x来计算出隐藏层a的值，这个g就是随便一个激活函数，比如sigmod<img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766055493403-4624d8d5-13e5-4195-b003-a917a0657965.png" alt="img"></p><p>再根据a的值计算出y^的值，然后根据y^的值以及真实值y计算出损失函数L，损失函数就用均方误差了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766055170364-d52495e0-98ea-4dd7-ac99-ef55660728e4.png" alt="img"></p><p>由于只有一个输出数据，所以把求符号省略掉了</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251224021425633.png" alt="image-20251224021425633"></p><h6 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h6><p>这个神经网络中共有4个参数，w1和w2，b1和b2要通过梯度下降的方式逐渐求解。</p><p>w1变化多少，会让L变化多少。</p><p>我们就看w1变化一个单位，a变化多少</p><p>再看a变化一个单位，会让y^变化多少</p><p>最后看y^变化一个单位，会对L变化多少</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766056428445-950f35bb-a739-4536-a9ff-31cdd7866b69.png" alt="img"></p><p>把三者相乘，就知道w变化一个单位，会使得L变化多少了</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766056479480-94de5713-01c1-4d26-a397-ece20d91c8ff.png" alt="img"></p><p>也就是微积分中的复合函数求导，在这里也叫做链式法则。</p><h6 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h6><p>因为我们可以从右向左计算求导公式，逐步更新每一层的参数，直到把所有的神经网络的参数，都计算一遍，所以前面计算用到的偏导数的值后面也会用到，所以不必计算太多，而是让这些值从右向左一点点传播过来，这个过程就叫做反向传播。</p><p><strong>训练</strong></p><p>我们通过前向传播输入x计算输出y，通过反向传播计算出损失函数个参数的梯度，每个参数都向着梯度的反方向变化，这就构成了神经网络的训练。当神经网络进行足够多的训练，直到让损失函数足够小，也就是找到了我们需要的那个函数。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1766057555821-4fcadbc3-0fa3-4678-b7af-a8f1c4ace229.png" alt="img"></p><h2 id="调教神经网络的方法"><a href="#调教神经网络的方法" class="headerlink" title="调教神经网络的方法"></a>调教神经网络的方法</h2><p>我们知道神经网络的本质就是线性变换，套上一个激活函数，不断组合而成的一个非常复杂的非线性函数，并且巧妙地通过梯度下降，</p><p>我们可以从肉眼看出下面哪个好，一点点计算出神经网络中的一组合适的参数，那这样看起来只要神经网络足够大，岂不是什么问题都能解决了，理论上确实是这样，但是理想很丰满，现实很骨感，令人头疼的问题很快就接踵而至。</p><p>上个视频中我们说过，我们的目标是让数据拟合的好，比如左边这个就拟合的挺好，右边这个就不太好</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260108235638803.png" alt="image-20260108235638803"></p><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a><strong>过拟合</strong></h3><p>那再来一组图，这回你认为是左边好还是右边好呢？</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109000320243.png" alt="image-20260109000320243"></p><p>纯从预测值与真实值误差来看，也就是损失值最小化这个目标来看的话，显然右边这个更好但直觉似乎告诉我们，右边这个好像有点好的太过了，结果可能是只适合训练数据，对新数据的预测反而不如左边的准，那这种在训练数据上表现的很完美，但是在没见过的数据上表现的很糟糕的现象，就叫做过拟合。而在没见过的数据上的表现能力我们叫<code>泛化能力</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109000615421.png" alt="image-20260109000615421"></p><p>那为什么会过拟合呢。看看刚刚这个图。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109000819688.png" alt="image-20260109000819688"></p><p>其实就是训练数据本身是个很简单的规律，但模型太复杂了，把那些噪声和随机波动也给学会了，那这该怎么办呢？</p><p>自然就是简化一下模型的复杂度</p><p>比如说这个案例中</p><p>你用一个非常复杂的神经网络模型来训练</p><p>效果甚至不如一个线性模型好</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109000910123.png" alt="image-20260109000910123"></p><p>这就告诉我们</p><p>神经网络不是越大越好</p><p>那简化模型复杂度有效果</p><p>与之相对的就是增加训练数据的量</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109000957748.png" alt="image-20260109000957748"></p><p>数据量足够充足</p><p>那原本复杂的模型也就相对变得简单了</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001032605.png" alt="image-20260109001032605"></p><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a><strong>数据增强</strong></h3><p>但有的时候我们确实无法收集</p><p>或者懒得收集更多的数据</p><p>怎么办呢</p><p>那就在原有的数据中创造更多的数据</p><p>比如说在图像处理中</p><p>我们可以对图像进行旋转翻转</p><p>裁剪加噪声等操作</p><p>创造出更多新的训练样本</p><p>这就叫做数据增强。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001229637.png" alt="image-20260109001229637"></p><h3 id="鲁棒性（Robostness）"><a href="#鲁棒性（Robostness）" class="headerlink" title="鲁棒性（Robostness）"></a>鲁棒性（Robostness）</h3><p>这样不仅仅能够产生更多的数据</p><p>还刚好训练了一个让模型不因</p><p>输入的一点点小的变化</p><p>而对结果产生很大的波动</p><p>这就是增强了模型的鲁棒性。</p><p>提前终止训练过程</p><p>好刚刚是从数据和模型本身入手来防止过拟合</p><p>那有没有可能从训练过程入手</p><p>阻止过拟合的发生呢</p><p>其实训练过程就是不断调整参数的过程吧</p><p>那其实只要不让参数继续过分的</p><p>向着过拟合的方向发展就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001525265.png" alt="image-20260109001525265"></p><p>所以有个简单到你都不敢相信的办法</p><p>就是提前终止训练过程</p><p>意思就是差不多就行了</p><p>不用追求那么完美</p><p>不过这种办法还是太粗糙了</p><p>像咱们这种精致的人</p><p>肯定还得追求一些更精细的办法</p><p>也就是说有没有什么办法</p><p>能够直接抑制参数的野蛮增长呢</p><p>非常简单</p><p>你想想看参数是怎么被训练出来的</p><p>是不是通过让参数往让损失函数变小的方向</p><p>不断调整</p><p>也就是梯度下降</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001711006.png" alt="image-20260109001711006"></p><p>那我们可以在损失函数中</p><p>把参数本身的值加上去</p><p>这样在参数往大了调整时</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001748033.png" alt="image-20260109001748033"></p><p>如果让损失函数减小的没有那么多</p><p>导致新的损失函数反而是变大的</p><p>那么此时调整就是不合适的</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20260109001813263.png" alt="image-20260109001813263"></p><p>因此一定程度上就抑制了参数的野蛮增长</p><p>除了可以用参数的绝对值之和之外</p><p>我们还可以用参数的平方和</p><p>这样参数大的时候</p><p>抑制的效果就更强了</p><p>我们把这一项叫做惩罚项</p><p>把通过这种向损失函数中添加权重</p><p>惩罚项</p><p>抑制其野蛮增长的方法叫做正则化</p><p>上面这个参数绝对值相加的叫L1正则化呃</p><p>下面这个平方向相加的叫L2正则化</p><p>然后和之前梯度下降时增加学习率</p><p>控制下降力度一样</p><p>我们也增加一个参数来控制惩罚项的力度</p><p>我们叫它正则化系数</p><p>而这些控制参数的参数我们以后统称为超参数</p><p>那为什么简简单单的公式叫什么L1正则化</p><p>L2正则化呢</p><p>因为绝对值之和叫做L1范数</p><p>而平方和的平方根叫做L2范数</p><p>这是向量空间中范数的概念</p><p>唉光是把这些名词术语念上一遍</p><p>都比讲这个原理本身还要长</p><p>真是苦了各位学习者了</p><p>总之这个破玩意儿</p><p>就只是为了抑制参数的野蛮增长罢了</p><p>呃除了这种方式外</p><p>还有一种令人简单到发指</p><p>但是就是效果显著的办法</p><p>你猜是什么</p><p>想想看哈</p><p>我们的目的是为了防止让模型过于依赖</p><p>某几个参数</p><p>举个形象的例子</p><p>假如神经网络中的参数是一支军队</p><p>里面有好多普通士兵</p><p>但是其中混入了一支战斗力极强的闪客</p><p>然后你研究各种战术</p><p>让士兵和别人打仗</p><p>如果每次训练都有闪客主导战局</p><p>那么你会误认为整体的战斗力很强</p><p>一旦遇到特殊情况</p><p>那就会败北</p><p>这就是过度依赖少量参数的典型表现</p><p>那怎么办呢</p><p>我们可以在训练过程中</p><p>每次都随机丢弃一部分参数</p><p>让闪客偶尔缺席</p><p>这样模型就必须学会依赖更多的普通士兵</p><p>从而避免了在某些关键参数上过度依赖的风险</p><p>虽然听起来有点玄学</p><p>但确实十分有效</p><p>这种方法叫drop out</p><p>其翻译过来就是丢弃</p><p>可能你此时会皱紧眉头</p><p>这都什么玩意儿</p><p>感觉怎么这么儿戏呢</p><p>对很无厘头</p><p>但没办法就是有效</p><p>而且这个方法是大名鼎鼎的深度学习之父</p><p>辛顿提出来的</p><p>好了上面我们了解了</p><p>在对抗过拟合这条路上</p><p>我们绞尽脑汁想了各种办法</p><p>包括增加数据量</p><p>减少模型复杂度</p><p>提前终止训练</p><p>L1正则化</p><p>L2正则化</p><p>drop out等等</p><p>那除此之外</p><p>模型还会遇到其他问题</p><p>比如说梯度消失</p><p>也就是网络越深</p><p>梯度反向传播时会越来越小</p><p>导致参数更新困难</p><p>梯度爆炸</p><p>梯度数值越来越大</p><p>参数的调整幅度失去了控制</p><p>收敛速度过慢</p><p>比如可能陷入局部最优或者来回震荡</p><p>计算开销过大</p><p>数据供应量太庞大了</p><p>每次完整的前向传播和反向传播都非常耗时</p><p>那每个问题人们都想了各种办法来解决</p><p>比如用梯度裁剪来防止梯度的更新过大</p><p>用合理的网络结构</p><p>比如残差网络来防止深层网络的梯度衰减</p><p>用合理的权重初始化和将输入数据归一化</p><p>让梯度分布更平滑</p><p>用动量法</p><p>r ms is prot adam等自适应优化器来加速收敛</p><p>减少震荡</p><p>用mini batch把巨量的训练数据分割成几个小批次</p><p>来降低单次的计算开销</p><p>呃这里的每个概念展开都是一个全新的世界</p><p>但他们和我们今天着重讲的内容一样</p><p>都是为了让训练过程更好罢了</p><p>鉴于我们这个系列是抓大放小</p><p>解决主要思想的特点</p><p>这里就不一一展开了</p><p>对哪个概念</p><p>如果特别感兴趣的朋友</p><p>可以弹幕或者评论区告诉我</p><p>我可以单独出几期拓展视频来讲解</p><p>只要神经网络足够大</p><p>就能包打天下的局面</p><p>正是由于出现了各种各样的困境</p><p>人们才想出各种五花八门的应对策略</p><p>也让人们不禁感叹</p><p>深度学习的确像是一门玄学</p><p>当然随着研究的不断深入</p><p>还有更多令人惊艳的技巧层出不穷</p><p>比如卷积网络</p><p>CNN如何利用卷积层池化层处理图片</p><p>数据循环网络</p><p>RNN如何利用上下文处理序列数据</p><p>以及后来的注意力机制</p><p>attention的引入催生了transformer</p><p>并衍生出了现在的众多大语言模型</p><p>让人工智能不仅仅是识别和判断</p><p>还可以创造和决策</p><h2 id="从矩阵到-CNN"><a href="#从矩阵到-CNN" class="headerlink" title="从矩阵到 CNN"></a>从矩阵到 CNN</h2><p>00:00 最简单的神经网络就是Y等于WX加B</p><p>00:03 套上一个激活函数</p><p>00:04 那如果输入变成了两个</p><p>00:06 那么就是两个W和两个X</p><p>00:09 如果输入变成了三个</p><p>00:10 那么就是三个W和三个X</p><p>00:13 以此类推</p><p>00:14 我就不写了</p><p>00:16 那如果输出变成两个</p><p>00:18 再来一行公式就可以了</p><p>00:20 那这里的W的标号保证不一样</p><p>00:23 能区分开就行</p><p>00:24 比如说这个W12</p><p>00:26 就表示第一个神经元的第二个参数</p><p>00:31 好你发现一个问题没有</p><p>00:34 就是这样写下去的话</p><p>00:36 太麻烦了</p><p>00:36 要是神经元多了的话</p><p>00:38 公是密密麻麻的</p><p>00:39 没有数学的简洁之美</p><p>00:41 那这怎么办呢</p><p>00:42 别急</p><p>00:43 现在我们的注意力放在这个公式上</p><p>00:46 注意看啊</p><p>00:47 我要变形了</p><p>00:55 再来一遍</p><p>00:57 其实就是把加减乘除替换成了矩阵运算的写法</p><p>01:04 额这里先忽略一下激活函数哈</p><p>01:07 重点看中间这个矩阵的乘法</p><p>01:09 矩阵乘法很简单</p><p>01:11 我们错个位</p><p>01:12 就是这一行W的元素</p><p>01:14 分别和X这一列的元素相乘</p><p>01:17 并求和</p><p>01:20 得到的结果呢放到这里</p><p>01:23 那同样对于第二行也是如此</p><p>01:27 回到刚刚</p><p>01:28 我们现在把这些矩阵都替换成新的字母</p><p>01:31 这里我们用大写的Y表示</p><p>01:33 这里用大写的W表示</p><p>01:35 这里用大写的X表示</p><p>01:37 这里用小写的B来表示</p><p>01:39 那么整个公式就化简成了这个样子</p><p>01:44 不过现在还有个问题</p><p>01:45 就是神经元的层并没有体现在公式中</p><p>01:48 那假如神经元再多几层怎么办呢</p><p>01:51 那我们此时抽象一下</p><p>01:53 也别分什么XY和隐藏层了</p><p>01:56 就通通用字母A来表示</p><p>01:58 那输入层就当做第零层</p><p>02:00 用A中括号零来表示</p><p>02:02 以此类推</p><p>02:04 那么第一层的公式就是这样</p><p>02:06 第二层的公式就是这样</p><p>02:09 第三层的公式就是这样</p><p>02:11 我们用L表示在第几层</p><p>02:14 那么最终的通用公式就是这个样子</p><p>02:17 每一层的神经元的值都是上一层的函数</p><p>02:22 那我们费了这么大劲</p><p>02:23 简化这个公式有啥用呢</p><p>02:25 一方面是公式简单了</p><p>02:27 也更抽象了</p><p>02:28 有利于我们进一步讨论更深的问题</p><p>02:31 另一方面是麻烦的加减乘除替换成了矩阵运算</p><p>02:35 可以充分利用GPU的并行计算的特性</p><p>02:38 加速神经网络的训练和推理过程</p><p>02:40 这就不仅仅是秀写法上的一个操作了</p><p>02:44 那回到这个公式和神经网络结构</p><p>02:47 可以看到这里的每个神经元</p><p>02:49 都与前一层的所有神经元相连</p><p>02:51 当然我们一直认为这是理所应当的</p><p>02:54 但它其实只是神经网络结构中的一种</p><p>02:57 叫做全连接层嗯</p><p>02:59 也就是说还有其他不是全连接的结构吗</p><p>03:02 别急</p><p>03:03 我们先来看一下全连接层的问题</p><p>03:06 假如我们现在要做个图像识别的模型</p><p>03:09 假如输入是个30×30的灰度图像</p><p>03:12 那么平铺展开后</p><p>03:13 喂给输入层的就是900个神经元呃</p><p>03:16 假如下一层的神经元的数量是1000个</p><p>03:19 那么这个全连接层的总参数量就达到了90万</p><p>03:22 这太大了</p><p>03:24 另外呢这里仅仅是把输入的图片平铺展开</p><p>03:28 无法保留像素之间的空间关系</p><p>03:30 图片稍稍动一下</p><p>03:32 可能所有神经元都和原来完全不同</p><p>03:34 但从图片整体上看</p><p>03:36 可能仅仅是平移或者变暗</p><p>03:38 这就是不能很好地理解图像的局部模式</p><p>03:41 那怎么办呢</p><p>03:43 我们随便在这个图像中取一个3×3的矩阵</p><p>03:46 这里面的数值就是颜色的灰度值</p><p>03:49 然后我们再来一个固定的矩阵</p><p>03:52 比如这样把这两个矩阵进行这样的一个运算</p><p>03:56 46×0加上75×-1</p><p>03:59 加上82×0</p><p>04:01 也就是把每个对应位置处的值相乘并求和</p><p>04:05 最终得到一个值是250</p><p>04:07 然后我们再选取一个地方再次进行这样的运算</p><p>04:12 最终我们把这种运算方式遍历</p><p>04:15 划过原图像的每个地方</p><p>04:17 得出的数值形成一个新的图像</p><p>04:20 那这种方式叫做卷积运算</p><p>04:22 而刚刚我们这个固定的矩阵叫做卷积核</p><p>04:27 卷积核不是一个新的概念</p><p>04:29 在传统的图像处理领域</p><p>04:31 卷积核是已知的</p><p>04:32 可以达到一定的图像处理效果</p><p>04:34 比如模糊效果</p><p>04:36 浮雕效果</p><p>04:38 轮廓效果以及刚刚的锐化效果等等</p><p>04:41 就是PS的常规操作嘛</p><p>04:44 那在深度学习领域</p><p>04:45 卷积核的值就是未知的</p><p>04:47 和神经网络中的其他参数一样</p><p>04:50 是被训练出来的一组值</p><p>04:52 那回到刚刚的经典神经网络结构</p><p>04:55 其实就是把其中一个全连接层替换成了卷积层</p><p>04:59 这就大大的减少了权重参数的数量</p><p>05:02 同时还能更有效地捕捉到图片中的</p><p>05:04 一些局部特征</p><p>05:05 可谓是一举两得</p><p>05:07 而从公式上看</p><p>05:09 其实就是把原来的矩阵的标准乘法及差乘</p><p>05:12 替换成了卷积运算</p><p>05:16 好</p><p>05:16 那接下来我们的神经网络</p><p>05:18 就不用再画成一个一个的小圈了</p><p>05:21 而用更抽象更简洁的图来表示</p><p>05:23 像这样在图像识别的神经网络结构中</p><p>05:28 除了卷积层外</p><p>05:29 通常还有池化层作用</p><p>05:31 是对卷积层后的特征图像进行降维</p><p>05:34 减少计算量</p><p>05:35 同时呢保留主要特征</p><p>05:37 这里的卷积层</p><p>05:38 池化层</p><p>05:39 全连接层都可以有多个</p><p>05:41 而这种适用于图像识别领域的神经网络结构</p><p>05:44 就叫做卷积神经网络</p><p>05:46 CNN</p><p>05:47 之前我们展示的手写数字识别的CNN可视化</p><p>05:51 就是这样的网络结构</p><p>05:53 最开始是一个输入层</p><p>05:55 我们写了一个数字六</p><p>05:57 然后是卷积层</p><p>05:59 池化层</p><p>06:01 再卷积层</p><p>06:02 再池化层</p><p>06:04 然后第一个全连接层</p><p>06:06 第二个全连接层</p><p>06:08 最终输出识别出是六</p><p>06:13 而使用卷积神经网络非常方便可视化</p><p>06:16 我们可以看到训练过程中所训练出的卷积核</p><p>06:19 从原始图像中提取了什么样的特征</p><p>06:22 虽然这些都是中间隐藏层的事情</p><p>06:25 但是却能神奇地观察出一些实际意义</p><p>06:28 这也是卷积神经网络让人着迷的地方</p><p>06:32 好我们来回顾一下今天讲的内容非常简单</p><p>06:36 我们把之前一个一个加减乘除很麻烦的写法</p><p>06:39 写成了矩阵的形式</p><p>06:41 一是为了方便讨论</p><p>06:42 比如刚刚介绍CNN的时候</p><p>06:44 就从公式直接看出</p><p>06:45 就是差乘变成了卷积运算而已</p><p>06:47 二是可以更好的利用GPU的并行计算提高效率</p><p>06:51 那接下来我们把之前默认的那种</p><p>06:53 所有神经元都连起来的形式叫做全连接</p><p>06:56 进而呢通过图像识别这个任务</p><p>06:59 意识到了全世界的局限性</p><p>07:01 接下来我们通过卷积运算</p><p>07:03 代替了全连接层的标准矩阵乘法</p><p>07:05 一方面使得训练参数大大的减少</p><p>07:08 另外一方面也更有利于提取图像的局部特征</p><p>07:11 这就解决了我们一开始说的问题</p><p>07:13 最后我们把神经网络结构再次抽象一个层次</p><p>07:17 原来我们画的各种小圈圈在更高的视角下</p><p>07:20 其实就是个全连接层而已</p><p>07:22 那么这些全连接层</p><p>07:23 卷积层</p><p>07:24 池化层的组合就构成了卷积神经网络CNN</p><p>07:28 当然卷积神经网络</p><p>07:30 CNN也只是神经网络结构中的一种</p><p>07:33 而且呢它有一个致命的局限性</p><p>07:35 就是它主要用于静态数据</p><p>07:37 比如说图片</p><p>07:38 那么如果我们要处理的是时间序列</p><p>07:41 文本</p><p>07:41 语音视频等动态数据</p><p>07:43 就需要引入另外一种神经网络结构了</p><p>07:46 它可以说是现在我们大语言模型的鼻祖了</p><p>07:50 好我们用了四个视频的内容</p><p>07:52 终于把前面所需要铺垫的知识</p><p>07:55 从头到尾给推出来了</p><p>07:56 那下个视频开始</p><p>07:58 我们就可以坐着我们这几个视频搭载的火箭</p><p>08:01 冲刺到现代AI技术的最前沿</p><p>08:03 请大家做好战斗准备吧</p><h2 id="从词嵌入到-RNN"><a href="#从词嵌入到-RNN" class="headerlink" title="从词嵌入到 RNN"></a>从词嵌入到 RNN</h2><p>00:00 给你几个字</p><p>00:00 让你生成下一个字</p><p>00:02 给你一句话</p><p>00:03 让你判断每个词的褒贬</p><p>00:05 如果把这些设计成一个神经网络的函数</p><p>00:07 来实现这个功能</p><p>00:09 你该怎么做呢</p><p>00:10 先别急</p><p>00:11 要想把这些文字作为输入参数</p><p>00:13 首先得把这些文字变成计算机能够识别的数字</p><p>00:17 这个过程就叫做编码</p><p>00:19 那具体怎么编码呢</p><p>00:21 有两种极端的方式</p><p>00:23 一种是只用一个数字标识来代表每个词</p><p>00:26 比如一代表我</p><p>00:27 二代表你3568代表地球等等</p><p>00:31 你的词表有多大</p><p>00:32 数字标识的范围就要有多大</p><p>00:35 这样的缺点非常明显</p><p>00:36 就是维度太低了</p><p>00:38 相当于一个一维的向量</p><p>00:40 而且数字标识本身对语言理解没有任何意义</p><p>00:43 无法灵活地衡量词和词之间的相关性</p><p>00:47 但另一种极端的方式是</p><p>00:48 准备一个超级超级大的向量</p><p>00:51 每个词只有向量中一个位置是一</p><p>00:54 剩下的都是零</p><p>00:55 这种编码方式叫做one hot</p><p>00:57 翻译过来叫独热编码</p><p>01:00 one hot的缺点也非常明显</p><p>01:02 就是维度太高了</p><p>01:03 而且非常稀疏</p><p>01:05 假如此表中有10万个词</p><p>01:07 那么这就是一个10万维度的向量</p><p>01:10 而且每个向量之间都是正交的</p><p>01:12 所以词和词之间仍然无法找到相关性</p><p>01:15 那如果把向量中每个位置都看作一个特征的话</p><p>01:19 这里就相当于每个特征都是非常死板的</p><p>01:22 是或者否维度太高不好</p><p>01:24 维度太低也不好</p><p>01:26 那简单了</p><p>01:27 弄一个不高不低的就好喽</p><p>01:28 这种方式就叫做此嵌入</p><p>01:31 通过磁嵌入的方式所得到的磁向量</p><p>01:35 维度不高也不低</p><p>01:36 每个位置数依然可以理解为某一个特征</p><p>01:39 只不过这是训练出来的</p><p>01:41 不是我们人定的</p><p>01:42 所以特征是什么</p><p>01:43 可能我们人类完全无法理解</p><p>01:46 那为什么这种方式可以表示词和词之间</p><p>01:49 语义上的相关性呢</p><p>01:50 我们可以用两个向量的点击或余弦相似度</p><p>01:54 来表示向量之间的相关性</p><p>01:56 进而表示两个词语之间的相关性</p><p>01:59 这就将自然语言之间的联系</p><p>02:02 转化为了可以用数学公式计算出来的方式</p><p>02:05 很关键</p><p>02:06 同时一些数学上的计算结果</p><p>02:08 也能反映出一些现实中很神奇的解释</p><p>02:11 比如一个训练好的词嵌入矩阵</p><p>02:14 可能会使得桌子减去椅子</p><p>02:16 等于鼠标减去键盘</p><p>02:18 你可以暂停下来</p><p>02:20 体会一下这里面蕴含的有趣的深意</p><p>02:24 把所有词向量组成了一个大矩阵</p><p>02:27 这个大的矩阵就叫做嵌入矩阵</p><p>02:29 这里的每一列就表示一个词向量</p><p>02:32 像刚刚说的这个矩阵</p><p>02:35 不是我们人类手动给每个词赋值而形成的</p><p>02:38 是通过深度学习的方法训练出来的</p><p>02:41 比如比较经典的方式就是word to back</p><p>02:43 这里就不展开讲解了</p><p>02:45 你就当做已经有了一个这样的嵌入矩阵</p><p>02:48 每一个可能的词语</p><p>02:50 都可以从这里找到对应的词向量</p><p>02:53 这些磁向量的维度非常高</p><p>02:55 所以它所在的空间的维度也非常高</p><p>02:58 这个空间就叫做前空间</p><p>03:00 我们人类对二维空间很好理解</p><p>03:03 最多到三维空间也还行</p><p>03:05 再往上就想象不出来了</p><p>03:07 那么这些词在高维前空间中的相对位置关系</p><p>03:11 虽然可以通过点击或余弦相似度算出来</p><p>03:14 但最好有一种直观的方式</p><p>03:16 能让我们亲眼可视化的看到</p><p>03:18 哪怕不那么准确也行</p><p>03:20 于是便有了一些方法</p><p>03:22 将这个前空间降维</p><p>03:24 投影到二维或三维的坐标系中</p><p>03:27 来直观的可视化不同词语之间的距离</p><p>03:30 还是非常有趣的</p><p>03:32 好了</p><p>03:33 有关词嵌入和嵌入矩阵</p><p>03:36 我们就先聊到这里</p><p>03:37 这时每个词都可以编码成向量</p><p>03:40 然后送到神经网络输入端的神经元中了</p><p>03:43 我们再来看看最初的需求</p><p>03:45 输入一句话</p><p>03:46 输出每个单词的褒贬性</p><p>03:49 这里有123455个词</p><p>03:51 通过词嵌入</p><p>03:52 把每个词变成一个300维的词向量</p><p>03:55 那么输入端就要一共有1500个神经元</p><p>03:59 这样行不行呢</p><p>04:00 当然可以</p><p>04:01 但是有两个问题</p><p>04:02 一个是输入层太大了</p><p>04:04 而且会随着一句话中词语数量多少而变化</p><p>04:08 是变长的</p><p>04:09 不确定的</p><p>04:10 另一个是无法体现词语的先后顺序</p><p>04:13 仅仅是把它们非常生硬的平铺展开</p><p>04:16 成了一个非常大的向量</p><p>04:17 一股脑地送入了输入层</p><p>04:19 这就好比我们之前说的图像识别领域</p><p>04:22 把一张图片的所有像素点展开成一个大向量</p><p>04:25 一股脑地送入输入层</p><p>04:27 一个道理</p><p>04:27 这样既增加了神经元的个数</p><p>04:29 又不能很好地抽象出特征和关联</p><p>04:32 有点费力不讨好</p><p>04:34 那在CNN中</p><p>04:35 我们是通过卷积操作提取了图像的特征</p><p>04:38 那么在自然语言处理领域</p><p>04:40 我们可以通过什么办法</p><p>04:41 既能解决词语之间的先后顺序问题</p><p>04:44 又能降低输入层的参数量呢</p><p>04:47 首先我们还是用经典的神经网络</p><p>04:50 但不要输入一句话</p><p>04:52 而是输入一个词</p><p>04:53 输出就是这个词是褒义还是贬义</p><p>04:56 当然这里的字母都表示矩阵就不再赘述了</p><p>04:59 这时假设第二个词来了</p><p>05:01 也是经过一样的神经网络很简单</p><p>05:04 那此时我们用尖括号表示是第几个词</p><p>05:07 这样就有了顺序关系</p><p>05:09 那现在的问题是</p><p>05:11 第二个词的计算过程</p><p>05:12 完全没有让第一个词的任何信息参与进来</p><p>05:16 那这该怎么办呢</p><p>05:17 答案已经写在脸上了</p><p>05:19 那就让他参与进来就好喽</p><p>05:21 那可以这样</p><p>05:22 我们让第一个词经过非线性变换后</p><p>05:25 别急着直接输出</p><p>05:27 结果先输出到一个隐藏状态H1</p><p>05:30 然后再经过一次非线性变换得到输出Y1</p><p>05:34 接下来这个隐藏状态H1的值和第二个词X2</p><p>05:39 一起参与运算</p><p>05:41 那同理对第二个词的流程也是一样</p><p>05:44 先输出一个隐藏状态H2</p><p>05:46 然后继续往下传递</p><p>05:48 那这样的话呢</p><p>05:50 前面的词的信息就这样不断的往下传递</p><p>05:53 直到传到最后一句话的最后一个词那里</p><p>05:56 这样就把一句话中</p><p>05:58 所有的词的信息都囊括进来了</p><p>06:01 当然这里的W就要有所区分了</p><p>06:03 有专门针对磁向量的WXH矩阵</p><p>06:07 有专门针对隐藏状态的WHH矩阵</p><p>06:10 以及最终计算输出结果的WHY矩阵</p><p>06:14 那同样对于偏执向B也是如此</p><p>06:17 把这个图简化一下</p><p>06:18 那这就是循环神经网络RNN</p><p>06:23 当然啦还会有个图这样画</p><p>06:26 那这个RN模型就具备了理解词和词之间</p><p>06:30 先后顺序的能力</p><p>06:32 那这样就可以解决</p><p>06:33 判断一句话中各个单词的褒贬词性</p><p>06:36 给出一句话</p><p>06:37 不断生成下一个字</p><p>06:39 以及翻译等多种自然语言处理的工作了</p><p>06:43 那如果你还有些懵的话</p><p>06:45 我们再把矩阵展开来看看</p><p>06:48 首先第一个词X1和权重矩阵WXH相乘</p><p>06:53 得到第一个词的隐藏状态</p><p>06:55 H1准备往后传</p><p>06:57 H1和权重矩阵WHY相乘</p><p>07:00 得到第一个词的输出结果</p><p>07:02 Y1这时候计算第二个词</p><p>07:05 同样要和权重矩阵WXH相乘</p><p>07:08 但注意这个时候要把第一个词的隐藏状态</p><p>07:12 加到输入向量里拼接起来</p><p>07:15 同时权重矩阵也增加一个WHH</p><p>07:18 最终计算出第二个词的隐藏状态</p><p>07:21 H2准备继续往后传</p><p>07:23 那后面的流程就一样了</p><p>07:47 最后看一下公式</p><p>07:48 其实非常简单</p><p>07:49 和经典的神经网络相比</p><p>07:51 就是多了一个前一时刻的隐藏状态而已</p><p>07:58 回顾一下</p><p>07:59 其实本期的内容非常简单</p><p>08:01 我们想处理自然语言的一系列问题</p><p>08:03 首先就要把词转换成计算机能够识别的数字</p><p>08:07 这个过程叫编码</p><p>08:09 通过编码词而形成的向量叫做磁向量</p><p>08:12 编码词向量有多种方式</p><p>08:14 其中一种是准备一个词表大小的向量</p><p>08:17 只有一个位置是一</p><p>08:19 这种方式叫做one hot及独热编码</p><p>08:22 这种编码方式维度太高</p><p>08:24 词之间缺乏相关性</p><p>08:26 所以另一种更有效的方式叫做词嵌入</p><p>08:29 词嵌入所需要经过训练而得到的矩阵</p><p>08:33 叫做嵌入矩阵</p><p>08:38 磁向量之间的相关性</p><p>08:39 可以用点击或余弦相似度来计算</p><p>08:42 有了磁向量之后</p><p>08:44 就可以输入到神经网络进行各种训练了</p><p>08:47 经典的神经网络无法表达词的先后顺序</p><p>08:50 因此我们增加了一个隐藏状态</p><p>08:52 在词和词之间传递不同的词</p><p>08:55 使用不同的时间步T来表示</p><p>08:57 那这个不同于经典神经网络的结构</p><p>09:00 就叫做循环神经网络RNN</p><p>09:04 当然RNN还有两个非常严重的问题</p><p>09:08 一信息会随着时间步的增多而逐渐丢失</p><p>09:11 无法捕捉长期依赖</p><p>09:13 而有的语句恰恰是距离很远的地方</p><p>09:16 起到了关键性的作用</p><p>09:17 2RN必须按顺序处理</p><p>09:20 每个时间步依赖上一个时间步的隐藏状态</p><p>09:23 的计算结果</p><p>09:25 那为了解决这些问题</p><p>09:26 人们使用GRU和LSTM改进了传统的RN</p><p>09:31 但是这些仍然是建立在让信息一点一点</p><p>09:34 按照时间簿传递的思路来解决</p><p>09:36 只能缓解而无法根治</p><p>09:39 那我们是否有一种可以彻底抛弃这种顺序计算</p><p>09:42 直接一眼把全部信息尽收眼底的新方案呢</p><p>09:47 有的那就是transformer</p><h2 id="简单而强大的-Transformer"><a href="#简单而强大的-Transformer" class="headerlink" title="简单而强大的 Transformer"></a>简单而强大的 Transformer</h2><p>00:00 用神经网络做个翻译任务</p><p>00:01 我爱你</p><p>00:02 宝贝</p><p>00:02 我爱你</p><p>00:03 宝贝儿</p><p>00:04 先用词嵌入的方式把每个词转换成一个词向量</p><p>00:07 简单点</p><p>00:08 假设维度就是六</p><p>00:09 如果把每个词直接丢到一个全连接神经网络中</p><p>00:12 那每个词都没有上下文的信息</p><p>00:15 且长度只能一一对应</p><p>00:16 不太行</p><p>00:17 如果用循环神经网络RNN又面临串行计算</p><p>00:21 而且如果句子太长</p><p>00:22 也会导致长期依赖困难的问题也不太行</p><p>00:26 那这也不行</p><p>00:27 那也不行</p><p>00:27 可咋整呢</p><p>00:28 小孩子才做选择</p><p>00:29 成年人全都不要直接发明一个全新的方案</p><p>00:33 跟我走</p><p>00:34 首先我们给每个词一个位置编码</p><p>00:36 表示这个词出现在整个句子中的位置</p><p>00:39 具体怎么计算</p><p>00:40 再说把位置编码加到原来的词向量里</p><p>00:43 现在这个词就有了位置信息</p><p>00:46 但此时每个词还没有其他词的上下文信息</p><p>00:50 也就是注意不到其他词的存在</p><p>00:52 那怎么办呢</p><p>00:53 接着看</p><p>00:54 别眨眼</p><p>00:55 首先我们用一个WQ矩阵和第一个词向量相乘</p><p>00:59 得到维度不变的Q1向量</p><p>01:01 这里的WQ矩阵是可以通过训练过程学习的</p><p>01:05 一组权重值</p><p>01:06 同理我们用wk矩阵和第一个词向量相乘</p><p>01:10 得到K1</p><p>01:11 再用WV矩阵得到V1</p><p>01:14 接着对其他词向量也和相同的WQ</p><p>01:18 KV矩阵相乘</p><p>01:19 分别得到自己对应的QKV向量</p><p>01:22 当然实际在计算机GPU中运算的时候</p><p>01:25 是通过拼接而成的大矩阵做乘法</p><p>01:28 并不是像我们刚刚那样一步一步计算的</p><p>01:31 得到的直接就是包含所有词向量的QKV矩阵</p><p>01:35 不过为了理解</p><p>01:36 我们解释的时候还是拆成一个个的词向量</p><p>01:39 现在原来的磁向量已经分别通过线性变换</p><p>01:42 映射成了QKV维度</p><p>01:45 和原来是一样的</p><p>01:46 接下来我们让Q1和K2做点击</p><p>01:50 这表示在第一个词的视角里</p><p>01:52 第一个词和第二个词的相似度是多少</p><p>01:56 同理依次和K3做点击</p><p>01:58 表示和第三个词的相似度</p><p>02:01 和K4做点击</p><p>02:02 表示和第四个词的相似度</p><p>02:04 最后呢也补上一个和自己做点击</p><p>02:07 表示和自己的相似度</p><p>02:09 那拿到这些相似度的系数后</p><p>02:12 分别和V向量相乘</p><p>02:14 再相加得到A1</p><p>02:16 那此时这个A1就表示在第一个词的视角下</p><p>02:21 按照和它相似度大小</p><p>02:23 按权重把每个词的词向量都加到了一块儿</p><p>02:26 那这就把全部上下文的信息</p><p>02:29 都包含在第一个词当中了</p><p>02:31 而且是用第一个词的视角来看的</p><p>02:34 同理其他几个词也按照这种方式</p><p>02:37 那么此时每个词都把其他词的词向量</p><p>02:42 按照和自己的相似度</p><p>02:43 权重加到了自己的词向量中</p><p>02:46 好那这里的什么QKV都是中间的计算过程了</p><p>02:50 我们从全局视角看</p><p>02:52 现在就是把最初的输入的词向量经过一番处理</p><p>02:56 变成了一组新的词向量</p><p>02:58 不一样的是呢</p><p>02:59 这组新的词向量中</p><p>03:00 每一个都是包含了位置信息和其他词</p><p>03:04 上下文信息的一组新的词向量</p><p>03:06 这就是注意力机制</p><p>03:08 attention做的事情</p><p>03:12 我们再进一步优化下</p><p>03:13 有的时候一个词和另一个词的关系</p><p>03:16 可能从不同的视角看是不一样的</p><p>03:19 对于注意力机制来说</p><p>03:21 如果只通过一种方式计算一次相关性</p><p>03:24 灵活性就会大大降低</p><p>03:26 所以我们做些改进</p><p>03:27 之前我们是每个词计算一组QKV</p><p>03:30 现在我们在这个QQV基础上</p><p>03:32 再经过两个权重矩阵变成两组QKV</p><p>03:36 给每个词两个学习机会</p><p>03:38 学习到不同的</p><p>03:39 要计算相似度QQV来增加语言的灵活性</p><p>03:43 这里的每组QKV成为一个头</p><p>03:46 接下来在每个头里面的QQV</p><p>03:49 仍然经过刚刚的注意力层的运算</p><p>03:52 得到A向量</p><p>03:53 然后把两个A向量拼接起来</p><p>03:55 得到了和刚刚一样的结构</p><p>03:58 而对于刚刚的注意力机制attention</p><p>04:00 这种方式就叫做多头注意力</p><p>04:02 多头注意力</p><p>04:04 而我们刚刚举的例子就是两个头的情况好</p><p>04:09 那我现在要恭喜你</p><p>04:11 已经把transformer架构</p><p>04:12 最核心的逻辑都搞清楚了</p><p>04:14 你信不信不信的话</p><p>04:16 我们对照一下transformer的经典论文</p><p>04:18 中的架构图来看看</p><p>04:19 首先第一步就是把输入的内容</p><p>04:22 通过词嵌入的方式转换成磁向量矩阵</p><p>04:25 对应的就是这里</p><p>04:27 第二步加入位置信息</p><p>04:29 其实就是再加个形状一样的矩阵</p><p>04:31 对应的就是这里</p><p>04:33 第三步经过多头注意力的处理</p><p>04:36 输出的矩阵维度和输入没有变化</p><p>04:38 给每个词向量增加了上下文信息</p><p>04:41 对应的就是这里</p><p>04:42 后面还有一步添加了残差网络和归一化处理</p><p>04:46 是为了解决梯度消失</p><p>04:48 并且让分布更加稳定而做的优化</p><p>04:50 我们刚刚没有展开这块儿</p><p>04:52 那对应的就是这里</p><p>04:54 同时我们也可以看到</p><p>04:55 整个transformer的标准架构中</p><p>04:57 最主要的就是多头注意力的处理</p><p>05:00 相当于我们把这些部分的逻辑都搞明白了</p><p>05:03 快给自己鼓鼓掌吧</p><p>05:08 下面深入到多头注意力机制的细节部分</p><p>05:11 我们再看看</p><p>05:12 如果是不分多头的单头注意力</p><p>05:15 那么就是先让Q和K相乘</p><p>05:17 得到一个相似度系数的一个矩阵</p><p>05:20 然后再和V相乘</p><p>05:21 最终得到了包含上下文信息的磁向量矩阵</p><p>05:26 当然我们上面的讲解过程呢</p><p>05:28 省略了中间的缩放掩码和一层soft max处理</p><p>05:32 再看右边的多头注意力情况</p><p>05:34 首先QKV分别经过线性变换</p><p>05:38 拆分成多组</p><p>05:39 相当于给了多次机会学习到不同的相似度关系</p><p>05:43 依次经过注意力机制运算后</p><p>05:45 把运算结果拼接起来</p><p>05:48 是不是完全一样呢</p><p>05:50 不过我们讲解的时候还省略了一次线性变换</p><p>05:53 即多头结果并不是简单的拼接起来</p><p>05:56 还需要再次经过一层权重矩阵的乘法</p><p>05:59 这时候再看两个核心公式就很好理解了</p><p>06:02 所谓注意力运算就是QK矩阵相乘经过缩放</p><p>06:07 在经过soft max层处理</p><p>06:09 最后和V相乘</p><p>06:12 对于多头情况</p><p>06:14 就是先将QKV矩阵</p><p>06:16 经过多个权重矩阵拆分到多个头中</p><p>06:19 分别经过注意力机制的运算</p><p>06:21 最后合并起来</p><p>06:22 再经过一次矩阵运算</p><p>06:24 得到了输出</p><p>06:26 再回过头来看一下这个全局的图</p><p>06:29 左边的部分叫做编码器</p><p>06:31 右边的部分叫做解码器</p><p>06:33 你实在不愿意叫也没关系</p><p>06:35 假设这个是用于翻译的任务</p><p>06:38 我们训练这个神经网络的过程是</p><p>06:40 首先输入要翻译的文本</p><p>06:42 我爱你，宝贝</p><p>06:44 然后经过词嵌入引入位置编码</p><p>06:47 经过多头注意力残差和归一化处理</p><p>06:50 接着送入一个全连接神经网络</p><p>06:53 再残差和归一化处理</p><p>06:55 结果送入解码器的一个多头注意力机制</p><p>06:58 的两个输入中</p><p>07:00 作为KV矩阵</p><p>07:01 再看右面解码器的部分输出是翻译后的文本</p><p>07:06 我爱你宝贝儿</p><p>07:07 同样经过此嵌入</p><p>07:09 引入位置编码</p><p>07:10 经过多头注意力</p><p>07:12 然后残差和归一化处理下</p><p>07:15 然后送入上面说的多头注意力的一个输入中</p><p>07:19 作为Q矩阵和刚刚从编码器中送入的KV矩阵</p><p>07:24 再经过多头注意力残差归一化</p><p>07:27 再全连接神经网络</p><p>07:29 再残差归一化</p><p>07:30 最后再经过一层线性变换的神经网络</p><p>07:34 投射到此表向量中</p><p>07:36 最后用soft max层转化为概率</p><p>07:39 这就代表预测的下一个词在词表中的概率分布</p><p>07:44 那我们取概率最高的就是下一个词应该是什么</p><p>07:48 这里有一个小的不同</p><p>07:50 就是有个掩码</p><p>07:51 这个掩码的作用是真正推理</p><p>07:54 翻译时是一个词一个词翻译的</p><p>07:56 比如说这个时候翻译到我下一个词应该是爱</p><p>08:00 所以输出我的时候是看不到后面的词的</p><p>08:04 这就需要掩码来把后面的词遮挡住</p><p>08:06 以便训练的时候模拟真实推理场景时的过程</p><p>08:10 比如当此时输入是i love you baby</p><p>08:13 输出只有一个词</p><p>08:14 我的时候经过这个神经网络</p><p>08:17 最后上方输出词表的概率分布</p><p>08:19 我们想要的结果就是I字的概率值最大</p><p>08:23 如果训练时有偏差</p><p>08:25 那么就计算损失函数</p><p>08:26 再反向传播</p><p>08:28 调整transformer结构中的各种权重矩阵</p><p>08:31 直到学习好为止</p><p>08:34 总的来说</p><p>08:34 transformer确实是个特别简单的架构</p><p>08:38 原文中也是这样说的</p><p>08:39 尤其是当你有了基础的神经网络知识之后</p><p>08:42 如果你看了这个系列之前的视频</p><p>08:45 那就只有多头注意力</p><p>08:46 这一层是陌生的</p><p>08:48 但是它其实拆解之后也是各种矩阵相乘呀</p><p>08:51 相加呀</p><p>08:51 这种操作罢了</p><p>08:52 那其余的词嵌入位置</p><p>08:55 编码残差归一化</p><p>08:56 经典神经网络</p><p>08:58 soft max层等等</p><p>08:59 都是我们之前的视频中已经了解过的概念</p><p>09:02 把这些老东西拼凑拼凑就诞生了</p><p>09:05 我们现在大模型技术的鼻祖transformer</p><p>09:09 那GBT的底层其实就是transform的一半</p><p>09:12 即只有解码器的部分</p><p>09:14 也不翻译</p><p>09:15 谁只管看前面的词</p><p>09:17 猜下一个词</p><p>09:18 别看他来回的猜词猜词</p><p>09:20 猜着猜着就变成了聊天写代码</p><p>09:23 解数学题的全能选手了</p><p>09:26 那transformer的架构来源于经典的论文</p><p>09:28 你只需要关注</p><p>09:30 本期视频的内容理解之后再去看这篇论文</p><p>09:33 你就会发现非常非常非常容易理解</p><p>09:36 因为它本身就是一个很简单的架构</p><p>09:39 也正因为简单粗暴</p><p>09:40 但是效果却出奇的好</p><p>09:42 所以才会广为流传</p><p>09:44 并成为现代大模型的基础</p><p>09:46 如果大家感兴趣</p><p>09:47 我可以专门出一期视频</p><p>09:49 从头到尾的讲解一下这篇论文</p><p>09:51 可以弹幕或评论区留下你的想法</p><p>09:53 当然啦</p><p>09:54 建议把这个系列之前的视频完整的看一遍</p><p>09:57 每期视频呢不到10分钟</p><p>09:59 但可以带着你从零开始真正理解神经网络</p><p>10:02 一步一步的发展脉络</p><p>10:04 加油吧</p><h2 id="速览大模型-99-词"><a href="#速览大模型-99-词" class="headerlink" title="速览大模型 99 词"></a>速览大模型 99 词</h2><p>00:00 万物皆函数</p><p>00:01 早期人们用符号主义的思想找到精确函数</p><p>00:04 试图解释一切原理</p><p>00:06 但遇到了瓶颈</p><p>00:07 后来人们转用连接主义思想</p><p>00:09 先啥都不管</p><p>00:10 弄一个非常复杂的函数</p><p>00:11 然后根据计算出的预测值与真实值的误差</p><p>00:14 不断调整里面的未知参数</p><p>00:17 这个函数叫做模型</p><p>00:19 模型里的参数叫做权重</p><p>00:21 如果模型中的参数量特别大</p><p>00:23 就叫做大模型</p><p>00:24 用于自然语言处理的大模型就叫做大语言模型</p><p>00:28 调整参数的过程就是模型的训练</p><p>00:31 事先训练好一个基础模型的方式叫做预训练</p><p>00:34 基于预训练的模型继续训练</p><p>00:36 让模型学会具体的任务的方式叫做微调参数</p><p>00:40 调整好后</p><p>00:41 根据函数的输入计算输出结果</p><p>00:43 这个过程叫做推理</p><p>00:45 这些概念在大模型时代到来之后</p><p>00:48 逐渐火热了起来</p><p>00:49 当模型参数量足够大的时候</p><p>00:51 对话能力有了质的提升</p><p>00:53 产生了一定程度的推理能力</p><p>00:55 这种量变引起质变</p><p>00:57 而突然出现的之前没有的能力的现象叫做涌现</p><p>01:01 大圆模型爆火的产品是2023年的chat gt</p><p>01:05 它是一款用于聊天的产品</p><p>01:07 而它背后使用的代言模型是GPT是个系列</p><p>01:11 开发这个模型的公司是OpenAI产品模型公司</p><p>01:15 这也是一开始很多人搞混淆的概念</p><p>01:18 而由于这家公司推出的产品</p><p>01:20 一直保持不开放源代码</p><p>01:22 也就是闭源</p><p>01:22 所以也正式更名为close AI括弧</p><p>01:25 开个玩笑</p><p>01:26 一个模型需要有训练它的代码</p><p>01:29 有了代码就可以训练出一组权重</p><p>01:31 有了权重就可以进行推理</p><p>01:33 也就是可以对外提供服务了</p><p>01:35 不开放源代码</p><p>01:37 也不开放权重</p><p>01:38 只对外提供服务的模型叫做闭源模型</p><p>01:41 如ChatGPT cloud germany y等开放模型</p><p>01:45 权重可以直接下载到自己电脑上</p><p>01:47 部署的模型叫做开源模型</p><p>01:49 但实际上大部分现在说的开源模型</p><p>01:52 只是开放了权重</p><p>01:53 而不开放训练代码和训练数据</p><p>01:56 所以准确说其实叫开放权重模型</p><p>01:59 比如最近爆火的deep seek以及划时代的lama等</p><p>02:02 不但开放了模型结构和权重</p><p>02:04 还开放了训练代码的模型</p><p>02:06 可以叫完全开源模型</p><p>02:08 比如说miss f</p><p>02:09 当然了</p><p>02:10 有了模型权重</p><p>02:11 其实就可以下载到本地进行部署</p><p>02:13 并且使用了</p><p>02:14 很少有人需要重新训练它</p><p>02:16 这个不依赖于他人的服务</p><p>02:18 而是把模型下载到本地进行使用的过程</p><p>02:21 叫做私有化部署</p><p>02:22 私有化部署依赖很多复杂的环境配置</p><p>02:25 就是需要装很多依赖的软件和工具包</p><p>02:28 而且需要性能较为强劲的GPU的支持</p><p>02:31 对于仅仅想尝鲜的个人</p><p>02:33 专门为此去买一台电脑不太合适</p><p>02:35 因此就有了云桌面的概念</p><p>02:37 你可以直接使用别人打包好的环境和软件</p><p>02:40 这个打包好的东西就叫做镜像</p><p>02:43 大语言模型的本质就是个大函数</p><p>02:45 根据前面的一句话</p><p>02:46 持续不断地计算下一个词是什么</p><p>02:49 这种基于输入内容</p><p>02:50 自动生成新内容的人工智能系统叫做生成式AI</p><p>02:54 当然除了文本</p><p>02:55 也包含图像</p><p>02:56 声</p><p>02:56 音视频等等</p><p>02:57 这里的每一个分割成最小力度的词叫做token</p><p>03:01 对话时所有给到大模型的信息叫做上下文</p><p>03:04 不同的模型有不同的上下文</p><p>03:06 长度限制越大</p><p>03:07 就越能记住前面的信息</p><p>03:08 上下文从另一个角度理解</p><p>03:10 也可以叫提示词</p><p>03:11 prompt可以指导模型的回答流程和风格</p><p>03:14 但其实就是个上下文而已</p><p>03:16 早期出现很多提示词工程师和提示词教程</p><p>03:19 其实本质就是教你怎么跟大模型说话而已</p><p>03:22 现在AI的对话越来越贴近人的方式了</p><p>03:25 所以你和人沟通起来有啥毛病</p><p>03:27 那么跟AI沟通也有啥毛病</p><p>03:29 你真正缺的是怎么表达清楚自己的意思</p><p>03:32 而不是prompt技巧</p><p>03:34 刚刚说了</p><p>03:35 大模型就是个大函数</p><p>03:36 函数是死的</p><p>03:37 所以根据前面的词输出的下一个词是固定的</p><p>03:40 但是我们可以一定程度的调整模型</p><p>03:43 输出的随机性</p><p>03:44 让下一个词的生成</p><p>03:45 并不总是取前面概率最高的那个词</p><p>03:48 控制输出的随机性的参数叫做温度控制范围</p><p>03:51 从概率最高的cake词中选择叫做top k</p><p>03:55 随机性太高</p><p>03:56 模型容易胡说</p><p>03:57 八道太低又会过于保守</p><p>03:59 也可能说错</p><p>03:59 这种在语言上说得通</p><p>04:01 但是在事实上狗屁不通</p><p>04:03 甚至虚假信息的现象叫做大模型的幻觉</p><p>04:06 为了解决幻觉问题</p><p>04:07 大模型或者一些套壳产品提供了联网能力</p><p>04:11 其实呢就是在大模型回答问题前</p><p>04:13 先去互联网上查找一些相关信息</p><p>04:16 把这些信息和你的问题拼接在一起</p><p>04:18 共同先发给大模型</p><p>04:20 然后进行回答</p><p>04:21 相当于带着答案回答问题了</p><p>04:23 之前很多自媒体的震惊体</p><p>04:25 炸裂体</p><p>04:26 天塌体的文章说</p><p>04:27 大模型拥有联网能力是有了重大突破</p><p>04:30 人类就要完蛋了</p><p>04:31 那实际上呢就是这么个玩意儿</p><p>04:33 有些数据网络上可能查不到</p><p>04:35 或者企业的数据不方便公开地放在互联网上</p><p>04:38 希望大模型去这些私有的数据库中查找答案</p><p>04:42 这种方式叫做检索</p><p>04:43 增强生成RAG和联网的思路一样</p><p>04:46 也是先查资料再回答问题</p><p>04:49 只不过查询的内容不在互联网上</p><p>04:51 而是在有一个私有的数据库中</p><p>04:53 我们通常叫它知识库</p><p>04:55 为了让模型和知识库中的语义进行匹配</p><p>04:57 知识通常会以向量的形式存储在向量数据库中</p><p>05:01 把文字转换成磁向量的方式叫做词嵌入对比</p><p>05:05 词向量之间的相似度</p><p>05:06 已在知识库中找到相关问题的答案的方式</p><p>05:09 叫做向量检索</p><p>05:11 解决了大模型的幻觉问题后</p><p>05:13 AI就可以真正的介入生产和生活中了</p><p>05:15 在内容创作领域</p><p>05:17 传统的由专业机构如影视公司</p><p>05:19 媒体机构</p><p>05:20 权威专家等创作的内容叫做pg c</p><p>05:23 随着移动互联网时代的到来</p><p>05:25 和自媒体时代的到来</p><p>05:26 由普通用户</p><p>05:27 比如说我创作的内容叫做UGC</p><p>05:29 而在AI时代</p><p>05:31 由AI创作或辅助创作的内容叫做AIGC</p><p>05:34 比较正向的案例呢</p><p>05:36 就是内容公司通过AI</p><p>05:37 加快产出速度和提升内容质量</p><p>05:39 而比较反面的案例呢</p><p>05:41 就是很多人用AI洗稿并疯狂产出内容</p><p>05:44 污染互联网的内容生态</p><p>05:46 插一嘴</p><p>05:46 这里有个比较容易混淆的词叫AGI</p><p>05:49 它的意思是人们对于人工智能最终形态的畅想</p><p>05:53 及通用人工智能大模型借鉴发展</p><p>05:56 不单单能处理文本内容</p><p>05:57 也能处理图片</p><p>05:58 声音视频等多种形式的内容</p><p>06:01 这种处理多种模式内容的能力叫做多模态</p><p>06:04 有的时候呢我们需要多次使用大模型的能力</p><p>06:07 比如第一步将口播稿分段</p><p>06:09 第二步给每个段落写成一个文生图的提示词</p><p>06:12 第三步生成一张合适的图片</p><p>06:15 这种把多个步骤编排成一个流程的能力</p><p>06:17 叫做工作流</p><p>06:18 包括可以在页面上进行傻瓜操作</p><p>06:21 编排工作流的工具</p><p>06:22 比如扣子</p><p>06:23 以及用代码的方式编排工作流的框架</p><p>06:26 如long unchain</p><p>06:26 按照工作流封装大模型和一整套工具集</p><p>06:30 用于自动完成某一类复杂任务的程序</p><p>06:33 叫做一个智能体</p><p>06:34 多个智能体互相协作</p><p>06:36 完成更复杂的任务的程序叫做多智能体</p><p>06:39 chat gbt的插件系统</p><p>06:41 早期昙花一现的auto gbt</p><p>06:43 以及最近又昙花一现的minus都属于智能体</p><p>06:46 智能体</p><p>06:47 需要操作各种应用</p><p>06:48 比如打开浏览器上网</p><p>06:50 打开计算器进行算术</p><p>06:52 或者操作手机上的微信</p><p>06:53 发送一条信息等</p><p>06:55 实现托管</p><p>06:56 为了更方便操作外部数据源和工具</p><p>06:58 as throi公司于2024年底</p><p>07:00 为AI系统提供了一个标准化的接口</p><p>07:03 或者说协议叫做MC</p><p>07:05 给了AI一个操作外部世界的统一标准</p><p>07:08 而谷歌于2025年4月推出的另一个协议</p><p>07:11 用于agent和agent之间的通信</p><p>07:14 叫做a to a协议</p><p>07:15 至此大模型的生态开始百花齐放</p><p>07:18 未来的想象空间是无限的</p><p>07:20 别看这么多工作流啊</p><p>07:22 智能体啊</p><p>07:22 MCP等概念兴起</p><p>07:24 但其实都是老一套工程方面的事情</p><p>07:26 大模型本身的能力已经发展的快到极限了</p><p>07:30 一方面呢模型大小到了极限</p><p>07:32 一个顶级大语言</p><p>07:33 模型的训练成本已经超过1亿美元了</p><p>07:36 另一方面模型的能力也快到达了极限</p><p>07:39 前十名模型能力的差距</p><p>07:41 已经从两年前的12%</p><p>07:43 缩小到了25年年初的5.4%</p><p>07:45 前两名更是从4.9%</p><p>07:47 缩小到了0.7%</p><p>07:49 模型之间已经快拉不出差距了</p><p>07:51 正所谓边际收益递减</p><p>07:53 所以呢就开始卷其他方向寻找出路</p><p>07:56 比如让模型更小</p><p>07:57 以便减少成本和方便个人使用的模型压缩方法</p><p>08:01 包括把模型中的浮点数用更低精度表示</p><p>08:04 以减少显存和计算的量化</p><p>08:07 用参数量较大的大模型</p><p>08:09 指导参数量较小的小模型的蒸馏</p><p>08:11 删除模型中不重要的神经元</p><p>08:14 让模型更稀疏</p><p>08:15 以提高速度的减脂</p><p>08:17 用更低成本改善微调方式的方法</p><p>08:20 如laura klaura adapter等</p><p>08:22 从推理能力方向增强模型能力的方式</p><p>08:25 如思维链</p><p>08:26 通过人类反馈的强化学习</p><p>08:28 让模型说的话更合人的心意的方法叫RLHF</p><p>08:33 当然啥方向都卷不动的时候</p><p>08:35 铁还可以封装现有的大模型接口</p><p>08:38 并对外提供服务</p><p>08:39 通俗的说法呢就是套壳或者提供AI工具</p><p>08:42 AI服务</p><p>08:43 AI课程</p><p>08:44 AI社区等</p><p>08:45 帮助别人开发和使用AI能力的周边产品</p><p>08:48 这种在AI淘金热里帮助别人淘金</p><p>08:51 来赚取金币的方式叫做卖铲子</p><p>08:54 可别看不上卖铲子的</p><p>08:55 这可是要对AI各领域的产品和生态</p><p>08:58 都了如指掌才行</p><p>09:00 和文字相关的就是自然语言处理</p><p>09:02 有名的包括刚刚说的chat gbt以及cloud Gemini</p><p>09:07 Deep sick</p><p>09:08 豆包同1000问腾讯元宝等</p><p>09:11 和图片相关的是计算机视觉</p><p>09:14 包括很多AI绘画的应用</p><p>09:16 比如闭源的mid journey</p><p>09:18 开源的stable diffusion</p><p>09:19 绘画工作流软件CONFEUI等</p><p>09:22 和语音相关的</p><p>09:24 包括文字转语音的TTS和</p><p>09:27 语音转文字的AS2</p><p>09:29 和视频相关的包括SORA</p><p>09:31 可灵及梦等AI视频生成应用</p><p>09:34 以及各种数字人应用等</p><p>09:36 除了帮助普通用户外</p><p>09:38 你还可以帮助开发者更好地使用AI</p><p>09:41 包括像英伟达一样提供好的显卡</p><p>09:44 也就是GPU以及配套的开发框架KA</p><p>09:47 或者提供专门针对人工智能的处理器</p><p>09:50 比如专门用于大规模神经网络训练与推理的</p><p>09:54 TPU和专门用于终端设备推理的AI加速芯片</p><p>09:58 NPU等软件方面</p><p>10:00 你可以提供适合AI的编程语言</p><p>10:02 Python提供针对AI编程的库</p><p>10:05 Pytorch tensorflow</p><p>10:06 建设AI开源平台和社区</p><p>10:09 Hugging face</p><p>10:09 方便开发者本地运行大模型的工具</p><p>10:12 欧拉马</p><p>10:13 提升大语言模型推理速度的推理引擎</p><p>10:16 VLMAI编程助手</p><p>10:18 包括单独以软件形式存在的cursor</p><p>10:21 或者以插件形式存在的GITHUBCOPD的等等等等</p><p>10:24 太多可以做的事情了</p><p>10:26 如果你认为还有哪些特别重要的没有提到</p><p>10:29 可以评论区或弹幕区帮我补充上</p><p>10:32 AI时代瞬息万变</p><p>10:33 产品工具层出不穷</p><p>10:35 但他的技术底座依然保持不变</p><p>10:38 从最底层的线性代数</p><p>10:40 微积分</p><p>10:41 概率论</p><p>10:42 最优化等数学知识</p><p>10:43 到深度学习中</p><p>10:45 用神经网络表示函数</p><p>10:46 用损失函数最小化为目标</p><p>10:49 通过反向传播训练参数</p><p>10:51 再到后面的经典神经网络结构</p><p>10:53 MLP用于图像数据处理的卷积神经网络</p><p>10:57 CNN用于序列数据处理的循环神经网络</p><p>11:00 Rn</p><p>11:01 以及引爆整个大模型时代的attention机制</p><p>11:04 和基于attention机制发明的transformer架构</p><p>11:08 他们共同撑起了现代AI技术的大厦</p><p>11:13 恭喜你</p><p>11:14 坚持到了现在</p><p>11:15 你已经超过了99%的人了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;video-container&quot;&gt;
[&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=115389581303333&amp;bvid=BV1u9W7zCEmh&amp;cid=33157</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>agi大模型</title>
    <link href="https://www.zhengcookie.site/zhengcookie/agi%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.zhengcookie.site/zhengcookie/agi%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-12-05T20:11:45.000Z</published>
    <updated>2025-12-26T12:11:21.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、python基础语法-08-47"><a href="#一、python基础语法-08-47" class="headerlink" title="一、python基础语法 ﻿08:47﻿"></a>一、python基础语法 ﻿08:47﻿</h4><h5 id="1-Python基础语法的主要知识点-11-23"><a href="#1-Python基础语法的主要知识点-11-23" class="headerlink" title="1. Python基础语法的主要知识点 ﻿11:23﻿"></a>1. Python基础语法的主要知识点 ﻿11:23﻿</h5><ul><li><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-1?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-xTdHOZrZcnEt1Wd6ZfcSSdy9EIs%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-e3e5470fe45c8510415775d4a4624afdb1e7417b4a6f05197495cc9b68998ce66b17aca0140eacf991dc906f7f27748f68117fd9c21a49ca305a5e1275657320&amp;expires=8h&amp;r=574195163&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-1&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-1&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca8395a30becffee929b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>数据类型：包括int、float、string等基本数据类型及其对应方法，如字符串的切割、切片等操作</li><li>函数：函数的定义、调用和使用方法，学到递归即可</li><li>面向对象编程：类的概念和使用</li><li>进阶内容：<ul><li>异常处理</li><li>内置模块的使用（如OS模块）</li><li>模块化编程</li></ul></li><li>学习建议：<ul><li>基础部分（数据类型和函数）必须掌握</li><li>面向对象编程建议学习</li><li>更高级内容可根据兴趣选择性学习</li><li>推荐B站等平台上的Python基础教程</li></ul></li></ul><h5 id="2-环境配置与工具使用-13-54"><a href="#2-环境配置与工具使用-13-54" class="headerlink" title="2. 环境配置与工具使用 ﻿13:54﻿"></a>2. 环境配置与工具使用 ﻿13:54﻿</h5><h6 id="1）Python安装与版本管理-14-50"><a href="#1）Python安装与版本管理-14-50" class="headerlink" title="1）Python安装与版本管理 ﻿14:50﻿"></a>1）Python安装与版本管理 ﻿14:50﻿</h6><ul><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-2?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-7g6X5BFksW332LvHn5eNIrh54XE%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-1bf45a877f6df9ec30190b61c96eb17486b583ce90e62f985e1eeafec1f63c073f45f83b9114f2f947732e05893d05f18747416aa91b6114305a5e1275657320&amp;expires=8h&amp;r=771730252&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-2&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-2&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=a7e1f23860a769ab07a05bfe2a8de2d58deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>版本选择：<ul><li>推荐Python 3.10或3.11版本</li><li>Mac电脑内置Python 3.8，可覆盖安装</li></ul></li><li>安装位置：<ul><li>Windows避免安装在C盘</li><li>Mac无盘符限制</li></ul></li><li>验证安装：<ul><li>Windows使用where python命令</li><li>Mac使用where python3命令</li><li>注意：C:\Users\Administrator\AppData\Local\Microsoft\WindowsApps\python.exe不是真正的安装路径</li></ul></li></ul><h6 id="2）Jupyter-Notebook使用-14-25"><a href="#2）Jupyter-Notebook使用-14-25" class="headerlink" title="2）Jupyter Notebook使用 ﻿14:25﻿"></a>2）Jupyter Notebook使用 ﻿14:25﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-3?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-EeASQkafxLuSE%2F2tfpJ2dsYoBZI%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-9d394fde795b531d2580561bc0a16c4e7e346fb5c0f7eb0f9b103e80a63da57b1a0bda9eebd39e4e3971fa51154e0fbe31ff62bef839560d305a5e1275657320&amp;expires=8h&amp;r=489872292&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-3&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-3&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca44342240fa99746f4c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>安装方法：</p></li><li><p>启动方式：</p><ul><li>在目标目录下打开终端输入jupyter notebook</li><li>启动后会在当前目录打开</li></ul></li><li><p>浏览器配置</p><p>：</p><ul><li>推荐使用Chrome浏览器</li><li>可复制带token的URL在其他浏览器打开</li></ul></li><li><p>基本操作</p><p>：</p><ul><li>代码单元格与Markdown单元格切换</li><li>运行快捷键：Shift+Enter或Ctrl+Enter</li><li>保存快捷键：Ctrl+S</li></ul></li><li><p>优势</p><p>：</p><ul><li>支持分段执行代码</li><li>适合教学演示和实验性编程</li></ul></li></ul><h6 id="3）PyCharm与VS-Code选择"><a href="#3）PyCharm与VS-Code选择" class="headerlink" title="3）PyCharm与VS Code选择"></a>3）PyCharm与VS Code选择</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-4?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-JZTl6SMvm1aFLPnDfMJLuNNe7Rk%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-1773fed66c0f1d0a1a4cf0128c3249422f18a92631a23ce8fc325850cb1df3bdc46b92fa6b1c915bfca643d8db9ffd4d726695a774e29a57305a5e1275657320&amp;expires=8h&amp;r=145751520&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-4&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-4&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=3612dd02eb4608ab5d190a3cea8128ca8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>PyCharm</p><p>：</p><ul><li>推荐社区版，无需专业版</li><li>启动较慢，需耐心等待</li><li>Mac用户直接使用社区版</li></ul></li><li><p>VS Code</p><p>：</p><ul><li>轻量级替代方案</li><li>适合配置较低的电脑</li></ul></li><li><p>选择建议</p><p>：</p><ul><li>根据个人习惯选择工具</li><li>不要纠结于工具版本</li><li>电脑性能较差时推荐VS Code</li></ul></li></ul><h6 id="4）环境变量配置-32-05"><a href="#4）环境变量配置-32-05" class="headerlink" title="4）环境变量配置 ﻿32:05﻿"></a>4）环境变量配置 ﻿32:05﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-5?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-UucxegEjTz5pM2w5nCJdVbEUGrA%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-f3b166f2b9ec8bb0b9454d6f41cc9f6d2c78e82a018cb6096c2a6eccfe8e2a378949d2ace53e61cc1fa0f8867a009f4bc79aaf275d1df5fc305a5e1275657320&amp;expires=8h&amp;r=740056837&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-5&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-5&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca56afef5411c6cb254c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>.env文件</p><p>：</p><ul><li>用于存储敏感信息如API KEY</li><li>格式：OPENAI_API_KEY=”your_key_here”</li></ul></li><li><p>代理设置：</p></li><li><p>加载方法：</p></li></ul><h6 id="5）常用命令"><a href="#5）常用命令" class="headerlink" title="5）常用命令"></a>5）常用命令</h6><ul><li><p>目录操作</p><p>：</p><ul><li>cd：切换目录</li><li>ls(Mac)/dir(Windows)：列出当前目录内容</li></ul></li><li><p>Python相关</p><p>：</p><ul><li>python —version：查看Python版本</li><li>pip install package_name：安装Python包</li></ul></li><li><p>Jupyter相关</p><p>：</p><ul><li>jupyter notebook：启动Notebook</li><li>!pip install package_name：在Notebook中安装包</li></ul></li></ul><h4 id="二、大模型的认知"><a href="#二、大模型的认知" class="headerlink" title="二、大模型的认知"></a>二、大模型的认知</h4><h5 id="1-env文件问题-32-16"><a href="#1-env文件问题-32-16" class="headerlink" title="1. env文件问题 ﻿32:16﻿"></a>1. env文件问题 ﻿32:16﻿</h5><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-6?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-u%2FMDYpThTS0wBOL3x4YWWc6sBUc%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-be110507975da4f7f1c40f44e19794dfda0916cfe9015510c9ebce8be8d45d67f1371b4e7ba41e94af41a6f0ed55359096c4741ad92e9bcd305a5e1275657320&amp;expires=8h&amp;r=511869968&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-6&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-6&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=3612dd02eb4608abcbc79c52d488987e8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>创建步骤</p><p>：</p><ul><li>Windows系统需先显示文件扩展名</li><li>右键新建文本文件后删除前缀，只保留”.env”后缀</li><li>内容必须使用英文引号，格式为：</li></ul></li><li><p>注意事项</p><p>：</p><ul><li>禁止将变量放入系统环境变量</li><li>Jupyter用户需重启内核才能识别新建的env文件</li><li>建议直接复制课件内容避免格式错误</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-7?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-j9ArjIPJCdYi5xtqGQMj%2BX3wT6g%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-6397271a13347297cda92d3430c620c2aa50b59cfae5ef13d04f63cf1b2cabba6c4fe1960f5d014e1c5b4feb25962f92369c695392e1c972305a5e1275657320&amp;expires=8h&amp;r=965441738&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-7&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-7&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121cabf9c9f5b8bcce4519b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>内容规范</p><p>：</p><ul><li>仅包含API_KEY和BASE_URL两个变量</li><li>所有符号必须为英文半角（包括引号、等号）</li><li>变量名严格区分大小写</li></ul></li></ul><h5 id="2-mac问题-36-38"><a href="#2-mac问题-36-38" class="headerlink" title="2. mac问题 ﻿36:38﻿"></a>2. mac问题 ﻿36:38﻿</h5><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-8?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-b128ju0B%2FrSzZV4RMXTBJ6UUd5E%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-636ad972efc2446118e7ffda020c04fd9f259a8d13af7e0a264a2522afeed634ee8e9aefa9153c27b3086499dce020a7d41643a96f2cf498305a5e1275657320&amp;expires=8h&amp;r=944619035&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-8&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-8&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=2a0349c66f068e0f07c7abd6ae653f448deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>特殊处理</p><p>：</p><ul><li>通过PyCharm/VSCode图形界面创建.env文件</li><li>在IDE中右键项目目录选择”New File”创建</li><li>注意.env是隐藏文件，在Finder中默认不可见</li></ul></li><li><p>验证方法</p><p>：</p><ul><li>使用代码编辑器确认文件内容</li><li>确保没有多余空格或换行符</li></ul></li></ul><h5 id="3-全局环境和虚拟环境问题-40-13"><a href="#3-全局环境和虚拟环境问题-40-13" class="headerlink" title="3. 全局环境和虚拟环境问题 ﻿40:13﻿"></a>3. 全局环境和虚拟环境问题 ﻿40:13﻿</h5><h6 id="1）全局环境和虚拟环境的概念"><a href="#1）全局环境和虚拟环境的概念" class="headerlink" title="1）全局环境和虚拟环境的概念"></a>1）全局环境和虚拟环境的概念</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-9?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-2Jgn%2BYPz7F4IhPScAgyhlQdiRXQ%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-4a8ebd782ad3246f6a58b81b4005d8a3194fd6a08e34315eeb23f1b04e102d1139a4b9b92747c8d12fffeb0f6072f9e2b5d956feccdedf5e305a5e1275657320&amp;expires=8h&amp;r=665301168&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-9&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-9&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=12146e4ffd7df3c9b7d6c8393faaedc69b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>核心区别</p><p>：</p><ul><li>全局环境：通过pip install直接安装到系统Python</li><li>虚拟环境：为每个项目创建隔离的Python运行环境</li></ul></li><li><p>典型场景</p><p>：</p><ul><li>当不同项目需要同一库的不同版本时（如A库需0.1.0和0.1.1）</li><li>避免卸载重装导致的版本冲突</li></ul></li><li><p>优势对比</p><p>：</p><ul><li>虚拟环境允许并行存在多个依赖版本</li><li>项目迁移时可通过requirements.txt重建环境</li></ul></li></ul><h6 id="2）GitHub示例操作-44-18"><a href="#2）GitHub示例操作-44-18" class="headerlink" title="2）GitHub示例操作 ﻿44:18﻿"></a>2）GitHub示例操作 ﻿44:18﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-10?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-aUsGhjRvYTMq%2BRbwbzvSBmIfKJQ%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-432f4f7334996d2cf245d23dabea1856bd4385eae007dd999244da7d6ccd6e79b957df9b05c3919840840249a3b7a07c8064367bb72d4cc2305a5e1275657320&amp;expires=8h&amp;r=207792599&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-10&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-10&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=738aa28698fb94aa61061f9ec8ddb82f8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>行业实践</p><p>：</p><ul><li>项目根目录通常包含requirements.txt或Pipfile</li><li>示例：Dify项目使用Dockerfile管理环境</li></ul></li><li><p>依赖导出</p><p>：</p><ul><li>使用pip freeze &gt; requirements.txt命令</li><li>该文件记录所有依赖包及其精确版本号</li></ul></li><li><p>环境重建：</p></li></ul><h4 id="三、Python环境使用详解-45-21"><a href="#三、Python环境使用详解-45-21" class="headerlink" title="三、Python环境使用详解 ﻿45:21﻿"></a>三、Python环境使用详解 ﻿45:21﻿</h4><h5 id="1-搜索Python相关资源"><a href="#1-搜索Python相关资源" class="headerlink" title="1. 搜索Python相关资源"></a>1. 搜索Python相关资源</h5><h6 id="1）GitHub上的RAG项目"><a href="#1）GitHub上的RAG项目" class="headerlink" title="1）GitHub上的RAG项目"></a>1）GitHub上的RAG项目</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-11?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-4NqRqJSCdSAnIv187EqthjjYdM0%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-2cb95e11025319ea3ec639378ce37491407b8ed91348359972e56181ee7bd17ed8532f626452a98f57e8e9ba6023109a6b6c70a447bf9ad2305a5e1275657320&amp;expires=8h&amp;r=352258822&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-11&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-11&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=12146e4ffd7df3c9bc45b0a9363017654c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>RAGFlow项目：开源RAG（检索增强生成）引擎，基于深度文档理解技术，支持Python语言开发（49.1%代码占比）</p></li><li><p>项目特点</p><p>：</p><ul><li>包含79.8k个相关仓库结果</li><li>支持多语言开发（TypeScript 47.0%，JavaScript 14%）</li><li>最新更新时间为1小时前，活跃度较高</li></ul></li></ul><h6 id="2）项目依赖管理方式"><a href="#2）项目依赖管理方式" class="headerlink" title="2）项目依赖管理方式"></a>2）项目依赖管理方式</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-12?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-wFNwvBe3pMcqs0BbjnH4MPGb0Io%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-60248f215d1402855bcad063fce751838566b3e1e9d43a7bccd151a0d9e977e07ef9f4a213721dd03f3aeb8f5fba3f786e2984ef74575615305a5e1275657320&amp;expires=8h&amp;r=160719341&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-12&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-12&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=4d291be9b94219595d190a3cea8128ca8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>依赖管理</p><p>：</p><ul><li>现代Python项目普遍采用Docker容器化部署</li><li>通过Dockerfile配置环境依赖（如Python 3.8+、JDK等）</li><li>包含NLTK数据、Tika服务器等专业组件</li></ul></li><li><p>典型依赖项</p><p>：</p><ul><li>基础库：libglib2.0、libgdiplus</li><li>Python包：python-pptx、selenium</li><li>工具链：docker-ce、apt-cacher-ng</li></ul></li></ul><h6 id="3）环境配置要点"><a href="#3）环境配置要点" class="headerlink" title="3）环境配置要点"></a>3）环境配置要点</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-13?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-69oYdj7U5mNyrNbdxCqPZgU%2BE5I%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-161d5ac282b590dbcc7b2e3de76b0d2757ef43dfd97f67482dcda0c11b0a0584b0e9c37d63b3b7481a7bcee0689c82e8f568de92f9f03fda305a5e1275657320&amp;expires=8h&amp;r=359147062&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-13&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-13&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=83f2b583554fba159c9dcc2c5a4d86874c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>关键配置</p><p>：</p><ul><li>使用虚拟环境隔离项目依赖</li><li>避免使用系统默认Python路径（如WindowsApps下的python.exe）</li><li>通过.env文件管理API密钥等敏感信息</li></ul></li><li><p>注意事项</p><p>：</p><ul><li>环境变量引号必须使用英文格式</li><li>不建议将密钥存入系统环境变量</li><li>典型项目结构包含requirements.txt文件管理Python依赖</li></ul></li></ul><h5 id="2-requirements-txt文件-46-00"><a href="#2-requirements-txt文件-46-00" class="headerlink" title="2. requirements.txt文件 ﻿46:00﻿"></a>2. requirements.txt文件 ﻿46:00﻿</h5><ul><li><img src="https://xacu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-14?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-OxX2%2Fq9ctdB9vzLCy8JsS5na2Z0%3D&amp;to=128&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CXian%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-77324a899d9c08ffc7f6cb094d76a1ae398c251980b4b54fc5c50b1986244f0ce55f44b23b8be4e004a0b5e6672185e6327f40277348f836305a5e1275657320&amp;expires=8h&amp;r=371058402&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-14&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-14&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=cf87eda222dfadb79bb24ef744090da98deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>项目依赖管理：在非Docker项目中，requirements.txt是Python项目常见的依赖配置文件</li><li>文件内容：记录了项目所需的所有Python模块及其精确版本号</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-15?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-QeKQgjMpjdVdfFUqUGbSwr17LV0%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-4bd5b43e650416e720d517871603c9e154259dbc58180a71b375e48e5360be028eaa8e93073929836b7c2af1730d78758637e564a2999e13305a5e1275657320&amp;expires=8h&amp;r=719367820&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-15&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-15&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=875e0ff32ac7bd89ec8b61f085efb7e49b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>典型示例：</li></ul><h6 id="1）文件作用"><a href="#1）文件作用" class="headerlink" title="1）文件作用"></a>1）文件作用</h6><ul><li><p>环境重建：通过该文件可以在新环境中快速安装相同版本的依赖</p></li><li><p>版本控制：确保不同开发者使用完全一致的依赖版本，避免兼容性问题</p></li><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-16?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-15kEX4qsbFSJ26SBMGpr%2FPfd5pY%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-357d63f8d50e15b99bc9b7eaa39d56d0cf6651dfa62028d6376648d428c21e1b5079668402f7abe3675cf63f622d02108795719c726f8ad2305a5e1275657320&amp;expires=8h&amp;r=778508889&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-16&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-16&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e80686faf624695b8f8f85d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>使用方法</p><p>：</p><ul><li>创建虚拟环境后执行pip install -r requirements.txt</li><li>全局环境安装需谨慎，建议使用虚拟环境</li></ul></li></ul><h6 id="2）导出依赖"><a href="#2）导出依赖" class="headerlink" title="2）导出依赖"></a>2）导出依赖</h6><ul><li><p>导出方法：使用pip freeze &gt; requirements.txt命令可将当前环境所有安装包导出</p></li><li><p>注意事项</p><p>：</p><ul><li>仅导出项目必要的依赖，避免包含无关包</li><li>导出版本号确保精确匹配</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-17?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-nKwF7LceyjwaEeQfGPLTImcir%2Bo%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-5e7a02a14ef07ea227116e28969fc72dad9ab82a7323bc512ae858d64a1440849b08ea25ca0d8942d6281632f9e60f1950e0db9d9a2702d0305a5e1275657320&amp;expires=8h&amp;r=751366413&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-17&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-17&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=875e0ff32ac7bd8947990d12e1e064b74c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>版本管理技巧</p><p>：</p><ul><li>全局环境与虚拟环境可以安装不同版本</li><li>项目开发时应固定主要依赖版本</li></ul></li></ul><h6 id="3）与Docker的区别"><a href="#3）与Docker的区别" class="headerlink" title="3）与Docker的区别"></a>3）与Docker的区别</h6><ul><li><p>轻量级方案：相比Docker容器化，requirements.txt提供更轻量的环境配置方案</p></li><li><p>适用场景</p><p>：</p><ul><li>快速分享Python项目依赖配置</li><li>不需要完整系统环境复现的场景</li><li>开发初期快速搭建环境</li></ul></li></ul><h5 id="3-问题答疑-47-34"><a href="#3-问题答疑-47-34" class="headerlink" title="3. 问题答疑 ﻿47:34﻿"></a>3. 问题答疑 ﻿47:34﻿</h5><h6 id="1）全局环境与虚拟环境-47-51"><a href="#1）全局环境与虚拟环境-47-51" class="headerlink" title="1）全局环境与虚拟环境 ﻿47:51﻿"></a>1）全局环境与虚拟环境 ﻿47:51﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-18?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-x%2FdW36NOD4zol8W%2BMDMcJqMfrOo%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-41826015bf2fb90f42a26b8d22fffaf4ed1d2b2e3a3c0308ed65ec21f3542a3798b9699fde12fbb7654ca539a1885b5b4d1efe65067b8260305a5e1275657320&amp;expires=8h&amp;r=148477954&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-18&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-18&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e8068173f2ae99a7b5b754c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>环境区别</p><p>:</p><ul><li>全局环境：通过pip install a=1.1.1安装的包对所有项目生效</li><li>虚拟环境：每个项目独立环境（如a=0.1.0），避免包版本冲突</li></ul></li><li><p>项目实践：建议每个项目创建独立虚拟环境，防止不同项目间的依赖冲突</p></li></ul><h6 id="2）设置Python环境-48-27"><a href="#2）设置Python环境-48-27" class="headerlink" title="2）设置Python环境 ﻿48:27﻿"></a>2）设置Python环境 ﻿48:27﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-19?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-6dFLNc9oS5bymWiy45Qxhiow69Q%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-aed8cf7f410ac1216ca84a29f0d0b2ace81a895a46b6bf0bb5e1edaae0df7b15261aa6fcf703c0939e12f4011da1440937df430708a6bc16305a5e1275657320&amp;expires=8h&amp;r=960790681&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-19&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-19&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=b3434a369726e9249598d5fd593929895d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>环境查询</p><p>：</p><ul><li>使用where python命令查看当前使用的Python解释器路径</li><li>第一个显示的路径即为当前激活环境</li></ul></li><li><p>环境切换</p><p>：</p><ul><li>在PyCharm中通过Settings &gt; Project &gt; Python Interpreter修改</li><li>可添加系统环境（System）或指定虚拟环境路径</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-20?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-4nCJW3Ign3Rjiq6yFMCBKdB8Oo8%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-98c4fd0a2739a159d33133f8b6eb0deab6ce9b8bfde1be0f4d83ea9a969d4385635d1a5ce8141ccbbd645daa2ad559895f6bb07b709c5aaa305a5e1275657320&amp;expires=8h&amp;r=537284088&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-20&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-20&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e8068c32f23017ea016b05d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>配置选项</p><p>：</p><ul><li>System：全局Python环境</li><li>Virtualenv：虚拟环境</li><li>Conda：Anaconda环境</li><li>Pipenv：Pipenv管理环境</li></ul></li><li><p>操作步骤</p><p>：</p><ul><li>点击”Add Interpreter”</li><li>选择环境类型</li><li>指定解释器路径（如D:\Python310\python.exe）</li></ul></li></ul><h6 id="3）虚拟环境的使用-49-12"><a href="#3）虚拟环境的使用-49-12" class="headerlink" title="3）虚拟环境的使用 ﻿49:12﻿"></a>3）虚拟环境的使用 ﻿49:12﻿</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-21?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-7jLFkxB6FxeU08%2B5uhpxsgn8Yeg%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-8e9c442e1d87f4f47e0e8a5f8301dab4878bcedf577c0be0875b21f332c2b8b66ca3420c05c8026f60b279b4c5632935f2fac3c06a1329fc305a5e1275657320&amp;expires=8h&amp;r=143797820&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-21&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-21&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=1524a5cd531d02e5ccc7bc964f060af44c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>存储位置</p><p>：</p><ul><li>默认路径：C:\Users\Administrator\llm_agent</li><li>包含不同项目的独立环境（如langchain、RAG等）</li></ul></li><li><p>创建原则</p><p>：</p><ul><li>PyCharm一般使用全局环境</li><li>项目开发时需创建专属虚拟环境</li><li>通过venv或virtualenv工具创建</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-22?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-muVY0OJdpEoghIsywItzHJu5L6c%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-3a757c683469977b6ecbb793adf48e76cba8bdacf7adf1ed36cfd28cceaf1a85029dafb1c2f9b31479aab4e4414aada59f2cb109bba34fad305a5e1275657320&amp;expires=8h&amp;r=988533937&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-22&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-22&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e80684cf9f0f2313dbfba4c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>管理技巧</p><p>：</p><ul><li>环境命名建议与项目名称关联（如langchain_env）</li><li>路径中应包含Scripts\python.exe可执行文件</li><li>激活后终端提示符会显示环境名称</li></ul></li><li><p>最佳实践</p><p>：</p><ul><li>开发时：使用项目专属虚拟环境</li><li>测试时：可切换至全局环境验证兼容性</li><li>部署时：通过requirements.txt固化依赖版本</li></ul></li></ul><h5 id="4-VScode-51-24"><a href="#4-VScode-51-24" class="headerlink" title="4. VScode ﻿51:24﻿"></a>4. VScode ﻿51:24﻿</h5><ul><li><p>主要用途：常被当作记事本使用，但实际是功能强大的代码编辑器</p></li><li><p>汉化设置</p><p>：</p><ul><li>搜索安装”Chinese”插件实现汉化</li><li>默认英文界面，汉化后更易理解但可能影响准确性</li></ul></li><li><p>插件推荐</p><p>：</p><ul><li>Code Runner：用于运行代码</li><li>Python扩展：支持Python开发</li><li>Jupyter支持：可运行.ipynb文件（但老师个人不推荐）</li></ul></li><li><p>优势特点</p><p>：</p><ul><li>插件生态丰富，支持多种语言</li><li>内存占用小，适合配置较低的设备</li><li>支持文件夹项目管理</li></ul></li><li><p>使用建议</p><p>：</p><ul><li>初学者可先汉化后逐步过渡到英文</li><li>虚拟环境设置需自行搜索配置</li></ul></li></ul><h5 id="5-PyCharm-55-17"><a href="#5-PyCharm-55-17" class="headerlink" title="5. PyCharm ﻿55:17﻿"></a>5. PyCharm ﻿55:17﻿</h5><ul><li><p>使用习惯：老师主要开发工具，已习惯英文界面</p></li><li><p>对比优势</p><p>：</p><ul><li>专业Python IDE，功能更全面</li><li>但内存占用较大</li></ul></li><li><p>汉化说明：支持汉化但不推荐，可能影响功能理解</p></li></ul><h5 id="6-Anaconda-55-38"><a href="#6-Anaconda-55-38" class="headerlink" title="6. Anaconda ﻿55:38﻿"></a>6. Anaconda ﻿55:38﻿</h5><ul><li><p>适用人群：不推荐零基础学习者使用</p></li><li><p>主要问题</p><p>：</p><ul><li>虚拟环境概念对新手较复杂</li><li>环境配置容易造成混淆</li></ul></li><li><p>替代方案：建议初学者使用PyCharm或VS Code</p></li></ul><h5 id="7-应用案例-59-01"><a href="#7-应用案例-59-01" class="headerlink" title="7. 应用案例 ﻿59:01﻿"></a>7. 应用案例 ﻿59:01﻿</h5><h6 id="1）例题-打印问题"><a href="#1）例题-打印问题" class="headerlink" title="1）例题:打印问题"></a>1）例题:打印问题</h6><ul><li>题目解析<ul><li>换行实现对比：<ul><li>单引号/双引号需手动添加转义字符\n</li><li>三引号自动支持多行文本</li></ul></li><li>本质区别：<ul><li>都是字符串类型（str）</li><li>语法形式不同但功能等价</li></ul></li><li>实际应用：<ul><li>多行文本处理时三引号更便捷</li><li>简单字符串可使用单/双引号</li></ul></li></ul></li></ul><h6 id="2）例题-三引号作用-59-12"><a href="#2）例题-三引号作用-59-12" class="headerlink" title="2）例题:三引号作用 ﻿59:12﻿"></a>2）例题:三引号作用 ﻿59:12﻿</h6><ul><li>题目解析<ul><li>核心功能：<ul><li>实现多行字符串定义</li><li>避免频繁使用转义字符</li></ul></li><li>类型验证：<ul><li>使用type()检查均为str类型</li></ul></li><li>使用场景：<ul><li>长文本处理</li><li>文档字符串(Docstring)</li></ul></li></ul></li></ul><p>需要保留原始格式的文本</p><ul><li><ul><li><ul><li>注：本笔记已按照康奈尔笔记法结构化整理，保留了所有关键知识点、使用建议和对比分析，并确保与课程内容完全对应。对于代码运行环境配置等实操性内容，建议结合具体开发环境进行实践验证。</li></ul></li></ul></li></ul><h5 id="8-在线编译器-01-00-34"><a href="#8-在线编译器-01-00-34" class="headerlink" title="8. 在线编译器 ﻿01:00:34﻿"></a>8. 在线编译器 ﻿01:00:34﻿</h5><h6 id="1）MasterCode工具介绍"><a href="#1）MasterCode工具介绍" class="headerlink" title="1）MasterCode工具介绍"></a>1）MasterCode工具介绍</h6><ul><li>核心功能：提供在线Python代码编写和运行环境，无需本地安装</li><li>适用场景：适合初学者快速验证基础语法，解决环境配置问题</li><li>访问方式：通过网页直接体验，老师推荐的学习工具</li><li>版本信息：默认使用Python 3.9.x版本环境</li></ul><h6 id="2）基础操作指南"><a href="#2）基础操作指南" class="headerlink" title="2）基础操作指南"></a>2）基础操作指南</h6><ul><li><p>项目创建</p><p>：</p><ul><li>新建项目时可自定义项目名称（如P007）</li><li>详情设置保持默认即可</li></ul></li><li><p>文件管理</p><p>：</p><ul><li>可删除默认生成的文件</li><li>支持新建.py文件（如demo.py）</li></ul></li><li><p>代码执行</p><p>：</p><ul><li>右键选择”Run”运行当前文件</li><li>支持通过顶部按钮运行主程序</li></ul></li></ul><h6 id="3）AI辅助功能"><a href="#3）AI辅助功能" class="headerlink" title="3）AI辅助功能"></a>3）AI辅助功能</h6><ul><li><p>代码解释</p><p>：</p><ul><li>选中代码后点击”解释”获取AI分析</li><li>支持整段代码的逐行解释（如环境变量加载、实例化过程等）</li></ul></li><li><p>注释生成</p><p>：</p><ul><li>自动为方法添加功能说明文档</li><li>包含参数说明和返回值描述</li><li>用户可选择接受(Y)或拒绝(N)生成的注释</li></ul></li><li><p>代码对话</p><p>：</p><ul><li>可询问方法调用方式等具体问题</li><li>提供使用示例和返回结果说明</li></ul></li></ul><h6 id="4）环境配置"><a href="#4）环境配置" class="headerlink" title="4）环境配置"></a>4）环境配置</h6><ul><li><p>模块安装</p><p>：</p><ul><li>支持通过pip install安装第三方库</li><li>安装速度快（如openai 1.59.6版本）</li></ul></li><li><p>系统限制</p><p>：</p><ul><li>内存上限4GB</li><li>硬盘空间有限制</li><li>不适合运行大型项目</li></ul></li></ul><h5 id="9-问题答疑-01-12-05"><a href="#9-问题答疑-01-12-05" class="headerlink" title="9. 问题答疑 ﻿01:12:05﻿"></a>9. 问题答疑 ﻿01:12:05﻿</h5><h6 id="1）虚拟环境问题"><a href="#1）虚拟环境问题" class="headerlink" title="1）虚拟环境问题"></a>1）虚拟环境问题</h6><ul><li>处理方案：将在正式课程中详细讲解虚拟环境创建和使用</li><li>应用场景：后续项目开发时会实际应用</li></ul><h6 id="2）程序员工作方式"><a href="#2）程序员工作方式" class="headerlink" title="2）程序员工作方式"></a>2）程序员工作方式</h6><ul><li><p>开发流程</p><p>：</p><ul><li>项目前期进行技术评审和框架选定</li><li>在确定的技术框架基础上实现需求</li></ul></li><li><p>代码编写</p><p>：</p><ul><li>传统开发以手写代码为主</li><li>固定代码段可采用复制粘贴</li><li>现代开发可结合AI辅助</li></ul></li><li><p>岗位区分</p><p>：</p><ul><li>开发、运维、设计等不同岗位工作内容差异大</li><li>不同编程语言有对应的专用框架</li></ul></li></ul><h6 id="3）网页运行原理"><a href="#3）网页运行原理" class="headerlink" title="3）网页运行原理"></a>3）网页运行原理</h6><ul><li>课程关联：已在前期课程中多次讲解网页运行机制</li><li>框架学习：后续将学习LangChain等专业框架的使用</li></ul><h4 id="四、Streamlit使用指南-01-15-23"><a href="#四、Streamlit使用指南-01-15-23" class="headerlink" title="四、Streamlit使用指南 ﻿01:15:23﻿"></a>四、Streamlit使用指南 ﻿01:15:23﻿</h4><h5 id="1-运行方法"><a href="#1-运行方法" class="headerlink" title="1. 运行方法"></a>1. 运行方法</h5><ul><li><p>运行命令: 使用streamlit run命令运行项目，需先定位到项目目录</p></li><li><p>目录定位方法</p><p>:</p><ul><li>在文件资源管理器中打开项目文件夹</li><li>通过cmd或终端进入项目目录</li><li>在PyCharm等IDE中，终端默认打开当前项目目录</li></ul></li></ul><h5 id="2-运行机制"><a href="#2-运行机制" class="headerlink" title="2. 运行机制"></a>2. 运行机制</h5><ul><li><p>自动启动: 运行后会默认打开浏览器显示界面</p></li><li><p>网络配置</p><p>:</p><ul><li>使用本机IP地址</li><li>端口号由Streamlit自动分配</li><li>首次运行直接敲回车即可</li></ul></li></ul><h5 id="3-环境注意事项"><a href="#3-环境注意事项" class="headerlink" title="3. 环境注意事项"></a>3. 环境注意事项</h5><ul><li><p>Windows系统</p><p>:</p><ul><li>用户名路径不要使用中文</li><li>项目路径避免包含中文字符</li></ul></li><li><p>目录结构</p><p>:</p><ul><li>项目应组织在单一文件夹内</li><li>打开最上层文件夹即可访问整个项目</li></ul></li></ul><h5 id="4-Streamlit优势探究"><a href="#4-Streamlit优势探究" class="headerlink" title="4. Streamlit优势探究"></a>4. Streamlit优势探究</h5><ul><li><p>作业要求</p><p>:</p><ul><li>对比Streamlit与其他框架的区别</li><li>分析Streamlit的独特优势</li><li>研究为何选择Streamlit开发界面</li></ul></li></ul><h5 id="5-开发建议"><a href="#5-开发建议" class="headerlink" title="5. 开发建议"></a>5. 开发建议</h5><ul><li><p>调试技巧</p><p>:</p><ul><li>通过与大模型对话解决编码问题</li><li>遇到问题时先分析错误信息</li></ul></li><li><p>教学目的</p><p>:</p><ul><li>重点掌握实际应用方法</li><li>理解问题解决思路比直接看结果更重要</li></ul></li></ul><h4 id="五、知识小结"><a href="#五、知识小结" class="headerlink" title="五、知识小结"></a>五、知识小结</h4><div class="table-container"><table><thead><tr><th>知识点</th><th>核心内容</th><th>考试重点/易混淆点</th><th>难度系数</th></tr></thead><tbody><tr><td>Python环境配置</td><td>全局环境与虚拟环境区别、jupyter notebook使用技巧</td><td>虚拟环境路径设置、不同系统命令差异(Win/mac)</td><td>⭐⭐⭐</td></tr><tr><td>代码调试方法</td><td>VS Code/PyCharm调试配置、在线编译器(MasterCode)使用</td><td>环境变量(.env)加载机制、浏览器兼容性问题</td><td>⭐⭐</td></tr><tr><td>Python基础语法</td><td>数据类型/函数/面向对象三大知识模块</td><td>三引号字符串特性、递归函数理解</td><td>⭐⭐⭐⭐</td></tr><tr><td>大模型开发基础</td><td>API密钥管理、Streamlit框架应用</td><td>代理设置、端点URL配置</td><td>⭐⭐⭐⭐</td></tr><tr><td>学习资源推荐</td><td>B站基础教程、AI代码解释工具</td><td>官方文档与第三方资源取舍</td><td>⭐</td></tr><tr><td>项目部署实践</td><td>requirements.txt文件作用、Docker基础概念</td><td>依赖版本冲突解决</td><td>⭐⭐⭐⭐</td></tr><tr><td>开发工具对比</td><td>PyCharm社区版/专业版差异、Jupyter分段执行优势</td><td>内存占用优化、快捷键配置</td><td>⭐⭐</td></tr><tr><td>代码理解技巧</td><td>AI辅助注释生成、多行代码解释方法</td><td>上下文关联分析</td><td>⭐</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、python基础语法-08-47&quot;&gt;&lt;a href=&quot;#一、python基础语法-08-47&quot; class=&quot;headerlink&quot; title=&quot;一、python基础语法 ﻿08:47﻿&quot;&gt;&lt;/a&gt;一、python基础语法 ﻿08:47﻿&lt;/h4&gt;&lt;h5 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Solidity智能合约零基础入门（二）Solidity基础语法</title>
    <link href="https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2025-11-30T09:26:22.000Z</published>
    <updated>2025-12-17T07:27:43.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solidity基础语法"><a href="#Solidity基础语法" class="headerlink" title="Solidity基础语法"></a>Solidity基础语法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Solidity是一种合约导向编程语言，用于编写智能合约，运行在Ethereum虚拟机（EVM）上。本文档将为您介绍Solidity的基本语法和概念，帮助您快速上手智能合约开发。</p><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-functions">函数</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰器</a>、<a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-events">事件</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>、 和 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleStorage &#123;<br>    <span class="hljs-built_in">uint</span> storedData; <span class="hljs-comment">// 状态变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有效的状态变量类型参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#types">类型</a> 章节， 对状态变量可见性有可能的选择参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a> 。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123; <span class="hljs-comment">// 函数</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#function-calls">函数调用</a> 可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a>）。</p><h4 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifiers">函数 </a>）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.22</span>;<br><br>contract Purchase &#123;<br>    address <span class="hljs-keyword">public</span> seller;<br><br>    <span class="hljs-function">modifier <span class="hljs-title">onlySeller</span>()</span> &#123; <span class="hljs-comment">// 修饰器</span><br>        require(<br>            msg.sender == seller,<br>            <span class="hljs-string">&quot;Only seller can call this.&quot;</span><br>        );<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">abort</span>() <span class="hljs-keyword">public</span> onlySeller</span> &#123; <span class="hljs-comment">// Modifier usage</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.21</span>;<br>contract SimpleAuction &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">address bidder, <span class="hljs-built_in">uint</span> amount</span>)</span>; <span class="hljs-comment">// 事件</span><br><br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">emit <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>; <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events">事件</a>。</p><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>结构是可以将几个变量分组的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#structs">结构体</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Ballot &#123;<br>    <span class="hljs-keyword">struct</span> Voter &#123; <span class="hljs-comment">// 结构</span><br>        <span class="hljs-built_in">uint</span> weight;<br>        <span class="hljs-built_in">bool</span> voted;<br>        address <span class="hljs-built_in">delegate</span>;<br>        <span class="hljs-built_in">uint</span> vote;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#enums">枚举类型</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    <span class="hljs-keyword">enum</span> State &#123; Created, Locked, Inactive &#125; <span class="hljs-comment">// 枚举</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p><code>bool</code> ：可能的取值为常数值 <code>true</code> 和 <code>false</code>。</p><p>运算符：</p><ul><li><code>!</code> (逻辑非)</li><li><code>&amp;&amp;</code> (逻辑与, “and”)</li><li><code>||</code> (逻辑或, “or”)</li><li><code>==</code> (等于)</li><li><code>!=</code> (不等于)</li></ul><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。 就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> / <code>false</code> ， 那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><code>int</code> / <code>uint</code>: 分别表示有符号和无符号的不同位数的整型变量。 关键字 <code>uint8</code> 到 <code>uint256</code> （无符号整型，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>， 以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> (异或)， <code>~</code> (位取反)</li><li>移位运算符： <code>&lt;&lt;</code> （左移）， <code>&gt;&gt;</code> （右移）</li><li>算数运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code> （只适用于有符号的整数）， <code>*</code>， <code>/</code>， <code>%</code> (取余)， <code>**</code> (幂)</li></ul><p>对于一个整数类型 <code>X</code>，您可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 来访问该类型代表的最小值和最大值。</p><h5 id="定长浮点型"><a href="#定长浮点型" class="headerlink" title="定长浮点型"></a>定长浮点型</h5><blockquote id="fn_警告"><sup>警告</sup>. Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。<a href="#reffn_警告" title="Jump back to footnote [警告] in the text."> &#8617;</a></blockquote><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中， <code>M</code> 表示该类型占用的位数， <code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x18</code> 和 <code>fixed128x18</code> 的别名。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>fixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>ufixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>ufixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回值是布尔型）</li><li>算术运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code> (取余数)</li></ul><h5 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h5><p>地址类型有两种大致相同的类型：</p><ul><li><code>address</code>: 保存一个20字节的值（一个以太坊地址的大小）。</li><li><code>address payable</code>: 与 <code>address</code> 类型相同，但有额外的方法 <code>transfer</code> 和 <code>send</code>。</li></ul><p>这种区别背后的想法是， <code>address payable</code> 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 <code>address</code>，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">address addr <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990<span class="hljs-comment">;</span><br>address payable addr_pay <span class="hljs-operator">=</span> payable(<span class="hljs-number">0</span>x8306300ffd616049FD7e4b0354a64Da835c1A81C)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li><code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> 和 <code>&gt;</code></li></ul><h5 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h5><p>值类型 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code> 代表从1到32的字节序列。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bytes32 public _byte32 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MiniSolidity&quot;</span><span class="hljs-comment">; </span><br><br>bytes1 public _byte <span class="hljs-operator">=</span> _byte32[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> (返回 <code>bool</code>)</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li><li>索引访问： 如果 <code>x</code> 是 <code>bytesI</code> 类型，那么当 <code>0 &lt;= k &lt; I</code> 时， <code>x[k]</code> 返回第 <code>k</code> 个字节（只读）。</li></ul><p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型）， 它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p><p>成员变量：</p><ul><li><code>.length</code> 表示这个字节数组的长度（只读）.</li></ul><h5 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。</p><p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code>0</code> 开始无符号整数值表示。</p><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 您可以得到给定枚举的最小值和最大值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br>contract test &#123;<br>    <span class="hljs-built_in">enum</span> ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;<br>    ActionChoices choice;<br>    ActionChoices constant defaultChoice = ActionChoices.GoStraight;<br><br>    <span class="hljs-function">function <span class="hljs-title">setGoStraight</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        choice = ActionChoices.GoStraight;<br>    &#125;<br><br>    <span class="hljs-comment">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span><br>    <span class="hljs-comment">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span><br>    <span class="hljs-function">function <span class="hljs-title">getChoice</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> choice;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getDefaultChoice</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">uint</span>(defaultChoice);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getLargestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).max;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getSmallestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 </p><p>类似的格式如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> &lt;<span class="hljs-keyword">function</span> <span class="hljs-type">name</span>&gt; (&lt;parameter <span class="hljs-keyword">types</span>&gt;) &#123;<span class="hljs-type">internal</span>|<span class="hljs-keyword">external</span>|<span class="hljs-built_in">public</span>|private&#125; &#123;modifier&#125; [pure|<span class="hljs-keyword">view</span>|payable] [<span class="hljs-keyword">returns</span> (&lt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">types</span>&gt;)]<br></code></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Solidity 中，相比于值类型，引用类型更复杂，通常包括占用更多内存的数组和结构体。当处理这些复杂的引用类型时，需要谨慎考虑它们的数据位置。</p><p>所有引用类型（如数组和结构体）都具有一个 “数据位置” 属性，指明数据是存储在内存中还是存储中。大多数情况下，数据位置有默认值，但可以通过在类型名后加 <code>storage</code> 或 <code>memory</code> 来显式指定。</p><ul><li><strong>memory</strong>：用于临时存储，数据在执行完后会被销毁。</li><li><strong>storage</strong>：用于持久保存，数据会永久保存，直到被修改或删除。</li><li><strong>calldata</strong>：只读，常用于存储外部函数的参数。</li></ul><h6 id="默认数据位置："><a href="#默认数据位置：" class="headerlink" title="默认数据位置："></a>默认数据位置：</h6><ul><li>函数参数（包括返回参数）的默认位置是 <strong>内存 (memory)</strong>。</li><li>局部变量的默认位置是 <strong>存储 (storage)</strong>。</li><li>状态变量的数据位置强制为 <strong>存储 (storage)</strong>。</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity ^0.8.0;<br>contract C &#123;<br>    // 我们选择使用string类型，这里使用storage。<br>    // 需要注意的是，在该位置时默认数据为storage，这个可以忽略<br>    // 这是因为状态变量不需要指定数据位置，默认为storage<br>    string public x;<br>    // memoryArray 的数据存储位置是 memory<br>    // 我们也可以给他的数据存储位置为 calldata<br>    function f(string memory memoryString) public&#123;<br>      // memoryString = &quot;hello&quot;<br>       x = memoryString;<br>    &#125;<br>    // calldata<br>    // memory<br>    function g(string calldata ) external &#123;<br>    &#125;<br>    // storage<br>    function h(string storage ) internal  &#123;    <br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="数据位置的重要性"><a href="#数据位置的重要性" class="headerlink" title="数据位置的重要性"></a>数据位置的重要性</h6><p>数据位置影响赋值行为：</p><ul><li>在 <strong>存储 (storage)</strong> 和 <strong>内存 (memory)</strong> 之间赋值会创建新的拷贝。</li><li><strong>存储 (storage)</strong>进行 赋值时，只会传递引用，不会创建新副本。</li><li><strong>内存 (memory)</strong> 之间的赋值通常不会创建新副本，因为它们共享相同的数据。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>强制指定的数据位置</strong>：<ul><li>外部函数,也就是<code>external</code>，形参的数据位置可以为 <code>calldata</code>，也可以为<code>memory</code>，但是绝对不是<code>storage</code>，<code>public</code>同理。</li><li>状态变量为 <code>storage</code>，也可以指定函数形参的数据位置为<code>storage</code>，不过基本上只能在内部函数<code>internal</code>执行。</li></ul></li><li><strong>默认数据位置</strong>：<ul><li>函数参数（包括返回参数）为 <code>memory</code>，也可以为<code>calldata</code>。</li><li>其他局部变量为 <code>storage</code>。</li></ul></li></ul><hr><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>Solidity 支持两种类型的数组：固定长度数组和动态数组。</p><p>一个元素类型为 <code>T</code>，固定长度为 <code>k</code> 的数组可以声明为 <code>T[k]</code>， 而动态数组声明为 <code>T[]</code>。</p><p><strong>固定长度数组</strong>:<code>uint[5]</code>,<code>uint[2][5]</code> …</p><p><strong>动态数组</strong>:<code>uint[]</code>,<code>uint[][5]</code> …</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[5] a = [1,2,3,4,5]; // 5 element array<br>uint[5] b;<br>uint[] c;<br>uint[] d = [1,2,3,4,5];<br></code></pre></td></tr></table></figure><p><strong>索引</strong>: 对元素中的一个数据进行定位，数组索引从0开始，访问一个数组中的其中一个元素，访问时的下标顺序与声明时相反。访问一个超过它的末端的数组会导致一个失败的断言。 </p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnOne() public view returns (uint)&#123;<br>    return d[0];//返回第一个元素<br>&#125;    <br>function returntwo() public view returns (uint)&#123;<br>    return d[1];//返回第二个元素<br>&#125;    <br></code></pre></td></tr></table></figure><p><strong>数组成员</strong>:</p><ul><li><p><strong>length</strong>:</p><p>数组有 <code>length</code> 成员变量表示当前数组的长度。一经创建， 内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时数组的参数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnLength() public view returns (uint)&#123;<br>    return d.length;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push()</code> 的成员函数， 您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用， 因此可以像 <code>x.push().t = 2</code> 或 <code>x.push() = b</code> 那样使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>     c.push();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push(x)</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push(x)</code> 的成员函数， 您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>d.push(x);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>pop()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>pop()</code> 的成员函数， 您可以用它来从数组的末端移除一个元素。 这也隐含地在被删除的元素上调用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete">delete</a>。该函数不返回任何东西。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function del() public&#123;<br>    d.pop(); //删除末尾<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建内存数组</strong>:具有动态长度的内存数组可以使用 <code>new</code> 操作符创建。 与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code>.push</code> 成员函数不可用）。 您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p><p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a> 进行初始化。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function createMemoryArray(uint len) public view returns (uint[] memory)&#123;<br>       uint[] memory arr = new uint[](len); //创建长度为len的内存数组<br>       arr[0] = 1;<br>       arr[1] = 2;<br>       return arr;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>数组切片</strong>: <code>x[start:end]</code></p><p>数组切片是对一个数组的连续部分的预览。 它们被写成 <code>x[start:end]</code>，其中 <code>start</code> 和 <code>end</code> 是表达式， 结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code>x[start]</code>， 最后一个元素是 <code>x[end - 1]</code>。</p><p>如果 <code>start</code> 大于 <code>end</code>，或者 <code>end</code> 大于数组的长度， 就会出现异常。</p><p><code>start</code> 和 <code>end</code> 都是可选的： <code>start</code> 默认为 <code>0</code>， <code>end</code> 默认为数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function get(uint[] calldata arr) public view returns (uint[] calldata)&#123;<br>      return arr[:6];<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>数组元素</strong>：数组元素可以是任何类型，包括映射或结构体。 并适用于类型的一般限制，映射只能存储在 <code>storage</code> 数据位置,下面是一些特殊的数组。</p><p><strong>bytes</strong></p><p><code>bytes</code> 类似于 <code>bytes1[]</code>， 但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。</p><p>您应该使用 <code>bytes</code> 而不是 <code>bytes1[]</code>，因为它更便宜， 因为在 <code>memory</code> 中使用 <code>bytes1[]</code> 会在元素之间增加31个填充字节。  一般来说，对于任意长度的原始字节数据使用 <code>bytes</code>，对于任意长度的字符串（UTF-8）数据使用 <code>string</code>。 如果您能将长度限制在一定的字节数，使用 <code>bytes1</code> 到 <code>bytes32</code> 中的一种值类型，因为它们更便宜。</p><p>函数:  <code>bytes.concat</code></p><p><code>bytes.concat</code> 函数可以连接任意数量的 <code>bytes</code> 或 <code>bytes1 ... bytes32</code> 值。 该函数返回一个单一的 <code>bytes memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用字符串参数或其他不能隐式转换为 <code>bytes</code> 的类型， 您需要先将它们转换为 <code>bytes</code> 或 <code>bytes1</code> /…/ <code>bytes32</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>string</strong></p><p><code>string</code> 与 <code>bytes</code> 相同，但不允许用长度或索引来访问。</p><p>Solidity没有字符串操作函数，但有第三方的字符串库。 可以用 <code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code> 来比较两个字符串的keccak256-hash，用 <code>string.concat(s1, s2)</code> 来连接两个字符串。</p><p>函数: <code>string.concat</code></p><p>可以使用 <code>string.concat</code> 连接任意数量的 <code>string</code> 值。 该函数返回一个单一的 <code>string memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用不能隐式转换为 <code>string</code> 的其他类型的参数，您需要先将它们转换为 <code>string</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>Solidity 支持通过结构体定义新类型。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract Struct&#123;<br>    struct user&#123;<br>        string name;<br>        uint age;<br>        string email;<br>    &#125;<br>    // function add(string memory name, uint age, string memory email)<br>    // public view returns (user memory)&#123;<br>    //     user memory newUser = user(name, age, email);<br>    //     return newUser;<br>    // &#125;<br>    user user1;<br>    function add(string memory name, uint age, string memory email)<br>    external&#123;<br>        user storage newUser = user1;<br>        newUser.name =&quot;hello&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="结构体的赋值和访问"><a href="#结构体的赋值和访问" class="headerlink" title="结构体的赋值和访问"></a>结构体的赋值和访问</h6><ul><li><strong>存储结构体</strong>：当结构体赋值给局部变量时，并不会复制数据，而是传递引用。</li><li><strong>成员访问</strong>：可以直接访问结构体的成员，例如 <code>campaigns[campaignID].amount = 0;</code>。</li></ul><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><h5 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h5><p><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择Solidity内置的值类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。下面这个例子会报错，因为<code>_KeyType</code>使用了我们自定义的结构体：</p><p><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</p><p><strong>规则3</strong>：如果映射声明为<code>public</code>，那么Solidity会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</p><p><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</p><h5 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h5><p><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</p><p><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。<a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage</a>)</p><p><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</p><h5 id="在Remix上验证-以-Mapping-sol为例"><a href="#在Remix上验证-以-Mapping-sol为例" class="headerlink" title="在Remix上验证 (以 Mapping.sol为例)"></a>在Remix上验证 (以 <code>Mapping.sol</code>为例)</h5><p>映射示例 1 部署</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/69dd365d690ea6ed3c8368f45a16d25a.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632090332-1f40dddf-c031-4692-8317-b15bc0d2d49e.jpeg" alt="img"></p><p>映射示例 3 key-value pair</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632088903-2bf9034a-c080-4d04-a18e-5cef2ce4ae1d.jpeg" alt="img"></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>在Solidity智能合约中，以下是一些常见运算符的简要说明和示例：</p><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a><strong>三元运算符</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">条件表达式</span>&gt;</span> ? <span class="hljs-tag">&lt;<span class="hljs-name">true条件表达式</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">false条件表达式</span>&gt;</span><br></code></pre></td></tr></table></figure><p>允许根据条件表达式选择执行两个表达式之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint public a = 10;<br>uint b = 20;<br>uint public x;<br>uint public max = a &gt; b ? a : b;<br>uint public min = a &lt; b ? a : b;<br></code></pre></td></tr></table></figure><h5 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a><strong>复合赋值运算符</strong></h5><p> <code>-=</code>，<code>+=</code>, <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>|=</code>， <code>&amp;=</code>， <code>^=</code>， <code>&lt;&lt;=</code> 和 <code>&gt;&gt;=</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function jian(uint y) public &#123;<br>        // a = a - y;<br>        a -= y;<br>    &#125;<br>    function add(uint y) public &#123;<br>        // a = a + y;<br>        a += y;<br>    &#125;<br>    function divide(uint y) public &#123;<br>        // a = a / y;<br>        a /= y;<br>    &#125;<br>    function multiply(uint y) public &#123;<br>        // a = a * y;<br>        a *= y;<br>    &#125;<br>    function test(uint y) public &#123;<br>        // a %= y;  // a = 10 % 2 = 0  <br>        // a |= y;  // a = a | y ;  10 | 2  1 0 1 0 | 0 0 1 0  = 1 0 1 0<br>        // a &amp;= y; // a = a &amp; y;  10 &amp; 2  1 0 1 0 | 0 0 1 0  = 0 0 1 0<br>        // a ^= y;  // a = a ^ y  10 ^ 2  1 0 1 0 | 0 0 1 0 = 1 0 0 0<br>        // a &lt;&lt;= y;  // a = a &lt;&lt; y  10 &lt;&lt; 2  0 0 0 0 1 0 1 0  &lt;&lt; 2 =  0 0 1 0 1 0 0 0 40<br>        a &gt;&gt;= y;  // a = a &gt;&gt; y  10 &gt;&gt; 2  0 0 0 0 1 0 1 0 &gt;&gt; 2   = 0 0 0 0 0 0 1 0 <br>    &#125;<br></code></pre></td></tr></table></figure><p>用于简洁地对变量进行更新。</p><h5 id="增量-减量运算符："><a href="#增量-减量运算符：" class="headerlink" title="增量/减量运算符："></a><strong>增量/减量运算符</strong>：</h5><p> a++<code>和</code>a—  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add1() public &#123;<br>       a++<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function divide1() public &#123;<br>   x = a--;<br>  &#125;<br></code></pre></td></tr></table></figure><p>—a<code>和</code>++a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add1() public &#123;<br>        x = ++a; <br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function divide1() public &#123;<br>     x = --a;<br> &#125;<br></code></pre></td></tr></table></figure><p>用于快速增加或减少变量的值。</p><h5 id="删除运算符"><a href="#删除运算符" class="headerlink" title="删除运算符"></a>删除运算符</h5><p>在Solidity中是存在 <code>delete</code> 运算符的。使用 <code>delete</code> 可以将变量设置为其类型的默认值。对于简单类型，如 <code>uint</code> 或 <code>int</code>，默认值是 <code>0</code>；对于数组，<code>delete</code> 会使数组的所有元素被置为默认值；对于结构体，它将重置结构体中的所有成员变量为它们的默认值。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract test2&#123;<br>    uint public x = 2;<br>    uint[]  array = [1,2,3,4];<br>    struct S &#123; uint a; uint b;&#125;<br>    S public s;<br>    function test() public returns(S memory)&#123;<br>        delete x;<br>        delete array[1];<br>        s.a = 5;<br>        s.b = 2;<br>        delete s;<br>        // delete s[0];<br>        return s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>delete</code> 对于动态数组只会将特定索引处的元素重置为默认值，并不会改变数组的长度。而对于静态数组，<code>delete</code> 将会重置整个数组为默认值。对于映射（mapping），<code>delete</code> 会使特定的键对应的值被移除。对于复杂类型的数组或映射，<code>delete</code> 不会递归删除内部元素，只会将它们设置为默认值。</p><h5 id="运算符优先顺序："><a href="#运算符优先顺序：" class="headerlink" title="运算符优先顺序："></a><strong>运算符优先顺序</strong>：</h5><div class="table-container"><table><thead><tr><th>优先级</th><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td><em>1</em></td><td>后置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>创建类型实例</td><td><code>new &lt;类型名&gt;</code></td></tr><tr><td></td><td>数组元素</td><td><code>&lt;数组&gt;[&lt;索引&gt;]</code></td></tr><tr><td></td><td>访问成员</td><td><code>&lt;对象&gt;.&lt;成员名&gt;</code></td></tr><tr><td></td><td>函数调用</td><td><code>&lt;函数&gt;(&lt;参数...&gt;)</code></td></tr><tr><td></td><td>小括号</td><td><code>(&lt;表达式&gt;)</code></td></tr><tr><td><em>2</em></td><td>前置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>一元运算减</td><td><code>-</code></td></tr><tr><td></td><td>一元操作符</td><td><code>delete</code></td></tr><tr><td></td><td>逻辑非</td><td><code>!</code></td></tr><tr><td></td><td>按位非</td><td><code>~</code></td></tr><tr><td><em>3</em></td><td>乘方</td><td><code>**</code></td></tr><tr><td><em>4</em></td><td>乘、除和模运算</td><td><code>*</code>， <code>/</code>， <code>%</code></td></tr><tr><td><em>5</em></td><td>算术加和减</td><td><code>+</code>， <code>-</code></td></tr><tr><td><em>6</em></td><td>移位操作符</td><td><code>&lt;&lt;</code>， <code>&gt;&gt;</code></td></tr><tr><td><em>7</em></td><td>按位与</td><td><code>&amp;</code></td></tr><tr><td><em>8</em></td><td>按位异或</td><td><code>^</code></td></tr><tr><td><em>9</em></td><td>按位或</td><td>`</td><td>`</td></tr><tr><td><em>10</em></td><td>非等操作符</td><td><code>&lt;</code>， <code>&gt;</code>， <code>&lt;=</code>， <code>&gt;=</code></td></tr><tr><td><em>11</em></td><td>等于操作符</td><td><code>==</code>， <code>!=</code></td></tr><tr><td><em>12</em></td><td>逻辑与</td><td><code>&amp;&amp;</code></td></tr><tr><td><em>13</em></td><td>逻辑或</td><td><code>==</code></td></tr><tr><td><em>14</em></td><td>三元操作符</td><td><code>&lt;判断条件&gt; ? &lt;如果为真时执行的表达式&gt; : &lt;如果为假时执行的表达式&gt;</code></td></tr><tr><td></td><td>赋值操作符</td><td><code>=</code>， `</td><td>=<code>，</code>^=<code>，</code>&amp;=<code>，</code>&lt;&lt;=<code>，</code>&gt;&gt;=<code>，</code>+=<code>，</code>-=<code>，</code>*=<code>，</code>/=<code>，</code>%=`</td></tr><tr><td><em>15</em></td><td>逗号</td><td><code>,</code></td></tr></tbody></table></div><p>运算符按照特定的优先级进行求值，例如：</p><ul><li><code>*</code>、<code>/</code>、<code>%</code>（乘、除、取余）具有高于<code>+</code>、<code>-</code>（加、减）的优先级。</li><li><code>&amp;&amp;</code>（逻辑与）的优先级高于<code>||</code>（逻辑或）。</li><li>使用括号<code>()</code>可以改变默认的优先级。<br>下面是一个运算符优先级的例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract test3&#123;<br>//     *、/、%（乘、除、取余）具有高于+、-（加、减）的优先级。<br>// &amp;&amp;（逻辑与）的优先级高于||（逻辑或）。<br>// 使用括号()可以改变默认的优先级。<br>    uint a = 2; uint b =3; uint c=4;<br>    // uint public result = a + b * c;<br>    // bool public result = true &amp;&amp; false || false;<br>    uint public result = (a + b) * c;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h4><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时， 编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义， 并且不会丢失信息，那么值-类型之间的隐式转换是可能的。</p><p>uint8 =&gt; uint16, int128=&gt;int256, int8 !=&gt; uint256【!=-1】</p><h5 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h5><p>如果编译器不允许隐式转换，但您确信转换会成功， 有时可以进行显式类型转换。 这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性， 所以一定要测试结果是否是您想要的和期望的!</p><p>int y=&gt; uint(y)</p><h4 id="字面常数和基本类型之间的转换"><a href="#字面常数和基本类型之间的转换" class="headerlink" title="字面常数和基本类型之间的转换"></a>字面常数和基本类型之间的转换</h4><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><p>十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断。</p><h5 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组</h5><p>十进制数字字面常数不能被隐含地转换为固定大小的字节数组。 十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。 但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型</p><h5 id="地址类型-1"><a href="#地址类型-1" class="headerlink" title="地址类型"></a>地址类型</h5><p>正如在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals">地址字面量（Address Literals）</a> 中所描述的那样，正确大小并通过校验测试的十六进制字是 <code>address</code> 类型。 其他字面常数不能隐含地转换为 <code>address</code> 类型。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h5><ul><li><strong>隐式转换</strong>：只有在“范围扩大 + 不丢失信息”时才允许。</li><li><strong>显式转换</strong>：允许开发者强制转换，但可能导致意外结果 → 必须验证。</li><li><p><strong>字面量转换规则</strong>：</p></li><li><ul><li>整数字面量可隐式转换（不超范围）。</li><li>十六进制字面量可用于定长字节数组（需精确字节数）。</li><li>地址必须是符合格式的十六进制字面量。</li></ul></li></ul><p>参考资料 : </p><p> <a href="https://docs.soliditylang.org/zh-cn/latest/index.html">Solidity — Solidity 0.8.24 文档</a></p><p><a href="https://www.wtf.academy/zh/course/solidity101">WTF Solidity课程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Solidity基础语法&quot;&gt;&lt;a href=&quot;#Solidity基础语法&quot; class=&quot;headerlink&quot; title=&quot;Solidity基础语法&quot;&gt;&lt;/a&gt;Solidity基础语法&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(三) 常量、变量和数据类型</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%89-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%89-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-11-26T13:04:56.000Z</published>
    <updated>2025-11-26T19:41:40.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是内存中用于保存固定值的单元，在程序中常量的值不能发生改变。</p><p>在Go语言 中定义常量的方法如下：</p><script type="math/tex; mode=display">const 常量标识符 [数据类型] = 常量值</script><p>例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> CAPITAL <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Guangdong&quot;</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是内存中命名的存储位置，与常量不同的是变量的值可以动态变化。与常量一 样，变量也有一个名字。</p><p>在Go语言中定义变量的方法如下：</p><script type="math/tex; mode=display">var 变量标识符 [数据类型]</script><p>例如，下面的代码定义了一个字符串变量str。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a><strong>布尔型</strong></h3></li></ol><p>Go语言的布尔型为bool，布尔型常量包括true和false。</p><p>例如，下面的代码定义了 一个布尔型变量existed。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> existed <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><ol><li><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><strong>数字类型</strong></h3><p>Go语言的数字类型包括整型和浮点型。Go语言支持的整型数据类型如下图所示。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126212023344.png" alt="image-20251126212023344"></p><p>Go语言支持的浮点型数据类型如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126212147032.png" alt="image-20251126212147032"></p><ol><li><h3 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a><strong>派生类型</strong></h3><p>Go语言的派生类型包括指针、结构体、枚举、数组、切片、集合、接口、通道、函数等。大多数派生类型都比较复杂，本小节只介绍其中比较简单的结构体类型和枚举类型。</p><p>（1）结构体类型</p><p>结构体是一种自定义的数据类型，即可以由一组不同的数据类型组合成一个新的数据类型。可以使用struct关键字来定义结构体类型，具体方法如下： </p><p>type结构体类型struct { </p><p>​    成员定义 </p><p>​    成员定义 </p><p>​    …… </p><p>​    成员定义</p><p> }</p><p>例如，下面的代码定义了一个Book结构体，其中包含Name（名称）、Author（作者）、Pagecount（页数）和Price（价格）等成员。 </p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Book</span> struct &#123;<br>    <span class="hljs-type">Name</span> string; <br>    <span class="hljs-type">Author</span> string;<br>    <span class="hljs-type">Pagecount</span> uint;<br>    <span class="hljs-type">Price</span> uint; <br>&#125;<br></code></pre></td></tr></table></figure><p>定义结构体类型后，可以使用如下方法声明结构体变量。 </p><p>变量：= 结构体类型 {字段值1， 字段值2,…，字段值n} </p><p>上面的代码在初始化结构体变量时按照其字段定义的顺序指定字段值，也可以按照 键值对的形式初始化结构体变量，方法如下： </p><p>变量：= 结构体类型 {字段名1：字段值1， 字段名2：字段值2,…，字段名n：字段值n}</p><p>初始化一个结构体时要指定每个成员的值。</p><p>例如，初始化一个Book变量b的方法如 下： </p><p>Book b = Book{“ 活着”, “余华”, 350, 90}</p><p>可以使用b.Name来访问结构体的成员Name。</p><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251127032517471.png" alt="image-20251127032517471"></p></li></ol><p>（2）枚举类型 </p><p>枚举类型是一种有有限可选值的数据类型，每个可选值都对应一个int值。</p><p>在Go语 言中，可以使用const关键字来定义一个枚举类型，方法如下：</p><p> type &lt;枚举类型名&gt; int const ( </p><p>&lt;可选值1&gt; &lt;枚举类型名&gt; = iota//值为0 </p><p>&lt;可选值2&gt; //值为1 </p><p>&lt;可选值3&gt; //值为2 </p><p>&lt;可选值4&gt; //值为3 </p><p>) </p><p>&lt;可选值1&gt;由iota初始化后，后面的可选值会自动递增。&lt;可选值1&gt;对应整型数0,&lt; 可选值2&gt;对应整型数1,&lt;可选值3&gt;对应整型数2，以此类推。</p><p>可以使用下面的方法引用枚举类型的可选值。 </p><p>&lt;枚举类型名&gt;.&lt;可选值n&gt;</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h2&gt;&lt;p&gt;常量是内存中用于保存固定值的单元，在程序中常量的值不能发生改变。&lt;/p&gt;
&lt;p&gt;在Go语言 中定义常量的方法如下：&lt;/p&gt;
&lt;script </summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(二) 第一个go应用</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E5%BA%94%E7%94%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E5%BA%94%E7%94%A8/</id>
    <published>2025-11-26T08:58:05.000Z</published>
    <updated>2025-11-26T19:29:24.926Z</updated>
    
    <content type="html"><![CDATA[<p>代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><br>&#123; <br><br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br><br> &#125;<br></code></pre></td></tr></table></figure><p>具体说明如下。 </p><p>·程序使用package关键字定义了一个名为main的包。这说明当前程序是一个可执 行程序。 </p><p>·程序使用import语句导入包fmt。fmt是Go语言的内置包，其中包含格式化I/O （Input/ Output，输入/输出）函数。 </p><p>·func关键字用于定义函数。本例中定义了一个main()函数，这是项目的主函数， 也是执行程序的入口。</p><p> ·调用fmt包中的Println()函数，在终端输出字符串“Hello World!”。</p><p> 这是一个非常简单的Go语言程序，但是其中包含Go语言程序的必要元素，例如包、 函数和字符串等。本章后面会详细介绍这些概念。</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码如下： &lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(一) 下载及安装</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85/</id>
    <published>2025-11-25T18:32:35.000Z</published>
    <updated>2025-11-26T19:29:14.925Z</updated>
    
    <content type="html"><![CDATA[<p>b本内容部分参考了书籍Go语言Hyperledger区块链开发实战<em>(李晓黎)</em></p><p>Go语言支持Windows、Linux、FreeBSD和macOS等多种操作系统。</p><p>下载官网</p><p><a href="https://golang.google.cn/">The Go Programming Language</a></p><p>这里只详细说一下windows怎么做，在windows中，下载完成之后的go默认的安装目录为C:\Program Files\Go【可以自行设置】，用户需要把C:\Program Files\Go\bin目录添加到环境变量PATH中【初次安装不需要，但也可能因人而异】，以便可以在任何目录下执行go命令。执行go version命令可以查看Go语言的版本信息，go env命令可以查看与Go语言相关的环境变量。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126023701181.png" alt="image-20251126023701181"></p><p>常用的与Go语言相关的环境变量如下。 </p><p>·GOROOT：存储Go语言的安装目录，默认为C:\Program Files\Go。 </p><p>·GOPATH：存储Go语言的项目目录，默认为C:\Users\Administrator\go。</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;b本内容部分参考了书籍Go语言Hyperledger区块链开发实战&lt;em&gt;(李晓黎)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Go语言支持Windows、Linux、FreeBSD和macOS等多种操作系统。&lt;/p&gt;
&lt;p&gt;下载官网&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gola</summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>Solidity智能合约零基础入门（一）区块链与智能合约概念</title>
    <link href="https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%A6%82%E5%BF%B5/</id>
    <published>2025-10-19T14:17:53.000Z</published>
    <updated>2025-12-11T09:14:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启程-区块链与智能合约概念"><a href="#启程-区块链与智能合约概念" class="headerlink" title="启程 - 区块链与智能合约概念"></a>启程 - 区块链与智能合约概念</h2><h3 id="比特币-vs-以太坊：为什么需要智能合约？"><a href="#比特币-vs-以太坊：为什么需要智能合约？" class="headerlink" title="比特币 vs 以太坊：为什么需要智能合约？"></a>比特币 vs 以太坊：为什么需要智能合约？</h3><p>比特币作为区块链技术的第一个成功应用，开创了去中心化数字货币的先河。它的核心功能是提供一种安全、透明且不可篡改的价值转移方式。然而，比特币的设计初衷是专注于支付和存储价值，其脚本语言（Script）虽然具有一定的可编程性，但功能较为有限，无法支持复杂的逻辑操作。<br>相比之下，以太坊在设计上引入了一个革命性的概念——<strong>智能合约</strong>。智能合约是一种运行在区块链上的程序代码，能够根据预设条件自动执行特定的操作。它使得以太坊不仅是一个去中心化的支付系统，更是一个通用的计算平台。通过智能合约，开发者可以构建各种去中心化应用（DApps），例如去中心化金融（DeFi）、非同质化代币（NFT）、去中心化自治组织（DAO）等。这种灵活性使以太坊成为区块链生态系统的核心支柱之一。<br>那么，为什么需要智能合约？智能合约的核心优势在于<strong>自动化执行</strong>和<strong>信任最小化</strong>。传统合约需要依赖第三方（如律师或仲裁机构）来确保执行，而智能合约通过代码直接定义规则并自动执行，无需中介参与。这不仅降低了交易成本，还提高了效率，同时减少了人为干预带来的风险。此外，智能合约的透明性和不可篡改性进一步增强了信任，使其在金融、供应链管理、身份认证等领域展现出巨大的潜力。</p><h3 id="什么是Gas？什么是交易？"><a href="#什么是Gas？什么是交易？" class="headerlink" title="什么是Gas？什么是交易？"></a>什么是Gas？什么是交易？</h3><h4 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h4><p>在以太坊网络中，<strong>Gas</strong> 是衡量执行智能合约或进行交易所需计算资源的单位。简单来说，Gas 是用户为使用以太坊网络支付的“燃料费”。每笔交易或智能合约的执行都需要消耗一定数量的 Gas，而 Gas 的价格由市场供需决定，通常以以太币（ETH）计价。<br>Gas 的存在有几个重要意义：</p><ol><li><strong>防止滥用网络资源</strong>：通过收取 Gas 费用，以太坊可以防止恶意用户发起无限循环或占用大量计算资源的操作。</li><li><strong>激励矿工/验证者</strong>：Gas 费用作为奖励分配给矿工（在 PoW 机制下）或验证者（在 PoS 机制下），以保障网络的安全性和稳定性。</li><li><strong>动态调节网络负载</strong>：当网络拥堵时，用户可以通过提高 Gas 价格来优先处理自己的交易。</li></ol><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>在区块链语境中，<strong>交易</strong>是指任何改变区块链状态的操作。交易可以分为两类：</p><ol><li><strong>普通转账交易</strong>：指从一个账户向另一个账户转移加密货币（如 ETH）。</li><li><strong>智能合约交互交易</strong>：指调用智能合约中的函数，可能涉及复杂的数据处理或状态更新。<br>每笔交易都需要包含以下信息：</li></ol><ul><li>发送方地址</li><li>接收方地址（如果是普通转账）或智能合约地址（如果是合约交互）</li><li>转账金额（如果是普通转账）</li><li>Gas 限制（Gas Limit）：用户愿意为该交易支付的最大 Gas 数量</li><li>Gas 价格（Gas Price）：每单位 Gas 的价格<br>如果交易执行所需的 Gas 超过了用户设置的 Gas 限制，交易将失败，但已消耗的 Gas 不会退还。</li></ul><h3 id="开发环境搭建（FISCO-BCOS-Remix-IDE）"><a href="#开发环境搭建（FISCO-BCOS-Remix-IDE）" class="headerlink" title="开发环境搭建（FISCO-BCOS, Remix IDE）"></a>开发环境搭建（FISCO-BCOS, Remix IDE）</h3><p>为了在区块链上开发和部署智能合约，我们需要搭建合适的开发环境。以下是两种常用的工具：<strong>FISCO-BCOS</strong> 和 <strong>Remix IDE</strong>。</p><h4 id="FISCO-BCOS"><a href="#FISCO-BCOS" class="headerlink" title="FISCO-BCOS"></a>FISCO-BCOS</h4><p>FISCO-BCOS 是一个国产的区块链底层平台，专注于企业级应用场景。它支持联盟链模式，适合构建私有链或联盟链项目。以下是搭建 FISCO-BCOS 的基本步骤：</p><p><a href="https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html">https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html</a></p><h4 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h4><p>Remix 是一个基于浏览器的集成开发环境（IDE），专为以太坊智能合约开发设计。它的界面友好，功能强大，非常适合初学者和快速原型开发。以下是使用 Remix 的基本流程：</p><ol><li><strong>访问 Remix IDE</strong>：</li></ol><ul><li><ul><li>打开浏览器，访问 <a href="https://remix.ethereum.org/">Remix 官网</a>。</li></ul></li></ul><ol><li><strong>编写智能合约</strong>：</li></ol><ul><li><ul><li>在 Remix 的“File Explorer”区域新建一个 <code>.sol</code> 文件，例如 <code>MyContract.sol</code>。</li><li>编写 Solidity 代码，例如：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract MyContract &#123;<br>    uint public value;<br>    function setValue(uint _value) public &#123;<br>        value = _value;<br>    &#125;<br>    function getValue() public view returns (uint) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>编译合约</strong>：</li></ol><ul><li><ul><li>切换到“Solidity Compiler”标签页，选择适当的编译器版本并点击“Compile”。</li></ul></li></ul><ol><li><strong>部署合约</strong>：</li></ol><ul><li><ul><li>切换到“Deploy &amp; Run Transactions”标签页，选择 JavaScript VM（虚拟机）或其他环境（如 MetaMask）。</li><li>点击“Deploy”按钮将合约部署到测试网络。</li></ul></li></ul><ol><li><strong>测试合约</strong>：</li></ol><ul><li><ul><li>在“Deployed Contracts”区域，调用合约的函数（如 <code>setValue</code> 和 <code>getValue</code>）进行交互。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;启程-区块链与智能合约概念&quot;&gt;&lt;a href=&quot;#启程-区块链与智能合约概念&quot; class=&quot;headerlink&quot; title=&quot;启程 - 区块链与智能合约概念&quot;&gt;&lt;/a&gt;启程 - 区块链与智能合约概念&lt;/h2&gt;&lt;h3 id=&quot;比特币-vs-以太坊：为什么需要智</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第九周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/</id>
    <published>2025-09-13T08:16:54.000Z</published>
    <updated>2025-12-11T09:11:10.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作内容与成果"><a href="#一、工作内容与成果" class="headerlink" title="一、工作内容与成果"></a>一、工作内容与成果</h2><p>本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：</p><p>（一）周一：后台界面优化工作</p><ol><li><p><strong>本地存储数据安全优化</strong>：针对后台界面，移除了通过 storage 本地存储模拟操作数据的方式。此优化有效避免了操作数据在本地透明可见的问题，提升了数据传输与存储的安全性，降低了数据被篡改或泄露的风险。</p></li><li><p><strong>核心业务逻辑调整</strong>：重点调整了后台作物管理与日志操作的核心逻辑。优化后，系统能够精准匹配对应地块的种子信息，确保作物数据与地块信息的关联性；同时，日志信息也能与具体操作场景、地块及作物数据准确对应，提升了后台数据管理的准确性与可读性，为后续数据查询与分析奠定基础。</p></li></ol><p>（二）周二：作物日志功能扩展</p><ol><li><p><strong>操作频次管控实现</strong>：为规范作物日志记录，新增作物日志每日操作限制规则，设定每种操作每日最多记录两次。该规则有效避免了日志数据冗余，保证了日志信息的简洁性与有效性，同时也符合农场日常运营中对作物操作的合理频次需求。</p></li><li><p><strong>日志生命周期管理</strong>：完善作物日志的生命周期逻辑，实现 “收获后自动删除日志，后续重新操作时添加新日志” 的功能。此举确保了日志信息与作物生长周期的同步性，避免了过期日志对数据管理的干扰，提升了日志数据的时效性。</p></li><li><p><strong>弱网环境数据保障</strong>：采用幂等性设计实现作物日志记录功能，在弱网、网络不流畅等不稳定环境下，能够有效防止重复添加日志数据，同时确保操作数据的完整性与准确性，提升了系统在复杂网络环境下的稳定性与可靠性。</p></li></ol><p>（三）周三：农场后台管理系统上线</p><ol><li><p><strong>管家日志管理功能</strong>：上线的农场后台管理系统中，新增管家后台日志记录功能，管家可通过系统的 “作物管理” 模块与 “每周日志” 模块，实时记录、查看与管理作物相关的操作日志，便于管家全面掌握作物生长过程中的关键操作，提升管理效率。</p></li><li><p><strong>种子图鉴管理功能</strong>：系统支持管家通过 “种子管理” 模块，上传、编辑与管理种子图鉴信息，包括种子品种、生长周期、适宜环境等关键数据。该功能为管家提供了统一的种子信息管理平台，便于规范种子信息管理，同时也为后续作物种植规划提供数据支持。</p></li><li><p><strong>订单查询管理功能</strong>：上线 “订单管理” 模块，管家可通过该模块快速查询所有订单信息，包括订单编号、订单类型、下单时间、订单状态等详细内容，支持按不同条件筛选查询，提升了订单信息的查询效率，便于管家及时跟进订单进度，保障农场运营的顺畅性。</p></li></ol><h3 id="二、核心工作成果"><a href="#二、核心工作成果" class="headerlink" title="二、核心工作成果"></a>二、核心工作成果</h3><p>本周聚焦农场相关系统完成三项关键工作：一是优化后台界面，移除 storage 本地存储模拟数据以强化安全，同时调整作物与日志逻辑，实现地块 - 种子 - 日志信息精准匹配；二是扩展作物日志功能，新增每日操作频次限制、收获后日志自动清理机制，并通过幂等设计解决弱网环境下数据重复问题；三是成功上线农场后台管理系统，为管家提供日志管理、种子图鉴上传、订单查询三大核心模块，满足日常管理需求。</p><h3 id="三、关键价值与亮点"><a href="#三、关键价值与亮点" class="headerlink" title="三、关键价值与亮点"></a>三、关键价值与亮点</h3><p>从安全性、实用性、稳定性三方面实现突破：安全层面，通过本地存储优化降低数据泄露风险，为系统数据安全奠定基础；实用层面，日志生命周期管理与后台系统功能模块，直接贴合农场运营场景，帮助管家提升数据管理与工作效率；稳定性层面，幂等设计的应用，有效应对复杂网络环境，保障操作数据的完整性，减少系统异常问题。</p><h3 id="四、后续行动方向"><a href="#四、后续行动方向" class="headerlink" title="四、后续行动方向"></a>四、后续行动方向</h3><p>后续将围绕 “优化体验、强化安全、拓展功能” 推进工作：优先收集管家使用反馈，迭代优化系统操作流程与功能漏洞；进一步完善数据安全体系，新增定期备份与恢复机制；结合农场实际需求调研新功能（如作物生长监控），同时持续监控系统性能，通过优化数据库、压缩资源等方式，确保系统长期稳定高效运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工作内容与成果&quot;&gt;&lt;a href=&quot;#一、工作内容与成果&quot; class=&quot;headerlink&quot; title=&quot;一、工作内容与成果&quot;&gt;&lt;/a&gt;一、工作内容与成果&lt;/h2&gt;&lt;p&gt;本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第八周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/</id>
    <published>2025-09-07T12:22:49.000Z</published>
    <updated>2025-12-11T09:11:06.117Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。<br><strong>整体进展：</strong> ✅ <strong>核心闭环成功打通！</strong> 用户可完成<code>购买服务</code> -&gt; <code>播种</code> -&gt; <code>日常管理（浇水）</code> -&gt; <code>生成日志</code> -&gt; <code>收获</code> -&gt; <code>下单配送</code>的全流程。后台管理功能得到显著增强。</p><hr><h3 id="一、-每日开发详情"><a href="#一、-每日开发详情" class="headerlink" title="一、 每日开发详情"></a>一、 每日开发详情</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>后端服务开发</strong></td><td style="text-align:left">✅ <strong>下单服务</strong>：完成接收、处理、存储订单信息的后端逻辑。<br>✅ <strong>后台托管服务</strong>：实现分配管家处理任务及切换角色登录权限的功能。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>后台管理系统开发</strong></td><td style="text-align:left">✅ <strong>订单管理页面</strong>：<br>  - 设计订单列表，可根据 <code>order_type</code> 动态展示信息。<br>  - 实现按类型、状态等条件的筛选功能。<br>  - 开发订单详情页，关联显示主表(<code>t_order</code>)与子表信息。<br>✅ <strong>托管日志集成</strong>：在作物管理界面中，可查看关联的托管服务日志。<br>✅ <strong>管家绑定</strong>：前端通过 <code>store</code> 中的用户ID查询并绑定 <code>caretaker_user_id</code>，管理作物。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>前后端功能联调</strong></td><td style="text-align:left">✅ <strong>日志查看</strong>：点击作物即可显示相关管家的操作日志。<br>✅ <strong>订单管理</strong>：用户可查询并修改自己的订单信息。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>功能优化与扩展</strong></td><td style="text-align:left">✅ <strong>修复前端显示</strong>：优化购买服务页面，为播种功能做准备。<br>✅ <strong>服务扩展</strong>：扩展下单服务，支持收获后生成配送订单的流程。<br>✅ <strong>界面优化</strong>：对订单列表的“待收获”界面进行了视觉和体验优化。</td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>交互功能实现</strong></td><td style="text-align:left">✅ <strong>确认操作</strong>：实现前端确认操作（如浇水）的功能。<br>✅ <strong>日志记录</strong>：为浇水等操作生成两种日志：<br>  - <strong>用户操作日志</strong> (用户点击触发)<br>  - <strong>管家工作日志</strong> (管家后台记录)<br>✅ <strong>通知机制</strong>：管家可在后台管理系统中获取相关操作的通知和日志。</td></tr><tr><td style="text-align:left"><strong>周六</strong></td><td style="text-align:left"><strong>全链路测试与BUG修复</strong></td><td style="text-align:left">✅ <strong>核心闭环验证</strong>：成功测试并修复逻辑BUG，确保从购买到收获下单的全流程畅通。<br>✅ <strong>遗留问题定位</strong>：<br>  - <strong>问题一</strong>：手机端支付后可重复点击购买，需前端优化交互。<br>  - <strong>问题二</strong>：后台订单界面需集成第三方服务（如支付、物流），待确定方案。</td></tr></tbody></table></div><hr><h3 id="二、-核心业务流程与逻辑-本周重大进展"><a href="#二、-核心业务流程与逻辑-本周重大进展" class="headerlink" title="二、 核心业务流程与逻辑 (本周重大进展)"></a>二、 核心业务流程与逻辑 (本周重大进展)</h3><ol><li><p><strong>收获后处理逻辑（后端）</strong>：<br>当用户发起收获并成功创建配送单后，系统自动执行以下操作，确保数据状态准确：</p><ul><li><strong>清空地块</strong>：将对应地块的作物状态重置为 <code>empty</code>。</li><li><strong>扣减权益</strong>：<ul><li>对于<strong>次数型</strong>权益：将 <code>uses_left</code> (剩余次数) 减1。若次数用尽，则将权益状态置为 <code>consumed</code>。</li><li>对于<strong>时长型</strong>权益：不扣减次数，仅检查有效期。</li></ul></li><li><strong>更新权益状态</strong>：重新计算该地块的 <code>owned</code> 字段。只要仍有有效的<code>active</code>权益（次数未用完或未过期），<code>owned</code> 即为 <code>true</code>，否则为 <code>false</code>。</li></ul></li><li><p><strong>前端支付流程优化（已解决）</strong>：<br>修复了 <code>purchaseServicePackage</code> 函数中 <code>await</code> 与 <code>success</code> 回调混用导致的逻辑问题。</p><ul><li><strong>解决方案</strong>：重写该函数，采用纯 <code>async/await</code> 方式调用支付接口。支付成功后，<strong>立即调用后端接口刷新地块数据</strong>，并提交一个 <code>mutation</code> 来本地更新状态，确保UI显示及时、准确。</li></ul></li></ol><hr><h3 id="三、-待解决的问题与下周计划"><a href="#三、-待解决的问题与下周计划" class="headerlink" title="三、 待解决的问题与下周计划"></a>三、 待解决的问题与下周计划</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>问题描述</strong></th><th style="text-align:left"><strong>性质</strong></th><th style="text-align:left"><strong>可能解决方案/下一步计划</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. 移动端支付后可重复点击</strong></td><td style="text-align:left">前端交互BUG</td><td style="text-align:left">在支付请求发起后，禁用按钮并显示加载状态，直到收到明确的成功/失败回调。</td></tr><tr><td style="text-align:left"><strong>2. 后台需集成第三方服务</strong></td><td style="text-align:left">技术方案调研</td><td style="text-align:left">调研并选择可靠的第三方服务提供商（如支付宝/微信支付官方API、聚合支付平台、物流公司API），然后编写对接代码。</td></tr></tbody></table></div><p><strong>下周计划：</strong></p><ul><li><strong>解决遗留问题</strong>：优先修复移动端支付交互BUG，并启动第三方服务对接的调研与开发。</li><li><strong>功能增强</strong>：基于已打通的闭环，考虑添加更多作物管理操作（如施肥、除虫）、优化日志系统、设计更完善的管家通知中心。</li><li><strong>测试与部署</strong>：进行更全面的测试，准备将新功能部署至测试或生产环境。</li></ul><hr><h3 id="四、-本周工作回顾：核心业务闭环全面打通"><a href="#四、-本周工作回顾：核心业务闭环全面打通" class="headerlink" title="四、 本周工作回顾：核心业务闭环全面打通"></a><strong>四、 本周工作回顾：核心业务闭环全面打通</strong></h3><p>本周的核心工作是推动农场项目的<strong>完整业务流程实现</strong>与<strong>后台管理系统强化</strong>，并成功完成了端到端的测试验证。</p><ol><li><strong>后端服务建设</strong>：完成了<strong>下单服务</strong>与<strong>后台托管服务</strong>的开发，实现了订单的接收、处理、存储，以及管家的任务分配与权限管理。</li><li><strong>后台管理功能增强</strong>：开发了功能完善的订单管理页面（列表、筛选、详情）、托管服务日志记录模块，并实现了作物与管家的绑定管理。</li><li><strong>核心业务闭环验证</strong>：成功打通了“<strong>用户购买服务 -&gt; 播种 -&gt; 进行浇水等管理操作 -&gt; 自动生成日志 -&gt; 收获并创建配送单 -&gt; 地块状态重置</strong>”的完整业务流程，标志着项目最核心的功能链路已全部跑通。</li><li><strong>前端体验优化</strong>：修复了购买服务页面的显示问题，优化了订单界面，并重写了支付逻辑，确保了交互的准确性和数据的一致性。</li></ol><h3 id="五、-问题与反思：技术方案与细节处理需持续打磨"><a href="#五、-问题与反思：技术方案与细节处理需持续打磨" class="headerlink" title="五、 问题与反思：技术方案与细节处理需持续打磨"></a>五<strong>、 问题与反思：技术方案与细节处理需持续打磨</strong></h3><p>在开发过程中，也遇到并识别了一些亟待解决的问题，主要集中在交互细节和技术方案选型上。</p><ol><li><strong>移动端交互细节问题</strong>：手机端支付成功后，按钮状态未能及时重置，导致用户可重复点击，<strong>暴露了前端对连续请求控制的不足</strong>。这需要通过添加加载状态和按钮禁用机制来优化。</li><li><strong>外部集成技术方案待定</strong>：后台系统需要接入支付、物流等第三方服务，但目前<strong>尚未确定具体的技术选型和对接方案</strong>，这是下一步需要重点调研和决策的点。</li><li><strong>逻辑严谨性</strong>：在解决“收获后清空地块”等复杂业务逻辑时，意识到必须通过<strong>精准的后端逻辑</strong>（如扣减权益、状态更新）来保证数据一致性，而非依赖前端。</li></ol><h3 id="六、-下周计划：解决遗留问题，推进系统集成与优化"><a href="#六、-下周计划：解决遗留问题，推进系统集成与优化" class="headerlink" title="六、 下周计划：解决遗留问题，推进系统集成与优化"></a><strong>六、 下周计划：解决遗留问题，推进系统集成与优化</strong></h3><p>基于本周的进展和问题，下周的工作将围绕以下重点展开：</p><ol><li><strong>优先解决遗留问题</strong>：<ul><li>修复移动端支付交互BUG，增加防重复提交机制。</li><li>启动对第三方服务（如支付、物流API）的调研，并形成初步的集成方案。</li></ul></li><li><strong>功能增强与优化</strong>：<ul><li>在现有闭环基础上，规划并开发更多的作物管理操作（如施肥、除虫）。</li><li>优化日志系统和管家通知中心，提升用户体验和管理效率。</li></ul></li><li><strong>测试与部署准备</strong>：<ul><li>对已打通的全流程进行更全面的测试，准备将稳定版本部署至测试环境。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ &lt;strong&gt;核心闭环成功打通！&lt;/strong&gt; 用户可完成&lt;code&gt;购买服务&lt;/code&gt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第七周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/</id>
    <published>2025-08-30T11:18:00.000Z</published>
    <updated>2025-12-11T09:11:35.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="周一：农场服务前端界面实现"><a href="#周一：农场服务前端界面实现" class="headerlink" title="周一：农场服务前端界面实现"></a><strong>周一：农场服务前端界面实现</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现托管服务操作流程：点击托管→选择种植物→确认收获→判断收获方式。  </li><li>搭建基础农场前端界面，完成用户交互逻辑。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>收获方式判断逻辑需与后端土地状态同步（未实时更新）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>添加前端定时查询地块状态，确保数据一致性。  </li></ul><hr><h3 id="周二：订单生成与支付界面优化"><a href="#周二：订单生成与支付界面优化" class="headerlink" title="周二：订单生成与支付界面优化"></a><strong>周二：订单生成与支付界面优化</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>对接托管服务订单接口（<code>/orders/service</code>），生成订单并关联用户与地块数据。  </li><li>优化支付界面样式，使其更简洁清晰，支持后续扩展托管服务类型。  </li><li>实现土地及托管服务数据存储，支持详细查询。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>支付界面在不同设备上显示错位（移动端适配问题）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>使用响应式布局（CSS Flexbox+Media Query）快速修复。  </li></ul><hr><h3 id="周三：扩展购买与播种功能"><a href="#周三：扩展购买与播种功能" class="headerlink" title="周三：扩展购买与播种功能"></a><strong>周三：扩展购买与播种功能</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>扩展托管服务购买功能（接口：<code>/farm/service/package/purchase</code>）。  </li><li>实现种子播种功能（接口：<code>/farm/plant</code>）并关联地块数据（接口：<code>/farm/plots</code>）。  </li><li>订单查询与支付状态联动（支付成功自动更新订单状态）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>播种请求超时（地块数据量增大导致查询缓慢）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>为<code>/farm/plots</code>接口添加缓存机制（Redis缓存地块信息）。  </li></ul><hr><h3 id="周四：后台管理系统开发"><a href="#周四：后台管理系统开发" class="headerlink" title="周四：后台管理系统开发"></a><strong>周四：后台管理系统开发</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现后台托管服务管理（增删改查）。  </li><li>开发作物管理模块（支持作物信息维护）。  </li><li>搭建每周日志记录功能（支持日志添加与查询）。  </li><li>完成种子管理基础功能（CRUD操作）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>管家管理模块需对接若依权限系统，但账户体系不兼容。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>暂独立开发管家管理模块，预留若依系统对接接口。  </li></ul><hr><h3 id="周五：后台功能完善与权限隔离"><a href="#周五：后台功能完善与权限隔离" class="headerlink" title="周五：后台功能完善与权限隔离"></a><strong>周五：后台功能完善与权限隔离</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>完成托管服务、作物管理、每周日志、种子管理的完整增删改查功能。  </li><li>优化后台数据查询效率（添加数据库索引）。  </li><li>管家管理模块独立运行（暂未关联若依登录）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>若依系统权限接口文档缺失，无法直接对接。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>优先保证其他后台功能上线，管家管理采用若依账号过渡。  </li></ul><hr><h3 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a><strong>本周总结</strong></h3><h4 id="1-独立完成内容"><a href="#1-独立完成内容" class="headerlink" title="1. 独立完成内容"></a><strong>1. 独立完成内容</strong></h4><ul><li>前端农场服务全流程（托管→支付→播种→收获）。  </li><li>订单与支付系统集成（微信支付+订单状态管理）。  </li><li>后台管理核心功能（作物、日志、种子、托管服务管理）。  </li></ul><h4 id="2-主要挑战"><a href="#2-主要挑战" class="headerlink" title="2. 主要挑战"></a><strong>2. 主要挑战</strong></h4><ul><li><strong>支付合规性</strong>：订单号长度限制（32位）、HTTPS证书配置。  </li><li><strong>系统兼容性</strong>：管家模块与若依权限系统账户体系不匹配。  </li><li><strong>性能问题</strong>：地块数据量增大导致查询缓慢。  </li></ul><h4 id="3-成长与改进"><a href="#3-成长与改进" class="headerlink" title="3. 成长与改进"></a><strong>3. 成长与改进</strong></h4><ul><li><strong>第三方集成经验</strong>：支付接口必须严格遵循字段规范（如订单号长度）。  </li><li><strong>解耦设计</strong>：模块化开发（如管家管理独立）降低系统耦合风险。  </li><li><strong>性能优化</strong>：引入缓存与数据库索引应对数据增长。  </li></ul><h4 id="4-后续计划"><a href="#4-后续计划" class="headerlink" title="4. 后续计划"></a><strong>4. 后续计划</strong></h4><ul><li>补全若依系统对接文档，完成管家权限集成。  </li><li>统一接口响应格式，编写后端API文档。  </li><li>增加农场操作（播种、收获）的事务回滚机制。  </li></ul><p><strong>总结</strong>：本周成功交付农场系统核心功能，但支付与权限集成暴露了<strong>预研不足</strong>的问题。后续类似项目需提前验证第三方接口（支付、登录）的合规性；  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;a href=&quot;#周一：农场服务前端界面实现&quot; class=&quot;headerlink&quot; title=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;周一：农场服务前端界面实现&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;完</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第六周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/</id>
    <published>2025-08-25T15:01:50.000Z</published>
    <updated>2025-12-11T09:11:12.926Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）<br><strong>整体进展：</strong> ✅ 成功打通<code>HTTPS部署</code> -&gt; <code>微信支付</code> -&gt; <code>农场种植</code>全链路，项目进入可演示阶段。</p><hr><h3 id="一、-每日工作记录"><a href="#一、-每日工作记录" class="headerlink" title="一、 每日工作记录"></a><strong>一、 每日工作记录</strong></h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>HTTPS服务配置</strong></td><td style="text-align:left">✅ <strong>前端</strong>：使用Nginx配置SSL证书，实现小程序前端页面的HTTPS安全访问。<br>✅ <strong>后端</strong>：在SpringBoot中配置SSL证书，使后端API支持HTTPS请求，为微信支付等安全接口打下基础。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>微信支付集成</strong></td><td style="text-align:left">✅ 集成<strong>微信支付V2版</strong>，完成下单、回调等核心流程开发。<br>✅ 使用<strong>内网穿透</strong>工具模拟支付环境，初步测试通过。<br>⚠️ <strong>待办</strong>：退款功能暂未实现。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>问题修复与设计</strong></td><td style="text-align:left">✅ <strong>修复支付Bug</strong>：深入分析并解决了官方文档中提及的“订单重复”问题，优化为首次<code>统一下单</code>、后续调用<code>jsapi</code>的稳定流程。<br>✅ <strong>数据库设计</strong>：为农场托管功能设计了<code>farms</code>（田地）、<code>crops</code>（种子）、<code>farmManagers</code>（农场管家）三张核心表，明确通过JWT鉴权来隔离用户数据。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>农场服务开发</strong></td><td style="text-align:left">✅ 开发并部署核心农场后端服务，提供初步可用的RESTful API：<br>  - <code>POST /farm/plant</code>： <strong>种植接口</strong><br>  - <code>POST /farm/init</code>： <strong>初始化用户田地</strong><br>  - <code>POST /farm/listByUser</code>： <strong>获取用户田地信息</strong></td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>联调与架构复盘</strong></td><td style="text-align:left">✅ 成功完成前端与农场服务的联调，可获取并展示用户种植数据。<br>✅ <strong>架构决策</strong>：确定使用<strong>混合云开发</strong>方案（自建MySQL + 云服务），兼顾了数据灵活性与开发效率。</td></tr></tbody></table></div><hr><h3 id="二、-本周最大的挑战与解决方案"><a href="#二、-本周最大的挑战与解决方案" class="headerlink" title="二、 本周最大的挑战与解决方案"></a><strong>二、 本周最大的挑战与解决方案</strong></h3><ul><li><strong>挑战：</strong> 技术选型在<strong>数据库扩展性</strong>与<strong>开发维护效率</strong>之间的权衡。纯微信云开发无法满足复杂的MySQL业务需求，而完全自建服务器运维成本较高。</li><li><strong>解决方案：</strong> 采用<strong>混合云架构</strong>。<ul><li><strong>核心业务数据</strong>（用户、订单、农场）：使用自建云服务器上的MySQL数据库，保证了对数据的完全控制和复杂查询能力。</li><li><strong>静态资源/轻量功能</strong>：后续可考虑使用云开发平台的服务，提升开发速度与稳定性。</li></ul></li><li><strong>结果：</strong> 该方案既满足了当前业务的复杂度，又为未来部分功能的快速迭代提供了灵活性，速度与稳定性兼得。</li></ul><hr><h3 id="三、-本周工作带来的成长"><a href="#三、-本周工作带来的成长" class="headerlink" title="三、 本周工作带来的成长"></a><strong>三、 本周工作带来的成长</strong></h3><ol><li><strong>全链路能力提升：</strong> 从最基础的HTTPS配置，到复杂的支付业务、数据库设计，再到后端服务开发，独立打通了核心功能的全链路，对前后端协同开发的理解更加深刻。</li><li><strong>技术方案设计能力：</strong> 不再局限于实现功能，开始从<strong>架构角度</strong>思考问题（如混合云选型），学会了在多种技术方案中权衡利弊，选择最适合当前业务阶段的方案。</li><li><strong>文档驱动开发：</strong> 通过编写设计文档来理清逻辑，再着手编码，有效减少了开发过程中的反复和错误，提升了开发效率和质量。</li></ol><hr><h3 id="四、-反思与未来优化"><a href="#四、-反思与未来优化" class="headerlink" title="四、 反思与未来优化"></a><strong>四、 反思与未来优化</strong></h3><ul><li><strong>本周不足：</strong> 最初的方案设计对<strong>云原生</strong>和<strong>混合架构</strong>的考量不够深入，导致中途需要调整技术路线，产生了一定的学习成本。</li><li><strong>未来优化：</strong><ol><li><strong>架构设计</strong>：在项目初期，应更系统地评估各种技术方案（自建、纯云、混合云）的优缺点，制作详细的对比表格，避免后期切换。</li><li><strong>可维护性</strong>：虽然混合方案稳定，但未来可以考虑使用<strong>Docker容器化</strong>来部署MySQL和应用，提升环境一致性和迁移效率。</li><li><strong>功能完善</strong>：下一步需补全<strong>退款流程</strong>，并开始构建基于农场数据的<strong>商城购买与订单生成</strong>功能，最终完成商业闭环。</li></ol></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ 成功打通&lt;code&gt;HTTPS部署&lt;/code&gt; -&amp;gt; &lt;code&gt;微信支付&lt;/code&gt; -&amp;g</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第五周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/</id>
    <published>2025-08-16T16:04:11.000Z</published>
    <updated>2025-12-11T09:11:39.892Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="table-container"><table><thead><tr><th>日期</th><th>核心工作</th><th>关键产出</th></tr></thead><tbody><tr><td><strong>周一</strong></td><td>后台系统技术选型与架构设计</td><td>✅ 选定 <strong>若依框架</strong> 搭建后台管理系统<br>✅ 完成 <strong>功能模块划分</strong> 及技术文档输出</td></tr><tr><td><strong>周二</strong></td><td>用户管理模块开发</td><td>✅ 实现用户信息 <strong>增删改查（CRUD）</strong> 全功能</td></tr><tr><td><strong>周三</strong></td><td>核心业务模块开发</td><td>✅ 完成 <strong>订单管理</strong> 业务流程设计<br>✅ 落地 <strong>土地管理</strong> CRUD 核心逻辑</td></tr><tr><td><strong>周四</strong></td><td>技术方案优化与问题修复</td><td>✅ 验证 <strong>微信云开发</strong> 替代方案可行性<br>✅ 修复 <strong>图片上传异常</strong> Bug（改用云存储+路径映射）</td></tr><tr><td><strong>周五</strong></td><td>混合架构设计与规划</td><td>✅ 制定 <strong>MySQL + 云数据库混合方案</strong><br>✅ 参与 <strong>后续原型扩展</strong> 技术讨论</td></tr></tbody></table></div><hr><h3 id="关键亮点说明："><a href="#关键亮点说明：" class="headerlink" title="关键亮点说明："></a>关键亮点说明：</h3><ol><li><p><strong>技术选型</strong>：  </p><ul><li>选择 <strong>若依框架</strong> → 节省60%基础模块开发时间  </li><li>放弃纯云开发 → 因 <strong>MySQL业务兼容性</strong> 不足  </li></ul></li><li><p><strong>架构突破</strong>：  </p><pre><code class=" mermaid">graph LRA[微信小程序] --&gt; B&#123;云存储&#125;A --&gt; C[自建服务器]B --&gt; D[图片/文件]C --&gt; E[MySQL业务库]</code></pre><p><strong>混合架构价值</strong>：静态资源云化减压，核心数据自主可控  </p></li></ol><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>工作内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长收获</strong></th></tr></thead><tbody><tr><td><strong>1. 后台系统设计</strong><br> - 技术选型（若依框架）<br> - 功能模块规划文档</td><td>• 平衡开发效率与后期扩展性</td><td>• 选择 <strong>开源后台框架若依</strong>（集成权限管理/代码生成）</td><td>✅ 掌握 <strong>快速搭建企业级后台</strong> 的方法论</td></tr><tr><td><strong>2. 核心模块开发</strong><br> - 用户管理（增删改查）<br> - 订单/土地管理功能</td><td>• 数据库设计需兼容农场业务逻辑<br>• 字段关联性复杂</td><td>• 先画 <strong>ER图梳理数据关系</strong><br>• 用若依代码生成器快速实现基础CRUD</td><td>✅ 提升 <strong>业务模型抽象能力</strong><br>✅ 熟练 <strong>框架工具提效技巧</strong></td></tr><tr><td><strong>3. 技术方案优化</strong><br> - 尝试微信云开发<br> - 图片上传BUG修复</td><td>• 云开发与传统MySQL不兼容<br>• 图片路径存储异常</td><td>• 改用 <strong>混合云架构</strong>：<br>  - 核心业务用云服务器+MySQL<br>  - 图片/文件用云存储</td><td>✅ 理解 <strong>混合云方案设计思维</strong><br>✅ 学会 <strong>根据场景灵活选型</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><ol><li><p><strong>「快 vs 稳」的博弈</strong>：  </p><blockquote><p>若依框架虽加速开发，但过度依赖其生成代码可能导致<strong>技术债积累</strong>（如订单扩展字段需手动调整），下次需预留20%自定义空间。  </p></blockquote></li><li><p><strong>云服务的双刃剑</strong>：  </p><blockquote><p>微信云开发适合轻量应用，但<strong>数据库生态封闭</strong>（不支持MySQL）成为硬伤，混合架构虽解燃眉之急，也带来运维复杂度。  </p></blockquote></li></ol><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><ol><li><p><strong>技术选型更严谨</strong>：  </p><ul><li><p>制作 <strong>方案对比表</strong>（如下），避免试错成本：<br>| 方案         | 扩展性 | 维护成本 | 适合场景       |<br>| —————— | ——— | ———— | ——————— |<br>| 自建MySQL    | ★★★★   | 中       | 复杂业务       |<br>| 纯微信云开发 | ★★     | 低       | 轻量工具类应用 |<br>| <strong>混合云</strong>   | ★★★    | <strong>中高</strong> | <strong>中庸型项目</strong> |</p></li><li><p>非核心功能（如图片上传）<strong>彻底云化</strong>，直接用云开发SDK。  </p></li></ul></li><li><p><strong>建立原型验证机制</strong>：  </p><ul><li>重要模块（如订单状态机）先写 <strong>伪代码流程图</strong> 与产品确认，避免返工。  </li></ul></li></ol><blockquote><p><strong>总结</strong>：本周深刻体会架构选型需考量 <strong>业务生命周期</strong>（短期效率 vs 长期扩展）。未来将坚持 <strong>“设计-原型-开发”三步走</strong>，让技术真正服务业务增长。  </p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;核心工作&lt;/th&gt;
&lt;th&gt;关键产出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;周一&lt;/</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第四周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/</id>
    <published>2025-08-10T05:28:04.000Z</published>
    <updated>2025-12-11T09:11:29.726Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周一：</strong>  </p><ul><li>完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  </li><li><em>注意点：</em> 补充了状态字段设计。</li></ul><p><strong>周二：</strong>  </p><ul><li>构建订单系统：创建订单主表及详情表，实现：  <ul><li>JWT用户订单查询  </li><li>多状态分类（待支付/待发货等）  </li><li>PageHelper分页（&gt;10自动分页，加载页面缓存进度）  </li></ul></li><li><em>遗留问题：</em> 订单号长度仅20位（需32位）。</li></ul><p><strong>周三：</strong>  </p><ul><li>订单详情增强：调用土地接口展示租赁地块信息。  </li><li>前端隐患：<code>this.orderInfo.items[0]</code> 强耦合数据绑定。  </li></ul><p><strong>周四：</strong>  </p><ul><li>订单状态管理：实现增删改查及状态流转（如取消订单同步释放土地）。  </li><li><em>优化：</em> 采用状态模式替代if-else链。  </li></ul><p><strong>周五：</strong>  </p><ul><li>支付功能受阻：  <ol><li><strong>致命问题：</strong> 后端未配置HTTPS（微信支付强制要求）  </li><li><strong>设计缺陷：</strong> 订单号长度不符支付接口规范（20位≠32位）  </li></ol></li><li><em>转向：</em> 启动手机号验证方案研究。  </li></ul><p><strong>周六：</strong>  </p><ul><li>微信验证困局：  <ul><li>手机号快速验证失败（需企业认证）  </li><li><code>getUserProfile</code>仅获取基础信息（头像/昵称）  </li><li>开放数据解密流程复杂且无进展  </li></ul></li><li><em>结论：</em> 当前微信政策下，获取手机号一键登录不可行。  </li></ul><hr><p><strong>核心卡点：</strong>  </p><ol><li><strong>支付环节：</strong> HTTPS缺失 + 订单号设计缺陷  </li><li><strong>微信生态：</strong> 政策收紧导致手机号获取路径封死</li></ol><h3 id="一、独立完成-amp-挑战-amp-成长"><a href="#一、独立完成-amp-挑战-amp-成长" class="headerlink" title="一、独立完成 &amp; 挑战 &amp; 成长"></a><strong>一、独立完成 &amp; 挑战 &amp; 成长</strong></h3><div class="table-container"><table><thead><tr><th><strong>事项</strong></th><th><strong>独立完成</strong></th><th><strong>最大挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长</strong></th></tr></thead><tbody><tr><td><strong>租地系统</strong></td><td>租赁表设计 + JWT用户绑定</td><td>状态字段缺失</td><td>快速补字段 + 关联订单状态</td><td>意识到<strong>数据扩展性</strong>的重要性</td></tr><tr><td><strong>订单中台</strong></td><td>双表创建 + 分页/状态筛 + 状态机</td><td>订单号长度设计不足(20位)</td><td>重构为32位 UUID</td><td><strong>关键字段需预判业务需求</strong></td></tr><tr><td><strong>支付对接</strong></td><td>调用微信支付流程开发</td><td>1. 无HTTPS<br>2. 微信政策限制</td><td>转向备用方案（手机号验证）</td><td>第三方功能<strong>必须预研环境/政策</strong></td></tr><tr><td><strong>微信集成</strong></td><td>实现<code>getUserProfile</code>基础授权</td><td>无法获取用户准确信息（政策封锁）</td><td>明确放弃，转为人工审核流程</td><td>学会<strong>在限制中寻找替代路径</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a><strong>二、本周工作思考</strong></h3><ol><li><strong>做得好的</strong>  <ul><li>基础功能闭环：租地→订单→状态流转全链路跑通  </li><li>快速响应问题：发现订单号缺陷应该立即重构  </li></ul></li><li><strong>待改进的</strong>  <ul><li><strong>致命疏忽</strong>：支付未提前验证HTTPS/字段规则 → 导致整块功能返工  </li><li><strong>过度乐观</strong>：低估微信政策限制（开发者权限）  </li></ul></li><li><strong>核心认知</strong>  <blockquote><p><strong>“能开发” ≠ “能上线”</strong><br>第三方依赖的合规性（HTTPS/政策）比代码更重要  </p></blockquote></li></ol><hr><h3 id="三、未来同样机会的做法"><a href="#三、未来同样机会的做法" class="headerlink" title="三、未来同样机会的做法"></a><strong>三、未来同样机会的做法</strong></h3><ol><li><p><strong>预研四象限（首日必做）</strong>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[技术]</span>      <span class="hljs-selector-attr">[政策]</span>      <span class="hljs-selector-attr">[环境]</span>       <span class="hljs-selector-attr">[兼容性]</span>  <br>│          │          │            │  <br>├─HTTPS?   ├─微信文档? ├─测试账号?   ├─字段长度?  <br>└─SDK兼容  └─权限范围  └─域名备案    └─数据格式  <br></code></pre></td></tr></table></figure></li><li><p><strong>设计两原则</strong>  </p><ul><li><strong>字段设计</strong>：订单号/金额等支付相关字段，直接对齐微信要求（32位/UUID）  </li><li><strong>解耦开发</strong>：支付模块用模拟运行，便于替换（例：HTTPS未就绪时模拟支付）  </li></ul></li><li><p><strong>政策应对</strong>  </p><ul><li>项目避免强依赖微信敏感接口（如手机号）  </li></ul></li></ol><blockquote><p><strong>总结一句话</strong>：<br><strong>下次先花2小时跑通支付Demo+政策验证，再动手写业务代码。</strong><br>功能开发速度 ≠ 交付速度，预研省下的就是返工浪费的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;周一：&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;注意点：&lt;/em&gt; 补充了状态字段设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;周二：&lt;/strong&gt;  </summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第三周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/</id>
    <published>2025-08-01T16:26:28.000Z</published>
    <updated>2025-12-11T09:11:57.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心目标：</strong> 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。</p><p><strong>本周主要进展：</strong></p><ol><li><p><strong>项目启动与基础搭建 (周一)：</strong></p><ul><li>用开发工具创建了小程序项目框架。</li><li><strong>首页：</strong> 实现了图片热区点击跳转（用<code>绝对定位</code>精确定位点击区域，<code>uni.switchTab</code>跳转底部菜单页）。</li><li><strong>公告栏：</strong> 暂时留空。</li><li><strong>我的农场：</strong> 开始设计核心玩法（比如种植收获逻辑）。</li><li><strong>个人中心：</strong> 画好了页面布局。</li><li>图片上传到<code>图床</code>，减小小程序安装包体积。</li></ul></li><li><p><strong>界面优化与农场互动 (周二)：</strong></p><ul><li><strong>首页：</strong> 用<code>媒体查询</code>让页面在不同尺寸手机上都好看（响应式布局）。</li><li><strong>我的农场：</strong> 用<code>Grid网格布局</code>做了9块整齐的地块。点击地块能弹出操作图片（比如选择种子）。</li><li><strong>个人中心：</strong> 本想做微信<code>一键登录</code>（获取手机号），但个人小程序权限不够。改用方案：用户授权获取微信<code>头像和昵称</code>绑定账号，登录成功后服务器返回一个<code>token</code>（身份令牌）存起来，代表用户已登录。</li></ul></li><li><p><strong>新增功能模块 (周三)：</strong></p><ul><li><strong>首页：</strong> 加了“马克农场”入口，点击后跳转新页面（用<code>uni.navigateTo</code>页面跳转）。</li><li><strong>个人中心：</strong> 增加了“设置”页面，可以修改个人信息。</li></ul></li><li><p><strong>核心登录功能实现 (周四)：</strong></p><ul><li><strong>个人中心：</strong><ul><li>实现了完整的微信登录流程：<ol><li>小程序获取临时登录凭证<code>code</code>。</li><li>把<code>code</code>发给我的后台服务器。</li><li>后台用<code>code</code>向微信服务器换取用户的<code>唯一标识(openid)</code>等信息。</li><li>后台查数据库：如果是新用户，就创建账号；老用户则读取信息。</li><li>后台生成<code>token</code>，连同用户信息一起返回给小程序。</li><li>小程序把<code>token</code>和用户信息存起来（<code>storage</code>），后续操作代表该用户。</li></ol></li><li><em>注：等小程序主体是企业后，可升级为手机号直接登录。</em></li></ul></li><li><strong>订单页：</strong> 实现了跳转到不同订单类型页的功能（在链接后面加<code>?type=...</code>传参）。解决了引入图标库时的兼容性问题。</li></ul></li><li><p><strong>用户信息保护与更新 (周五)：</strong></p><ul><li>完善登录后的安全措施：采用<code>JWT令牌</code>进行<code>鉴权</code>（验证身份）。<ul><li><strong>为什么选JWT？</strong> 主要因为它不需要<code>Cookie</code>，避免了<code>跨域(CORS)</code>问题，更方便不同服务器间协作。而且服务器不用存储用户登录状态（<code>无状态</code>），减轻负担。</li><li><strong>怎么用？</strong> 用户登录后拿到<code>JWT token</code>（就是周四的那个token）。当用户想修改头像昵称等需要登录的操作时，小程序在请求头里带上这个token（格式：<code>Authorization: Bearer &lt;你的token&gt;</code>）。后台收到请求后，先<code>验证token是否有效且合法</code>，验证通过了才允许修改用户信息。</li></ul></li><li>实现了登录后修改头像和昵称的功能。</li></ul></li></ol><p><strong>简单来说，这周：</strong> 搭好了小程序的基础架子，重点实现了用户<code>登录注册流程</code>（包括微信授权、后台验证、生成令牌JWT），完成了个人中心的主要功能（信息展示、设置、头像昵称修改），并开始为订单系统做跳转准备。技术上解决了图片优化、布局适配、登录授权、身份验证（JWT）等关键点。</p><p>以下是对本周工作的结构化复盘总结，结合实践与成长思考：</p><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>完成内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>带来的成长</strong></th></tr></thead><tbody><tr><td><strong>1. 用户系统全流程搭建</strong><br> - 微信登录+JWT鉴权<br> - 头像/昵称修改功能</td><td>• 个人小程序无法直接获取手机号<br>• JWT无状态鉴权首次实战</td><td>• 改用 <strong>Code→OpenID→Token</strong> 替代方案<br>• 研读JWT机制，设计 <strong>Bearer Token</strong> 请求头鉴权逻辑</td><td>✅ 掌握<strong>受限条件下的灵活架构能力</strong><br>✅ 理解<strong>无状态认证</strong>的设计优势与风险</td></tr><tr><td><strong>2. 农场交互核心模块</strong><br> - Grid九宫格布局<br> - 地块点击弹窗交互</td><td>• 动态弹窗与地块操作状态联动<br>• 多端样式适配</td><td>• 用 <strong>CSS变量+媒体查询</strong> 控制响应式<br>• <strong>事件委托</strong> 统一管理地块点击逻辑</td><td>✅ 强化 <strong>复杂交互前端设计能力</strong><br>✅ 提升 <strong>CSS3实战应用水平</strong></td></tr><tr><td><strong>3. 项目基建优化</strong><br> - 图床节省包体积<br> - 路由传参统一管理</td><td>• 图标库兼容性问题<br>• 路由跳转类型混乱</td><td>• <strong>源码调试+强制样式覆盖</strong> 解决依赖冲突<br>• 封装 <strong>路由工具函数</strong> 统一处理?type=参数</td><td>✅ 学会 <strong>第三方库问题排查技巧</strong><br>✅ 养成 <strong>提前封装工具类</strong> 的习惯</td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><p><strong>1. 技术决策的价值</strong>：  </p><blockquote><p>选择JWT不仅解决了跨域问题，更让我意识到<strong>技术选型需服务业务场景</strong>——个人小程序无法用企业级登录方案时，用Token机制快速搭建安全认证体系是最优解。  </p></blockquote><p><strong>2. 限制催生创新</strong>：  </p><blockquote><p>微信API权限限制反而推动设计出更通用的 <strong>「Code+OpenID+DB」用户绑定流程</strong>，未来扩展手机号/邮箱登录只需复用该流程。  </p></blockquote><p><strong>3. 技术债预警</strong>：  </p><blockquote><p>临时解决CSS兼容性的“hack手段”需在迭代中重构，<strong>开发效率与代码质量必须动态平衡</strong>。  </p></blockquote><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><p><strong>1. 前置设计更彻底</strong>：  </p><blockquote><ul><li>用<strong>流程图</strong>预先规划登录/鉴权全链路（避免周四返工）  </li><li>订单系统数据库<strong>提前预留扩展字段</strong>（如<code>order_type</code>应对跳转传参）  </li></ul></blockquote><p><strong>2. 技术方案分层验证</strong>：  </p><blockquote><ul><li>关键模块（如JWT）先写<strong>技术原型Demo</strong>再集成  </li><li>第三方库（uView）提前做<strong>兼容性测试矩阵</strong>  </li></ul></blockquote><p><strong>3. 自动化提效</strong>：  </p><blockquote><ul><li>用<strong>CI/CD工具</strong>自动压缩图片上传图床  </li><li>编写<strong>路由配置生成脚本</strong>避免手写跳转参数  </li></ul><p><strong>总结</strong>：未来需更注重<strong>前瞻性设计</strong>与<strong>可持续架构</strong>，让代码既能跑得快，更能跑得远。  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心目标：&lt;/strong&gt; 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周主要进展：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;项目启动与基础搭建 (周一)：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第二周：手撕验证码Session，给订单系统“安家落户”</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/</id>
    <published>2025-07-26T17:20:11.000Z</published>
    <updated>2025-12-11T09:12:00.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心任务：</strong> 独立完成车位项目订单系统后端接口、前端页面及数据库设计。</p><p><strong>本周开发纪实：</strong></p><ol><li><strong>周一：</strong> 复盘上周工作，为本周冲刺蓄力。</li><li><strong>周二：</strong> 承接新需求：<ul><li><strong>记住手机号：</strong> 提升用户体验。</li><li><strong>自定义弹窗：</strong> 实现灵活交互。</li><li><strong>价格需求：</strong> 核心业务逻辑。</li><li><strong>技术选型：</strong> 确定使用 <code>HttpSession</code> 存储 <code>手机号:验证码</code> 键值对，作为临时认证方案。</li></ul></li><li><strong>周三：</strong> 功能实现日<ul><li>完成“记住手机号” ✅</li><li>集成验证码登录 ✅ (<strong>注意点：</strong> 接口参数类型需严格匹配，<code>Session ID</code> 不一致会导致校验失败 - <em>已解决</em>)</li><li>实现协议勾选及自定义弹窗 ✅</li><li><strong>兼容性问题：</strong> 确认微信浏览器不支持 <code>datalist</code> 元素。 (<em>已找到替代方案-采用div来自定义下拉框</em>✅)</li></ul></li><li><strong>周四：</strong> 优化与设计<ul><li><strong>验证码生命周期优化：</strong> 将清除逻辑从固定5分钟 (<code>setInterval</code>)，升级为 <strong>登录成功即销毁</strong> 或 <strong>5分钟到期销毁</strong>，更贴合实际场景。</li><li><strong>数据库设计：</strong> 新增 <code>订单表 (order)</code>。<ul><li>关键设计：通过 <code>spot_id</code> 外键关联车位表。</li><li>决策说明：未直接复用车位表 <code>user_id</code> 字段 (因车位归属逻辑与订单用户逻辑存在差异)。</li></ul></li></ul></li><li><strong>周五：</strong> 数据库深化<ul><li>完善 <code>订单表</code> 结构，清晰记录交易信息。</li><li>设计 <code>优惠规则表 (discount_rule)</code>，定义车位关联的折扣类型与规则。 (<em>终于给优惠上了“户口本”</em>)</li></ul></li><li><strong>周六：</strong> 逻辑实现 &amp; 性能飞跃<ul><li>完成订单金额计算引擎，支持匹配优惠规则。</li><li><strong>接口性能重大优化：</strong><ul><li><strong>问题：</strong> 原有设计需两个接口拉取 <strong>全量用户车位数据</strong>，效率低下。</li><li><strong>方案：</strong> 重构为单一接口，精准查询 <strong>当前用户订单信息</strong>。</li><li><strong>成果：</strong> <strong>响应速度显著提升，数据库压力大幅降低。</strong> ( <em>成功给臃肿接口“瘦身”</em> )</li></ul></li></ul></li></ol><p><strong>本周总结与反思：</strong></p><ol><li><p><strong>主要成就与挑战：</strong></p><ul><li><strong>独立完成：</strong> 成功独立完成了车位及订单模块的后端接口开发、前端订单页面设计以及相关数据库设计。</li><li><strong>关键挑战：</strong> 如何在后端安全、有效地存储和验证用户专属的短信验证码，避免多用户共用同一验证码的风险。</li><li><strong>解决方案：</strong> 采用基于 <code>HttpSession</code> 的存储方案：<ul><li>Key: 用户手机号</li><li>Value: 对应的验证码</li><li>生命周期管理：用户成功登录后或 Session 超时（设置 5 分钟）自动销毁。</li></ul></li><li><strong>成长点：</strong> 深入理解了 <code>HttpSession</code> 机制在后端数据临时存储中的应用。</li></ul></li><li><p><strong>反思与改进点：</strong></p><ul><li><strong>需求理解：</strong> 未来开发前，应更深入地与客户/产品沟通需求细节，以便更好地支持后续扩展性开发。</li><li><strong>数据库设计：</strong> 反思当前设计是否足够精细？例如 <code>user</code> 表可考虑增加 <code>user_type</code>、<code>created_at</code>、<code>last_login_at</code> 等字段增强功能性和可追溯性。</li><li><strong>设计文档：</strong> 意识到个人设计文档的详细度有待提高，需加强文档规范。</li></ul></li><li><p><strong>未来优化方向：</strong></p><ul><li><strong>沟通：</strong> 加强沟通，确保需求理解透彻，及时同步进展。</li><li><strong>数据库：</strong><ul><li>精细化核心表结构（如扩展 <code>user</code> 表字段）。</li><li>建立更清晰的表关系。</li></ul></li><li><strong>后端架构：</strong><ul><li>进行更清晰的分层设计（Controller / Service / Repository / Entity）。</li><li>将车位管理、用户收藏等模块进行逻辑拆分，提高可维护性。</li></ul></li><li><strong>前端：</strong><ul><li>加强浏览器兼容性测试（如已发现的微信 <code>datalist</code> 问题）。</li><li>持续进行界面加载速度优化。</li></ul></li><li><strong>目标：</strong> 通过以上改进，全面提升开发效率、代码质量和系统健壮性，促进个人技术能力的成长。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心任务：&lt;/strong&gt; 独立完成车位项目订单系统后端接口、前端页面及数据库设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周开发纪实：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;周一：&lt;/strong&gt; 复盘上周工作，为本周冲刺蓄力。&lt;/li</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第一周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/</id>
    <published>2025-07-18T16:24:08.000Z</published>
    <updated>2025-12-11T09:11:52.499Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：新手村报到</strong><br>广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！</p><p><strong>Day 1: HTML星辰大海，打包是个误会？</strong><br>产品经理的原型图甩过来，先设计好文档没问题了再开干！祭出神器 <code>Cursor</code> + <code>Claude-3-Connect</code>，AI 辅助下吭哧吭哧撸完一堆纯 HTML 页面。AI 老哥贴心提示：“亲，打包上传哦~”。我信了！一头扎进打包工具的坑里折腾半天，汗流浃背。结果？<strong>发现特么的纯 HTML 直接扔服务器就能跑！</strong> 打包？打包了个寂寞！今日教训：AI 的话，也得结合上下文判断啊… (╯‵□′)╯︵┻━┻</p><p><strong>Day 2: SpringBoot 从零开始，CSDN 付费墙刺客！</strong><br>今日任务：搞后端 API 录入。第一次正经从零搭 <code>SpringBoot</code> 项目。IDEA 社区版 2023 有点坑，创建方式藏得深。CSDN 搜教程，好家伙，第一步就让装个插件，装完重启直接弹登录+<strong>付费订阅</strong>！真·知识付费刺客！果断弃坑。翻到良心文章指路：<a href="https://start.spring.io">https://start.spring.io</a>，官方生成器真香！唯一小插曲：我 JDK 11 的“老环境”，伺候不了 SpringBoot 3 这位“新贵”，手动把版本和相关依赖<strong>降级到 2.x</strong>，世界终于清净。结论：CSDN 水文害人，官方文档/工具永流传！</p><p><strong>Day 3: 宝塔端口玄学 &amp; “数字小孩”落户口！</strong><br>任务：把后端 API 部署上云服务器（宝塔面板）。一顿操作猛如虎：端口放行√，配置√。测试？<strong>死活连不上！</strong> CSDN 又跳出来“指点”：搞个随机域名数据库？一看还得付费固定域名？我信你个鬼！焦头烂额之际，<strong>猛然想起腾讯云还有个安全组！</strong> 火速添上端口规则，瞬间畅通！啊，这熟悉的安全感… (长舒一口气)</p><ul><li><strong>技术小悟：</strong> 跨域问题，不一定非搬 Nginx 大神。后端配个全局 <code>CORS</code>，指定好前端地址，也能愉快玩耍！省事！</li><li><strong>短信验证码插曲：</strong> 折腾半天接好了，但备案没过的号能发成功吗？心里有点虚，先当它行吧！</li></ul><p><strong>🌟 今日高光时刻 🌟</strong><br>今年我们团队的心血——<strong>“医疗健康问诊系统”</strong>，<strong>喜提国家版权局颁发的《计算机软件著作权登记证书》！</strong> 正式拥有了“<strong>数字小孩</strong>”的户口本！🎉</p><blockquote><p>感谢并肩作战的伙伴，<br>感谢每个改bug到天亮的自己。<br>——【医疗健康问诊系统】软著𝐆𝐞𝐭，未来可期！</p></blockquote><p><strong>Day 4: 切图仔の挣扎 vs 后端の从容（伪）</strong><br>实现一个“点击录入所有数据”的功能。纯 HTML + Vue 的组合，对我这个后端半吊子来说，操作 DOM 像在绣花… <strong>切图仔，属实不易！</strong> 顺带搞了车位收藏功能，数据库表设计修修补补好几回，勉强上线。<strong>结论：前端水太深，后端（的CRUD）才是俺的舒适区（暂时）！</strong></p><p><strong>Day 5: 数据库改改改，AI又救我狗命！</strong><br>搞车位收藏和抢购的多表查询。<strong>是的，我又双叒改数据库了！</strong> 最初设计图样图森破：想着一个车位记录，既能标记收藏又能记录谁买了，还绑 UserID。结果，“车位必须空闲”的规则和用户操作直接打架！卡壳半天，<strong>求助 AI 老哥</strong>，一语点醒：这设计有坑！火速重构，把状态、归属理清楚，功能终于跑通。<strong>教训：数据库设计，脑子得提前多绕几圈，少走弯路！</strong></p><p><strong>周记结尾：</strong><br>第一周，在疯狂踩坑、暴躁搜索、偶尔顿悟和一次巨大惊喜（软著！）中飞逝。从打包误会到安全组玄学，从被 CSDN 付费墙背刺到 AI 救场，从切图痛苦到改库狂魔… <strong>真实又酸爽！</strong> 见识了工具的便利与坑爹，体会了团队的温暖（和一起加班）。代码世界的大门刚推开一条缝，路还长，坑还多，但看着“数字小孩”上了户口，值了！下周，继续升级打怪！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：新手村报到&lt;/strong&gt;&lt;br&gt;广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Day 1: HTML星辰大海，打包是个误会？&lt;/stro</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链智能合约教程-医疗</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/</id>
    <published>2025-07-12T13:31:15.000Z</published>
    <updated>2025-12-22T19:34:03.266Z</updated>
    
    <content type="html"><![CDATA[<p>源码</p><p> <a href="https://zhengcookie.github.io\file\区块链\智能合约\medical\医疗\Main.sol">Main.sol</a> </p><p>以下是智能合约代码的逐段解析，按功能模块分类说明：</p><hr><h3 id="1-患者信息管理"><a href="#1-患者信息管理" class="headerlink" title="1. 患者信息管理"></a><strong>1. 患者信息管理</strong></h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Sick &#123;<br>    address accountAddress; // 患者钱包地址<br>    string name;            // 姓名<br>    string sex;             // 性别<br>    uint256 age;            // 年龄<br>    uint256 id;             // 身份证号(主键)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Sick) public sicks;  // 身份证号→患者信息的映射<br>uint256[] public sickIds;               // 所有患者身份证号列表<br></code></pre></td></tr></table></figure><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建患者档案 (需校验参数有效性)<br>function createSick(...) public &#123;<br>    // 参数校验...<br>    sicks[identityNumber] = Sick(...);  // 存储信息<br>    sickIds.push(identityNumber);       // 记录ID<br>    emit SickCreated(...);              // 触发事件<br>&#125;<br><br>// 按身份证查询患者<br>function getSickByIdentityNumber(...) public view returns (...) &#123;<br>    require(sick.accountAddress != address(0)); // 校验存在性<br>    return (sick.accountAddress, ...); <br>&#125;<br><br>// 按钱包地址查询患者<br>function getSickByAccountAddress(...) public view returns (...) &#123;<br>    uint256 sickID = findSickIDByAccountAddress(accountAddr); // 内部遍历查找<br>    return (sick.name, ...);<br>&#125;<br><br>// 辅助函数：地址→ID映射<br>function findSickIDByAccountAddress(...) internal view returns (...) &#123;<br>    for (uint256 i = 0; i &lt; sickIds.length; i++) &#123;<br>        if (sicks[sickID].accountAddress == accountAddr) return sickID;<br>    &#125;<br>    return 0;<br>&#125;<br><br>// 检查患者是否存在<br>function isSickExist(uint256 sickID) public view returns (bool) &#123;<br>    return sicks[sickID].accountAddress != address(0);<br>&#125;<br><br>// 获取所有患者ID列表<br>function getSicksList() public view returns (uint256[] memory) &#123;<br>    return sickIds;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-预约挂号系统"><a href="#2-预约挂号系统" class="headerlink" title="2. 预约挂号系统"></a><strong>2. 预约挂号系统</strong></h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Appointment &#123;<br>    string hospitalName; // 医院名称<br>    string department;   // 科室名称<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Appointment) public sickAppointment; // 患者ID→预约信息<br></code></pre></td></tr></table></figure><h4 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建预约<br>function createAppointment(...) public &#123;<br>    require(isSickExist(sickID));          // 患者必须存在<br>    sickAppointment[sickID] = Appointment(...); // 存储预约<br>    emit AppointmentCreated(...);           // 触发事件<br>&#125;<br><br>// 查询预约<br>function getSickAppointment(...) public view returns (...) &#123;<br>    require(bytes(appointment.hospitalName).length &gt; 0); // 校验存在性<br>    return (appointment.hospitalName, ...);<br>&#125;<br><br>// 删除预约<br>function deleteSickAppointment(uint256 sickID) public &#123;<br>    delete sickAppointment[sickID];  // 清除预约记录<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-电子病历管理"><a href="#3-电子病历管理" class="headerlink" title="3. 电子病历管理"></a><strong>3. 电子病历管理</strong></h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct MedicalRecord &#123;<br>    uint256 sickID;               // 患者ID<br>    string hospitalName;          // 医院<br>    string department;            // 科室<br>    string doctorName;            // 医生姓名<br>    string registrationInfo;      // 挂号信息<br>    string pastMedicalHistory;    // 既往病史<br>    string currentMedicalHistory; // 现病史<br>    string isFilled;              // 是否完成(&quot;Yes&quot;/&quot;No&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-2"><a href="#数据存储-2" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; MedicalRecord) public sickMedicalRecords; // 患者ID→病历<br></code></pre></td></tr></table></figure><h4 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建空白病历<br>function createMedicalRecord(...) public &#123;<br>    sickMedicalRecords[sickID] = MedicalRecord(...);<br>    emit MedicalRecordCreated(...);<br>&#125;<br><br>// 授权医生访问病历<br>function authorizeDoctor(...) public &#123;<br>    if (病历不存在) createMedicalRecord(...); // 自动创建空病历<br>    sickMedicalRecords[sickID].doctorName = doctorName; // 设置医生<br>&#125;<br><br>// 更新病历内容<br>function updateMedicalRecord(...) public &#123;<br>    medicalRecord.hospitalName = hospitalName; <br>    medicalRecord.pastMedicalHistory = pastMedicalHistory; // 更新病史等<br>    emit MedicalRecordUpdated(...);<br>&#125;<br><br>// 查询完整病历<br>function getMedicalRecordByIdentityNumber(...) public view returns (...) &#123;<br>    return (medicalRecord.hospitalName, ...); // 返回所有病历字段<br>&#125;<br><br>// 查询特定科室的既往病史<br>function getPastMedicalHistory(...) public view returns (...) &#123;<br>    require(keccak256(科室)==keccak256(目标科室)); // 严格科室匹配<br>    return medicalRecord.pastMedicalHistory;<br>&#125;<br><br>// 标记病历完成状态<br>function endMedicalConsultation(...) public &#123;<br>    medicalRecord.isFilled = mrtype; // 设置&quot;Yes&quot;/&quot;No&quot;<br>&#125;<br><br>// 检查病历是否完成<br>function isMedicalRecordFilled(...) public view returns (bool) &#123;<br>    return keccak256(medicalRecord.isFilled) == keccak256(&quot;Yes&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>该合约完整实现了患者档案管理、挂号预约、电子病历三大核心功能，构建了医疗数据上链的基础框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://zhengcookie.github.io&#92;file&#92;区块链&#92;智能合约&#92;medical&#92;医疗&#92;Main.sol&quot;&gt;Main.sol&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;以下是智能合约代码的逐段解析，按功能模块分类说明：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链赛题智能合约" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B5%9B%E9%A2%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://www.zhengcookie.site/zhengcookie/CSS/"/>
    <id>https://www.zhengcookie.site/zhengcookie/CSS/</id>
    <published>2025-07-11T20:10:39.000Z</published>
    <updated>2025-10-01T04:54:48.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><div class="table-container"><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>.classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref=“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table></div><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>内联样式：1000；</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><div class="table-container"><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table></div><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>　（2）<strong>inline：</strong>元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><strong>transform: scale(0,0)</strong>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者**</strong>区别如下：**</p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是**</strong>继承属性**</p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<span class="hljs-attribute">color</span>: red&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png" alt="img"></p><p>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong>如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p><p><strong>为什么要使用它们？</strong> </p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.css&quot;</span> /&gt;</span></span> <br>&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; </span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: none; </span></span><br><span class="language-css"><span class="language-xml">  &#125; </span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示<br><span class="hljs-attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行<br></code></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示<br><span class="hljs-attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。<br>-webkit-<span class="hljs-attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp:<span class="hljs-number">3</span>;        // 显示的行数<br></code></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位-1"><a href="#1-常见的CSS布局单位-1" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景-1"><a href="#2-px、em、rem的区别及使用场景-1" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现-1"><a href="#3-两栏布局的实现-1" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现-1"><a href="#4-三栏布局的实现-1" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现-1"><a href="#5-水平垂直居中的实现-1" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？-1"><a href="#6-如何根据设计稿进行移动端适配？-1" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景-1"><a href="#7-对Flex布局的理解及其使用场景-1" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong></p><p>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="9-响应式设计的概念及基本原理"><a href="#9-响应式设计的概念及基本原理" class="headerlink" title="9. 响应式设计的概念及基本原理"></a>9. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attr">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\200B&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>  &#125;<br>  <span class="hljs-selector-class">.clearfix</span>&#123;<br>    *<span class="hljs-attribute">zoom</span>: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clear</span>:none|left|right|both<br></code></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 </li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br> <br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">left</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">right</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级非定位后代元素。</p><p>（4）浮动盒：非定位浮动元素。</p><p>（5）行内盒：文档流内行内级非定位后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><div class="table-container"><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table></div><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong>元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png" alt="img"></p><ul><li><strong>fixed：</strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png" alt="img"></p><ul><li><strong>absolute：</strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: orange blue red green;<br>&#125;<br></code></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png" alt="img"></p><p>所以可以根据border这个特性来绘制三角形：</p><p><strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png" alt="img"></p><p><strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png" alt="img"></p><p><strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png" alt="img"></p><p><strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png" alt="img"></p><p><strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png" alt="img"></p><p>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-top-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png" alt="img"></p><p><strong>（1）实现圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>/<span class="hljs-number">150px</span>; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">100%</span>;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br></code></pre></td></tr></table></figure><p>为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。</p><p><strong>（2）实现半圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用元素的margin/padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;trapezoid&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>（1）实现一个直角梯形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">40px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773730069-a1bf7073-14ba-4665-9e5e-cf0aa0722235.png" alt="img"></p><p>（2）实现一个等腰梯形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-width</span>:<span class="hljs-number">0</span> <span class="hljs-number">40px</span> <span class="hljs-number">100px</span> <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">border-style</span>:none solid solid;<br>  <span class="hljs-attribute">border-color</span>:transparent transparent red;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773825580-c1821c13-4513-4462-9a13-73ad4a3ef6e6.png" alt="img"></p><h3 id="5-画一条0-5px的线"><a href="#5-画一条0-5px的线" class="headerlink" title="5. 画一条0.5px的线"></a>5. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, minimum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, maximum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>&quot;/&gt;<br></code></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="6-设置小于12px的字体"><a href="#6-设置小于12px的字体" class="headerlink" title="6. 设置小于12px的字体"></a>6. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="7-如何解决-1px-问题？"><a href="#7-如何解决-1px-问题？" class="headerlink" title="7. 如何解决 1px 问题？"></a>7. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">window.devicePixelRatio = 设备的物理像素 / CSS像素。<br></code></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.png" alt="img"></p><p>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。</p><p><strong>解决**</strong>1px 问题的三种思路：**</p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span><br></code></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：**</strong>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的<strong><strong>宽和高都设置为目标元素的两倍，border值设为 1px。</strong></strong>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一<strong>**，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scale = <span class="hljs-number">1</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;<br><span class="hljs-comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br>metaEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">`width=device-width,user-scalable=no,initial-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,maximum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,minimum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、CSS基础&quot;&gt;&lt;a href=&quot;#一、CSS基础&quot; class=&quot;headerlink&quot; title=&quot;一、CSS基础&quot;&gt;&lt;/a&gt;一、CSS基础&lt;/h2&gt;&lt;h3 id=&quot;1-CSS选择器及其优先级&quot;&gt;&lt;a href=&quot;#1-CSS选择器及其优先级&quot; class</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="css" scheme="https://www.zhengcookie.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://www.zhengcookie.site/zhengcookie/HTML/"/>
    <id>https://www.zhengcookie.site/zhengcookie/HTML/</id>
    <published>2025-07-11T19:55:23.000Z</published>
    <updated>2025-10-01T04:54:48.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p><p>（1）src</p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src =”js.<span class="hljs-property">js</span>”&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p><p>（2）href</p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link href=”common.<span class="hljs-property">css</span>” rel=”stylesheet”/&gt;<br></code></pre></td></tr></table></figure><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h2><p><strong>语义化是指**</strong>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  头部<br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>  导航栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  区块（有语义化的div）<br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  主要区域<br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  主要内容<br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  侧边栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>  底部<br></code></pre></td></tr></table></figure><h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义**</strong>来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h2 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:</p><p><img src="https://zhengcookie.github.io/file/前端面试题/HTML.assets/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="img"></p><p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h2 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值/device-width)</li><li><code>height viewport</code> ：高度(数值/device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&#x27;true&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop=‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&#x27;imgs/aa.jpg&#x27;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签</p><p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.flv&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/flv&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.mp4&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li>placeholder ：提示信息</li><li>autofocus ：自动获取焦点</li><li><p>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li>pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li><li>multiple：可以选择多个文件或者多个邮箱</li><li>form=” form表单的ID”</li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong></p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h2 id="9-对-web-worker-的理解"><a href="#9-对-web-worker-的理解" class="headerlink" title="9. 对 web worker 的理解"></a>9. 对 web worker 的理解</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong></p><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong></p><p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 </p><p>其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;1-src和href的区别&quot;&gt;&lt;a href=&quot;#1-src和href的区别&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="html" scheme="https://www.zhengcookie.site/tags/html/"/>
    
  </entry>
  
</feed>
