<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengcookie</title>
  
  <subtitle>zhengcookie的个人博客</subtitle>
  <link href="https://www.zhengcookie.site/atom.xml" rel="self"/>
  
  <link href="https://www.zhengcookie.site/"/>
  <updated>2025-12-11T09:12:46.208Z</updated>
  <id>https://www.zhengcookie.site/</id>
  
  <author>
    <name>zhengcookie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>agi大模型</title>
    <link href="https://www.zhengcookie.site/zhengcookie/agi%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.zhengcookie.site/zhengcookie/agi%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-12-05T20:11:45.000Z</published>
    <updated>2025-12-11T09:12:46.208Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、python基础语法-08-47"><a href="#一、python基础语法-08-47" class="headerlink" title="一、python基础语法 ﻿08:47﻿"></a>一、python基础语法 ﻿08:47﻿</h4><h5 id="1-Python基础语法的主要知识点-11-23"><a href="#1-Python基础语法的主要知识点-11-23" class="headerlink" title="1. Python基础语法的主要知识点 ﻿11:23﻿"></a>1. Python基础语法的主要知识点 ﻿11:23﻿</h5><ul><li><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-1?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-xTdHOZrZcnEt1Wd6ZfcSSdy9EIs%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-e3e5470fe45c8510415775d4a4624afdb1e7417b4a6f05197495cc9b68998ce66b17aca0140eacf991dc906f7f27748f68117fd9c21a49ca305a5e1275657320&amp;expires=8h&amp;r=574195163&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-1&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-1&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca8395a30becffee929b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>数据类型：包括int、float、string等基本数据类型及其对应方法，如字符串的切割、切片等操作</li><li>函数：函数的定义、调用和使用方法，学到递归即可</li><li>面向对象编程：类的概念和使用</li><li>进阶内容：<ul><li>异常处理</li><li>内置模块的使用（如OS模块）</li><li>模块化编程</li></ul></li><li>学习建议：<ul><li>基础部分（数据类型和函数）必须掌握</li><li>面向对象编程建议学习</li><li>更高级内容可根据兴趣选择性学习</li><li>推荐B站等平台上的Python基础教程</li></ul></li></ul><h5 id="2-环境配置与工具使用-13-54"><a href="#2-环境配置与工具使用-13-54" class="headerlink" title="2. 环境配置与工具使用 ﻿13:54﻿"></a>2. 环境配置与工具使用 ﻿13:54﻿</h5><h6 id="1）Python安装与版本管理-14-50"><a href="#1）Python安装与版本管理-14-50" class="headerlink" title="1）Python安装与版本管理 ﻿14:50﻿"></a>1）Python安装与版本管理 ﻿14:50﻿</h6><ul><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-2?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-7g6X5BFksW332LvHn5eNIrh54XE%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-1bf45a877f6df9ec30190b61c96eb17486b583ce90e62f985e1eeafec1f63c073f45f83b9114f2f947732e05893d05f18747416aa91b6114305a5e1275657320&amp;expires=8h&amp;r=771730252&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-2&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-2&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=a7e1f23860a769ab07a05bfe2a8de2d58deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>版本选择：<ul><li>推荐Python 3.10或3.11版本</li><li>Mac电脑内置Python 3.8，可覆盖安装</li></ul></li><li>安装位置：<ul><li>Windows避免安装在C盘</li><li>Mac无盘符限制</li></ul></li><li>验证安装：<ul><li>Windows使用where python命令</li><li>Mac使用where python3命令</li><li>注意：C:\Users\Administrator\AppData\Local\Microsoft\WindowsApps\python.exe不是真正的安装路径</li></ul></li></ul><h6 id="2）Jupyter-Notebook使用-14-25"><a href="#2）Jupyter-Notebook使用-14-25" class="headerlink" title="2）Jupyter Notebook使用 ﻿14:25﻿"></a>2）Jupyter Notebook使用 ﻿14:25﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-3?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-EeASQkafxLuSE%2F2tfpJ2dsYoBZI%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-9d394fde795b531d2580561bc0a16c4e7e346fb5c0f7eb0f9b103e80a63da57b1a0bda9eebd39e4e3971fa51154e0fbe31ff62bef839560d305a5e1275657320&amp;expires=8h&amp;r=489872292&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-3&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-3&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca44342240fa99746f4c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>安装方法：</p></li><li><p>启动方式：</p><ul><li>在目标目录下打开终端输入jupyter notebook</li><li>启动后会在当前目录打开</li></ul></li><li><p>浏览器配置</p><p>：</p><ul><li>推荐使用Chrome浏览器</li><li>可复制带token的URL在其他浏览器打开</li></ul></li><li><p>基本操作</p><p>：</p><ul><li>代码单元格与Markdown单元格切换</li><li>运行快捷键：Shift+Enter或Ctrl+Enter</li><li>保存快捷键：Ctrl+S</li></ul></li><li><p>优势</p><p>：</p><ul><li>支持分段执行代码</li><li>适合教学演示和实验性编程</li></ul></li></ul><h6 id="3）PyCharm与VS-Code选择"><a href="#3）PyCharm与VS-Code选择" class="headerlink" title="3）PyCharm与VS Code选择"></a>3）PyCharm与VS Code选择</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-4?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-JZTl6SMvm1aFLPnDfMJLuNNe7Rk%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-1773fed66c0f1d0a1a4cf0128c3249422f18a92631a23ce8fc325850cb1df3bdc46b92fa6b1c915bfca643d8db9ffd4d726695a774e29a57305a5e1275657320&amp;expires=8h&amp;r=145751520&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-4&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-4&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=3612dd02eb4608ab5d190a3cea8128ca8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>PyCharm</p><p>：</p><ul><li>推荐社区版，无需专业版</li><li>启动较慢，需耐心等待</li><li>Mac用户直接使用社区版</li></ul></li><li><p>VS Code</p><p>：</p><ul><li>轻量级替代方案</li><li>适合配置较低的电脑</li></ul></li><li><p>选择建议</p><p>：</p><ul><li>根据个人习惯选择工具</li><li>不要纠结于工具版本</li><li>电脑性能较差时推荐VS Code</li></ul></li></ul><h6 id="4）环境变量配置-32-05"><a href="#4）环境变量配置-32-05" class="headerlink" title="4）环境变量配置 ﻿32:05﻿"></a>4）环境变量配置 ﻿32:05﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-5?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-UucxegEjTz5pM2w5nCJdVbEUGrA%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-f3b166f2b9ec8bb0b9454d6f41cc9f6d2c78e82a018cb6096c2a6eccfe8e2a378949d2ace53e61cc1fa0f8867a009f4bc79aaf275d1df5fc305a5e1275657320&amp;expires=8h&amp;r=740056837&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-5&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-5&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121ca56afef5411c6cb254c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>.env文件</p><p>：</p><ul><li>用于存储敏感信息如API KEY</li><li>格式：OPENAI_API_KEY=”your_key_here”</li></ul></li><li><p>代理设置：</p></li><li><p>加载方法：</p></li></ul><h6 id="5）常用命令"><a href="#5）常用命令" class="headerlink" title="5）常用命令"></a>5）常用命令</h6><ul><li><p>目录操作</p><p>：</p><ul><li>cd：切换目录</li><li>ls(Mac)/dir(Windows)：列出当前目录内容</li></ul></li><li><p>Python相关</p><p>：</p><ul><li>python —version：查看Python版本</li><li>pip install package_name：安装Python包</li></ul></li><li><p>Jupyter相关</p><p>：</p><ul><li>jupyter notebook：启动Notebook</li><li>!pip install package_name：在Notebook中安装包</li></ul></li></ul><h4 id="二、大模型的认知"><a href="#二、大模型的认知" class="headerlink" title="二、大模型的认知"></a>二、大模型的认知</h4><h5 id="1-env文件问题-32-16"><a href="#1-env文件问题-32-16" class="headerlink" title="1. env文件问题 ﻿32:16﻿"></a>1. env文件问题 ﻿32:16﻿</h5><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-6?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-u%2FMDYpThTS0wBOL3x4YWWc6sBUc%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-be110507975da4f7f1c40f44e19794dfda0916cfe9015510c9ebce8be8d45d67f1371b4e7ba41e94af41a6f0ed55359096c4741ad92e9bcd305a5e1275657320&amp;expires=8h&amp;r=511869968&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-6&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-6&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=3612dd02eb4608abcbc79c52d488987e8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>创建步骤</p><p>：</p><ul><li>Windows系统需先显示文件扩展名</li><li>右键新建文本文件后删除前缀，只保留”.env”后缀</li><li>内容必须使用英文引号，格式为：</li></ul></li><li><p>注意事项</p><p>：</p><ul><li>禁止将变量放入系统环境变量</li><li>Jupyter用户需重启内核才能识别新建的env文件</li><li>建议直接复制课件内容避免格式错误</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-7?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-j9ArjIPJCdYi5xtqGQMj%2BX3wT6g%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-6397271a13347297cda92d3430c620c2aa50b59cfae5ef13d04f63cf1b2cabba6c4fe1960f5d014e1c5b4feb25962f92369c695392e1c972305a5e1275657320&amp;expires=8h&amp;r=965441738&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-7&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-7&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=718800a01e5121cabf9c9f5b8bcce4519b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>内容规范</p><p>：</p><ul><li>仅包含API_KEY和BASE_URL两个变量</li><li>所有符号必须为英文半角（包括引号、等号）</li><li>变量名严格区分大小写</li></ul></li></ul><h5 id="2-mac问题-36-38"><a href="#2-mac问题-36-38" class="headerlink" title="2. mac问题 ﻿36:38﻿"></a>2. mac问题 ﻿36:38﻿</h5><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-8?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-b128ju0B%2FrSzZV4RMXTBJ6UUd5E%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-636ad972efc2446118e7ffda020c04fd9f259a8d13af7e0a264a2522afeed634ee8e9aefa9153c27b3086499dce020a7d41643a96f2cf498305a5e1275657320&amp;expires=8h&amp;r=944619035&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-8&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-8&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=2a0349c66f068e0f07c7abd6ae653f448deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>特殊处理</p><p>：</p><ul><li>通过PyCharm/VSCode图形界面创建.env文件</li><li>在IDE中右键项目目录选择”New File”创建</li><li>注意.env是隐藏文件，在Finder中默认不可见</li></ul></li><li><p>验证方法</p><p>：</p><ul><li>使用代码编辑器确认文件内容</li><li>确保没有多余空格或换行符</li></ul></li></ul><h5 id="3-全局环境和虚拟环境问题-40-13"><a href="#3-全局环境和虚拟环境问题-40-13" class="headerlink" title="3. 全局环境和虚拟环境问题 ﻿40:13﻿"></a>3. 全局环境和虚拟环境问题 ﻿40:13﻿</h5><h6 id="1）全局环境和虚拟环境的概念"><a href="#1）全局环境和虚拟环境的概念" class="headerlink" title="1）全局环境和虚拟环境的概念"></a>1）全局环境和虚拟环境的概念</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-9?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-2Jgn%2BYPz7F4IhPScAgyhlQdiRXQ%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-4a8ebd782ad3246f6a58b81b4005d8a3194fd6a08e34315eeb23f1b04e102d1139a4b9b92747c8d12fffeb0f6072f9e2b5d956feccdedf5e305a5e1275657320&amp;expires=8h&amp;r=665301168&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-9&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-9&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=12146e4ffd7df3c9b7d6c8393faaedc69b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>核心区别</p><p>：</p><ul><li>全局环境：通过pip install直接安装到系统Python</li><li>虚拟环境：为每个项目创建隔离的Python运行环境</li></ul></li><li><p>典型场景</p><p>：</p><ul><li>当不同项目需要同一库的不同版本时（如A库需0.1.0和0.1.1）</li><li>避免卸载重装导致的版本冲突</li></ul></li><li><p>优势对比</p><p>：</p><ul><li>虚拟环境允许并行存在多个依赖版本</li><li>项目迁移时可通过requirements.txt重建环境</li></ul></li></ul><h6 id="2）GitHub示例操作-44-18"><a href="#2）GitHub示例操作-44-18" class="headerlink" title="2）GitHub示例操作 ﻿44:18﻿"></a>2）GitHub示例操作 ﻿44:18﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-10?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-aUsGhjRvYTMq%2BRbwbzvSBmIfKJQ%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-432f4f7334996d2cf245d23dabea1856bd4385eae007dd999244da7d6ccd6e79b957df9b05c3919840840249a3b7a07c8064367bb72d4cc2305a5e1275657320&amp;expires=8h&amp;r=207792599&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-10&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-10&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=738aa28698fb94aa61061f9ec8ddb82f8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>行业实践</p><p>：</p><ul><li>项目根目录通常包含requirements.txt或Pipfile</li><li>示例：Dify项目使用Dockerfile管理环境</li></ul></li><li><p>依赖导出</p><p>：</p><ul><li>使用pip freeze &gt; requirements.txt命令</li><li>该文件记录所有依赖包及其精确版本号</li></ul></li><li><p>环境重建：</p></li></ul><h4 id="三、Python环境使用详解-45-21"><a href="#三、Python环境使用详解-45-21" class="headerlink" title="三、Python环境使用详解 ﻿45:21﻿"></a>三、Python环境使用详解 ﻿45:21﻿</h4><h5 id="1-搜索Python相关资源"><a href="#1-搜索Python相关资源" class="headerlink" title="1. 搜索Python相关资源"></a>1. 搜索Python相关资源</h5><h6 id="1）GitHub上的RAG项目"><a href="#1）GitHub上的RAG项目" class="headerlink" title="1）GitHub上的RAG项目"></a>1）GitHub上的RAG项目</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-11?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-4NqRqJSCdSAnIv187EqthjjYdM0%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-2cb95e11025319ea3ec639378ce37491407b8ed91348359972e56181ee7bd17ed8532f626452a98f57e8e9ba6023109a6b6c70a447bf9ad2305a5e1275657320&amp;expires=8h&amp;r=352258822&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-11&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-11&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=12146e4ffd7df3c9bc45b0a9363017654c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>RAGFlow项目：开源RAG（检索增强生成）引擎，基于深度文档理解技术，支持Python语言开发（49.1%代码占比）</p></li><li><p>项目特点</p><p>：</p><ul><li>包含79.8k个相关仓库结果</li><li>支持多语言开发（TypeScript 47.0%，JavaScript 14%）</li><li>最新更新时间为1小时前，活跃度较高</li></ul></li></ul><h6 id="2）项目依赖管理方式"><a href="#2）项目依赖管理方式" class="headerlink" title="2）项目依赖管理方式"></a>2）项目依赖管理方式</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-12?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-wFNwvBe3pMcqs0BbjnH4MPGb0Io%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-60248f215d1402855bcad063fce751838566b3e1e9d43a7bccd151a0d9e977e07ef9f4a213721dd03f3aeb8f5fba3f786e2984ef74575615305a5e1275657320&amp;expires=8h&amp;r=160719341&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-12&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-12&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=4d291be9b94219595d190a3cea8128ca8deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>依赖管理</p><p>：</p><ul><li>现代Python项目普遍采用Docker容器化部署</li><li>通过Dockerfile配置环境依赖（如Python 3.8+、JDK等）</li><li>包含NLTK数据、Tika服务器等专业组件</li></ul></li><li><p>典型依赖项</p><p>：</p><ul><li>基础库：libglib2.0、libgdiplus</li><li>Python包：python-pptx、selenium</li><li>工具链：docker-ce、apt-cacher-ng</li></ul></li></ul><h6 id="3）环境配置要点"><a href="#3）环境配置要点" class="headerlink" title="3）环境配置要点"></a>3）环境配置要点</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-13?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-69oYdj7U5mNyrNbdxCqPZgU%2BE5I%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-161d5ac282b590dbcc7b2e3de76b0d2757ef43dfd97f67482dcda0c11b0a0584b0e9c37d63b3b7481a7bcee0689c82e8f568de92f9f03fda305a5e1275657320&amp;expires=8h&amp;r=359147062&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-13&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-13&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=83f2b583554fba159c9dcc2c5a4d86874c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>关键配置</p><p>：</p><ul><li>使用虚拟环境隔离项目依赖</li><li>避免使用系统默认Python路径（如WindowsApps下的python.exe）</li><li>通过.env文件管理API密钥等敏感信息</li></ul></li><li><p>注意事项</p><p>：</p><ul><li>环境变量引号必须使用英文格式</li><li>不建议将密钥存入系统环境变量</li><li>典型项目结构包含requirements.txt文件管理Python依赖</li></ul></li></ul><h5 id="2-requirements-txt文件-46-00"><a href="#2-requirements-txt文件-46-00" class="headerlink" title="2. requirements.txt文件 ﻿46:00﻿"></a>2. requirements.txt文件 ﻿46:00﻿</h5><ul><li><img src="https://xacu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-14?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-OxX2%2Fq9ctdB9vzLCy8JsS5na2Z0%3D&amp;to=128&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CXian%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-77324a899d9c08ffc7f6cb094d76a1ae398c251980b4b54fc5c50b1986244f0ce55f44b23b8be4e004a0b5e6672185e6327f40277348f836305a5e1275657320&amp;expires=8h&amp;r=371058402&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-14&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-14&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=cf87eda222dfadb79bb24ef744090da98deec605ca7b091f&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>项目依赖管理：在非Docker项目中，requirements.txt是Python项目常见的依赖配置文件</li><li>文件内容：记录了项目所需的所有Python模块及其精确版本号</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-15?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-QeKQgjMpjdVdfFUqUGbSwr17LV0%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-4bd5b43e650416e720d517871603c9e154259dbc58180a71b375e48e5360be028eaa8e93073929836b7c2af1730d78758637e564a2999e13305a5e1275657320&amp;expires=8h&amp;r=719367820&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-15&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-15&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=875e0ff32ac7bd89ec8b61f085efb7e49b0c4e2d279992da&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li><li>典型示例：</li></ul><h6 id="1）文件作用"><a href="#1）文件作用" class="headerlink" title="1）文件作用"></a>1）文件作用</h6><ul><li><p>环境重建：通过该文件可以在新环境中快速安装相同版本的依赖</p></li><li><p>版本控制：确保不同开发者使用完全一致的依赖版本，避免兼容性问题</p></li><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-16?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-15kEX4qsbFSJ26SBMGpr%2FPfd5pY%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-357d63f8d50e15b99bc9b7eaa39d56d0cf6651dfa62028d6376648d428c21e1b5079668402f7abe3675cf63f622d02108795719c726f8ad2305a5e1275657320&amp;expires=8h&amp;r=778508889&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-16&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-16&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e80686faf624695b8f8f85d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>使用方法</p><p>：</p><ul><li>创建虚拟环境后执行pip install -r requirements.txt</li><li>全局环境安装需谨慎，建议使用虚拟环境</li></ul></li></ul><h6 id="2）导出依赖"><a href="#2）导出依赖" class="headerlink" title="2）导出依赖"></a>2）导出依赖</h6><ul><li><p>导出方法：使用pip freeze &gt; requirements.txt命令可将当前环境所有安装包导出</p></li><li><p>注意事项</p><p>：</p><ul><li>仅导出项目必要的依赖，避免包含无关包</li><li>导出版本号确保精确匹配</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-17?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-nKwF7LceyjwaEeQfGPLTImcir%2Bo%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-5e7a02a14ef07ea227116e28969fc72dad9ab82a7323bc512ae858d64a1440849b08ea25ca0d8942d6281632f9e60f1950e0db9d9a2702d0305a5e1275657320&amp;expires=8h&amp;r=751366413&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-17&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-17&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=875e0ff32ac7bd8947990d12e1e064b74c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>版本管理技巧</p><p>：</p><ul><li>全局环境与虚拟环境可以安装不同版本</li><li>项目开发时应固定主要依赖版本</li></ul></li></ul><h6 id="3）与Docker的区别"><a href="#3）与Docker的区别" class="headerlink" title="3）与Docker的区别"></a>3）与Docker的区别</h6><ul><li><p>轻量级方案：相比Docker容器化，requirements.txt提供更轻量的环境配置方案</p></li><li><p>适用场景</p><p>：</p><ul><li>快速分享Python项目依赖配置</li><li>不需要完整系统环境复现的场景</li><li>开发初期快速搭建环境</li></ul></li></ul><h5 id="3-问题答疑-47-34"><a href="#3-问题答疑-47-34" class="headerlink" title="3. 问题答疑 ﻿47:34﻿"></a>3. 问题答疑 ﻿47:34﻿</h5><h6 id="1）全局环境与虚拟环境-47-51"><a href="#1）全局环境与虚拟环境-47-51" class="headerlink" title="1）全局环境与虚拟环境 ﻿47:51﻿"></a>1）全局环境与虚拟环境 ﻿47:51﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-18?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-x%2FdW36NOD4zol8W%2BMDMcJqMfrOo%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-41826015bf2fb90f42a26b8d22fffaf4ed1d2b2e3a3c0308ed65ec21f3542a3798b9699fde12fbb7654ca539a1885b5b4d1efe65067b8260305a5e1275657320&amp;expires=8h&amp;r=148477954&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-18&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-18&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e8068173f2ae99a7b5b754c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>环境区别</p><p>:</p><ul><li>全局环境：通过pip install a=1.1.1安装的包对所有项目生效</li><li>虚拟环境：每个项目独立环境（如a=0.1.0），避免包版本冲突</li></ul></li><li><p>项目实践：建议每个项目创建独立虚拟环境，防止不同项目间的依赖冲突</p></li></ul><h6 id="2）设置Python环境-48-27"><a href="#2）设置Python环境-48-27" class="headerlink" title="2）设置Python环境 ﻿48:27﻿"></a>2）设置Python环境 ﻿48:27﻿</h6><ul><li><p><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-19?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-6dFLNc9oS5bymWiy45Qxhiow69Q%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-aed8cf7f410ac1216ca84a29f0d0b2ace81a895a46b6bf0bb5e1edaae0df7b15261aa6fcf703c0939e12f4011da1440937df430708a6bc16305a5e1275657320&amp;expires=8h&amp;r=960790681&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-19&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-19&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=b3434a369726e9249598d5fd593929895d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>环境查询</p><p>：</p><ul><li>使用where python命令查看当前使用的Python解释器路径</li><li>第一个显示的路径即为当前激活环境</li></ul></li><li><p>环境切换</p><p>：</p><ul><li>在PyCharm中通过Settings &gt; Project &gt; Python Interpreter修改</li><li>可添加系统环境（System）或指定虚拟环境路径</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-20?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-4nCJW3Ign3Rjiq6yFMCBKdB8Oo8%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-98c4fd0a2739a159d33133f8b6eb0deab6ce9b8bfde1be0f4d83ea9a969d4385635d1a5ce8141ccbbd645daa2ad559895f6bb07b709c5aaa305a5e1275657320&amp;expires=8h&amp;r=537284088&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-20&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-20&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e8068c32f23017ea016b05d769a06a6f8ff993639323619ab123a&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>配置选项</p><p>：</p><ul><li>System：全局Python环境</li><li>Virtualenv：虚拟环境</li><li>Conda：Anaconda环境</li><li>Pipenv：Pipenv管理环境</li></ul></li><li><p>操作步骤</p><p>：</p><ul><li>点击”Add Interpreter”</li><li>选择环境类型</li><li>指定解释器路径（如D:\Python310\python.exe）</li></ul></li></ul><h6 id="3）虚拟环境的使用-49-12"><a href="#3）虚拟环境的使用-49-12" class="headerlink" title="3）虚拟环境的使用 ﻿49:12﻿"></a>3）虚拟环境的使用 ﻿49:12﻿</h6><ul><li><p><img src="https://yqcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-21?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-7jLFkxB6FxeU08%2B5uhpxsgn8Yeg%3D&amp;to=119&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-8e9c442e1d87f4f47e0e8a5f8301dab4878bcedf577c0be0875b21f332c2b8b66ca3420c05c8026f60b279b4c5632935f2fac3c06a1329fc305a5e1275657320&amp;expires=8h&amp;r=143797820&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-21&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-21&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=1524a5cd531d02e5ccc7bc964f060af44c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></p></li><li><p>存储位置</p><p>：</p><ul><li>默认路径：C:\Users\Administrator\llm_agent</li><li>包含不同项目的独立环境（如langchain、RAG等）</li></ul></li><li><p>创建原则</p><p>：</p><ul><li>PyCharm一般使用全局环境</li><li>项目开发时需创建专属虚拟环境</li><li>通过venv或virtualenv工具创建</li><li><img src="https://bdcu01.baidupcs.com/file/p-f26333f5f50c2d48e13625874f318371-40-2025042100-22?bkt=en-3de6f374fcad9f514a94920d227b7f50&amp;fid=282335-250528-&amp;time=1765207027&amp;sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-muVY0OJdpEoghIsywItzHJu5L6c%3D&amp;to=136&amp;size=10&amp;sta_dx=10&amp;sta_cs=0&amp;sta_ft=&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CBaoding%2CAnywhere%2C%2C广东%2Ccnc&amp;ctime=0&amp;mtime=0&amp;dt3=0&amp;resv0=-1&amp;resv1=0&amp;resv2=rlim&amp;resv3=5&amp;resv4=10&amp;vuk=0&amp;iv=2&amp;vl=0&amp;htype=&amp;randtype=&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=en-3a757c683469977b6ecbb793adf48e76cba8bdacf7adf1ed36cfd28cceaf1a85029dafb1c2f9b31479aab4e4414aada59f2cb109bba34fad305a5e1275657320&amp;expires=8h&amp;r=988533937&amp;vbdid=-&amp;fin=p-f26333f5f50c2d48e13625874f318371-40-2025042100-22&amp;fn=p-f26333f5f50c2d48e13625874f318371-40-2025042100-22&amp;rtype=1&amp;dp-logid=9084176436728216142&amp;dp-callid=0.1&amp;hps=1&amp;tsl=0&amp;csl=0&amp;fsl=-1&amp;csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&amp;so=0&amp;ut=1&amp;uter=1&amp;serv=-1&amp;uc=741949868&amp;ti=66239664855e80684cf9f0f2313dbfba4c88d07557ce4a43305a5e1275657320&amp;hflag=30&amp;from_type=&amp;adg=n&amp;reqlabel=250528_n_6b9a84f07cc8d87d9fb3f04e181a8479_0_6e9ee3c1076923df6c6b82e025aca87e&amp;chkv=5&amp;bid=250528&amp;by=themis" alt="img"></li></ul></li><li><p>管理技巧</p><p>：</p><ul><li>环境命名建议与项目名称关联（如langchain_env）</li><li>路径中应包含Scripts\python.exe可执行文件</li><li>激活后终端提示符会显示环境名称</li></ul></li><li><p>最佳实践</p><p>：</p><ul><li>开发时：使用项目专属虚拟环境</li><li>测试时：可切换至全局环境验证兼容性</li><li>部署时：通过requirements.txt固化依赖版本</li></ul></li></ul><h5 id="4-VScode-51-24"><a href="#4-VScode-51-24" class="headerlink" title="4. VScode ﻿51:24﻿"></a>4. VScode ﻿51:24﻿</h5><ul><li><p>主要用途：常被当作记事本使用，但实际是功能强大的代码编辑器</p></li><li><p>汉化设置</p><p>：</p><ul><li>搜索安装”Chinese”插件实现汉化</li><li>默认英文界面，汉化后更易理解但可能影响准确性</li></ul></li><li><p>插件推荐</p><p>：</p><ul><li>Code Runner：用于运行代码</li><li>Python扩展：支持Python开发</li><li>Jupyter支持：可运行.ipynb文件（但老师个人不推荐）</li></ul></li><li><p>优势特点</p><p>：</p><ul><li>插件生态丰富，支持多种语言</li><li>内存占用小，适合配置较低的设备</li><li>支持文件夹项目管理</li></ul></li><li><p>使用建议</p><p>：</p><ul><li>初学者可先汉化后逐步过渡到英文</li><li>虚拟环境设置需自行搜索配置</li></ul></li></ul><h5 id="5-PyCharm-55-17"><a href="#5-PyCharm-55-17" class="headerlink" title="5. PyCharm ﻿55:17﻿"></a>5. PyCharm ﻿55:17﻿</h5><ul><li><p>使用习惯：老师主要开发工具，已习惯英文界面</p></li><li><p>对比优势</p><p>：</p><ul><li>专业Python IDE，功能更全面</li><li>但内存占用较大</li></ul></li><li><p>汉化说明：支持汉化但不推荐，可能影响功能理解</p></li></ul><h5 id="6-Anaconda-55-38"><a href="#6-Anaconda-55-38" class="headerlink" title="6. Anaconda ﻿55:38﻿"></a>6. Anaconda ﻿55:38﻿</h5><ul><li><p>适用人群：不推荐零基础学习者使用</p></li><li><p>主要问题</p><p>：</p><ul><li>虚拟环境概念对新手较复杂</li><li>环境配置容易造成混淆</li></ul></li><li><p>替代方案：建议初学者使用PyCharm或VS Code</p></li></ul><h5 id="7-应用案例-59-01"><a href="#7-应用案例-59-01" class="headerlink" title="7. 应用案例 ﻿59:01﻿"></a>7. 应用案例 ﻿59:01﻿</h5><h6 id="1）例题-打印问题"><a href="#1）例题-打印问题" class="headerlink" title="1）例题:打印问题"></a>1）例题:打印问题</h6><ul><li>题目解析<ul><li>换行实现对比：<ul><li>单引号/双引号需手动添加转义字符\n</li><li>三引号自动支持多行文本</li></ul></li><li>本质区别：<ul><li>都是字符串类型（str）</li><li>语法形式不同但功能等价</li></ul></li><li>实际应用：<ul><li>多行文本处理时三引号更便捷</li><li>简单字符串可使用单/双引号</li></ul></li></ul></li></ul><h6 id="2）例题-三引号作用-59-12"><a href="#2）例题-三引号作用-59-12" class="headerlink" title="2）例题:三引号作用 ﻿59:12﻿"></a>2）例题:三引号作用 ﻿59:12﻿</h6><ul><li>题目解析<ul><li>核心功能：<ul><li>实现多行字符串定义</li><li>避免频繁使用转义字符</li></ul></li><li>类型验证：<ul><li>使用type()检查均为str类型</li></ul></li><li>使用场景：<ul><li>长文本处理</li><li>文档字符串(Docstring)</li></ul></li></ul></li></ul><p>需要保留原始格式的文本</p><ul><li><ul><li><ul><li>注：本笔记已按照康奈尔笔记法结构化整理，保留了所有关键知识点、使用建议和对比分析，并确保与课程内容完全对应。对于代码运行环境配置等实操性内容，建议结合具体开发环境进行实践验证。</li></ul></li></ul></li></ul><h5 id="8-在线编译器-01-00-34"><a href="#8-在线编译器-01-00-34" class="headerlink" title="8. 在线编译器 ﻿01:00:34﻿"></a>8. 在线编译器 ﻿01:00:34﻿</h5><h6 id="1）MasterCode工具介绍"><a href="#1）MasterCode工具介绍" class="headerlink" title="1）MasterCode工具介绍"></a>1）MasterCode工具介绍</h6><ul><li>核心功能：提供在线Python代码编写和运行环境，无需本地安装</li><li>适用场景：适合初学者快速验证基础语法，解决环境配置问题</li><li>访问方式：通过网页直接体验，老师推荐的学习工具</li><li>版本信息：默认使用Python 3.9.x版本环境</li></ul><h6 id="2）基础操作指南"><a href="#2）基础操作指南" class="headerlink" title="2）基础操作指南"></a>2）基础操作指南</h6><ul><li><p>项目创建</p><p>：</p><ul><li>新建项目时可自定义项目名称（如P007）</li><li>详情设置保持默认即可</li></ul></li><li><p>文件管理</p><p>：</p><ul><li>可删除默认生成的文件</li><li>支持新建.py文件（如demo.py）</li></ul></li><li><p>代码执行</p><p>：</p><ul><li>右键选择”Run”运行当前文件</li><li>支持通过顶部按钮运行主程序</li></ul></li></ul><h6 id="3）AI辅助功能"><a href="#3）AI辅助功能" class="headerlink" title="3）AI辅助功能"></a>3）AI辅助功能</h6><ul><li><p>代码解释</p><p>：</p><ul><li>选中代码后点击”解释”获取AI分析</li><li>支持整段代码的逐行解释（如环境变量加载、实例化过程等）</li></ul></li><li><p>注释生成</p><p>：</p><ul><li>自动为方法添加功能说明文档</li><li>包含参数说明和返回值描述</li><li>用户可选择接受(Y)或拒绝(N)生成的注释</li></ul></li><li><p>代码对话</p><p>：</p><ul><li>可询问方法调用方式等具体问题</li><li>提供使用示例和返回结果说明</li></ul></li></ul><h6 id="4）环境配置"><a href="#4）环境配置" class="headerlink" title="4）环境配置"></a>4）环境配置</h6><ul><li><p>模块安装</p><p>：</p><ul><li>支持通过pip install安装第三方库</li><li>安装速度快（如openai 1.59.6版本）</li></ul></li><li><p>系统限制</p><p>：</p><ul><li>内存上限4GB</li><li>硬盘空间有限制</li><li>不适合运行大型项目</li></ul></li></ul><h5 id="9-问题答疑-01-12-05"><a href="#9-问题答疑-01-12-05" class="headerlink" title="9. 问题答疑 ﻿01:12:05﻿"></a>9. 问题答疑 ﻿01:12:05﻿</h5><h6 id="1）虚拟环境问题"><a href="#1）虚拟环境问题" class="headerlink" title="1）虚拟环境问题"></a>1）虚拟环境问题</h6><ul><li>处理方案：将在正式课程中详细讲解虚拟环境创建和使用</li><li>应用场景：后续项目开发时会实际应用</li></ul><h6 id="2）程序员工作方式"><a href="#2）程序员工作方式" class="headerlink" title="2）程序员工作方式"></a>2）程序员工作方式</h6><ul><li><p>开发流程</p><p>：</p><ul><li>项目前期进行技术评审和框架选定</li><li>在确定的技术框架基础上实现需求</li></ul></li><li><p>代码编写</p><p>：</p><ul><li>传统开发以手写代码为主</li><li>固定代码段可采用复制粘贴</li><li>现代开发可结合AI辅助</li></ul></li><li><p>岗位区分</p><p>：</p><ul><li>开发、运维、设计等不同岗位工作内容差异大</li><li>不同编程语言有对应的专用框架</li></ul></li></ul><h6 id="3）网页运行原理"><a href="#3）网页运行原理" class="headerlink" title="3）网页运行原理"></a>3）网页运行原理</h6><ul><li>课程关联：已在前期课程中多次讲解网页运行机制</li><li>框架学习：后续将学习LangChain等专业框架的使用</li></ul><h4 id="四、Streamlit使用指南-01-15-23"><a href="#四、Streamlit使用指南-01-15-23" class="headerlink" title="四、Streamlit使用指南 ﻿01:15:23﻿"></a>四、Streamlit使用指南 ﻿01:15:23﻿</h4><h5 id="1-运行方法"><a href="#1-运行方法" class="headerlink" title="1. 运行方法"></a>1. 运行方法</h5><ul><li><p>运行命令: 使用streamlit run命令运行项目，需先定位到项目目录</p></li><li><p>目录定位方法</p><p>:</p><ul><li>在文件资源管理器中打开项目文件夹</li><li>通过cmd或终端进入项目目录</li><li>在PyCharm等IDE中，终端默认打开当前项目目录</li></ul></li></ul><h5 id="2-运行机制"><a href="#2-运行机制" class="headerlink" title="2. 运行机制"></a>2. 运行机制</h5><ul><li><p>自动启动: 运行后会默认打开浏览器显示界面</p></li><li><p>网络配置</p><p>:</p><ul><li>使用本机IP地址</li><li>端口号由Streamlit自动分配</li><li>首次运行直接敲回车即可</li></ul></li></ul><h5 id="3-环境注意事项"><a href="#3-环境注意事项" class="headerlink" title="3. 环境注意事项"></a>3. 环境注意事项</h5><ul><li><p>Windows系统</p><p>:</p><ul><li>用户名路径不要使用中文</li><li>项目路径避免包含中文字符</li></ul></li><li><p>目录结构</p><p>:</p><ul><li>项目应组织在单一文件夹内</li><li>打开最上层文件夹即可访问整个项目</li></ul></li></ul><h5 id="4-Streamlit优势探究"><a href="#4-Streamlit优势探究" class="headerlink" title="4. Streamlit优势探究"></a>4. Streamlit优势探究</h5><ul><li><p>作业要求</p><p>:</p><ul><li>对比Streamlit与其他框架的区别</li><li>分析Streamlit的独特优势</li><li>研究为何选择Streamlit开发界面</li></ul></li></ul><h5 id="5-开发建议"><a href="#5-开发建议" class="headerlink" title="5. 开发建议"></a>5. 开发建议</h5><ul><li><p>调试技巧</p><p>:</p><ul><li>通过与大模型对话解决编码问题</li><li>遇到问题时先分析错误信息</li></ul></li><li><p>教学目的</p><p>:</p><ul><li>重点掌握实际应用方法</li><li>理解问题解决思路比直接看结果更重要</li></ul></li></ul><h4 id="五、知识小结"><a href="#五、知识小结" class="headerlink" title="五、知识小结"></a>五、知识小结</h4><div class="table-container"><table><thead><tr><th>知识点</th><th>核心内容</th><th>考试重点/易混淆点</th><th>难度系数</th></tr></thead><tbody><tr><td>Python环境配置</td><td>全局环境与虚拟环境区别、jupyter notebook使用技巧</td><td>虚拟环境路径设置、不同系统命令差异(Win/mac)</td><td>⭐⭐⭐</td></tr><tr><td>代码调试方法</td><td>VS Code/PyCharm调试配置、在线编译器(MasterCode)使用</td><td>环境变量(.env)加载机制、浏览器兼容性问题</td><td>⭐⭐</td></tr><tr><td>Python基础语法</td><td>数据类型/函数/面向对象三大知识模块</td><td>三引号字符串特性、递归函数理解</td><td>⭐⭐⭐⭐</td></tr><tr><td>大模型开发基础</td><td>API密钥管理、Streamlit框架应用</td><td>代理设置、端点URL配置</td><td>⭐⭐⭐⭐</td></tr><tr><td>学习资源推荐</td><td>B站基础教程、AI代码解释工具</td><td>官方文档与第三方资源取舍</td><td>⭐</td></tr><tr><td>项目部署实践</td><td>requirements.txt文件作用、Docker基础概念</td><td>依赖版本冲突解决</td><td>⭐⭐⭐⭐</td></tr><tr><td>开发工具对比</td><td>PyCharm社区版/专业版差异、Jupyter分段执行优势</td><td>内存占用优化、快捷键配置</td><td>⭐⭐</td></tr><tr><td>代码理解技巧</td><td>AI辅助注释生成、多行代码解释方法</td><td>上下文关联分析</td><td>⭐</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、python基础语法-08-47&quot;&gt;&lt;a href=&quot;#一、python基础语法-08-47&quot; class=&quot;headerlink&quot; title=&quot;一、python基础语法 ﻿08:47﻿&quot;&gt;&lt;/a&gt;一、python基础语法 ﻿08:47﻿&lt;/h4&gt;&lt;h5 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Solidity智能合约零基础入门（二）Solidity基础语法</title>
    <link href="https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89Solidity%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2025-11-30T09:26:22.000Z</published>
    <updated>2025-12-17T05:45:08.024Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-gAbYerzl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2086093868" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#b76f40"    ></div><h2 id="Solidity基础语法"><a href="#Solidity基础语法" class="headerlink" title="Solidity基础语法"></a>Solidity基础语法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Solidity是一种合约导向编程语言，用于编写智能合约，运行在Ethereum虚拟机（EVM）上。本文档将为您介绍Solidity的基本语法和概念，帮助您快速上手智能合约开发。</p><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-functions">函数</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰器</a>、<a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-events">事件</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>、 和 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleStorage &#123;<br>    <span class="hljs-built_in">uint</span> storedData; <span class="hljs-comment">// 状态变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有效的状态变量类型参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#types">类型</a> 章节， 对状态变量可见性有可能的选择参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a> 。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123; <span class="hljs-comment">// 函数</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#function-calls">函数调用</a> 可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a>）。</p><h4 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifiers">函数 </a>）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.22</span>;<br><br>contract Purchase &#123;<br>    address <span class="hljs-keyword">public</span> seller;<br><br>    <span class="hljs-function">modifier <span class="hljs-title">onlySeller</span>()</span> &#123; <span class="hljs-comment">// 修饰器</span><br>        require(<br>            msg.sender == seller,<br>            <span class="hljs-string">&quot;Only seller can call this.&quot;</span><br>        );<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">abort</span>() <span class="hljs-keyword">public</span> onlySeller</span> &#123; <span class="hljs-comment">// Modifier usage</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.21</span>;<br>contract SimpleAuction &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">address bidder, <span class="hljs-built_in">uint</span> amount</span>)</span>; <span class="hljs-comment">// 事件</span><br><br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">emit <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>; <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events">事件</a>。</p><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>结构是可以将几个变量分组的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#structs">结构体</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Ballot &#123;<br>    <span class="hljs-keyword">struct</span> Voter &#123; <span class="hljs-comment">// 结构</span><br>        <span class="hljs-built_in">uint</span> weight;<br>        <span class="hljs-built_in">bool</span> voted;<br>        address <span class="hljs-built_in">delegate</span>;<br>        <span class="hljs-built_in">uint</span> vote;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#enums">枚举类型</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    <span class="hljs-keyword">enum</span> State &#123; Created, Locked, Inactive &#125; <span class="hljs-comment">// 枚举</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p><code>bool</code> ：可能的取值为常数值 <code>true</code> 和 <code>false</code>。</p><p>运算符：</p><ul><li><code>!</code> (逻辑非)</li><li><code>&amp;&amp;</code> (逻辑与, “and”)</li><li><code>||</code> (逻辑或, “or”)</li><li><code>==</code> (等于)</li><li><code>!=</code> (不等于)</li></ul><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。 就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> / <code>false</code> ， 那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><code>int</code> / <code>uint</code>: 分别表示有符号和无符号的不同位数的整型变量。 关键字 <code>uint8</code> 到 <code>uint256</code> （无符号整型，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>， 以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> (异或)， <code>~</code> (位取反)</li><li>移位运算符： <code>&lt;&lt;</code> （左移）， <code>&gt;&gt;</code> （右移）</li><li>算数运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code> （只适用于有符号的整数）， <code>*</code>， <code>/</code>， <code>%</code> (取余)， <code>**</code> (幂)</li></ul><p>对于一个整数类型 <code>X</code>，您可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 来访问该类型代表的最小值和最大值。</p><h5 id="定长浮点型"><a href="#定长浮点型" class="headerlink" title="定长浮点型"></a>定长浮点型</h5><blockquote id="fn_警告"><sup>警告</sup>. Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。<a href="#reffn_警告" title="Jump back to footnote [警告] in the text."> &#8617;</a></blockquote><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中， <code>M</code> 表示该类型占用的位数， <code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x18</code> 和 <code>fixed128x18</code> 的别名。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>fixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>ufixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>ufixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回值是布尔型）</li><li>算术运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code> (取余数)</li></ul><h5 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h5><p>地址类型有两种大致相同的类型：</p><ul><li><code>address</code>: 保存一个20字节的值（一个以太坊地址的大小）。</li><li><code>address payable</code>: 与 <code>address</code> 类型相同，但有额外的方法 <code>transfer</code> 和 <code>send</code>。</li></ul><p>这种区别背后的想法是， <code>address payable</code> 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 <code>address</code>，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">address addr <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990<span class="hljs-comment">;</span><br>address payable addr_pay <span class="hljs-operator">=</span> payable(<span class="hljs-number">0</span>x8306300ffd616049FD7e4b0354a64Da835c1A81C)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li><code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> 和 <code>&gt;</code></li></ul><h5 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h5><p>值类型 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code> 代表从1到32的字节序列。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bytes32 public _byte32 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MiniSolidity&quot;</span><span class="hljs-comment">; </span><br><br>bytes1 public _byte <span class="hljs-operator">=</span> _byte32[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> (返回 <code>bool</code>)</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li><li>索引访问： 如果 <code>x</code> 是 <code>bytesI</code> 类型，那么当 <code>0 &lt;= k &lt; I</code> 时， <code>x[k]</code> 返回第 <code>k</code> 个字节（只读）。</li></ul><p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型）， 它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p><p>成员变量：</p><ul><li><code>.length</code> 表示这个字节数组的长度（只读）.</li></ul><h5 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。</p><p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code>0</code> 开始无符号整数值表示。</p><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 您可以得到给定枚举的最小值和最大值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br>contract test &#123;<br>    <span class="hljs-built_in">enum</span> ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;<br>    ActionChoices choice;<br>    ActionChoices constant defaultChoice = ActionChoices.GoStraight;<br><br>    <span class="hljs-function">function <span class="hljs-title">setGoStraight</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        choice = ActionChoices.GoStraight;<br>    &#125;<br><br>    <span class="hljs-comment">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span><br>    <span class="hljs-comment">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span><br>    <span class="hljs-function">function <span class="hljs-title">getChoice</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> choice;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getDefaultChoice</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">uint</span>(defaultChoice);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getLargestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).max;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getSmallestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 </p><p>类似的格式如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> &lt;<span class="hljs-keyword">function</span> <span class="hljs-type">name</span>&gt; (&lt;parameter <span class="hljs-keyword">types</span>&gt;) &#123;<span class="hljs-type">internal</span>|<span class="hljs-keyword">external</span>|<span class="hljs-built_in">public</span>|private&#125; &#123;modifier&#125; [pure|<span class="hljs-keyword">view</span>|payable] [<span class="hljs-keyword">returns</span> (&lt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">types</span>&gt;)]<br></code></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Solidity 中，相比于值类型，引用类型更复杂，通常包括占用更多内存的数组和结构体。当处理这些复杂的引用类型时，需要谨慎考虑它们的数据位置。</p><p>所有引用类型（如数组和结构体）都具有一个 “数据位置” 属性，指明数据是存储在内存中还是存储中。大多数情况下，数据位置有默认值，但可以通过在类型名后加 <code>storage</code> 或 <code>memory</code> 来显式指定。</p><ul><li><strong>memory</strong>：用于临时存储，数据在执行完后会被销毁。</li><li><strong>storage</strong>：用于持久保存，数据会永久保存，直到被修改或删除。</li><li><strong>calldata</strong>：只读，常用于存储外部函数的参数。</li></ul><h6 id="默认数据位置："><a href="#默认数据位置：" class="headerlink" title="默认数据位置："></a>默认数据位置：</h6><ul><li>函数参数（包括返回参数）的默认位置是 <strong>内存 (memory)</strong>。</li><li>局部变量的默认位置是 <strong>存储 (storage)</strong>。</li><li>状态变量的数据位置强制为 <strong>存储 (storage)</strong>。</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity ^0.8.0;<br>contract C &#123;<br>    // 我们选择使用string类型，这里使用storage。<br>    // 需要注意的是，在该位置时默认数据为storage，这个可以忽略<br>    // 这是因为状态变量不需要指定数据位置，默认为storage<br>    string public x;<br>    // memoryArray 的数据存储位置是 memory<br>    // 我们也可以给他的数据存储位置为 calldata<br>    function f(string memory memoryString) public&#123;<br>      // memoryString = &quot;hello&quot;<br>       x = memoryString;<br>    &#125;<br>    // calldata<br>    // memory<br>    function g(string calldata ) external &#123;<br>    &#125;<br>    // storage<br>    function h(string storage ) internal  &#123;    <br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="数据位置的重要性"><a href="#数据位置的重要性" class="headerlink" title="数据位置的重要性"></a>数据位置的重要性</h6><p>数据位置影响赋值行为：</p><ul><li>在 <strong>存储 (storage)</strong> 和 <strong>内存 (memory)</strong> 之间赋值会创建新的拷贝。</li><li><strong>存储 (storage)</strong>进行 赋值时，只会传递引用，不会创建新副本。</li><li><strong>内存 (memory)</strong> 之间的赋值通常不会创建新副本，因为它们共享相同的数据。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>强制指定的数据位置</strong>：<ul><li>外部函数,也就是<code>external</code>，形参的数据位置可以为 <code>calldata</code>，也可以为<code>memory</code>，但是绝对不是<code>storage</code>，<code>public</code>同理。</li><li>状态变量为 <code>storage</code>，也可以指定函数形参的数据位置为<code>storage</code>，不过基本上只能在内部函数<code>internal</code>执行。</li></ul></li><li><strong>默认数据位置</strong>：<ul><li>函数参数（包括返回参数）为 <code>memory</code>，也可以为<code>calldata</code>。</li><li>其他局部变量为 <code>storage</code>。</li></ul></li></ul><hr><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>Solidity 支持两种类型的数组：固定长度数组和动态数组。</p><p>一个元素类型为 <code>T</code>，固定长度为 <code>k</code> 的数组可以声明为 <code>T[k]</code>， 而动态数组声明为 <code>T[]</code>。</p><p><strong>固定长度数组</strong>:<code>uint[5]</code>,<code>uint[2][5]</code> …</p><p><strong>动态数组</strong>:<code>uint[]</code>,<code>uint[][5]</code> …</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[5] a = [1,2,3,4,5]; // 5 element array<br>uint[5] b;<br>uint[] c;<br>uint[] d = [1,2,3,4,5];<br></code></pre></td></tr></table></figure><p><strong>索引</strong>: 对元素中的一个数据进行定位，数组索引从0开始，访问一个数组中的其中一个元素，访问时的下标顺序与声明时相反。访问一个超过它的末端的数组会导致一个失败的断言。 </p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnOne() public view returns (uint)&#123;<br>    return d[0];//返回第一个元素<br>&#125;    <br>function returntwo() public view returns (uint)&#123;<br>    return d[1];//返回第二个元素<br>&#125;    <br></code></pre></td></tr></table></figure><p><strong>数组成员</strong>:</p><ul><li><p><strong>length</strong>:</p><p>数组有 <code>length</code> 成员变量表示当前数组的长度。一经创建， 内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时数组的参数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnLength() public view returns (uint)&#123;<br>    return d.length;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push()</code> 的成员函数， 您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用， 因此可以像 <code>x.push().t = 2</code> 或 <code>x.push() = b</code> 那样使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>     c.push();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push(x)</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push(x)</code> 的成员函数， 您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>d.push(x);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>pop()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>pop()</code> 的成员函数， 您可以用它来从数组的末端移除一个元素。 这也隐含地在被删除的元素上调用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete">delete</a>。该函数不返回任何东西。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function del() public&#123;<br>    d.pop(); //删除末尾<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建内存数组</strong>:具有动态长度的内存数组可以使用 <code>new</code> 操作符创建。 与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code>.push</code> 成员函数不可用）。 您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p><p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a> 进行初始化。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function createMemoryArray(uint len) public view returns (uint[] memory)&#123;<br>       uint[] memory arr = new uint[](len); //创建长度为len的内存数组<br>       arr[0] = 1;<br>       arr[1] = 2;<br>       return arr;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>数组切片</strong>: <code>x[start:end]</code></p><p>数组切片是对一个数组的连续部分的预览。 它们被写成 <code>x[start:end]</code>，其中 <code>start</code> 和 <code>end</code> 是表达式， 结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code>x[start]</code>， 最后一个元素是 <code>x[end - 1]</code>。</p><p>如果 <code>start</code> 大于 <code>end</code>，或者 <code>end</code> 大于数组的长度， 就会出现异常。</p><p><code>start</code> 和 <code>end</code> 都是可选的： <code>start</code> 默认为 <code>0</code>， <code>end</code> 默认为数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function get(uint[] calldata arr) public view returns (uint[] calldata)&#123;<br>      return arr[:6];<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>数组元素</strong>：数组元素可以是任何类型，包括映射或结构体。 并适用于类型的一般限制，映射只能存储在 <code>storage</code> 数据位置,下面是一些特殊的数组。</p><p><strong>bytes</strong></p><p><code>bytes</code> 类似于 <code>bytes1[]</code>， 但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。</p><p>您应该使用 <code>bytes</code> 而不是 <code>bytes1[]</code>，因为它更便宜， 因为在 <code>memory</code> 中使用 <code>bytes1[]</code> 会在元素之间增加31个填充字节。  一般来说，对于任意长度的原始字节数据使用 <code>bytes</code>，对于任意长度的字符串（UTF-8）数据使用 <code>string</code>。 如果您能将长度限制在一定的字节数，使用 <code>bytes1</code> 到 <code>bytes32</code> 中的一种值类型，因为它们更便宜。</p><p>函数:  <code>bytes.concat</code></p><p><code>bytes.concat</code> 函数可以连接任意数量的 <code>bytes</code> 或 <code>bytes1 ... bytes32</code> 值。 该函数返回一个单一的 <code>bytes memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用字符串参数或其他不能隐式转换为 <code>bytes</code> 的类型， 您需要先将它们转换为 <code>bytes</code> 或 <code>bytes1</code> /…/ <code>bytes32</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>string</strong></p><p><code>string</code> 与 <code>bytes</code> 相同，但不允许用长度或索引来访问。</p><p>Solidity没有字符串操作函数，但有第三方的字符串库。 可以用 <code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code> 来比较两个字符串的keccak256-hash，用 <code>string.concat(s1, s2)</code> 来连接两个字符串。</p><p>函数: <code>string.concat</code></p><p>可以使用 <code>string.concat</code> 连接任意数量的 <code>string</code> 值。 该函数返回一个单一的 <code>string memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用不能隐式转换为 <code>string</code> 的其他类型的参数，您需要先将它们转换为 <code>string</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>Solidity 支持通过结构体定义新类型。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract Struct&#123;<br>    struct user&#123;<br>        string name;<br>        uint age;<br>        string email;<br>    &#125;<br>    // function add(string memory name, uint age, string memory email)<br>    // public view returns (user memory)&#123;<br>    //     user memory newUser = user(name, age, email);<br>    //     return newUser;<br>    // &#125;<br>    user user1;<br>    function add(string memory name, uint age, string memory email)<br>    external&#123;<br>        user storage newUser = user1;<br>        newUser.name =&quot;hello&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="结构体的赋值和访问"><a href="#结构体的赋值和访问" class="headerlink" title="结构体的赋值和访问"></a>结构体的赋值和访问</h6><ul><li><strong>存储结构体</strong>：当结构体赋值给局部变量时，并不会复制数据，而是传递引用。</li><li><strong>成员访问</strong>：可以直接访问结构体的成员，例如 <code>campaigns[campaignID].amount = 0;</code>。</li></ul><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><h5 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h5><p><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择Solidity内置的值类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。下面这个例子会报错，因为<code>_KeyType</code>使用了我们自定义的结构体：</p><p><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</p><p><strong>规则3</strong>：如果映射声明为<code>public</code>，那么Solidity会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</p><p><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</p><h5 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h5><p><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</p><p><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。<a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage</a>)</p><p><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</p><h5 id="在Remix上验证-以-Mapping-sol为例"><a href="#在Remix上验证-以-Mapping-sol为例" class="headerlink" title="在Remix上验证 (以 Mapping.sol为例)"></a>在Remix上验证 (以 <code>Mapping.sol</code>为例)</h5><p>映射示例 1 部署</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/69dd365d690ea6ed3c8368f45a16d25a.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632090332-1f40dddf-c031-4692-8317-b15bc0d2d49e.jpeg" alt="img"></p><p>映射示例 3 key-value pair</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632088903-2bf9034a-c080-4d04-a18e-5cef2ce4ae1d.jpeg" alt="img"></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>在Solidity智能合约中，以下是一些常见运算符的简要说明和示例：</p><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a><strong>三元运算符</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">条件表达式</span>&gt;</span> ? <span class="hljs-tag">&lt;<span class="hljs-name">true条件表达式</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">false条件表达式</span>&gt;</span><br></code></pre></td></tr></table></figure><p>允许根据条件表达式选择执行两个表达式之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint public a = 10;<br>uint b = 20;<br>uint public x;<br>uint public max = a &gt; b ? a : b;<br>uint public min = a &lt; b ? a : b;<br></code></pre></td></tr></table></figure><h5 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a><strong>复合赋值运算符</strong></h5><p> <code>-=</code>，<code>+=</code>, <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>|=</code>， <code>&amp;=</code>， <code>^=</code>， <code>&lt;&lt;=</code> 和 <code>&gt;&gt;=</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function jian(uint y) public &#123;<br>        // a = a - y;<br>        a -= y;<br>    &#125;<br>    function add(uint y) public &#123;<br>        // a = a + y;<br>        a += y;<br>    &#125;<br>    function divide(uint y) public &#123;<br>        // a = a / y;<br>        a /= y;<br>    &#125;<br>    function multiply(uint y) public &#123;<br>        // a = a * y;<br>        a *= y;<br>    &#125;<br>    function test(uint y) public &#123;<br>        // a %= y;  // a = 10 % 2 = 0  <br>        // a |= y;  // a = a | y ;  10 | 2  1 0 1 0 | 0 0 1 0  = 1 0 1 0<br>        // a &amp;= y; // a = a &amp; y;  10 &amp; 2  1 0 1 0 | 0 0 1 0  = 0 0 1 0<br>        // a ^= y;  // a = a ^ y  10 ^ 2  1 0 1 0 | 0 0 1 0 = 1 0 0 0<br>        // a &lt;&lt;= y;  // a = a &lt;&lt; y  10 &lt;&lt; 2  0 0 0 0 1 0 1 0  &lt;&lt; 2 =  0 0 1 0 1 0 0 0 40<br>        a &gt;&gt;= y;  // a = a &gt;&gt; y  10 &gt;&gt; 2  0 0 0 0 1 0 1 0 &gt;&gt; 2   = 0 0 0 0 0 0 1 0 <br>    &#125;<br></code></pre></td></tr></table></figure><p>用于简洁地对变量进行更新。</p><h5 id="增量-减量运算符："><a href="#增量-减量运算符：" class="headerlink" title="增量/减量运算符："></a><strong>增量/减量运算符</strong>：</h5><p> a++<code>和</code>a—  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add1() public &#123;<br>       a++<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function divide1() public &#123;<br>   x = a--;<br>  &#125;<br></code></pre></td></tr></table></figure><p>—a<code>和</code>++a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add1() public &#123;<br>        x = ++a; <br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function divide1() public &#123;<br>     x = --a;<br> &#125;<br></code></pre></td></tr></table></figure><p>用于快速增加或减少变量的值。</p><h5 id="删除运算符"><a href="#删除运算符" class="headerlink" title="删除运算符"></a>删除运算符</h5><p>在Solidity中是存在 <code>delete</code> 运算符的。使用 <code>delete</code> 可以将变量设置为其类型的默认值。对于简单类型，如 <code>uint</code> 或 <code>int</code>，默认值是 <code>0</code>；对于数组，<code>delete</code> 会使数组的所有元素被置为默认值；对于结构体，它将重置结构体中的所有成员变量为它们的默认值。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract test2&#123;<br>    uint public x = 2;<br>    uint[]  array = [1,2,3,4];<br>    struct S &#123; uint a; uint b;&#125;<br>    S public s;<br>    function test() public returns(S memory)&#123;<br>        delete x;<br>        delete array[1];<br>        s.a = 5;<br>        s.b = 2;<br>        delete s;<br>        // delete s[0];<br>        return s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>delete</code> 对于动态数组只会将特定索引处的元素重置为默认值，并不会改变数组的长度。而对于静态数组，<code>delete</code> 将会重置整个数组为默认值。对于映射（mapping），<code>delete</code> 会使特定的键对应的值被移除。对于复杂类型的数组或映射，<code>delete</code> 不会递归删除内部元素，只会将它们设置为默认值。</p><h5 id="运算符优先顺序："><a href="#运算符优先顺序：" class="headerlink" title="运算符优先顺序："></a><strong>运算符优先顺序</strong>：</h5><div class="table-container"><table><thead><tr><th>优先级</th><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td><em>1</em></td><td>后置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>创建类型实例</td><td><code>new &lt;类型名&gt;</code></td></tr><tr><td></td><td>数组元素</td><td><code>&lt;数组&gt;[&lt;索引&gt;]</code></td></tr><tr><td></td><td>访问成员</td><td><code>&lt;对象&gt;.&lt;成员名&gt;</code></td></tr><tr><td></td><td>函数调用</td><td><code>&lt;函数&gt;(&lt;参数...&gt;)</code></td></tr><tr><td></td><td>小括号</td><td><code>(&lt;表达式&gt;)</code></td></tr><tr><td><em>2</em></td><td>前置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>一元运算减</td><td><code>-</code></td></tr><tr><td></td><td>一元操作符</td><td><code>delete</code></td></tr><tr><td></td><td>逻辑非</td><td><code>!</code></td></tr><tr><td></td><td>按位非</td><td><code>~</code></td></tr><tr><td><em>3</em></td><td>乘方</td><td><code>**</code></td></tr><tr><td><em>4</em></td><td>乘、除和模运算</td><td><code>*</code>， <code>/</code>， <code>%</code></td></tr><tr><td><em>5</em></td><td>算术加和减</td><td><code>+</code>， <code>-</code></td></tr><tr><td><em>6</em></td><td>移位操作符</td><td><code>&lt;&lt;</code>， <code>&gt;&gt;</code></td></tr><tr><td><em>7</em></td><td>按位与</td><td><code>&amp;</code></td></tr><tr><td><em>8</em></td><td>按位异或</td><td><code>^</code></td></tr><tr><td><em>9</em></td><td>按位或</td><td>`</td><td>`</td></tr><tr><td><em>10</em></td><td>非等操作符</td><td><code>&lt;</code>， <code>&gt;</code>， <code>&lt;=</code>， <code>&gt;=</code></td></tr><tr><td><em>11</em></td><td>等于操作符</td><td><code>==</code>， <code>!=</code></td></tr><tr><td><em>12</em></td><td>逻辑与</td><td><code>&amp;&amp;</code></td></tr><tr><td><em>13</em></td><td>逻辑或</td><td><code>==</code></td></tr><tr><td><em>14</em></td><td>三元操作符</td><td><code>&lt;判断条件&gt; ? &lt;如果为真时执行的表达式&gt; : &lt;如果为假时执行的表达式&gt;</code></td></tr><tr><td></td><td>赋值操作符</td><td><code>=</code>， `</td><td>=<code>，</code>^=<code>，</code>&amp;=<code>，</code>&lt;&lt;=<code>，</code>&gt;&gt;=<code>，</code>+=<code>，</code>-=<code>，</code>*=<code>，</code>/=<code>，</code>%=`</td></tr><tr><td><em>15</em></td><td>逗号</td><td><code>,</code></td></tr></tbody></table></div><p>运算符按照特定的优先级进行求值，例如：</p><ul><li><code>*</code>、<code>/</code>、<code>%</code>（乘、除、取余）具有高于<code>+</code>、<code>-</code>（加、减）的优先级。</li><li><code>&amp;&amp;</code>（逻辑与）的优先级高于<code>||</code>（逻辑或）。</li><li>使用括号<code>()</code>可以改变默认的优先级。<br>下面是一个运算符优先级的例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract test3&#123;<br>//     *、/、%（乘、除、取余）具有高于+、-（加、减）的优先级。<br>// &amp;&amp;（逻辑与）的优先级高于||（逻辑或）。<br>// 使用括号()可以改变默认的优先级。<br>    uint a = 2; uint b =3; uint c=4;<br>    // uint public result = a + b * c;<br>    // bool public result = true &amp;&amp; false || false;<br>    uint public result = (a + b) * c;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h4><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p>在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时， 编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义， 并且不会丢失信息，那么值-类型之间的隐式转换是可能的。</p><p>uint8 =&gt; uint16, int128=&gt;int256, int8 !=&gt; uint256【!=-1】</p><h5 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h5><p>如果编译器不允许隐式转换，但您确信转换会成功， 有时可以进行显式类型转换。 这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性， 所以一定要测试结果是否是您想要的和期望的!</p><p>int y=&gt; uint(y)</p><h4 id="字面常数和基本类型之间的转换"><a href="#字面常数和基本类型之间的转换" class="headerlink" title="字面常数和基本类型之间的转换"></a>字面常数和基本类型之间的转换</h4><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><p>十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断。</p><h5 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组</h5><p>十进制数字字面常数不能被隐含地转换为固定大小的字节数组。 十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。 但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型</p><h5 id="地址类型-1"><a href="#地址类型-1" class="headerlink" title="地址类型"></a>地址类型</h5><p>正如在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals">地址字面量（Address Literals）</a> 中所描述的那样，正确大小并通过校验测试的十六进制字是 <code>address</code> 类型。 其他字面常数不能隐含地转换为 <code>address</code> 类型。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h5><ul><li><strong>隐式转换</strong>：只有在“范围扩大 + 不丢失信息”时才允许。</li><li><strong>显式转换</strong>：允许开发者强制转换，但可能导致意外结果 → 必须验证。</li><li><p><strong>字面量转换规则</strong>：</p></li><li><ul><li>整数字面量可隐式转换（不超范围）。</li><li>十六进制字面量可用于定长字节数组（需精确字节数）。</li><li>地址必须是符合格式的十六进制字面量。</li></ul></li></ul><p>参考资料 : </p><p> <a href="https://docs.soliditylang.org/zh-cn/latest/index.html">Solidity — Solidity 0.8.24 文档</a></p><p><a href="https://www.wtf.academy/zh/course/solidity101">WTF Solidity课程</a></p>]]></content>
    
    
      
      
    <summary type="html">
    &lt;div id=&quot;aplayer-gAbYerzl&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;2086093868&quot; data-server=&quot;netease&quot; dat</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(三) 常量、变量和数据类型</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%89-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%89-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-11-26T13:04:56.000Z</published>
    <updated>2025-11-26T19:41:40.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是内存中用于保存固定值的单元，在程序中常量的值不能发生改变。</p><p>在Go语言 中定义常量的方法如下：</p><script type="math/tex; mode=display">const 常量标识符 [数据类型] = 常量值</script><p>例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> CAPITAL <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Guangdong&quot;</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是内存中命名的存储位置，与常量不同的是变量的值可以动态变化。与常量一 样，变量也有一个名字。</p><p>在Go语言中定义变量的方法如下：</p><script type="math/tex; mode=display">var 变量标识符 [数据类型]</script><p>例如，下面的代码定义了一个字符串变量str。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a><strong>布尔型</strong></h3></li></ol><p>Go语言的布尔型为bool，布尔型常量包括true和false。</p><p>例如，下面的代码定义了 一个布尔型变量existed。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> existed <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><ol><li><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><strong>数字类型</strong></h3><p>Go语言的数字类型包括整型和浮点型。Go语言支持的整型数据类型如下图所示。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126212023344.png" alt="image-20251126212023344"></p><p>Go语言支持的浮点型数据类型如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126212147032.png" alt="image-20251126212147032"></p><ol><li><h3 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a><strong>派生类型</strong></h3><p>Go语言的派生类型包括指针、结构体、枚举、数组、切片、集合、接口、通道、函数等。大多数派生类型都比较复杂，本小节只介绍其中比较简单的结构体类型和枚举类型。</p><p>（1）结构体类型</p><p>结构体是一种自定义的数据类型，即可以由一组不同的数据类型组合成一个新的数据类型。可以使用struct关键字来定义结构体类型，具体方法如下： </p><p>type结构体类型struct { </p><p>​    成员定义 </p><p>​    成员定义 </p><p>​    …… </p><p>​    成员定义</p><p> }</p><p>例如，下面的代码定义了一个Book结构体，其中包含Name（名称）、Author（作者）、Pagecount（页数）和Price（价格）等成员。 </p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Book</span> struct &#123;<br>    <span class="hljs-type">Name</span> string; <br>    <span class="hljs-type">Author</span> string;<br>    <span class="hljs-type">Pagecount</span> uint;<br>    <span class="hljs-type">Price</span> uint; <br>&#125;<br></code></pre></td></tr></table></figure><p>定义结构体类型后，可以使用如下方法声明结构体变量。 </p><p>变量：= 结构体类型 {字段值1， 字段值2,…，字段值n} </p><p>上面的代码在初始化结构体变量时按照其字段定义的顺序指定字段值，也可以按照 键值对的形式初始化结构体变量，方法如下： </p><p>变量：= 结构体类型 {字段名1：字段值1， 字段名2：字段值2,…，字段名n：字段值n}</p><p>初始化一个结构体时要指定每个成员的值。</p><p>例如，初始化一个Book变量b的方法如 下： </p><p>Book b = Book{“ 活着”, “余华”, 350, 90}</p><p>可以使用b.Name来访问结构体的成员Name。</p><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251127032517471.png" alt="image-20251127032517471"></p></li></ol><p>（2）枚举类型 </p><p>枚举类型是一种有有限可选值的数据类型，每个可选值都对应一个int值。</p><p>在Go语 言中，可以使用const关键字来定义一个枚举类型，方法如下：</p><p> type &lt;枚举类型名&gt; int const ( </p><p>&lt;可选值1&gt; &lt;枚举类型名&gt; = iota//值为0 </p><p>&lt;可选值2&gt; //值为1 </p><p>&lt;可选值3&gt; //值为2 </p><p>&lt;可选值4&gt; //值为3 </p><p>) </p><p>&lt;可选值1&gt;由iota初始化后，后面的可选值会自动递增。&lt;可选值1&gt;对应整型数0,&lt; 可选值2&gt;对应整型数1,&lt;可选值3&gt;对应整型数2，以此类推。</p><p>可以使用下面的方法引用枚举类型的可选值。 </p><p>&lt;枚举类型名&gt;.&lt;可选值n&gt;</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h2&gt;&lt;p&gt;常量是内存中用于保存固定值的单元，在程序中常量的值不能发生改变。&lt;/p&gt;
&lt;p&gt;在Go语言 中定义常量的方法如下：&lt;/p&gt;
&lt;script </summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(二) 第一个go应用</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E5%BA%94%E7%94%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E5%BA%94%E7%94%A8/</id>
    <published>2025-11-26T08:58:05.000Z</published>
    <updated>2025-11-26T19:29:24.926Z</updated>
    
    <content type="html"><![CDATA[<p>代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><br>&#123; <br><br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br><br> &#125;<br></code></pre></td></tr></table></figure><p>具体说明如下。 </p><p>·程序使用package关键字定义了一个名为main的包。这说明当前程序是一个可执 行程序。 </p><p>·程序使用import语句导入包fmt。fmt是Go语言的内置包，其中包含格式化I/O （Input/ Output，输入/输出）函数。 </p><p>·func关键字用于定义函数。本例中定义了一个main()函数，这是项目的主函数， 也是执行程序的入口。</p><p> ·调用fmt包中的Println()函数，在终端输出字符串“Hello World!”。</p><p> 这是一个非常简单的Go语言程序，但是其中包含Go语言程序的必要元素，例如包、 函数和字符串等。本章后面会详细介绍这些概念。</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码如下： &lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础(一) 下载及安装</title>
    <link href="https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    <id>https://www.zhengcookie.site/zhengcookie/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85/</id>
    <published>2025-11-25T18:32:35.000Z</published>
    <updated>2025-11-26T19:29:14.925Z</updated>
    
    <content type="html"><![CDATA[<p>b本内容部分参考了书籍Go语言Hyperledger区块链开发实战<em>(李晓黎)</em></p><p>Go语言支持Windows、Linux、FreeBSD和macOS等多种操作系统。</p><p>下载官网</p><p><a href="https://golang.google.cn/">The Go Programming Language</a></p><p>这里只详细说一下windows怎么做，在windows中，下载完成之后的go默认的安装目录为C:\Program Files\Go【可以自行设置】，用户需要把C:\Program Files\Go\bin目录添加到环境变量PATH中【初次安装不需要，但也可能因人而异】，以便可以在任何目录下执行go命令。执行go version命令可以查看Go语言的版本信息，go env命令可以查看与Go语言相关的环境变量。</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/image-20251126023701181.png" alt="image-20251126023701181"></p><p>常用的与Go语言相关的环境变量如下。 </p><p>·GOROOT：存储Go语言的安装目录，默认为C:\Program Files\Go。 </p><p>·GOPATH：存储Go语言的项目目录，默认为C:\Users\Administrator\go。</p><p>参考资料:    Go语言Hyperledger区块链开发实战_(李晓黎)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;b本内容部分参考了书籍Go语言Hyperledger区块链开发实战&lt;em&gt;(李晓黎)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Go语言支持Windows、Linux、FreeBSD和macOS等多种操作系统。&lt;/p&gt;
&lt;p&gt;下载官网&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gola</summary>
      
    
    
    
    <category term="后端开发" scheme="https://www.zhengcookie.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="GoLang" scheme="https://www.zhengcookie.site/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>Solidity智能合约零基础入门（一）区块链与智能合约概念</title>
    <link href="https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.zhengcookie.site/zhengcookie/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%A6%82%E5%BF%B5/</id>
    <published>2025-10-19T14:17:53.000Z</published>
    <updated>2025-12-11T09:14:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启程-区块链与智能合约概念"><a href="#启程-区块链与智能合约概念" class="headerlink" title="启程 - 区块链与智能合约概念"></a>启程 - 区块链与智能合约概念</h2><h3 id="比特币-vs-以太坊：为什么需要智能合约？"><a href="#比特币-vs-以太坊：为什么需要智能合约？" class="headerlink" title="比特币 vs 以太坊：为什么需要智能合约？"></a>比特币 vs 以太坊：为什么需要智能合约？</h3><p>比特币作为区块链技术的第一个成功应用，开创了去中心化数字货币的先河。它的核心功能是提供一种安全、透明且不可篡改的价值转移方式。然而，比特币的设计初衷是专注于支付和存储价值，其脚本语言（Script）虽然具有一定的可编程性，但功能较为有限，无法支持复杂的逻辑操作。<br>相比之下，以太坊在设计上引入了一个革命性的概念——<strong>智能合约</strong>。智能合约是一种运行在区块链上的程序代码，能够根据预设条件自动执行特定的操作。它使得以太坊不仅是一个去中心化的支付系统，更是一个通用的计算平台。通过智能合约，开发者可以构建各种去中心化应用（DApps），例如去中心化金融（DeFi）、非同质化代币（NFT）、去中心化自治组织（DAO）等。这种灵活性使以太坊成为区块链生态系统的核心支柱之一。<br>那么，为什么需要智能合约？智能合约的核心优势在于<strong>自动化执行</strong>和<strong>信任最小化</strong>。传统合约需要依赖第三方（如律师或仲裁机构）来确保执行，而智能合约通过代码直接定义规则并自动执行，无需中介参与。这不仅降低了交易成本，还提高了效率，同时减少了人为干预带来的风险。此外，智能合约的透明性和不可篡改性进一步增强了信任，使其在金融、供应链管理、身份认证等领域展现出巨大的潜力。</p><h3 id="什么是Gas？什么是交易？"><a href="#什么是Gas？什么是交易？" class="headerlink" title="什么是Gas？什么是交易？"></a>什么是Gas？什么是交易？</h3><h4 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h4><p>在以太坊网络中，<strong>Gas</strong> 是衡量执行智能合约或进行交易所需计算资源的单位。简单来说，Gas 是用户为使用以太坊网络支付的“燃料费”。每笔交易或智能合约的执行都需要消耗一定数量的 Gas，而 Gas 的价格由市场供需决定，通常以以太币（ETH）计价。<br>Gas 的存在有几个重要意义：</p><ol><li><strong>防止滥用网络资源</strong>：通过收取 Gas 费用，以太坊可以防止恶意用户发起无限循环或占用大量计算资源的操作。</li><li><strong>激励矿工/验证者</strong>：Gas 费用作为奖励分配给矿工（在 PoW 机制下）或验证者（在 PoS 机制下），以保障网络的安全性和稳定性。</li><li><strong>动态调节网络负载</strong>：当网络拥堵时，用户可以通过提高 Gas 价格来优先处理自己的交易。</li></ol><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>在区块链语境中，<strong>交易</strong>是指任何改变区块链状态的操作。交易可以分为两类：</p><ol><li><strong>普通转账交易</strong>：指从一个账户向另一个账户转移加密货币（如 ETH）。</li><li><strong>智能合约交互交易</strong>：指调用智能合约中的函数，可能涉及复杂的数据处理或状态更新。<br>每笔交易都需要包含以下信息：</li></ol><ul><li>发送方地址</li><li>接收方地址（如果是普通转账）或智能合约地址（如果是合约交互）</li><li>转账金额（如果是普通转账）</li><li>Gas 限制（Gas Limit）：用户愿意为该交易支付的最大 Gas 数量</li><li>Gas 价格（Gas Price）：每单位 Gas 的价格<br>如果交易执行所需的 Gas 超过了用户设置的 Gas 限制，交易将失败，但已消耗的 Gas 不会退还。</li></ul><h3 id="开发环境搭建（FISCO-BCOS-Remix-IDE）"><a href="#开发环境搭建（FISCO-BCOS-Remix-IDE）" class="headerlink" title="开发环境搭建（FISCO-BCOS, Remix IDE）"></a>开发环境搭建（FISCO-BCOS, Remix IDE）</h3><p>为了在区块链上开发和部署智能合约，我们需要搭建合适的开发环境。以下是两种常用的工具：<strong>FISCO-BCOS</strong> 和 <strong>Remix IDE</strong>。</p><h4 id="FISCO-BCOS"><a href="#FISCO-BCOS" class="headerlink" title="FISCO-BCOS"></a>FISCO-BCOS</h4><p>FISCO-BCOS 是一个国产的区块链底层平台，专注于企业级应用场景。它支持联盟链模式，适合构建私有链或联盟链项目。以下是搭建 FISCO-BCOS 的基本步骤：</p><p><a href="https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html">https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html</a></p><h4 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h4><p>Remix 是一个基于浏览器的集成开发环境（IDE），专为以太坊智能合约开发设计。它的界面友好，功能强大，非常适合初学者和快速原型开发。以下是使用 Remix 的基本流程：</p><ol><li><strong>访问 Remix IDE</strong>：</li></ol><ul><li><ul><li>打开浏览器，访问 <a href="https://remix.ethereum.org/">Remix 官网</a>。</li></ul></li></ul><ol><li><strong>编写智能合约</strong>：</li></ol><ul><li><ul><li>在 Remix 的“File Explorer”区域新建一个 <code>.sol</code> 文件，例如 <code>MyContract.sol</code>。</li><li>编写 Solidity 代码，例如：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract MyContract &#123;<br>    uint public value;<br>    function setValue(uint _value) public &#123;<br>        value = _value;<br>    &#125;<br>    function getValue() public view returns (uint) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>编译合约</strong>：</li></ol><ul><li><ul><li>切换到“Solidity Compiler”标签页，选择适当的编译器版本并点击“Compile”。</li></ul></li></ul><ol><li><strong>部署合约</strong>：</li></ol><ul><li><ul><li>切换到“Deploy &amp; Run Transactions”标签页，选择 JavaScript VM（虚拟机）或其他环境（如 MetaMask）。</li><li>点击“Deploy”按钮将合约部署到测试网络。</li></ul></li></ul><ol><li><strong>测试合约</strong>：</li></ol><ul><li><ul><li>在“Deployed Contracts”区域，调用合约的函数（如 <code>setValue</code> 和 <code>getValue</code>）进行交互。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;启程-区块链与智能合约概念&quot;&gt;&lt;a href=&quot;#启程-区块链与智能合约概念&quot; class=&quot;headerlink&quot; title=&quot;启程 - 区块链与智能合约概念&quot;&gt;&lt;/a&gt;启程 - 区块链与智能合约概念&lt;/h2&gt;&lt;h3 id=&quot;比特币-vs-以太坊：为什么需要智</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第九周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/</id>
    <published>2025-09-13T08:16:54.000Z</published>
    <updated>2025-12-11T09:11:10.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作内容与成果"><a href="#一、工作内容与成果" class="headerlink" title="一、工作内容与成果"></a>一、工作内容与成果</h2><p>本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：</p><p>（一）周一：后台界面优化工作</p><ol><li><p><strong>本地存储数据安全优化</strong>：针对后台界面，移除了通过 storage 本地存储模拟操作数据的方式。此优化有效避免了操作数据在本地透明可见的问题，提升了数据传输与存储的安全性，降低了数据被篡改或泄露的风险。</p></li><li><p><strong>核心业务逻辑调整</strong>：重点调整了后台作物管理与日志操作的核心逻辑。优化后，系统能够精准匹配对应地块的种子信息，确保作物数据与地块信息的关联性；同时，日志信息也能与具体操作场景、地块及作物数据准确对应，提升了后台数据管理的准确性与可读性，为后续数据查询与分析奠定基础。</p></li></ol><p>（二）周二：作物日志功能扩展</p><ol><li><p><strong>操作频次管控实现</strong>：为规范作物日志记录，新增作物日志每日操作限制规则，设定每种操作每日最多记录两次。该规则有效避免了日志数据冗余，保证了日志信息的简洁性与有效性，同时也符合农场日常运营中对作物操作的合理频次需求。</p></li><li><p><strong>日志生命周期管理</strong>：完善作物日志的生命周期逻辑，实现 “收获后自动删除日志，后续重新操作时添加新日志” 的功能。此举确保了日志信息与作物生长周期的同步性，避免了过期日志对数据管理的干扰，提升了日志数据的时效性。</p></li><li><p><strong>弱网环境数据保障</strong>：采用幂等性设计实现作物日志记录功能，在弱网、网络不流畅等不稳定环境下，能够有效防止重复添加日志数据，同时确保操作数据的完整性与准确性，提升了系统在复杂网络环境下的稳定性与可靠性。</p></li></ol><p>（三）周三：农场后台管理系统上线</p><ol><li><p><strong>管家日志管理功能</strong>：上线的农场后台管理系统中，新增管家后台日志记录功能，管家可通过系统的 “作物管理” 模块与 “每周日志” 模块，实时记录、查看与管理作物相关的操作日志，便于管家全面掌握作物生长过程中的关键操作，提升管理效率。</p></li><li><p><strong>种子图鉴管理功能</strong>：系统支持管家通过 “种子管理” 模块，上传、编辑与管理种子图鉴信息，包括种子品种、生长周期、适宜环境等关键数据。该功能为管家提供了统一的种子信息管理平台，便于规范种子信息管理，同时也为后续作物种植规划提供数据支持。</p></li><li><p><strong>订单查询管理功能</strong>：上线 “订单管理” 模块，管家可通过该模块快速查询所有订单信息，包括订单编号、订单类型、下单时间、订单状态等详细内容，支持按不同条件筛选查询，提升了订单信息的查询效率，便于管家及时跟进订单进度，保障农场运营的顺畅性。</p></li></ol><h3 id="二、核心工作成果"><a href="#二、核心工作成果" class="headerlink" title="二、核心工作成果"></a>二、核心工作成果</h3><p>本周聚焦农场相关系统完成三项关键工作：一是优化后台界面，移除 storage 本地存储模拟数据以强化安全，同时调整作物与日志逻辑，实现地块 - 种子 - 日志信息精准匹配；二是扩展作物日志功能，新增每日操作频次限制、收获后日志自动清理机制，并通过幂等设计解决弱网环境下数据重复问题；三是成功上线农场后台管理系统，为管家提供日志管理、种子图鉴上传、订单查询三大核心模块，满足日常管理需求。</p><h3 id="三、关键价值与亮点"><a href="#三、关键价值与亮点" class="headerlink" title="三、关键价值与亮点"></a>三、关键价值与亮点</h3><p>从安全性、实用性、稳定性三方面实现突破：安全层面，通过本地存储优化降低数据泄露风险，为系统数据安全奠定基础；实用层面，日志生命周期管理与后台系统功能模块，直接贴合农场运营场景，帮助管家提升数据管理与工作效率；稳定性层面，幂等设计的应用，有效应对复杂网络环境，保障操作数据的完整性，减少系统异常问题。</p><h3 id="四、后续行动方向"><a href="#四、后续行动方向" class="headerlink" title="四、后续行动方向"></a>四、后续行动方向</h3><p>后续将围绕 “优化体验、强化安全、拓展功能” 推进工作：优先收集管家使用反馈，迭代优化系统操作流程与功能漏洞；进一步完善数据安全体系，新增定期备份与恢复机制；结合农场实际需求调研新功能（如作物生长监控），同时持续监控系统性能，通过优化数据库、压缩资源等方式，确保系统长期稳定高效运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工作内容与成果&quot;&gt;&lt;a href=&quot;#一、工作内容与成果&quot; class=&quot;headerlink&quot; title=&quot;一、工作内容与成果&quot;&gt;&lt;/a&gt;一、工作内容与成果&lt;/h2&gt;&lt;p&gt;本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第八周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/</id>
    <published>2025-09-07T12:22:49.000Z</published>
    <updated>2025-12-11T09:11:06.117Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。<br><strong>整体进展：</strong> ✅ <strong>核心闭环成功打通！</strong> 用户可完成<code>购买服务</code> -&gt; <code>播种</code> -&gt; <code>日常管理（浇水）</code> -&gt; <code>生成日志</code> -&gt; <code>收获</code> -&gt; <code>下单配送</code>的全流程。后台管理功能得到显著增强。</p><hr><h3 id="一、-每日开发详情"><a href="#一、-每日开发详情" class="headerlink" title="一、 每日开发详情"></a>一、 每日开发详情</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>后端服务开发</strong></td><td style="text-align:left">✅ <strong>下单服务</strong>：完成接收、处理、存储订单信息的后端逻辑。<br>✅ <strong>后台托管服务</strong>：实现分配管家处理任务及切换角色登录权限的功能。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>后台管理系统开发</strong></td><td style="text-align:left">✅ <strong>订单管理页面</strong>：<br>  - 设计订单列表，可根据 <code>order_type</code> 动态展示信息。<br>  - 实现按类型、状态等条件的筛选功能。<br>  - 开发订单详情页，关联显示主表(<code>t_order</code>)与子表信息。<br>✅ <strong>托管日志集成</strong>：在作物管理界面中，可查看关联的托管服务日志。<br>✅ <strong>管家绑定</strong>：前端通过 <code>store</code> 中的用户ID查询并绑定 <code>caretaker_user_id</code>，管理作物。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>前后端功能联调</strong></td><td style="text-align:left">✅ <strong>日志查看</strong>：点击作物即可显示相关管家的操作日志。<br>✅ <strong>订单管理</strong>：用户可查询并修改自己的订单信息。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>功能优化与扩展</strong></td><td style="text-align:left">✅ <strong>修复前端显示</strong>：优化购买服务页面，为播种功能做准备。<br>✅ <strong>服务扩展</strong>：扩展下单服务，支持收获后生成配送订单的流程。<br>✅ <strong>界面优化</strong>：对订单列表的“待收获”界面进行了视觉和体验优化。</td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>交互功能实现</strong></td><td style="text-align:left">✅ <strong>确认操作</strong>：实现前端确认操作（如浇水）的功能。<br>✅ <strong>日志记录</strong>：为浇水等操作生成两种日志：<br>  - <strong>用户操作日志</strong> (用户点击触发)<br>  - <strong>管家工作日志</strong> (管家后台记录)<br>✅ <strong>通知机制</strong>：管家可在后台管理系统中获取相关操作的通知和日志。</td></tr><tr><td style="text-align:left"><strong>周六</strong></td><td style="text-align:left"><strong>全链路测试与BUG修复</strong></td><td style="text-align:left">✅ <strong>核心闭环验证</strong>：成功测试并修复逻辑BUG，确保从购买到收获下单的全流程畅通。<br>✅ <strong>遗留问题定位</strong>：<br>  - <strong>问题一</strong>：手机端支付后可重复点击购买，需前端优化交互。<br>  - <strong>问题二</strong>：后台订单界面需集成第三方服务（如支付、物流），待确定方案。</td></tr></tbody></table></div><hr><h3 id="二、-核心业务流程与逻辑-本周重大进展"><a href="#二、-核心业务流程与逻辑-本周重大进展" class="headerlink" title="二、 核心业务流程与逻辑 (本周重大进展)"></a>二、 核心业务流程与逻辑 (本周重大进展)</h3><ol><li><p><strong>收获后处理逻辑（后端）</strong>：<br>当用户发起收获并成功创建配送单后，系统自动执行以下操作，确保数据状态准确：</p><ul><li><strong>清空地块</strong>：将对应地块的作物状态重置为 <code>empty</code>。</li><li><strong>扣减权益</strong>：<ul><li>对于<strong>次数型</strong>权益：将 <code>uses_left</code> (剩余次数) 减1。若次数用尽，则将权益状态置为 <code>consumed</code>。</li><li>对于<strong>时长型</strong>权益：不扣减次数，仅检查有效期。</li></ul></li><li><strong>更新权益状态</strong>：重新计算该地块的 <code>owned</code> 字段。只要仍有有效的<code>active</code>权益（次数未用完或未过期），<code>owned</code> 即为 <code>true</code>，否则为 <code>false</code>。</li></ul></li><li><p><strong>前端支付流程优化（已解决）</strong>：<br>修复了 <code>purchaseServicePackage</code> 函数中 <code>await</code> 与 <code>success</code> 回调混用导致的逻辑问题。</p><ul><li><strong>解决方案</strong>：重写该函数，采用纯 <code>async/await</code> 方式调用支付接口。支付成功后，<strong>立即调用后端接口刷新地块数据</strong>，并提交一个 <code>mutation</code> 来本地更新状态，确保UI显示及时、准确。</li></ul></li></ol><hr><h3 id="三、-待解决的问题与下周计划"><a href="#三、-待解决的问题与下周计划" class="headerlink" title="三、 待解决的问题与下周计划"></a>三、 待解决的问题与下周计划</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>问题描述</strong></th><th style="text-align:left"><strong>性质</strong></th><th style="text-align:left"><strong>可能解决方案/下一步计划</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. 移动端支付后可重复点击</strong></td><td style="text-align:left">前端交互BUG</td><td style="text-align:left">在支付请求发起后，禁用按钮并显示加载状态，直到收到明确的成功/失败回调。</td></tr><tr><td style="text-align:left"><strong>2. 后台需集成第三方服务</strong></td><td style="text-align:left">技术方案调研</td><td style="text-align:left">调研并选择可靠的第三方服务提供商（如支付宝/微信支付官方API、聚合支付平台、物流公司API），然后编写对接代码。</td></tr></tbody></table></div><p><strong>下周计划：</strong></p><ul><li><strong>解决遗留问题</strong>：优先修复移动端支付交互BUG，并启动第三方服务对接的调研与开发。</li><li><strong>功能增强</strong>：基于已打通的闭环，考虑添加更多作物管理操作（如施肥、除虫）、优化日志系统、设计更完善的管家通知中心。</li><li><strong>测试与部署</strong>：进行更全面的测试，准备将新功能部署至测试或生产环境。</li></ul><hr><h3 id="四、-本周工作回顾：核心业务闭环全面打通"><a href="#四、-本周工作回顾：核心业务闭环全面打通" class="headerlink" title="四、 本周工作回顾：核心业务闭环全面打通"></a><strong>四、 本周工作回顾：核心业务闭环全面打通</strong></h3><p>本周的核心工作是推动农场项目的<strong>完整业务流程实现</strong>与<strong>后台管理系统强化</strong>，并成功完成了端到端的测试验证。</p><ol><li><strong>后端服务建设</strong>：完成了<strong>下单服务</strong>与<strong>后台托管服务</strong>的开发，实现了订单的接收、处理、存储，以及管家的任务分配与权限管理。</li><li><strong>后台管理功能增强</strong>：开发了功能完善的订单管理页面（列表、筛选、详情）、托管服务日志记录模块，并实现了作物与管家的绑定管理。</li><li><strong>核心业务闭环验证</strong>：成功打通了“<strong>用户购买服务 -&gt; 播种 -&gt; 进行浇水等管理操作 -&gt; 自动生成日志 -&gt; 收获并创建配送单 -&gt; 地块状态重置</strong>”的完整业务流程，标志着项目最核心的功能链路已全部跑通。</li><li><strong>前端体验优化</strong>：修复了购买服务页面的显示问题，优化了订单界面，并重写了支付逻辑，确保了交互的准确性和数据的一致性。</li></ol><h3 id="五、-问题与反思：技术方案与细节处理需持续打磨"><a href="#五、-问题与反思：技术方案与细节处理需持续打磨" class="headerlink" title="五、 问题与反思：技术方案与细节处理需持续打磨"></a>五<strong>、 问题与反思：技术方案与细节处理需持续打磨</strong></h3><p>在开发过程中，也遇到并识别了一些亟待解决的问题，主要集中在交互细节和技术方案选型上。</p><ol><li><strong>移动端交互细节问题</strong>：手机端支付成功后，按钮状态未能及时重置，导致用户可重复点击，<strong>暴露了前端对连续请求控制的不足</strong>。这需要通过添加加载状态和按钮禁用机制来优化。</li><li><strong>外部集成技术方案待定</strong>：后台系统需要接入支付、物流等第三方服务，但目前<strong>尚未确定具体的技术选型和对接方案</strong>，这是下一步需要重点调研和决策的点。</li><li><strong>逻辑严谨性</strong>：在解决“收获后清空地块”等复杂业务逻辑时，意识到必须通过<strong>精准的后端逻辑</strong>（如扣减权益、状态更新）来保证数据一致性，而非依赖前端。</li></ol><h3 id="六、-下周计划：解决遗留问题，推进系统集成与优化"><a href="#六、-下周计划：解决遗留问题，推进系统集成与优化" class="headerlink" title="六、 下周计划：解决遗留问题，推进系统集成与优化"></a><strong>六、 下周计划：解决遗留问题，推进系统集成与优化</strong></h3><p>基于本周的进展和问题，下周的工作将围绕以下重点展开：</p><ol><li><strong>优先解决遗留问题</strong>：<ul><li>修复移动端支付交互BUG，增加防重复提交机制。</li><li>启动对第三方服务（如支付、物流API）的调研，并形成初步的集成方案。</li></ul></li><li><strong>功能增强与优化</strong>：<ul><li>在现有闭环基础上，规划并开发更多的作物管理操作（如施肥、除虫）。</li><li>优化日志系统和管家通知中心，提升用户体验和管理效率。</li></ul></li><li><strong>测试与部署准备</strong>：<ul><li>对已打通的全流程进行更全面的测试，准备将稳定版本部署至测试环境。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ &lt;strong&gt;核心闭环成功打通！&lt;/strong&gt; 用户可完成&lt;code&gt;购买服务&lt;/code&gt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第七周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/</id>
    <published>2025-08-30T11:18:00.000Z</published>
    <updated>2025-12-11T09:11:35.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="周一：农场服务前端界面实现"><a href="#周一：农场服务前端界面实现" class="headerlink" title="周一：农场服务前端界面实现"></a><strong>周一：农场服务前端界面实现</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现托管服务操作流程：点击托管→选择种植物→确认收获→判断收获方式。  </li><li>搭建基础农场前端界面，完成用户交互逻辑。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>收获方式判断逻辑需与后端土地状态同步（未实时更新）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>添加前端定时查询地块状态，确保数据一致性。  </li></ul><hr><h3 id="周二：订单生成与支付界面优化"><a href="#周二：订单生成与支付界面优化" class="headerlink" title="周二：订单生成与支付界面优化"></a><strong>周二：订单生成与支付界面优化</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>对接托管服务订单接口（<code>/orders/service</code>），生成订单并关联用户与地块数据。  </li><li>优化支付界面样式，使其更简洁清晰，支持后续扩展托管服务类型。  </li><li>实现土地及托管服务数据存储，支持详细查询。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>支付界面在不同设备上显示错位（移动端适配问题）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>使用响应式布局（CSS Flexbox+Media Query）快速修复。  </li></ul><hr><h3 id="周三：扩展购买与播种功能"><a href="#周三：扩展购买与播种功能" class="headerlink" title="周三：扩展购买与播种功能"></a><strong>周三：扩展购买与播种功能</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>扩展托管服务购买功能（接口：<code>/farm/service/package/purchase</code>）。  </li><li>实现种子播种功能（接口：<code>/farm/plant</code>）并关联地块数据（接口：<code>/farm/plots</code>）。  </li><li>订单查询与支付状态联动（支付成功自动更新订单状态）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>播种请求超时（地块数据量增大导致查询缓慢）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>为<code>/farm/plots</code>接口添加缓存机制（Redis缓存地块信息）。  </li></ul><hr><h3 id="周四：后台管理系统开发"><a href="#周四：后台管理系统开发" class="headerlink" title="周四：后台管理系统开发"></a><strong>周四：后台管理系统开发</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现后台托管服务管理（增删改查）。  </li><li>开发作物管理模块（支持作物信息维护）。  </li><li>搭建每周日志记录功能（支持日志添加与查询）。  </li><li>完成种子管理基础功能（CRUD操作）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>管家管理模块需对接若依权限系统，但账户体系不兼容。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>暂独立开发管家管理模块，预留若依系统对接接口。  </li></ul><hr><h3 id="周五：后台功能完善与权限隔离"><a href="#周五：后台功能完善与权限隔离" class="headerlink" title="周五：后台功能完善与权限隔离"></a><strong>周五：后台功能完善与权限隔离</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>完成托管服务、作物管理、每周日志、种子管理的完整增删改查功能。  </li><li>优化后台数据查询效率（添加数据库索引）。  </li><li>管家管理模块独立运行（暂未关联若依登录）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>若依系统权限接口文档缺失，无法直接对接。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>优先保证其他后台功能上线，管家管理采用若依账号过渡。  </li></ul><hr><h3 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a><strong>本周总结</strong></h3><h4 id="1-独立完成内容"><a href="#1-独立完成内容" class="headerlink" title="1. 独立完成内容"></a><strong>1. 独立完成内容</strong></h4><ul><li>前端农场服务全流程（托管→支付→播种→收获）。  </li><li>订单与支付系统集成（微信支付+订单状态管理）。  </li><li>后台管理核心功能（作物、日志、种子、托管服务管理）。  </li></ul><h4 id="2-主要挑战"><a href="#2-主要挑战" class="headerlink" title="2. 主要挑战"></a><strong>2. 主要挑战</strong></h4><ul><li><strong>支付合规性</strong>：订单号长度限制（32位）、HTTPS证书配置。  </li><li><strong>系统兼容性</strong>：管家模块与若依权限系统账户体系不匹配。  </li><li><strong>性能问题</strong>：地块数据量增大导致查询缓慢。  </li></ul><h4 id="3-成长与改进"><a href="#3-成长与改进" class="headerlink" title="3. 成长与改进"></a><strong>3. 成长与改进</strong></h4><ul><li><strong>第三方集成经验</strong>：支付接口必须严格遵循字段规范（如订单号长度）。  </li><li><strong>解耦设计</strong>：模块化开发（如管家管理独立）降低系统耦合风险。  </li><li><strong>性能优化</strong>：引入缓存与数据库索引应对数据增长。  </li></ul><h4 id="4-后续计划"><a href="#4-后续计划" class="headerlink" title="4. 后续计划"></a><strong>4. 后续计划</strong></h4><ul><li>补全若依系统对接文档，完成管家权限集成。  </li><li>统一接口响应格式，编写后端API文档。  </li><li>增加农场操作（播种、收获）的事务回滚机制。  </li></ul><p><strong>总结</strong>：本周成功交付农场系统核心功能，但支付与权限集成暴露了<strong>预研不足</strong>的问题。后续类似项目需提前验证第三方接口（支付、登录）的合规性；  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;a href=&quot;#周一：农场服务前端界面实现&quot; class=&quot;headerlink&quot; title=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;周一：农场服务前端界面实现&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;完</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第六周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/</id>
    <published>2025-08-25T15:01:50.000Z</published>
    <updated>2025-12-11T09:11:12.926Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）<br><strong>整体进展：</strong> ✅ 成功打通<code>HTTPS部署</code> -&gt; <code>微信支付</code> -&gt; <code>农场种植</code>全链路，项目进入可演示阶段。</p><hr><h3 id="一、-每日工作记录"><a href="#一、-每日工作记录" class="headerlink" title="一、 每日工作记录"></a><strong>一、 每日工作记录</strong></h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>HTTPS服务配置</strong></td><td style="text-align:left">✅ <strong>前端</strong>：使用Nginx配置SSL证书，实现小程序前端页面的HTTPS安全访问。<br>✅ <strong>后端</strong>：在SpringBoot中配置SSL证书，使后端API支持HTTPS请求，为微信支付等安全接口打下基础。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>微信支付集成</strong></td><td style="text-align:left">✅ 集成<strong>微信支付V2版</strong>，完成下单、回调等核心流程开发。<br>✅ 使用<strong>内网穿透</strong>工具模拟支付环境，初步测试通过。<br>⚠️ <strong>待办</strong>：退款功能暂未实现。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>问题修复与设计</strong></td><td style="text-align:left">✅ <strong>修复支付Bug</strong>：深入分析并解决了官方文档中提及的“订单重复”问题，优化为首次<code>统一下单</code>、后续调用<code>jsapi</code>的稳定流程。<br>✅ <strong>数据库设计</strong>：为农场托管功能设计了<code>farms</code>（田地）、<code>crops</code>（种子）、<code>farmManagers</code>（农场管家）三张核心表，明确通过JWT鉴权来隔离用户数据。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>农场服务开发</strong></td><td style="text-align:left">✅ 开发并部署核心农场后端服务，提供初步可用的RESTful API：<br>  - <code>POST /farm/plant</code>： <strong>种植接口</strong><br>  - <code>POST /farm/init</code>： <strong>初始化用户田地</strong><br>  - <code>POST /farm/listByUser</code>： <strong>获取用户田地信息</strong></td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>联调与架构复盘</strong></td><td style="text-align:left">✅ 成功完成前端与农场服务的联调，可获取并展示用户种植数据。<br>✅ <strong>架构决策</strong>：确定使用<strong>混合云开发</strong>方案（自建MySQL + 云服务），兼顾了数据灵活性与开发效率。</td></tr></tbody></table></div><hr><h3 id="二、-本周最大的挑战与解决方案"><a href="#二、-本周最大的挑战与解决方案" class="headerlink" title="二、 本周最大的挑战与解决方案"></a><strong>二、 本周最大的挑战与解决方案</strong></h3><ul><li><strong>挑战：</strong> 技术选型在<strong>数据库扩展性</strong>与<strong>开发维护效率</strong>之间的权衡。纯微信云开发无法满足复杂的MySQL业务需求，而完全自建服务器运维成本较高。</li><li><strong>解决方案：</strong> 采用<strong>混合云架构</strong>。<ul><li><strong>核心业务数据</strong>（用户、订单、农场）：使用自建云服务器上的MySQL数据库，保证了对数据的完全控制和复杂查询能力。</li><li><strong>静态资源/轻量功能</strong>：后续可考虑使用云开发平台的服务，提升开发速度与稳定性。</li></ul></li><li><strong>结果：</strong> 该方案既满足了当前业务的复杂度，又为未来部分功能的快速迭代提供了灵活性，速度与稳定性兼得。</li></ul><hr><h3 id="三、-本周工作带来的成长"><a href="#三、-本周工作带来的成长" class="headerlink" title="三、 本周工作带来的成长"></a><strong>三、 本周工作带来的成长</strong></h3><ol><li><strong>全链路能力提升：</strong> 从最基础的HTTPS配置，到复杂的支付业务、数据库设计，再到后端服务开发，独立打通了核心功能的全链路，对前后端协同开发的理解更加深刻。</li><li><strong>技术方案设计能力：</strong> 不再局限于实现功能，开始从<strong>架构角度</strong>思考问题（如混合云选型），学会了在多种技术方案中权衡利弊，选择最适合当前业务阶段的方案。</li><li><strong>文档驱动开发：</strong> 通过编写设计文档来理清逻辑，再着手编码，有效减少了开发过程中的反复和错误，提升了开发效率和质量。</li></ol><hr><h3 id="四、-反思与未来优化"><a href="#四、-反思与未来优化" class="headerlink" title="四、 反思与未来优化"></a><strong>四、 反思与未来优化</strong></h3><ul><li><strong>本周不足：</strong> 最初的方案设计对<strong>云原生</strong>和<strong>混合架构</strong>的考量不够深入，导致中途需要调整技术路线，产生了一定的学习成本。</li><li><strong>未来优化：</strong><ol><li><strong>架构设计</strong>：在项目初期，应更系统地评估各种技术方案（自建、纯云、混合云）的优缺点，制作详细的对比表格，避免后期切换。</li><li><strong>可维护性</strong>：虽然混合方案稳定，但未来可以考虑使用<strong>Docker容器化</strong>来部署MySQL和应用，提升环境一致性和迁移效率。</li><li><strong>功能完善</strong>：下一步需补全<strong>退款流程</strong>，并开始构建基于农场数据的<strong>商城购买与订单生成</strong>功能，最终完成商业闭环。</li></ol></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ 成功打通&lt;code&gt;HTTPS部署&lt;/code&gt; -&amp;gt; &lt;code&gt;微信支付&lt;/code&gt; -&amp;g</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第五周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/</id>
    <published>2025-08-16T16:04:11.000Z</published>
    <updated>2025-12-11T09:11:39.892Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="table-container"><table><thead><tr><th>日期</th><th>核心工作</th><th>关键产出</th></tr></thead><tbody><tr><td><strong>周一</strong></td><td>后台系统技术选型与架构设计</td><td>✅ 选定 <strong>若依框架</strong> 搭建后台管理系统<br>✅ 完成 <strong>功能模块划分</strong> 及技术文档输出</td></tr><tr><td><strong>周二</strong></td><td>用户管理模块开发</td><td>✅ 实现用户信息 <strong>增删改查（CRUD）</strong> 全功能</td></tr><tr><td><strong>周三</strong></td><td>核心业务模块开发</td><td>✅ 完成 <strong>订单管理</strong> 业务流程设计<br>✅ 落地 <strong>土地管理</strong> CRUD 核心逻辑</td></tr><tr><td><strong>周四</strong></td><td>技术方案优化与问题修复</td><td>✅ 验证 <strong>微信云开发</strong> 替代方案可行性<br>✅ 修复 <strong>图片上传异常</strong> Bug（改用云存储+路径映射）</td></tr><tr><td><strong>周五</strong></td><td>混合架构设计与规划</td><td>✅ 制定 <strong>MySQL + 云数据库混合方案</strong><br>✅ 参与 <strong>后续原型扩展</strong> 技术讨论</td></tr></tbody></table></div><hr><h3 id="关键亮点说明："><a href="#关键亮点说明：" class="headerlink" title="关键亮点说明："></a>关键亮点说明：</h3><ol><li><p><strong>技术选型</strong>：  </p><ul><li>选择 <strong>若依框架</strong> → 节省60%基础模块开发时间  </li><li>放弃纯云开发 → 因 <strong>MySQL业务兼容性</strong> 不足  </li></ul></li><li><p><strong>架构突破</strong>：  </p><pre><code class=" mermaid">graph LRA[微信小程序] --&gt; B&#123;云存储&#125;A --&gt; C[自建服务器]B --&gt; D[图片/文件]C --&gt; E[MySQL业务库]</code></pre><p><strong>混合架构价值</strong>：静态资源云化减压，核心数据自主可控  </p></li></ol><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>工作内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长收获</strong></th></tr></thead><tbody><tr><td><strong>1. 后台系统设计</strong><br> - 技术选型（若依框架）<br> - 功能模块规划文档</td><td>• 平衡开发效率与后期扩展性</td><td>• 选择 <strong>开源后台框架若依</strong>（集成权限管理/代码生成）</td><td>✅ 掌握 <strong>快速搭建企业级后台</strong> 的方法论</td></tr><tr><td><strong>2. 核心模块开发</strong><br> - 用户管理（增删改查）<br> - 订单/土地管理功能</td><td>• 数据库设计需兼容农场业务逻辑<br>• 字段关联性复杂</td><td>• 先画 <strong>ER图梳理数据关系</strong><br>• 用若依代码生成器快速实现基础CRUD</td><td>✅ 提升 <strong>业务模型抽象能力</strong><br>✅ 熟练 <strong>框架工具提效技巧</strong></td></tr><tr><td><strong>3. 技术方案优化</strong><br> - 尝试微信云开发<br> - 图片上传BUG修复</td><td>• 云开发与传统MySQL不兼容<br>• 图片路径存储异常</td><td>• 改用 <strong>混合云架构</strong>：<br>  - 核心业务用云服务器+MySQL<br>  - 图片/文件用云存储</td><td>✅ 理解 <strong>混合云方案设计思维</strong><br>✅ 学会 <strong>根据场景灵活选型</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><ol><li><p><strong>「快 vs 稳」的博弈</strong>：  </p><blockquote><p>若依框架虽加速开发，但过度依赖其生成代码可能导致<strong>技术债积累</strong>（如订单扩展字段需手动调整），下次需预留20%自定义空间。  </p></blockquote></li><li><p><strong>云服务的双刃剑</strong>：  </p><blockquote><p>微信云开发适合轻量应用，但<strong>数据库生态封闭</strong>（不支持MySQL）成为硬伤，混合架构虽解燃眉之急，也带来运维复杂度。  </p></blockquote></li></ol><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><ol><li><p><strong>技术选型更严谨</strong>：  </p><ul><li><p>制作 <strong>方案对比表</strong>（如下），避免试错成本：<br>| 方案         | 扩展性 | 维护成本 | 适合场景       |<br>| —————— | ——— | ———— | ——————— |<br>| 自建MySQL    | ★★★★   | 中       | 复杂业务       |<br>| 纯微信云开发 | ★★     | 低       | 轻量工具类应用 |<br>| <strong>混合云</strong>   | ★★★    | <strong>中高</strong> | <strong>中庸型项目</strong> |</p></li><li><p>非核心功能（如图片上传）<strong>彻底云化</strong>，直接用云开发SDK。  </p></li></ul></li><li><p><strong>建立原型验证机制</strong>：  </p><ul><li>重要模块（如订单状态机）先写 <strong>伪代码流程图</strong> 与产品确认，避免返工。  </li></ul></li></ol><blockquote><p><strong>总结</strong>：本周深刻体会架构选型需考量 <strong>业务生命周期</strong>（短期效率 vs 长期扩展）。未来将坚持 <strong>“设计-原型-开发”三步走</strong>，让技术真正服务业务增长。  </p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;核心工作&lt;/th&gt;
&lt;th&gt;关键产出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;周一&lt;/</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第四周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/</id>
    <published>2025-08-10T05:28:04.000Z</published>
    <updated>2025-12-11T09:11:29.726Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周一：</strong>  </p><ul><li>完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  </li><li><em>注意点：</em> 补充了状态字段设计。</li></ul><p><strong>周二：</strong>  </p><ul><li>构建订单系统：创建订单主表及详情表，实现：  <ul><li>JWT用户订单查询  </li><li>多状态分类（待支付/待发货等）  </li><li>PageHelper分页（&gt;10自动分页，加载页面缓存进度）  </li></ul></li><li><em>遗留问题：</em> 订单号长度仅20位（需32位）。</li></ul><p><strong>周三：</strong>  </p><ul><li>订单详情增强：调用土地接口展示租赁地块信息。  </li><li>前端隐患：<code>this.orderInfo.items[0]</code> 强耦合数据绑定。  </li></ul><p><strong>周四：</strong>  </p><ul><li>订单状态管理：实现增删改查及状态流转（如取消订单同步释放土地）。  </li><li><em>优化：</em> 采用状态模式替代if-else链。  </li></ul><p><strong>周五：</strong>  </p><ul><li>支付功能受阻：  <ol><li><strong>致命问题：</strong> 后端未配置HTTPS（微信支付强制要求）  </li><li><strong>设计缺陷：</strong> 订单号长度不符支付接口规范（20位≠32位）  </li></ol></li><li><em>转向：</em> 启动手机号验证方案研究。  </li></ul><p><strong>周六：</strong>  </p><ul><li>微信验证困局：  <ul><li>手机号快速验证失败（需企业认证）  </li><li><code>getUserProfile</code>仅获取基础信息（头像/昵称）  </li><li>开放数据解密流程复杂且无进展  </li></ul></li><li><em>结论：</em> 当前微信政策下，获取手机号一键登录不可行。  </li></ul><hr><p><strong>核心卡点：</strong>  </p><ol><li><strong>支付环节：</strong> HTTPS缺失 + 订单号设计缺陷  </li><li><strong>微信生态：</strong> 政策收紧导致手机号获取路径封死</li></ol><h3 id="一、独立完成-amp-挑战-amp-成长"><a href="#一、独立完成-amp-挑战-amp-成长" class="headerlink" title="一、独立完成 &amp; 挑战 &amp; 成长"></a><strong>一、独立完成 &amp; 挑战 &amp; 成长</strong></h3><div class="table-container"><table><thead><tr><th><strong>事项</strong></th><th><strong>独立完成</strong></th><th><strong>最大挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长</strong></th></tr></thead><tbody><tr><td><strong>租地系统</strong></td><td>租赁表设计 + JWT用户绑定</td><td>状态字段缺失</td><td>快速补字段 + 关联订单状态</td><td>意识到<strong>数据扩展性</strong>的重要性</td></tr><tr><td><strong>订单中台</strong></td><td>双表创建 + 分页/状态筛 + 状态机</td><td>订单号长度设计不足(20位)</td><td>重构为32位 UUID</td><td><strong>关键字段需预判业务需求</strong></td></tr><tr><td><strong>支付对接</strong></td><td>调用微信支付流程开发</td><td>1. 无HTTPS<br>2. 微信政策限制</td><td>转向备用方案（手机号验证）</td><td>第三方功能<strong>必须预研环境/政策</strong></td></tr><tr><td><strong>微信集成</strong></td><td>实现<code>getUserProfile</code>基础授权</td><td>无法获取用户准确信息（政策封锁）</td><td>明确放弃，转为人工审核流程</td><td>学会<strong>在限制中寻找替代路径</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a><strong>二、本周工作思考</strong></h3><ol><li><strong>做得好的</strong>  <ul><li>基础功能闭环：租地→订单→状态流转全链路跑通  </li><li>快速响应问题：发现订单号缺陷应该立即重构  </li></ul></li><li><strong>待改进的</strong>  <ul><li><strong>致命疏忽</strong>：支付未提前验证HTTPS/字段规则 → 导致整块功能返工  </li><li><strong>过度乐观</strong>：低估微信政策限制（开发者权限）  </li></ul></li><li><strong>核心认知</strong>  <blockquote><p><strong>“能开发” ≠ “能上线”</strong><br>第三方依赖的合规性（HTTPS/政策）比代码更重要  </p></blockquote></li></ol><hr><h3 id="三、未来同样机会的做法"><a href="#三、未来同样机会的做法" class="headerlink" title="三、未来同样机会的做法"></a><strong>三、未来同样机会的做法</strong></h3><ol><li><p><strong>预研四象限（首日必做）</strong>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[技术]</span>      <span class="hljs-selector-attr">[政策]</span>      <span class="hljs-selector-attr">[环境]</span>       <span class="hljs-selector-attr">[兼容性]</span>  <br>│          │          │            │  <br>├─HTTPS?   ├─微信文档? ├─测试账号?   ├─字段长度?  <br>└─SDK兼容  └─权限范围  └─域名备案    └─数据格式  <br></code></pre></td></tr></table></figure></li><li><p><strong>设计两原则</strong>  </p><ul><li><strong>字段设计</strong>：订单号/金额等支付相关字段，直接对齐微信要求（32位/UUID）  </li><li><strong>解耦开发</strong>：支付模块用模拟运行，便于替换（例：HTTPS未就绪时模拟支付）  </li></ul></li><li><p><strong>政策应对</strong>  </p><ul><li>项目避免强依赖微信敏感接口（如手机号）  </li></ul></li></ol><blockquote><p><strong>总结一句话</strong>：<br><strong>下次先花2小时跑通支付Demo+政策验证，再动手写业务代码。</strong><br>功能开发速度 ≠ 交付速度，预研省下的就是返工浪费的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;周一：&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;注意点：&lt;/em&gt; 补充了状态字段设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;周二：&lt;/strong&gt;  </summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第三周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/</id>
    <published>2025-08-01T16:26:28.000Z</published>
    <updated>2025-12-11T09:11:57.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心目标：</strong> 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。</p><p><strong>本周主要进展：</strong></p><ol><li><p><strong>项目启动与基础搭建 (周一)：</strong></p><ul><li>用开发工具创建了小程序项目框架。</li><li><strong>首页：</strong> 实现了图片热区点击跳转（用<code>绝对定位</code>精确定位点击区域，<code>uni.switchTab</code>跳转底部菜单页）。</li><li><strong>公告栏：</strong> 暂时留空。</li><li><strong>我的农场：</strong> 开始设计核心玩法（比如种植收获逻辑）。</li><li><strong>个人中心：</strong> 画好了页面布局。</li><li>图片上传到<code>图床</code>，减小小程序安装包体积。</li></ul></li><li><p><strong>界面优化与农场互动 (周二)：</strong></p><ul><li><strong>首页：</strong> 用<code>媒体查询</code>让页面在不同尺寸手机上都好看（响应式布局）。</li><li><strong>我的农场：</strong> 用<code>Grid网格布局</code>做了9块整齐的地块。点击地块能弹出操作图片（比如选择种子）。</li><li><strong>个人中心：</strong> 本想做微信<code>一键登录</code>（获取手机号），但个人小程序权限不够。改用方案：用户授权获取微信<code>头像和昵称</code>绑定账号，登录成功后服务器返回一个<code>token</code>（身份令牌）存起来，代表用户已登录。</li></ul></li><li><p><strong>新增功能模块 (周三)：</strong></p><ul><li><strong>首页：</strong> 加了“马克农场”入口，点击后跳转新页面（用<code>uni.navigateTo</code>页面跳转）。</li><li><strong>个人中心：</strong> 增加了“设置”页面，可以修改个人信息。</li></ul></li><li><p><strong>核心登录功能实现 (周四)：</strong></p><ul><li><strong>个人中心：</strong><ul><li>实现了完整的微信登录流程：<ol><li>小程序获取临时登录凭证<code>code</code>。</li><li>把<code>code</code>发给我的后台服务器。</li><li>后台用<code>code</code>向微信服务器换取用户的<code>唯一标识(openid)</code>等信息。</li><li>后台查数据库：如果是新用户，就创建账号；老用户则读取信息。</li><li>后台生成<code>token</code>，连同用户信息一起返回给小程序。</li><li>小程序把<code>token</code>和用户信息存起来（<code>storage</code>），后续操作代表该用户。</li></ol></li><li><em>注：等小程序主体是企业后，可升级为手机号直接登录。</em></li></ul></li><li><strong>订单页：</strong> 实现了跳转到不同订单类型页的功能（在链接后面加<code>?type=...</code>传参）。解决了引入图标库时的兼容性问题。</li></ul></li><li><p><strong>用户信息保护与更新 (周五)：</strong></p><ul><li>完善登录后的安全措施：采用<code>JWT令牌</code>进行<code>鉴权</code>（验证身份）。<ul><li><strong>为什么选JWT？</strong> 主要因为它不需要<code>Cookie</code>，避免了<code>跨域(CORS)</code>问题，更方便不同服务器间协作。而且服务器不用存储用户登录状态（<code>无状态</code>），减轻负担。</li><li><strong>怎么用？</strong> 用户登录后拿到<code>JWT token</code>（就是周四的那个token）。当用户想修改头像昵称等需要登录的操作时，小程序在请求头里带上这个token（格式：<code>Authorization: Bearer &lt;你的token&gt;</code>）。后台收到请求后，先<code>验证token是否有效且合法</code>，验证通过了才允许修改用户信息。</li></ul></li><li>实现了登录后修改头像和昵称的功能。</li></ul></li></ol><p><strong>简单来说，这周：</strong> 搭好了小程序的基础架子，重点实现了用户<code>登录注册流程</code>（包括微信授权、后台验证、生成令牌JWT），完成了个人中心的主要功能（信息展示、设置、头像昵称修改），并开始为订单系统做跳转准备。技术上解决了图片优化、布局适配、登录授权、身份验证（JWT）等关键点。</p><p>以下是对本周工作的结构化复盘总结，结合实践与成长思考：</p><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>完成内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>带来的成长</strong></th></tr></thead><tbody><tr><td><strong>1. 用户系统全流程搭建</strong><br> - 微信登录+JWT鉴权<br> - 头像/昵称修改功能</td><td>• 个人小程序无法直接获取手机号<br>• JWT无状态鉴权首次实战</td><td>• 改用 <strong>Code→OpenID→Token</strong> 替代方案<br>• 研读JWT机制，设计 <strong>Bearer Token</strong> 请求头鉴权逻辑</td><td>✅ 掌握<strong>受限条件下的灵活架构能力</strong><br>✅ 理解<strong>无状态认证</strong>的设计优势与风险</td></tr><tr><td><strong>2. 农场交互核心模块</strong><br> - Grid九宫格布局<br> - 地块点击弹窗交互</td><td>• 动态弹窗与地块操作状态联动<br>• 多端样式适配</td><td>• 用 <strong>CSS变量+媒体查询</strong> 控制响应式<br>• <strong>事件委托</strong> 统一管理地块点击逻辑</td><td>✅ 强化 <strong>复杂交互前端设计能力</strong><br>✅ 提升 <strong>CSS3实战应用水平</strong></td></tr><tr><td><strong>3. 项目基建优化</strong><br> - 图床节省包体积<br> - 路由传参统一管理</td><td>• 图标库兼容性问题<br>• 路由跳转类型混乱</td><td>• <strong>源码调试+强制样式覆盖</strong> 解决依赖冲突<br>• 封装 <strong>路由工具函数</strong> 统一处理?type=参数</td><td>✅ 学会 <strong>第三方库问题排查技巧</strong><br>✅ 养成 <strong>提前封装工具类</strong> 的习惯</td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><p><strong>1. 技术决策的价值</strong>：  </p><blockquote><p>选择JWT不仅解决了跨域问题，更让我意识到<strong>技术选型需服务业务场景</strong>——个人小程序无法用企业级登录方案时，用Token机制快速搭建安全认证体系是最优解。  </p></blockquote><p><strong>2. 限制催生创新</strong>：  </p><blockquote><p>微信API权限限制反而推动设计出更通用的 <strong>「Code+OpenID+DB」用户绑定流程</strong>，未来扩展手机号/邮箱登录只需复用该流程。  </p></blockquote><p><strong>3. 技术债预警</strong>：  </p><blockquote><p>临时解决CSS兼容性的“hack手段”需在迭代中重构，<strong>开发效率与代码质量必须动态平衡</strong>。  </p></blockquote><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><p><strong>1. 前置设计更彻底</strong>：  </p><blockquote><ul><li>用<strong>流程图</strong>预先规划登录/鉴权全链路（避免周四返工）  </li><li>订单系统数据库<strong>提前预留扩展字段</strong>（如<code>order_type</code>应对跳转传参）  </li></ul></blockquote><p><strong>2. 技术方案分层验证</strong>：  </p><blockquote><ul><li>关键模块（如JWT）先写<strong>技术原型Demo</strong>再集成  </li><li>第三方库（uView）提前做<strong>兼容性测试矩阵</strong>  </li></ul></blockquote><p><strong>3. 自动化提效</strong>：  </p><blockquote><ul><li>用<strong>CI/CD工具</strong>自动压缩图片上传图床  </li><li>编写<strong>路由配置生成脚本</strong>避免手写跳转参数  </li></ul><p><strong>总结</strong>：未来需更注重<strong>前瞻性设计</strong>与<strong>可持续架构</strong>，让代码既能跑得快，更能跑得远。  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心目标：&lt;/strong&gt; 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周主要进展：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;项目启动与基础搭建 (周一)：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第二周：手撕验证码Session，给订单系统“安家落户”</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/</id>
    <published>2025-07-26T17:20:11.000Z</published>
    <updated>2025-12-11T09:12:00.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心任务：</strong> 独立完成车位项目订单系统后端接口、前端页面及数据库设计。</p><p><strong>本周开发纪实：</strong></p><ol><li><strong>周一：</strong> 复盘上周工作，为本周冲刺蓄力。</li><li><strong>周二：</strong> 承接新需求：<ul><li><strong>记住手机号：</strong> 提升用户体验。</li><li><strong>自定义弹窗：</strong> 实现灵活交互。</li><li><strong>价格需求：</strong> 核心业务逻辑。</li><li><strong>技术选型：</strong> 确定使用 <code>HttpSession</code> 存储 <code>手机号:验证码</code> 键值对，作为临时认证方案。</li></ul></li><li><strong>周三：</strong> 功能实现日<ul><li>完成“记住手机号” ✅</li><li>集成验证码登录 ✅ (<strong>注意点：</strong> 接口参数类型需严格匹配，<code>Session ID</code> 不一致会导致校验失败 - <em>已解决</em>)</li><li>实现协议勾选及自定义弹窗 ✅</li><li><strong>兼容性问题：</strong> 确认微信浏览器不支持 <code>datalist</code> 元素。 (<em>已找到替代方案-采用div来自定义下拉框</em>✅)</li></ul></li><li><strong>周四：</strong> 优化与设计<ul><li><strong>验证码生命周期优化：</strong> 将清除逻辑从固定5分钟 (<code>setInterval</code>)，升级为 <strong>登录成功即销毁</strong> 或 <strong>5分钟到期销毁</strong>，更贴合实际场景。</li><li><strong>数据库设计：</strong> 新增 <code>订单表 (order)</code>。<ul><li>关键设计：通过 <code>spot_id</code> 外键关联车位表。</li><li>决策说明：未直接复用车位表 <code>user_id</code> 字段 (因车位归属逻辑与订单用户逻辑存在差异)。</li></ul></li></ul></li><li><strong>周五：</strong> 数据库深化<ul><li>完善 <code>订单表</code> 结构，清晰记录交易信息。</li><li>设计 <code>优惠规则表 (discount_rule)</code>，定义车位关联的折扣类型与规则。 (<em>终于给优惠上了“户口本”</em>)</li></ul></li><li><strong>周六：</strong> 逻辑实现 &amp; 性能飞跃<ul><li>完成订单金额计算引擎，支持匹配优惠规则。</li><li><strong>接口性能重大优化：</strong><ul><li><strong>问题：</strong> 原有设计需两个接口拉取 <strong>全量用户车位数据</strong>，效率低下。</li><li><strong>方案：</strong> 重构为单一接口，精准查询 <strong>当前用户订单信息</strong>。</li><li><strong>成果：</strong> <strong>响应速度显著提升，数据库压力大幅降低。</strong> ( <em>成功给臃肿接口“瘦身”</em> )</li></ul></li></ul></li></ol><p><strong>本周总结与反思：</strong></p><ol><li><p><strong>主要成就与挑战：</strong></p><ul><li><strong>独立完成：</strong> 成功独立完成了车位及订单模块的后端接口开发、前端订单页面设计以及相关数据库设计。</li><li><strong>关键挑战：</strong> 如何在后端安全、有效地存储和验证用户专属的短信验证码，避免多用户共用同一验证码的风险。</li><li><strong>解决方案：</strong> 采用基于 <code>HttpSession</code> 的存储方案：<ul><li>Key: 用户手机号</li><li>Value: 对应的验证码</li><li>生命周期管理：用户成功登录后或 Session 超时（设置 5 分钟）自动销毁。</li></ul></li><li><strong>成长点：</strong> 深入理解了 <code>HttpSession</code> 机制在后端数据临时存储中的应用。</li></ul></li><li><p><strong>反思与改进点：</strong></p><ul><li><strong>需求理解：</strong> 未来开发前，应更深入地与客户/产品沟通需求细节，以便更好地支持后续扩展性开发。</li><li><strong>数据库设计：</strong> 反思当前设计是否足够精细？例如 <code>user</code> 表可考虑增加 <code>user_type</code>、<code>created_at</code>、<code>last_login_at</code> 等字段增强功能性和可追溯性。</li><li><strong>设计文档：</strong> 意识到个人设计文档的详细度有待提高，需加强文档规范。</li></ul></li><li><p><strong>未来优化方向：</strong></p><ul><li><strong>沟通：</strong> 加强沟通，确保需求理解透彻，及时同步进展。</li><li><strong>数据库：</strong><ul><li>精细化核心表结构（如扩展 <code>user</code> 表字段）。</li><li>建立更清晰的表关系。</li></ul></li><li><strong>后端架构：</strong><ul><li>进行更清晰的分层设计（Controller / Service / Repository / Entity）。</li><li>将车位管理、用户收藏等模块进行逻辑拆分，提高可维护性。</li></ul></li><li><strong>前端：</strong><ul><li>加强浏览器兼容性测试（如已发现的微信 <code>datalist</code> 问题）。</li><li>持续进行界面加载速度优化。</li></ul></li><li><strong>目标：</strong> 通过以上改进，全面提升开发效率、代码质量和系统健壮性，促进个人技术能力的成长。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心任务：&lt;/strong&gt; 独立完成车位项目订单系统后端接口、前端页面及数据库设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周开发纪实：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;周一：&lt;/strong&gt; 复盘上周工作，为本周冲刺蓄力。&lt;/li</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第一周</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/</id>
    <published>2025-07-18T16:24:08.000Z</published>
    <updated>2025-12-11T09:11:52.499Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：新手村报到</strong><br>广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！</p><p><strong>Day 1: HTML星辰大海，打包是个误会？</strong><br>产品经理的原型图甩过来，先设计好文档没问题了再开干！祭出神器 <code>Cursor</code> + <code>Claude-3-Connect</code>，AI 辅助下吭哧吭哧撸完一堆纯 HTML 页面。AI 老哥贴心提示：“亲，打包上传哦~”。我信了！一头扎进打包工具的坑里折腾半天，汗流浃背。结果？<strong>发现特么的纯 HTML 直接扔服务器就能跑！</strong> 打包？打包了个寂寞！今日教训：AI 的话，也得结合上下文判断啊… (╯‵□′)╯︵┻━┻</p><p><strong>Day 2: SpringBoot 从零开始，CSDN 付费墙刺客！</strong><br>今日任务：搞后端 API 录入。第一次正经从零搭 <code>SpringBoot</code> 项目。IDEA 社区版 2023 有点坑，创建方式藏得深。CSDN 搜教程，好家伙，第一步就让装个插件，装完重启直接弹登录+<strong>付费订阅</strong>！真·知识付费刺客！果断弃坑。翻到良心文章指路：<a href="https://start.spring.io">https://start.spring.io</a>，官方生成器真香！唯一小插曲：我 JDK 11 的“老环境”，伺候不了 SpringBoot 3 这位“新贵”，手动把版本和相关依赖<strong>降级到 2.x</strong>，世界终于清净。结论：CSDN 水文害人，官方文档/工具永流传！</p><p><strong>Day 3: 宝塔端口玄学 &amp; “数字小孩”落户口！</strong><br>任务：把后端 API 部署上云服务器（宝塔面板）。一顿操作猛如虎：端口放行√，配置√。测试？<strong>死活连不上！</strong> CSDN 又跳出来“指点”：搞个随机域名数据库？一看还得付费固定域名？我信你个鬼！焦头烂额之际，<strong>猛然想起腾讯云还有个安全组！</strong> 火速添上端口规则，瞬间畅通！啊，这熟悉的安全感… (长舒一口气)</p><ul><li><strong>技术小悟：</strong> 跨域问题，不一定非搬 Nginx 大神。后端配个全局 <code>CORS</code>，指定好前端地址，也能愉快玩耍！省事！</li><li><strong>短信验证码插曲：</strong> 折腾半天接好了，但备案没过的号能发成功吗？心里有点虚，先当它行吧！</li></ul><p><strong>🌟 今日高光时刻 🌟</strong><br>今年我们团队的心血——<strong>“医疗健康问诊系统”</strong>，<strong>喜提国家版权局颁发的《计算机软件著作权登记证书》！</strong> 正式拥有了“<strong>数字小孩</strong>”的户口本！🎉</p><blockquote><p>感谢并肩作战的伙伴，<br>感谢每个改bug到天亮的自己。<br>——【医疗健康问诊系统】软著𝐆𝐞𝐭，未来可期！</p></blockquote><p><strong>Day 4: 切图仔の挣扎 vs 后端の从容（伪）</strong><br>实现一个“点击录入所有数据”的功能。纯 HTML + Vue 的组合，对我这个后端半吊子来说，操作 DOM 像在绣花… <strong>切图仔，属实不易！</strong> 顺带搞了车位收藏功能，数据库表设计修修补补好几回，勉强上线。<strong>结论：前端水太深，后端（的CRUD）才是俺的舒适区（暂时）！</strong></p><p><strong>Day 5: 数据库改改改，AI又救我狗命！</strong><br>搞车位收藏和抢购的多表查询。<strong>是的，我又双叒改数据库了！</strong> 最初设计图样图森破：想着一个车位记录，既能标记收藏又能记录谁买了，还绑 UserID。结果，“车位必须空闲”的规则和用户操作直接打架！卡壳半天，<strong>求助 AI 老哥</strong>，一语点醒：这设计有坑！火速重构，把状态、归属理清楚，功能终于跑通。<strong>教训：数据库设计，脑子得提前多绕几圈，少走弯路！</strong></p><p><strong>周记结尾：</strong><br>第一周，在疯狂踩坑、暴躁搜索、偶尔顿悟和一次巨大惊喜（软著！）中飞逝。从打包误会到安全组玄学，从被 CSDN 付费墙背刺到 AI 救场，从切图痛苦到改库狂魔… <strong>真实又酸爽！</strong> 见识了工具的便利与坑爹，体会了团队的温暖（和一起加班）。代码世界的大门刚推开一条缝，路还长，坑还多，但看着“数字小孩”上了户口，值了！下周，继续升级打怪！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：新手村报到&lt;/strong&gt;&lt;br&gt;广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Day 1: HTML星辰大海，打包是个误会？&lt;/stro</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链智能合约教程-医疗</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/</id>
    <published>2025-07-12T13:31:15.000Z</published>
    <updated>2025-10-01T04:54:48.513Z</updated>
    
    <content type="html"><![CDATA[<p>源码</p><p> <a href="https://zhengcookie.github.io\file\区块链\智能合约\medical\医疗\Main.sol">Main.sol</a> </p><p>以下是智能合约代码的逐段解析，按功能模块分类说明：</p><hr><h3 id="1-患者信息管理"><a href="#1-患者信息管理" class="headerlink" title="1. 患者信息管理"></a><strong>1. 患者信息管理</strong></h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Sick &#123;<br>    address accountAddress; // 患者钱包地址<br>    string name;            // 姓名<br>    string sex;             // 性别<br>    uint256 age;            // 年龄<br>    uint256 id;             // 身份证号(主键)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Sick) public sicks;  // 身份证号→患者信息的映射<br>uint256[] public sickIds;               // 所有患者身份证号列表<br></code></pre></td></tr></table></figure><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建患者档案 (需校验参数有效性)<br>function createSick(...) public &#123;<br>    // 参数校验...<br>    sicks[identityNumber] = Sick(...);  // 存储信息<br>    sickIds.push(identityNumber);       // 记录ID<br>    emit SickCreated(...);              // 触发事件<br>&#125;<br><br>// 按身份证查询患者<br>function getSickByIdentityNumber(...) public view returns (...) &#123;<br>    require(sick.accountAddress != address(0)); // 校验存在性<br>    return (sick.accountAddress, ...); <br>&#125;<br><br>// 按钱包地址查询患者<br>function getSickByAccountAddress(...) public view returns (...) &#123;<br>    uint256 sickID = findSickIDByAccountAddress(accountAddr); // 内部遍历查找<br>    return (sick.name, ...);<br>&#125;<br><br>// 辅助函数：地址→ID映射<br>function findSickIDByAccountAddress(...) internal view returns (...) &#123;<br>    for (uint256 i = 0; i &lt; sickIds.length; i++) &#123;<br>        if (sicks[sickID].accountAddress == accountAddr) return sickID;<br>    &#125;<br>    return 0;<br>&#125;<br><br>// 检查患者是否存在<br>function isSickExist(uint256 sickID) public view returns (bool) &#123;<br>    return sicks[sickID].accountAddress != address(0);<br>&#125;<br><br>// 获取所有患者ID列表<br>function getSicksList() public view returns (uint256[] memory) &#123;<br>    return sickIds;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-预约挂号系统"><a href="#2-预约挂号系统" class="headerlink" title="2. 预约挂号系统"></a><strong>2. 预约挂号系统</strong></h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Appointment &#123;<br>    string hospitalName; // 医院名称<br>    string department;   // 科室名称<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Appointment) public sickAppointment; // 患者ID→预约信息<br></code></pre></td></tr></table></figure><h4 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建预约<br>function createAppointment(...) public &#123;<br>    require(isSickExist(sickID));          // 患者必须存在<br>    sickAppointment[sickID] = Appointment(...); // 存储预约<br>    emit AppointmentCreated(...);           // 触发事件<br>&#125;<br><br>// 查询预约<br>function getSickAppointment(...) public view returns (...) &#123;<br>    require(bytes(appointment.hospitalName).length &gt; 0); // 校验存在性<br>    return (appointment.hospitalName, ...);<br>&#125;<br><br>// 删除预约<br>function deleteSickAppointment(uint256 sickID) public &#123;<br>    delete sickAppointment[sickID];  // 清除预约记录<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-电子病历管理"><a href="#3-电子病历管理" class="headerlink" title="3. 电子病历管理"></a><strong>3. 电子病历管理</strong></h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct MedicalRecord &#123;<br>    uint256 sickID;               // 患者ID<br>    string hospitalName;          // 医院<br>    string department;            // 科室<br>    string doctorName;            // 医生姓名<br>    string registrationInfo;      // 挂号信息<br>    string pastMedicalHistory;    // 既往病史<br>    string currentMedicalHistory; // 现病史<br>    string isFilled;              // 是否完成(&quot;Yes&quot;/&quot;No&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-2"><a href="#数据存储-2" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; MedicalRecord) public sickMedicalRecords; // 患者ID→病历<br></code></pre></td></tr></table></figure><h4 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建空白病历<br>function createMedicalRecord(...) public &#123;<br>    sickMedicalRecords[sickID] = MedicalRecord(...);<br>    emit MedicalRecordCreated(...);<br>&#125;<br><br>// 授权医生访问病历<br>function authorizeDoctor(...) public &#123;<br>    if (病历不存在) createMedicalRecord(...); // 自动创建空病历<br>    sickMedicalRecords[sickID].doctorName = doctorName; // 设置医生<br>&#125;<br><br>// 更新病历内容<br>function updateMedicalRecord(...) public &#123;<br>    medicalRecord.hospitalName = hospitalName; <br>    medicalRecord.pastMedicalHistory = pastMedicalHistory; // 更新病史等<br>    emit MedicalRecordUpdated(...);<br>&#125;<br><br>// 查询完整病历<br>function getMedicalRecordByIdentityNumber(...) public view returns (...) &#123;<br>    return (medicalRecord.hospitalName, ...); // 返回所有病历字段<br>&#125;<br><br>// 查询特定科室的既往病史<br>function getPastMedicalHistory(...) public view returns (...) &#123;<br>    require(keccak256(科室)==keccak256(目标科室)); // 严格科室匹配<br>    return medicalRecord.pastMedicalHistory;<br>&#125;<br><br>// 标记病历完成状态<br>function endMedicalConsultation(...) public &#123;<br>    medicalRecord.isFilled = mrtype; // 设置&quot;Yes&quot;/&quot;No&quot;<br>&#125;<br><br>// 检查病历是否完成<br>function isMedicalRecordFilled(...) public view returns (bool) &#123;<br>    return keccak256(medicalRecord.isFilled) == keccak256(&quot;Yes&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>该合约完整实现了患者档案管理、挂号预约、电子病历三大核心功能，构建了医疗数据上链的基础框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://zhengcookie.github.io&#92;file&#92;区块链&#92;智能合约&#92;medical&#92;医疗&#92;Main.sol&quot;&gt;Main.sol&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;以下是智能合约代码的逐段解析，按功能模块分类说明：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链赛题智能合约" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B5%9B%E9%A2%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://www.zhengcookie.site/zhengcookie/CSS/"/>
    <id>https://www.zhengcookie.site/zhengcookie/CSS/</id>
    <published>2025-07-11T20:10:39.000Z</published>
    <updated>2025-10-01T04:54:48.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><div class="table-container"><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>.classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref=“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table></div><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>内联样式：1000；</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><div class="table-container"><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table></div><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>　（2）<strong>inline：</strong>元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><strong>transform: scale(0,0)</strong>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者**</strong>区别如下：**</p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是**</strong>继承属性**</p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<span class="hljs-attribute">color</span>: red&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png" alt="img"></p><p>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong>如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p><p><strong>为什么要使用它们？</strong> </p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.css&quot;</span> /&gt;</span></span> <br>&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; </span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: none; </span></span><br><span class="language-css"><span class="language-xml">  &#125; </span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示<br><span class="hljs-attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行<br></code></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示<br><span class="hljs-attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。<br>-webkit-<span class="hljs-attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp:<span class="hljs-number">3</span>;        // 显示的行数<br></code></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位-1"><a href="#1-常见的CSS布局单位-1" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景-1"><a href="#2-px、em、rem的区别及使用场景-1" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现-1"><a href="#3-两栏布局的实现-1" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现-1"><a href="#4-三栏布局的实现-1" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现-1"><a href="#5-水平垂直居中的实现-1" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？-1"><a href="#6-如何根据设计稿进行移动端适配？-1" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景-1"><a href="#7-对Flex布局的理解及其使用场景-1" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong></p><p>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="9-响应式设计的概念及基本原理"><a href="#9-响应式设计的概念及基本原理" class="headerlink" title="9. 响应式设计的概念及基本原理"></a>9. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attr">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\200B&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>  &#125;<br>  <span class="hljs-selector-class">.clearfix</span>&#123;<br>    *<span class="hljs-attribute">zoom</span>: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clear</span>:none|left|right|both<br></code></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 </li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br> <br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">left</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">right</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级非定位后代元素。</p><p>（4）浮动盒：非定位浮动元素。</p><p>（5）行内盒：文档流内行内级非定位后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><div class="table-container"><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table></div><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong>元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png" alt="img"></p><ul><li><strong>fixed：</strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png" alt="img"></p><ul><li><strong>absolute：</strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: orange blue red green;<br>&#125;<br></code></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png" alt="img"></p><p>所以可以根据border这个特性来绘制三角形：</p><p><strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png" alt="img"></p><p><strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png" alt="img"></p><p><strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png" alt="img"></p><p><strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png" alt="img"></p><p><strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png" alt="img"></p><p>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-top-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png" alt="img"></p><p><strong>（1）实现圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>/<span class="hljs-number">150px</span>; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">100%</span>;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br></code></pre></td></tr></table></figure><p>为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。</p><p><strong>（2）实现半圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用元素的margin/padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;trapezoid&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>（1）实现一个直角梯形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">40px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773730069-a1bf7073-14ba-4665-9e5e-cf0aa0722235.png" alt="img"></p><p>（2）实现一个等腰梯形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-width</span>:<span class="hljs-number">0</span> <span class="hljs-number">40px</span> <span class="hljs-number">100px</span> <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">border-style</span>:none solid solid;<br>  <span class="hljs-attribute">border-color</span>:transparent transparent red;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773825580-c1821c13-4513-4462-9a13-73ad4a3ef6e6.png" alt="img"></p><h3 id="5-画一条0-5px的线"><a href="#5-画一条0-5px的线" class="headerlink" title="5. 画一条0.5px的线"></a>5. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, minimum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, maximum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>&quot;/&gt;<br></code></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="6-设置小于12px的字体"><a href="#6-设置小于12px的字体" class="headerlink" title="6. 设置小于12px的字体"></a>6. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="7-如何解决-1px-问题？"><a href="#7-如何解决-1px-问题？" class="headerlink" title="7. 如何解决 1px 问题？"></a>7. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">window.devicePixelRatio = 设备的物理像素 / CSS像素。<br></code></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.png" alt="img"></p><p>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。</p><p><strong>解决**</strong>1px 问题的三种思路：**</p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span><br></code></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：**</strong>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的<strong><strong>宽和高都设置为目标元素的两倍，border值设为 1px。</strong></strong>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一<strong>**，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scale = <span class="hljs-number">1</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;<br><span class="hljs-comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br>metaEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">`width=device-width,user-scalable=no,initial-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,maximum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,minimum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、CSS基础&quot;&gt;&lt;a href=&quot;#一、CSS基础&quot; class=&quot;headerlink&quot; title=&quot;一、CSS基础&quot;&gt;&lt;/a&gt;一、CSS基础&lt;/h2&gt;&lt;h3 id=&quot;1-CSS选择器及其优先级&quot;&gt;&lt;a href=&quot;#1-CSS选择器及其优先级&quot; class</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="css" scheme="https://www.zhengcookie.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://www.zhengcookie.site/zhengcookie/HTML/"/>
    <id>https://www.zhengcookie.site/zhengcookie/HTML/</id>
    <published>2025-07-11T19:55:23.000Z</published>
    <updated>2025-10-01T04:54:48.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p><p>（1）src</p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src =”js.<span class="hljs-property">js</span>”&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p><p>（2）href</p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link href=”common.<span class="hljs-property">css</span>” rel=”stylesheet”/&gt;<br></code></pre></td></tr></table></figure><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h2><p><strong>语义化是指**</strong>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  头部<br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>  导航栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  区块（有语义化的div）<br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  主要区域<br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  主要内容<br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  侧边栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>  底部<br></code></pre></td></tr></table></figure><h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义**</strong>来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h2 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:</p><p><img src="https://zhengcookie.github.io/file/前端面试题/HTML.assets/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="img"></p><p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h2 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值/device-width)</li><li><code>height viewport</code> ：高度(数值/device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&#x27;true&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop=‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&#x27;imgs/aa.jpg&#x27;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签</p><p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.flv&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/flv&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.mp4&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li>placeholder ：提示信息</li><li>autofocus ：自动获取焦点</li><li><p>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li>pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li><li>multiple：可以选择多个文件或者多个邮箱</li><li>form=” form表单的ID”</li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong></p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h2 id="9-对-web-worker-的理解"><a href="#9-对-web-worker-的理解" class="headerlink" title="9. 对 web worker 的理解"></a>9. 对 web worker 的理解</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong></p><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong></p><p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 </p><p>其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;1-src和href的区别&quot;&gt;&lt;a href=&quot;#1-src和href的区别&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="html" scheme="https://www.zhengcookie.site/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="https://www.zhengcookie.site/zhengcookie/javascript/"/>
    <id>https://www.zhengcookie.site/zhengcookie/javascript/</id>
    <published>2025-07-11T19:33:56.000Z</published>
    <updated>2025-12-17T00:37:50.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是**</strong>判断在其原型链中能否找到该类型的原型**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br> <br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br> <br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>([]));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">000</span>: object   - 当前存储的数据指向一个对象。<br>  <span class="hljs-number">1</span>: int      - 当前存储的数据是一个 <span class="hljs-number">31</span> 位的有符号整数。<br><span class="hljs-number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<br><span class="hljs-number">100</span>: string   - 当前存储的数据指向一个字符串。<br><span class="hljs-number">110</span>: boolean  - 当前存储的数据是布尔值。<br></code></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011.</span>..<br></code></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> <span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(arg1 - arg2) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;        <br>&#125;        <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numberepsilon</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-其他值到字符串的转换规则？"><a href="#11-其他值到字符串的转换规则？" class="headerlink" title="11. 其他值到字符串的转换规则？"></a>11. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="12-其他值到数字值的转换规则？"><a href="#12-其他值到数字值的转换规则？" class="headerlink" title="12. 其他值到数字值的转换规则？"></a>12. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="13-其他值到布尔类型的值的转换规则？"><a href="#13-其他值到布尔类型的值的转换规则？" class="headerlink" title="13. 其他值到布尔类型的值的转换规则？"></a>13. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p><p>• undefined</p><p>• null</p><p>• false</p><p>• +0、-0 和 NaN</p><p>• “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#15-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="15. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>15. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-JavaScript-中如何进行隐式类型转换？"><a href="#17-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="17. JavaScript 中如何进行隐式类型转换？"></a>17. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@obj</span> 需要转换的对象</span><br><span class="hljs-comment">* <span class="hljs-doctag">@type</span> 期望的结果类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">ToPrimitive</span>(obj,type)<br></code></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>**type**</code><strong>为</strong><code>**number**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>**type**</code><strong>为</strong><code>**string**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">objToNumber</span> = value =&gt; <span class="hljs-title class_">Number</span>(value.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>())<br><span class="hljs-title function_">objToNumber</span>([]) === <span class="hljs-number">0</span><br><span class="hljs-title function_">objToNumber</span>(&#123;&#125;) === <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>**+**</code><strong>操作符</strong><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// &#x27;123&#x27;</span><br> <span class="hljs-number">1</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// 1 </span><br> <span class="hljs-number">1</span> + <span class="hljs-title class_">Symbol</span>() <span class="hljs-comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span><br> <span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &#x27;1false&#x27;</span><br> <span class="hljs-literal">false</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li><code>**-**</code><strong>、</strong><code>*****</code><strong>、</strong><code>**\**</code><strong>操作符</strong><code>NaN</code>也是一个数字</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// 23</span><br> <span class="hljs-number">1</span> * <span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br> <span class="hljs-number">1</span> / <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**==**</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false, 3 转为number为3，true转为number为1</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// &#x27;0&#x27;转为number为0</span><br></code></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**&lt;**</code><strong>和</strong><code>**&gt;**</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;ca&#x27;</span> &lt; <span class="hljs-string">&#x27;bd&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;a&#x27;</span> &lt; <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;12&#x27;</span> &lt; <span class="hljs-number">13</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> &gt; -<span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;<br>a &gt; <span class="hljs-number">2</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br><span class="hljs-title class_">NaN</span> &gt; <span class="hljs-number">2</span> <span class="hljs-comment">//false，得出比较结果</span><br></code></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;<br><span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>b.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// 同理</span><br>b.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong>块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><div class="table-container"><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table></div><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的<strong>proto</strong>属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doesNotReturn</span>();<br></code></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;GLOBAL&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">a</span>();    <span class="hljs-comment">// &#x27;OBJ&#x27;</span><br>obj.<span class="hljs-title function_">b</span>();    <span class="hljs-comment">// &#x27;GLOBAL&#x27;</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">a</span>()  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">b</span>()  <span class="hljs-comment">// Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>)<br>&#125;;<br><span class="hljs-title function_">fun1</span>();                     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">apply</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);    <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;)();   <span class="hljs-comment">// &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 </span><br><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === obj); <br>    &#125;; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5，由 Babel 转译</span><br><span class="hljs-keyword">var</span> obj = &#123; <br>   <span class="hljs-attr">getArrow</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>; <br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_this === obj); <br>     &#125;; <br>   &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = &#123; ...bar &#125;; <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, bar); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> baz = &#123;...bar, ...&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>&#125;&#125;;  <span class="hljs-comment">// &#123;a: 2, b: 4&#125;</span><br></code></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对**</strong>对象实例的拷贝属于浅拷贝**。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>])<br><span class="hljs-comment">// 1 [2, 3, 4] 5</span><br></code></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1];<br></code></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;one&#x27;</span>, ...arr1, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>];<br><span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></code></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>first <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];         <span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">const</span> [first, ...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[...<span class="hljs-string">&#x27;hello&#x27;</span>]    <span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>**Math**</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...numbers); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...numbers); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h3 id="7-对对象与数组的解构的理解"><a href="#7-对对象与数组的解构的理解" class="headerlink" title="7. 对对象与数组的解构的理解"></a>7. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p><p><strong>1）数组的解构</strong></p><p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913177-30749c84-8254-4543-a3e7-c2fb488a4228.png" alt="img"></p><p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913186-eb8be693-9b19-48e5-bda5-9dbd7cc77ea6.png" alt="img"></p><p><strong>2）对象的解构</strong></p><p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stu = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name, age &#125; = stu<br></code></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913314-53687a23-07ef-4a01-a78a-a0304f2b2826.png" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; age, name &#125; = stu<br></code></pre></td></tr></table></figure><h3 id="8-如何提取高度嵌套的对象里的指定属性？"><a href="#8-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="8. 如何提取高度嵌套的对象里的指定属性？"></a>8. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> school = &#123;<br>   <span class="hljs-attr">classes</span>: &#123;<br>      <span class="hljs-attr">stu</span>: &#123;<br>         <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>         <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name &#125; = school<br></code></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; classes &#125; = school<br><span class="hljs-keyword">const</span> &#123; stu &#125; = classes<br><span class="hljs-keyword">const</span> &#123; name &#125; = stu<br>name <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">classes</span>: &#123; <span class="hljs-attr">stu</span>: &#123; name &#125; &#125;&#125; = school<br>       <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)  <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="9-对-rest-参数的理解"><a href="#9-对-rest-参数的理解" class="headerlink" title="9. 对 rest 参数的理解"></a>9. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> args) &#123;<br>    result *= val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="10-ES6中模板语法与字符串处理"><a href="#10-ES6中模板语法与字符串处理" class="headerlink" title="10. ES6中模板语法与字符串处理"></a>10. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">&#x27;my name is &#x27;</span> + name + <span class="hljs-string">&#x27;, I work as a &#x27;</span> + career + <span class="hljs-string">&#x27;, I love &#x27;</span> + hobby[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27; and &#x27;</span> + hobby[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>, I work as a <span class="hljs-subst">$&#123;career&#125;</span> I love <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">0</span>]&#125;</span> and <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">1</span>]&#125;</span>`</span><br></code></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 正确输出，不存在报错</span><br></code></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">const</span> finalString = <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> + <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a+b&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalString)<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 &#x27;1 + 2 = 3&#x27;</span><br></code></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><ul><li><p><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p></li><li><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> son = <span class="hljs-string">&#x27;haha&#x27;</span> <br><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">includes</span>(son) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;haha&#x27;</span>) <span class="hljs-comment">// false</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;xixi&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>  father.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;hehe&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">&#x27;repeat for 3 times;&#x27;</span><br><span class="hljs-keyword">const</span> repeated = sourceCode.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(repeated) <span class="hljs-comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span><br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><div class="table-container"><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table></div><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在</p><p>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p><p>例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 </p><p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong>给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong>动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong>设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>`</td><td>`</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table></div><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。</p><p>例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span> <br>   <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br> = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，3|5的值为7。</p><p>注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><p>因此，3^5的值为6。</p><p>异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p>运算规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p><p>例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br>= <span class="hljs-number">1111</span> <span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p><p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br>   = <span class="hljs-number">1111</span> <span class="hljs-number">1001</span><br>反码：<span class="hljs-number">1000</span> <span class="hljs-number">0110</span><br>补码：<span class="hljs-number">1000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p><p>设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</p><p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。</p><p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。</p><p>例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br></code></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br>补码：<span class="hljs-number">1111</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">const</span> arrArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>) <br>  arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">const</span> arrArgs = [...<span class="hljs-variable language_">arguments</span>] <br>    arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)) <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p></li><li><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong></p><p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp);<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp[i]);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别： </p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。 </li></ul><p>ES6 Module和CommonJS模块的共同点： </p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。 </li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong>for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table></div><p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Person.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> <span class="hljs-comment">// Person</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1605247722640-5bcb9156-a8b4-4d7c-83d7-9ff80930e1de.jpeg" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-params">obj</span>)&#123;<br>   <span class="hljs-keyword">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))<br>           res.<span class="hljs-title function_">push</span>(key+<span class="hljs-string">&#x27;: &#x27;</span>+obj[key]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">B</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-title function_">A</span>()<br><span class="hljs-title function_">B</span>() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  ;(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, j * <span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong></p><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>**eval**</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong></p><p>此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<span class="hljs-comment">//1. 打印 script start</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)<span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async/await"></a>（3）async/await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func1</span>())<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1604021075237-8249a8df-3a28-4bca-9f22-02923aba8618.png" alt="img"></p><p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">func1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  <span class="hljs-comment">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong></p><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>**new Promise()**</code><strong>来创建promise对象，但是也可以使用</strong><code>**promise.resolve**</code><strong>和</strong> <code>**promise.reject**</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">11</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(“我错了，请原谅俺！！”));<br></code></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;我错了，请原谅俺！！&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br><span class="hljs-title function_">testPromise</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">promise.then(function(value) &#123;<br>  // success<br>&#125;, function(error) &#123;<br>  // failure<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p><p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>); <br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-comment">//结果为：[1,2,3] </span><br>&#125;)<br></code></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">//结果：2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">rej</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server.<span class="hljs-title function_">listen</span>(port)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(server.<span class="hljs-property">stop</span>);<br></code></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise<br>.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>  fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; <span class="hljs-title function_">reject</span>(error)<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">read</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data) <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）**</strong>Promise.all**</p><p><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async/await 的理解"></a>7.  对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1605099411873-d2eac25a-5d8c-4586-bc36-769bce79010e.png" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>() <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2);<br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">resolve</span>(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  <span class="hljs-keyword">let</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 3秒钟之后出现cug</span><br>&#125;<br><span class="hljs-title function_">testAwt</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async/await的优势"></a>9.  async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="hljs-comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">takeLongTime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-title function_">step1</span>(time1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> <span class="hljs-title function_">step2</span>(time2))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> <span class="hljs-title function_">step3</span>(time3))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br><span class="hljs-comment">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="hljs-comment">// step1 with 300</span><br><span class="hljs-comment">// step2 with 500</span><br><span class="hljs-comment">// step3 with 700</span><br><span class="hljs-comment">// result is 900</span><br><span class="hljs-comment">// doIt: 1507.251ms</span><br></code></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 </li><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 </li><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 </li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 </li></ul><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p><p><strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code>obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj1 = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> obj2 = &#123;&#125;;<br>    obj1.<span class="hljs-property">a</span> = obj2; <span class="hljs-comment">// obj1 引用 obj2</span><br>    obj2.<span class="hljs-property">a</span> = obj1; <span class="hljs-comment">// obj2 引用 obj1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj1.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br> obj2.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>**object**</code><strong>进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型&quot;&gt;&lt;/a&gt;一、数据类型&lt;/h2&gt;&lt;h3 id=&quot;1-JavaScript有哪些数据类型，它们的区别？&quot;&gt;&lt;a href=&quot;#1-JavaScrip</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="javascript" scheme="https://www.zhengcookie.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>合约</title>
    <link href="https://www.zhengcookie.site/zhengcookie/%E5%90%88%E7%BA%A6/"/>
    <id>https://www.zhengcookie.site/zhengcookie/%E5%90%88%E7%BA%A6/</id>
    <published>2025-07-09T11:00:01.000Z</published>
    <updated>2025-11-06T09:10:08.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts"></a></h1><p>Solidity中的合约类似于面向对象语言中的类。 它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。 在不同的合约（实例）上调用一个函数将执行一个EVM函数调用， 从而切换上下文，使调用合约中的状态变量无法访问。 任何事情的发生都需要调用合约及其函数。 在以太坊中没有 “定时（cron）” 的概念来在特定事件中自动调用函数。</p><h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-1"></a></h2><p>可以通过以太坊交易 “从外部” 或从 Solidity 合约内部创建合约。</p><p>集成开发环境，如 <a href="https://remix.ethereum.org/">Remix</a>，使用UI元素使创建过程无缝化。</p><p>在以太坊上以编程方式创建合约的一种方法是通过JavaScript API <a href="https://github.com/web3/web3.js">web3.js</a>。 它有一个名为 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的函数， 以方便创建合约。</p><p>当一个合约被创建时，它的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor">构造函数（constructor）</a> （一个用 <code>constructor</code> 关键字声明的函数）被执行一次。</p><p>构造函数是可选的。但是只允许有一个构造函数，这意味着不支持重写。</p><p>构造函数执行完毕后，合约的最终代码被存储在区块链上。 这段代码包括所有公开和外部函数，以及所有通过函数调用可从那里到达的函数。 部署的代码不包括构造函数代码或只从构造函数调用的内部函数。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 传递， 但是如果您使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想创建另一个合约，创建者必须知道所创建合约的源代码（和二进制）。 这意味着，循环的创建依赖是不可能的。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIOaYr+WmguS4i+WumuS5ieeahOWQiOe6puexu+Wei+OAggogICAgLy8g5LiN5Yib5bu65paw5ZCI57qm55qE6K+d77yM5Lmf5Y+v5Lul5byV55So5a6D44CCCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8g6L+Z5piv5rOo5YaMIGNyZWF0b3Ig5ZKM6K6+572u5ZCN56ew55qE5p6E6YCg5Ye95pWw44CCCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8g54q25oCB5Y+Y6YeP6YCa6L+H5YW25ZCN56ew6K6/6Zeu77yMCiAgICAgICAgLy8g6ICM5LiN5piv6YCa6L+H5L6L5aaCIGB0aGlzLm93bmVyYCDnmoTmlrnlvI/orr/pl67jgIIKICAgICAgICAvLyDlh73mlbDlj6/ku6Xnm7TmjqXmiJbpgJrov4cgYHRoaXMuZmAg6K6/6Zeu44CCCiAgICAgICAgLy8g5L2G5ZCO6ICF5o+Q5L6b5LqG5LiA5Liq5a+55Ye95pWw55qE5aSW6YOo5Y+v6KeG5pa55rOV44CCCiAgICAgICAgLy8g54m55Yir5piv5Zyo5p6E6YCg5Ye95pWw5Lit77yM5oKo5LiN5bqU6K+l5LuO5aSW6YOo6K6/6Zeu5Ye95pWw77yMCiAgICAgICAgLy8g5Zug5Li66K+l5Ye95pWw6L+Y5LiN5a2Y5Zyo44CCCiAgICAgICAgLy8g6K+m6KeB5LiL5LiA6IqC44CCCiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgICAgICAvLyDmiJHku6zov5vooYzkuobku44gYGFkZHJlc3NgIOWIsCBgVG9rZW5DcmVhdG9yYCDnmoTmmL7lvI/nsbvlnovovazmjaLvvIwKICAgICAgICAvLyDlubblgYflrprosIPnlKjlkIjnuqbnmoTnsbvlnovmmK8gYFRva2VuQ3JlYXRvcmDvvIwKICAgICAgICAvLyDmsqHmnInnnJ/mraPnmoTmlrnms5XmnaXpqozor4HvvIwKICAgICAgICAvLyDov5nlubbmsqHmnInliJvlu7rkuIDkuKrmlrDnmoTlkIjnuqbjgIIKICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyDlj6rmnInliJvlu7rogIXlj6/ku6XmlLnlj5jlkI3np7DjgIIKICAgICAgICAvLyDmiJHku6zmoLnmja7lkIjnuqbnmoTlnLDlnYDov5vooYzmr5TovoPvvIwKICAgICAgICAvLyDlroPlj6/ku6XpgJrov4fmmL7lvI/ovazmjaLkuLrlnLDlnYDmnaXmo4DntKLjgIIKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBhZGRyZXNzKGNyZWF0b3IpKQogICAgICAgICAgICBuYW1lID0gbmV3TmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgewogICAgICAgIC8vIOWPquacieW9k+WJjeaJgOacieiAheaJjeiDveWPkemAgSB0b2tlbuOAggogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIOaIkeS7rOmAmui/h+S9v+eUqOS4i+mdouWumuS5ieeahCBgVG9rZW5DcmVhdG9yYCDlkIjnuqbnmoTkuIDkuKrlh73mlbAKICAgICAgICAvLyDmnaXor6Lpl67liJvlu7rogIXlkIjnuqbmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICAvLyDlpoLmnpzosIPnlKjlpLHotKXvvIjkvovlpoLnlLHkuo7nh4PmlpnlgLzogJflsL3vvInvvIwKICAgICAgICAvLyDov5nph4znmoTmiafooYzkuZ/kvJrlpLHotKXjgIIKICAgICAgICBpZiAoY3JlYXRvci5pc1Rva2VuVHJhbnNmZXJPSyhvd25lciwgbmV3T3duZXIpKQogICAgICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9CgoKY29udHJhY3QgVG9rZW5DcmVhdG9yIHsKICAgIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGJ5dGVzMzIgbmFtZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChPd25lZFRva2VuIHRva2VuQWRkcmVzcykKICAgIHsKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgYFRva2VuYCDlkIjnuqblubbov5Tlm57lhbblnLDlnYDjgIIKICAgICAgICAvLyDku45KYXZhU2NyaXB05pa56Z2i5p2l55yL77yMCiAgICAgICAgLy8g6L+Z5Liq5Ye95pWw55qE6L+U5Zue57G75Z6L5pivIGBhZGRyZXNzYO+8jAogICAgICAgIC8vIOWboOS4uui/meaYr0FCSeS4reacgOaOpei/keeahOexu+Wei+OAggogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8g5ZCM5qC377yMYHRva2VuQWRkcmVzc2Ag55qE5aSW6YOo57G75Z6L5piv566A5Y2V55qEIGBhZGRyZXNzYOOAggogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIOaJp+ihjOajgOafpe+8jOS7peehruWumuaYr+WQpuW6lOivpeWwhuS7o+W4gei9rOenu+WIsCBgT3duZWRUb2tlbmAg5ZCI57qm5LiK44CCCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyDmo4Dmn6XkuIDkuKrku7vmhI/nmoTmnaHku7bvvIznnIvmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoY3VycmVudE93bmVyLCBuZXdPd25lcikpWzBdID09IDB4N2Y7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br>contract OwnedToken &#123;<br>    <span class="hljs-comment">// `TokenCreator` 是如下定义的合约类型。</span><br>    <span class="hljs-comment">// 不创建新合约的话，也可以引用它。</span><br>    TokenCreator creator;<br>    address owner;<br>    bytes32 name;<br><br>    <span class="hljs-comment">// 这是注册 creator 和设置名称的构造函数。</span><br>    constructor(bytes32 name_) &#123;<br>        <span class="hljs-comment">// 状态变量通过其名称访问，</span><br>        <span class="hljs-comment">// 而不是通过例如 `this.owner` 的方式访问。</span><br>        <span class="hljs-comment">// 函数可以直接或通过 `this.f` 访问。</span><br>        <span class="hljs-comment">// 但后者提供了一个对函数的外部可视方法。</span><br>        <span class="hljs-comment">// 特别是在构造函数中，您不应该从外部访问函数，</span><br>        <span class="hljs-comment">// 因为该函数还不存在。</span><br>        <span class="hljs-comment">// 详见下一节。</span><br>        owner = msg.sender;<br><br>        <span class="hljs-comment">// 我们进行了从 `address` 到 `TokenCreator` 的显式类型转换，</span><br>        <span class="hljs-comment">// 并假定调用合约的类型是 `TokenCreator`，</span><br>        <span class="hljs-comment">// 没有真正的方法来验证，</span><br>        <span class="hljs-comment">// 这并没有创建一个新的合约。</span><br>        creator = TokenCreator(msg.sender);<br>        name = name_;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(bytes32 newName) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有创建者可以改变名称。</span><br>        <span class="hljs-comment">// 我们根据合约的地址进行比较，</span><br>        <span class="hljs-comment">// 它可以通过显式转换为地址来检索。</span><br>        <span class="hljs-keyword">if</span> (msg.sender == address(creator))<br>            name = newName;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> transfer(address newOwner) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有当前所有者才能发送 token。</span><br>        <span class="hljs-keyword">if</span> (msg.sender != owner) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 我们通过使用下面定义的 `TokenCreator` 合约的一个函数</span><br>        <span class="hljs-comment">// 来询问创建者合约是否应该进行转移。</span><br>        <span class="hljs-comment">// 如果调用失败（例如由于燃料值耗尽），</span><br>        <span class="hljs-comment">// 这里的执行也会失败。</span><br>        <span class="hljs-keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))<br>            owner = newOwner;<br>    &#125;<br>&#125;<br><br><br>contract TokenCreator &#123;<br>    <span class="hljs-built_in">function</span> createToken(bytes32 name)<br>        <span class="hljs-keyword">public</span><br>        returns (OwnedToken tokenAddress)<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的 `Token` 合约并返回其地址。</span><br>        <span class="hljs-comment">// 从JavaScript方面来看，</span><br>        <span class="hljs-comment">// 这个函数的返回类型是 `address`，</span><br>        <span class="hljs-comment">// 因为这是ABI中最接近的类型。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OwnedToken(name);<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(OwnedToken tokenAddress, bytes32 name) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 同样，`tokenAddress` 的外部类型是简单的 `address`。</span><br>        tokenAddress.changeName(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行检查，以确定是否应该将代币转移到 `OwnedToken` 合约上。</span><br>    <span class="hljs-built_in">function</span> isTokenTransferOK(address currentOwner, address newOwner)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">bool</span> ok)<br>    &#123;<br>        <span class="hljs-comment">// 检查一个任意的条件，看是否应该进行转移。</span><br>        <span class="hljs-keyword">return</span> keccak256(abi.encodePacked(currentOwner, newOwner))[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>x7f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可见性和-getter-函数"><a href="#可见性和-getter-函数" class="headerlink" title="可见性和 getter 函数"></a>可见性和 getter 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter"></a></h2><h3 id="状态变量的可见性"><a href="#状态变量的可见性" class="headerlink" title="状态变量的可见性"></a>状态变量的可见性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id3"></a></h3><ul><li><p><code>public</code></p><p>公开状态变量与内部变量的不同之处在于，编译器会自动为它们生成 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions">getter函数</a>， 从而允许其他合约读取它们的值。当在同一个合约中使用时，外部访问（例如 <code>this.x</code>）会调用getter， 而内部访问（例如 <code>x</code>）会直接从存储中获取变量值。 Setter函数没有被生成，所以其他合约不能直接修改其值。</p></li><li><p><code>internal</code></p><p>内部状态变量只能从它们所定义的合约和派生合约中访问。 它们不能被外部访问。 这是状态变量的默认可见性。</p></li><li><p><code>private</code></p><p>私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p></li></ul><p>警告</p><p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p><h3 id="函数的可见性"><a href="#函数的可见性" class="headerlink" title="函数的可见性"></a>函数的可见性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id4"></a></h3><p>Solidity 有两种函数调用：确实创建了实际 EVM 消息调用的外部函数和不创建 EVM 消息调用的内部函数。 此外，派生合约可能无法访问内部函数。 这就产生了四种类型的函数的可见性。</p><ul><li><p><code>external</code></p><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用 （即 <code>f()</code> 不起作用，但 <code>this.f()</code> 可以）。</p></li><li><p><code>public</code></p><p>公开函数是合约接口的一部分，可以在内部或通过消息调用。</p></li><li><p><code>internal</code></p><p>内部函数只能从当前的合约或从它派生出来的合约中访问。 它们不能被外部访问。 由于它们没有通过合约的ABI暴露在外部，它们可以接受内部类型的参数，如映射或存储引用。</p></li><li><p><code>private</code></p><p>私有函数和内部函数一样，但它们在派生合约中是不可见的。</p></li></ul><p>警告</p><p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p><p>在状态变量的类型之后，以及在函数的参数列表和返回参数列表之间，都会给出可见性指定符。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a) <span class="hljs-keyword">private</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> b) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-built_in">function</span> setData(<span class="hljs-built_in">uint</span> a) internal &#123; data = a; &#125;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的例子中，合约 <code>D</code>, 可以调用 <code>c.getData()</code> 来检索状态存储中 <code>data</code> 的值， 但不能调用 <code>f</code>。 合约 <code>E</code> 是从合约 <code>C</code> 派生出来的，因此可以调用 <code>compute</code>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyDov5nlsIbkuI3kvJrnvJbor5EKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyDplJnor6/vvJrmiJDlkZggYGZgIOS4jeWPr+ingQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyDplJnor6/vvJrmiJDlkZggYGNvbXB1dGVgIOS4jeWPr+ingQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIOiuv+mXruWGhemDqOaIkOWRmO+8iOS7jue7p+aJv+WQiOe6puiuv+mXrueItuWQiOe6puaIkOWRmO+8iQogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">private</span> data;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">private</span> pure <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> b</span>)</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">setData</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">public</span></span> &#123; data = a; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">getData</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">compute</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b</span>) <span class="hljs-keyword">internal</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;<br><br><span class="hljs-comment">// 这将不会编译</span><br>contract D &#123;<br>    <span class="hljs-function">function <span class="hljs-title">readData</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> local = c.f(<span class="hljs-number">7</span>); <span class="hljs-comment">// 错误：成员 `f` 不可见</span><br>        c.setData(<span class="hljs-number">3</span>);<br>        local = c.getData();<br>        local = c.compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 错误：成员 `compute` 不可见</span><br>    &#125;<br>&#125;<br><br>contract E <span class="hljs-keyword">is</span> C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> val = compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 访问内部成员（从继承合约访问父合约成员）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Getter-函数"><a href="#Getter-函数" class="headerlink" title="Getter 函数"></a>Getter 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions"></a></h3><p>编译器会自动为所有 <strong>公开</strong> 状态变量创建getter函数。 对于下面给出的合约，编译器将生成一个名为 <code>data</code> 的函数， 它没有任何输入参数，并返回一个 <code>uint</code>， 即状态变量 <code>data</code> 的值。状态变量在声明时可以被初始化。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data = <span class="hljs-number">42</span>;<br>&#125;<br><br>contract Caller &#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> c.data();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getter函数具有外部可见性。 如果该符号被内部访问（即没有 <code>this.</code>），它被评估为一个状态变量。 如果它被外部访问（即有 <code>this.</code>），它将被评价为一个函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIOWGhemDqOiuv+mXrgogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8g5aSW6YOo6K6/6ZeuCiAgICB9Cn0=">open in Remix</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint <span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span>;<br>    function x() <span class="hljs-keyword">public</span> returns (uint) &#123;<br>        <span class="hljs-keyword">data</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 内部访问</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>(); <span class="hljs-comment">// 外部访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您有一个数组类型的 <code>public</code> 状态变量， 那么您只能通过生成的getter函数检索数组的单个元素。 这种机制的存在是为了避免在返回整个数组时产生高额的燃料成本。 您可以使用参数来指定要返回的单个元素，例如 <code>myArray(0)</code>。 如果您想在一次调用中返回整个数组，那么您需要写一个函数，例如：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyDlhazlvIDnirbmgIHlj5jph48KICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyDnvJbor5HlmajnlJ/miJDnmoRnZXR0ZXLlh73mlbAKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyDov5Tlm57mlbTkuKrmlbDnu4TnmoTlh73mlbAKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract arrayExample &#123;<br>    <span class="hljs-comment">// 公开状态变量</span><br>    <span class="hljs-built_in">uint</span>[] <span class="hljs-keyword">public</span> myArray;<br><br>    <span class="hljs-comment">// 编译器生成的getter函数</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    function myArray(uint i) public view returns (uint) &#123;</span><br><span class="hljs-comment">        return myArray[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 返回整个数组的函数</span><br>    <span class="hljs-function">function <span class="hljs-title">getArray</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> myArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在您可以使用 <code>getArray()</code> 来检索整个数组， 而不是使用 <code>myArray(i)</code>，它每次调用只返回一个元素。</p><p>下一个例子稍微复杂一些：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcodWludCA9PiB1aW50KSBtYXA7CiAgICAgICAgdWludFszXSBjOwogICAgICAgIHVpbnRbXSBkOwogICAgICAgIGJ5dGVzIGU7CiAgICB9CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhib29sID0+IERhdGFbXSkpIHB1YmxpYyBkYXRhOwp9">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Complex &#123;<br>    struct Data &#123;<br>        <span class="hljs-keyword">uint</span> a;<br>        bytes3 b;<br>        mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">uint</span>) map;<br>        <span class="hljs-keyword">uint</span>[<span class="hljs-number">3</span>] c;<br>        <span class="hljs-keyword">uint</span>[] d;<br>        bytes e;<br>    &#125;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; mapping(<span class="hljs-keyword">bool</span> =&gt; Data[])) <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>它生成了一个如下形式的函数。结构中的映射和数组（字节数组除外）被省略了， 因为没有好的方法来选择单个结构成员或为映射提供一个键：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9">open in Remix</a></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">function</span> <span class="hljs-class"><span class="hljs-keyword">data</span>(<span class="hljs-title">uint</span> <span class="hljs-title">arg1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">arg2</span>, <span class="hljs-title">uint</span> <span class="hljs-title">arg3</span>)</span><br>    public<br>    returns (uint a, bytes3 b, bytes memory e)<br>&#123;<br>    a = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].a;</span><br>    b = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].b;</span><br>    e = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].e;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifiers"></a></h2><p>函数修饰器可以用来以声明的方式改变函数的行为。 例如，您可以使用修饰器在执行函数之前自动检查一个条件。</p><p>修饰器是合约的可继承属性，可以被派生合约重写， 但只有当它们被标记为 <code>virtual</code> 时，才能被重写。 详情请见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding">修饰器重写</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIOi/meS4quWQiOe6puWPquWumuS5ieS6huS4gOS4quS/rumlsOWZqO+8jOS9huayoeacieS9v+eUqOWug++8mgogICAgLy8g5a6D5bCG5Zyo5rS+55Sf5ZCI57qm5Lit5L2/55So44CCCiAgICAvLyDkv67ppbDlmajmiYDkv67ppbDnmoTlh73mlbDkvZPkvJrooqvmj5LlhaXliLDnibnmrornrKblj7cgYF87YCDnmoTkvY3nva7jgIIKICAgIC8vIOi/meaEj+WRs+edgO+8jOWmguaenOaJgOacieiAheiwg+eUqOi/meS4quWHveaVsO+8jOi/meS4quWHveaVsOWwseS8muiiq+aJp+ihjO+8jAogICAgLy8g5ZCm5YiZ5bCx5Lya5oqb5Ye65LiA5Liq5byC5bi444CCCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgZGVzdHJ1Y3RpYmxlIGlzIG93bmVkIHsKICAgIC8vIOi/meS4quWQiOe6puS7jiBgb3duZWRgIOWQiOe6pue7p+aJv+S6hiBgb25seU93bmVyYCDkv67ppbDlmajvvIwKICAgIC8vIOW5tuWwhuWFtuW6lOeUqOS6jiBgZGVzdHJveWAg5Ye95pWw77yMCiAgICAvLyDlj6rmnInlnKjlkIjnuqbph4zkv53lrZjnmoQgb3duZXIg6LCD55SoIGBkZXN0cm95YCDlh73mlbDvvIzmiY3kvJrnlJ/mlYjjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBzZWxmZGVzdHJ1Y3Qob3duZXIpOwogICAgfQp9Cgpjb250cmFjdCBwcmljZWQgewogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul5o6l5Y+X5Y+C5pWw77yaCiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHJlZ2lzdGVyZWRBZGRyZXNzZXM7CiAgICB1aW50IHByaWNlOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgaW5pdGlhbFByaWNlKSB7IHByaWNlID0gaW5pdGlhbFByaWNlOyB9CgogICAgLy8g5Zyo6L+Z6YeM5Lmf5L2/55So5YWz6ZSu5a2XIGBwYXlhYmxlYCDpnZ7luLjph43opoHvvIwKICAgIC8vIOWQpuWImeWHveaVsOS8muiHquWKqOaLkue7neaJgOacieWPkemAgee7meWug+eahOS7peWkquW4geOAggogICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSBwdWJsaWMgcGF5YWJsZSBjb3N0cyhwcmljZSkgewogICAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzZXNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZVByaWNlKHVpbnQgcHJpY2VfKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBwcmljZSA9IHByaWNlXzsKICAgIH0KfQoKY29udHJhY3QgTXV0ZXggewogICAgYm9vbCBsb2NrZWQ7CiAgICBtb2RpZmllciBub1JlZW50cmFuY3koKSB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIWxvY2tlZCwKICAgICAgICAgICAgIlJlZW50cmFudCBjYWxsLiIKICAgICAgICApOwogICAgICAgIGxvY2tlZCA9IHRydWU7CiAgICAgICAgXzsKICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICAvLy8g6L+Z5Liq5Ye95pWw5Y+X5LqS5pal6YeP5L+d5oqk77yM6L+Z5oSP5ZGz552AIGBtc2cuc2VuZGVyLmNhbGxgIOS4reeahOmHjeWFpeiwg+eUqOS4jeiDveWGjeasoeiwg+eUqCAgYGZg44CCCiAgICAvLy8gYHJldHVybiA3YCDor63lj6XmjIflrprov5Tlm57lgLzkuLogN++8jOS9huS/rumlsOWZqOS4reeahOivreWPpSBgbG9ja2VkID0gZmFsc2VgIOS7jeS8muaJp+ihjOOAggogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br><br>    <span class="hljs-comment">// 这个合约只定义了一个修饰器，但没有使用它：</span><br>    <span class="hljs-comment">// 它将在派生合约中使用。</span><br>    <span class="hljs-comment">// 修饰器所修饰的函数体会被插入到特殊符号 `_;` 的位置。</span><br>    <span class="hljs-comment">// 这意味着，如果所有者调用这个函数，这个函数就会被执行，</span><br>    <span class="hljs-comment">// 否则就会抛出一个异常。</span><br>    modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            <span class="hljs-string">&quot;Only owner can call this function.&quot;</span><br>        );<br>        _;<br>    &#125;<br>&#125;<br><br>contract destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-comment">// 这个合约从 `owned` 合约继承了 `onlyOwner` 修饰器，</span><br>    <span class="hljs-comment">// 并将其应用于 `destroy` 函数，</span><br>    <span class="hljs-comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract priced &#123;<br>    <span class="hljs-comment">// 修饰器可以接受参数：</span><br>    <span class="hljs-function">modifier <span class="hljs-title">costs</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-keyword">value</span> &gt;= price) &#123;<br>            _;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Register <span class="hljs-keyword">is</span> priced, destructible &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">bool</span>) registeredAddresses;<br>    <span class="hljs-built_in">uint</span> price;<br><br>    constructor(<span class="hljs-built_in">uint</span> initialPrice) &#123; price = initialPrice; &#125;<br><br>    <span class="hljs-comment">// 在这里也使用关键字 `payable` 非常重要，</span><br>    <span class="hljs-comment">// 否则函数会自动拒绝所有发送给它的以太币。</span><br>    <span class="hljs-function">function <span class="hljs-title">register</span>() <span class="hljs-keyword">public</span> payable <span class="hljs-title">costs</span>(<span class="hljs-params">price</span>)</span> &#123;<br>        registeredAddresses[msg.sender] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">changePrice</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price_</span>) <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        price = price_;<br>    &#125;<br>&#125;<br><br>contract Mutex &#123;<br>    <span class="hljs-built_in">bool</span> locked;<br>    <span class="hljs-function">modifier <span class="hljs-title">noReentrancy</span>()</span> &#123;<br>        require(<br>            !locked,<br>            <span class="hljs-string">&quot;Reentrant call.&quot;</span><br>        );<br>        locked = <span class="hljs-literal">true</span>;<br>        _;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> `return 7` 语句指定返回值为 7，但修饰器中的语句 `locked = false` 仍会执行。</span><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> noReentrancy <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        (<span class="hljs-built_in">bool</span> success,) = msg.sender.call(<span class="hljs-string">&quot;&quot;</span>);<br>        require(success);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您想访问定义在合约 <code>C</code> 中的修饰器 <code>m</code>， 您可以使用 <code>C.m</code> 来引用它而不需要虚拟查询。 只能使用定义在当前合约或其基础合约中的修饰器。 修饰器也可以定义在库合约中，但其使用仅限于同一库合约的函数。</p><p>如果同一个函数有多个修饰器，它们之间以空格隔开，并按照所呈现的顺序进行评估运算。</p><p>修饰器不能隐式地访问或改变它们所修改的函数的参数和返回值。 它们的值只能在调用的时候明确地传递给它们。</p><p>在函数修改器中，有必要指定何时运行应用修改器的函数。 占位符语句（用单个下划线字符 <code>_</code> 表示）用于表示被修改的函数主体应该插入的位置。 请注意，占位符操作符与在变量名中使用下划线作为前导或尾随字符不同， 后者是一种风格上的选择。</p><p>修饰器或函数体的显式返回只离开当前修饰器或函数体。 返回变量会被赋值，但整个执行逻辑会从前一个修饰器中定义的 <code>_</code> 之后继续执行。</p><p>警告</p><p>在Solidity的早期版本中，具有修饰器的函数中的 <code>return</code> 语句会表现的不同。</p><p>用 <code>return;</code> 从修饰器显式返回并不影响函数返回的值。 然而，修饰器可以选择完全不执行函数主体，在这种情况下， 返回变量被设置为 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>，就像函数有一个空主体一样。</p><p><code>_</code> 符号可以在修饰器中多次出现。每次出现都会被替换成函数体。 该函数返回最后一次调用的返回值。</p><p>允许修饰器参数使用任意表达式，在这种情况下，所有从函数中可见的符号在修饰器中都是可见的。 修饰器中引入的符号在函数中是不可见的（因为它们可能因重写而改变）。</p><h2 id="常量和不可变状态变量"><a href="#常量和不可变状态变量" class="headerlink" title="常量和不可变状态变量"></a>常量和不可变状态变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constants"></a></h2><p>状态变量可以被声明为 <code>constant</code> 或 <code>immutable</code>。 在这两种情况下，变量在合约构建完成后不能被修改。 对于 <code>constant</code> 变量，其值必须在编译时固定， 而对于 <code>immutable</code> 变量，仍然可以在构造时分配。</p><p>也可以在文件级别定义 <code>constant</code> 变量。</p><p>编译器并没有为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式。</p><p>与普通的状态变量相比，常量变量（constant）和不可改变的变量（immutable）的燃料成本要低得多。 对于常量变量，分配给它的表达式被复制到所有访问它的地方，并且每次都要重新评估， 这使得局部优化成为可能。不可变的变量在构造时被评估一次，其值被复制到代码中所有被访问的地方。 对于这些值，要保留32个字节，即使它们可以装入更少的字节。由于这个原因，常量值有时会比不可变的值更便宜。</p><p>目前，并非所有的常量和不可变量的类型都已实现。 唯一支持的类型是 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#strings">字符串类型</a> （仅用于常量）和 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#value-types">值类型</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjE7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzID0gMTg7CiAgICB1aW50IGltbXV0YWJsZSBtYXhCYWxhbmNlOwogICAgYWRkcmVzcyBpbW11dGFibGUgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgZGVjaW1hbHNfLCBhZGRyZXNzIHJlZikgewogICAgICAgIGlmIChkZWNpbWFsc18gIT0gMCkKICAgICAgICAgICAgLy8gaW1tdXRhYmxl5Y+Y6YeP5Y+q5pyJ5Zyo6YOo572y5pe25omN5piv5LiN5Y+v5Y+Y55qE44CCCiAgICAgICAgICAgIC8vIOWcqOaehOW7uuaXtu+8jOWug+S7rOWPr+S7peiiq+WIhumFjeS7u+aEj+asoeaVsOOAggogICAgICAgICAgICBkZWNpbWFscyA9IGRlY2ltYWxzXzsKCiAgICAgICAgLy8g5a+5aW1tdXRhYmxl5Y+Y6YeP55qE6LWL5YC855Sa6Iez5Y+v5Lul6K6/6Zeu546v5aKD5Y+Y6YeP44CCCiAgICAgICAgbWF4QmFsYW5jZSA9IHJlZi5iYWxhbmNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGlzQmFsYW5jZVRvb0hpZ2goYWRkcmVzcyBvdGhlcikgcHVibGljIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBvdGhlci5iYWxhbmNlID4gbWF4QmFsYW5jZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.21</span>;<br><br><span class="hljs-built_in">uint</span> constant X = <span class="hljs-number">32</span>**<span class="hljs-number">22</span> + <span class="hljs-number">8</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">string</span> constant TEXT = <span class="hljs-string">&quot;abc&quot;</span>;<br>    bytes32 constant MY_HASH = keccak256(<span class="hljs-string">&quot;abc&quot;</span>);<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> decimals = <span class="hljs-number">18</span>;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> maxBalance;<br>    address <span class="hljs-keyword">immutable</span> owner = msg.sender;<br><br>    constructor(<span class="hljs-built_in">uint</span> decimals_, address <span class="hljs-keyword">ref</span>) &#123;<br>        <span class="hljs-keyword">if</span> (decimals_ != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// immutable变量只有在部署时才是不可变的。</span><br>            <span class="hljs-comment">// 在构建时，它们可以被分配任意次数。</span><br>            decimals = decimals_;<br><br>        <span class="hljs-comment">// 对immutable变量的赋值甚至可以访问环境变量。</span><br>        maxBalance = <span class="hljs-keyword">ref</span>.balance;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> isBalanceTooHigh(address other) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">bool</span>) &#123;<br>        <span class="hljs-keyword">return</span> other.balance &gt; maxBalance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constant"></a></h3><p>对于 <code>constant</code> 变量，其值在编译时必须是一个常量，并且必须在变量声明的地方分配。 任何访问存储、区块链数据（例如： <code>block.timestamp</code>, <code>address(this).balance</code> 或 <code>block.number</code>） 或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code>）或者调用外部合约的表达式都是不允许的。 但可能对内存分配产生副作用的表达式是允许的，但那些可能对其他内存对象产生副作用的表达式是不允许的。 内置函数 <code>keccak256</code>， <code>sha256</code>， <code>ripemd160</code>， <code>ecrecover</code>， <code>addmod</code> 和 <code>mulmod</code> 是允许的（尽管除了 <code>keccak256</code>，它们确实调用了外部合约）。</p><p>允许在内存分配器上产生副作用的原因是， 它应该可以构建复杂的对象，比如说查找表。 这个功能现在还不能完全使用。</p><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#immutable"></a></h3><p>声明为 <code>immutable</code> 的变量比声明为 <code>constant</code> 的变量受到的限制要少一些： 不可变（immutable）变量可以在构造时赋值。 该值在部署前的任何时候都可以更改，然后成为永久值。</p><p>另外一个限制是，不可变变量只能分配给创建后不可能被执行的表达式内部。 这就排除了所有修改器定义和构造函数以外的函数。</p><p>读取不可变变量没有任何限制。 读取甚至可以在变量第一次被写入之前进行， 因为Solidity中的变量总是有一个定义明确的初始值。 因此，也允许永远不对不可变变量显式赋值。</p><p>警告</p><p>在构造时访问不可变变量时，请牢记 <a href="https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#state-variable-initialization-order">初始化顺序</a>。 即使您提供了显式初始化器，某些表达式可能最终会在初始化器之前被求值， 尤其是当它们处于继承层次结构的不同层级时。</p><p>备注</p><p>在 Solidity 0.8.21 之前，不可变变量的初始化限制较多。 这些变量必须在构造时被初始化一次，而且在此之前不能被读取。</p><p>编译器生成的合约创建代码会在返回合约之前修改合约的运行时代码， 并用分配给它们的值替换所有对不可变变量的引用。 如果您要比较编译器生成的运行时代码和实际存储在区块链中的运行时代码，这一点非常重要。 编译器会在 <a href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api">编译器JSON标准输出</a> 的 <code>immutableReferences</code> 字段中 输出这些不可变变量在部署字节码中的位置。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#functions"></a></h2><p>可以在合约内部和外部定义函数。</p><p>合约之外的函数，也称为 “自由函数”，总是隐含着 <code>internal</code> 的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">可见性</a>。 它们的代码包含在所有调用它们的合约中，类似于内部库函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Zyo5YaF6YOo6LCD55So6Ieq55Sx5Ye95pWw44CCCiAgICAgICAgLy8g57yW6K+R5Zmo5Lya5bCG5YW25Luj56CB5re75Yqg5Yiw5ZCI57qm5Lit44CCCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)<br>        s += arr[i];<br>&#125;<br><br>contract ArrayExample &#123;<br>    <span class="hljs-keyword">bool</span> found;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这在内部调用自由函数。</span><br>        <span class="hljs-comment">// 编译器会将其代码添加到合约中。</span><br>        <span class="hljs-keyword">uint</span> s = sum(arr);<br>        <span class="hljs-keyword">require</span>(s &gt;= <span class="hljs-number">10</span>);<br>        found = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>在合约之外定义的函数仍然总是在合约的范围内执行。 它们仍然可以调用其他合约，向它们发送以太，并销毁调用它们的合约，以及其他一些事情。 与合约内定义的函数的主要区别是，自由函数不能直接访问变量 <code>this</code>，存储变量和不在其范围内的函数。</p><h3 id="函数参数和返回变量"><a href="#函数参数和返回变量" class="headerlink" title="函数参数和返回变量"></a>函数参数和返回变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-parameters-return-variables"></a></h3><p>与许多其他语言不同, 函数接受类型化的参数作为输入， 也可以返回任意数量的值作为输出。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id10"></a></h4><p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。</p><p>例如，如果您想让您的合约接受一种带有两个整数的外部调用，您可以使用类似以下的方式：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">uint</span> sum;<br>    <span class="hljs-built_in">function</span> taker(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> &#123;<br>        sum = a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数参数可以像任何其他局部变量一样使用，它们也可以被赋值。</p><h4 id="返回的变量"><a href="#返回的变量" class="headerlink" title="返回的变量"></a>返回的变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8"></a></h4><p>函数的返回变量在 <code>returns</code> 关键字之后用同样的语法声明。</p><p>例如，假设您想返回两个结果：作为函数参数传递的两个整数的总和和乘积，那么您就使用类似的方法：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        sum = a + b;<br>        product = a * b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回变量的名字可以被省略。返回变量可以像其他本地变量一样使用， 它们被初始化为相应的 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>， 并且在它们被（重新）赋值之前拥有这个值。</p><p>您可以明确地赋值给返回变量，然后像上面那样结束函数， 或者您可以用 <code>return</code> 语句直接提供返回值（单个或 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return">多个返回值</a>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (a + b, a * b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您过早使用 <code>return</code> 来结束一个有返回变量的函数，您必须在返回语句中同时提供返回值。</p><p>备注</p><p>您不能从非内部函数返回某些类型。 这包括下面列出的类型和任何递归地包含它们的复合类型：</p><ul><li>映射，</li><li>内部函数类型，</li><li>参考类型，位置设置为 <code>storage</code>，</li><li>多维数组（仅适用于 <a href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>），</li><li>结构体（仅适用于 <a href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>）。</li></ul><p>这个限制不适用于库函数，因为它们有不同的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#library-selectors">内部 ABI</a>。</p><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return"></a></h4><p>当一个函数有多个返回类型时，语句 <code>return (v0, v1, ..., vn)</code> 可以用来返回多个值。 声明的数量必须与返回变量的数量相同，并且它们的类型必须匹配， 有可能是经过 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types-conversion-elementary-types">隐式转换</a>。</p><h3 id="状态可变性"><a href="#状态可变性" class="headerlink" title="状态可变性"></a>状态可变性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#state-mutability"></a></h3><h4 id="View-函数"><a href="#View-函数" class="headerlink" title="View 函数"></a>View 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#view"></a></h4><p>函数可以被声明为 <code>view</code>，在这种情况下，它们承诺不修改状态。</p><p>备注</p><p>如果编译器的EVM版本是Byzantium或更新的（默认）， 当调用 <code>view</code> 函数时，会使用操作码 <code>STATICCALL</code>，这使得状态作为EVM执行的一部分保持不被修改。 对于库合约的 <code>view</code> 函数，会使用 <code>DELEGATECALL</code>， 因为没有组合的 <code>DELEGATECALL</code> 和 <code>STATICCALL</code>。 这意味着库合约中的 <code>view</code> 函数没有防止状态修改的运行时的检查。 这应该不会对安全产生负面影响，因为库合约的代码通常在编译时就知道了， 而且静态检查器也会进行编译时检查。</p><p>以下声明被认为是修改状态：</p><ol><li>修改状态变量。</li><li><a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events">产生事件</a>。</li><li><a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts">创建其它合约</a>。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送以太币。</li><li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含特定操作码的内联汇编。</li></ol><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>) + block.timestamp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>函数上的 <code>constant</code> 曾经是 <code>view</code> 的别名，但在0.5.0版本中被取消。</p><p>备注</p><p>Getter方法被自动标记为 <code>view</code>。</p><p>备注</p><p>在0.5.0版本之前，编译器没有为 <code>view</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得 <code>view</code> 函数通过使用无效的显式类型转换进行状态修改。 通过对 <code>view</code> 函数使用 <code>STATICCALL</code>，在EVM层面上防止了对状态的修改。</p><h4 id="Pure-函数"><a href="#Pure-函数" class="headerlink" title="Pure 函数"></a>Pure 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#pure"></a></h4><p>函数可以被声明为 <code>pure</code>，在这种情况下，它们承诺不读取或修改状态。 特别是，应该可以在编译时评估一个 <code>pure</code> 函数，只给它的输入和 <code>msg.data</code>， 但不知道当前区块链状态。这意味着读取 <code>immutable</code> 的变量可以是一个非标准pure的操作。</p><p>备注</p><p>如果编译器的EVM版本是Byzantium或更新的（默认），则使用操作码 <code>STATICCALL</code>， 这并不能保证不读取状态，但至少不能修改。</p><p>除了上面解释的状态修改语句列表外，以下内容被认为是从状态中读取的：</p><ol><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或者 <code>&lt;address&gt;.balance</code>。</li><li>访问 <code>block</code>， <code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">错误发生</a> 时， Pure 函数能够使用 <code>revert()</code> 和 <code>require()</code> 函数来恢复潜在的状态变化。</p><p>恢复一个状态变化不被认为是 “状态修改”， 因为只有之前在没有 <code>view</code> 或 <code>pure</code> 限制的代码中对状态的改变才会被恢复， 并且该代码可以选择捕捉 <code>revert</code> 而不传递给它。</p><p>这种行为也与 <code>STATICCALL</code> 操作码一致。</p><p>警告</p><p>在EVM层面不可能阻止函数读取状态，只可能阻止它们写入状态 （即只有 <code>view</code> 可以在EVM层面执行， <code>pure</code> 不可以）。</p><p>备注</p><p>在0.5.0版本之前，编译器没有为 <code>pure</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得在 <code>pure</code> 函数中通过使用无效的显式类型转换进行状态修改。 通过对 <code>pure</code> 函数使用 <code>STATICCALL</code>，在EVM层面防止了对状态的修改。</p><p>备注</p><p>在0.4.17版本之前，编译器并没有强制要求 <code>pure</code> 不读取状态。 这是一个编译时的类型检查，可以规避在合约类型之间做无效的显式转换， 因为编译器可以验证合约的类型不做改变状态的操作， 但它不能检查将在运行时被调用的合约是否真的属于该类型。</p><h3 id="特殊的函数"><a href="#特殊的函数" class="headerlink" title="特殊的函数"></a>特殊的函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#special-functions"></a></h3><h4 id="接收以太的函数"><a href="#接收以太的函数" class="headerlink" title="接收以太的函数"></a>接收以太的函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function"></a></h4><p>一个合约最多可以有一个 <code>receive</code> 函数， 使用 <code>receive() external payable &#123; ... &#125;</code> 来声明。（没有 <code>function</code> 关键字）。 这个函数不能有参数，不能返回任何东西，必须具有 <code>external</code> 的可见性和 <code>payable</code> 的状态可变性。 它可以是虚拟的，可以重写，也可以有修饰器。</p><p>receive 函数是在调用合约时执行的，并带有空的 calldata。 这是在纯以太传输（例如通过 <code>.send()</code> 或 <code>.transfer()</code> ）时执行的函数。 如果不存在这样的函数，但存在一个 payable 类型的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function">fallback函数</a>， 这个 fallback 函数将在纯以太传输时被调用。 如果既没有直接接收以太（receive函数），也没有 payable 类型的 fallback 函数， 那么合约就不能通过不代表支付函数调用的交易接收以太币，还会抛出一个异常。</p><p>在最坏的情况下， <code>receive</code> 函数只有2300个燃料可用（例如当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基本的记录外，几乎没有空间来执行其他操作。以下操作的消耗燃料将超过2300燃料的规定：</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量燃料的外部函数</li><li>发送以太币</li></ul><p>警告</p><p>当以太被直接发送到一个合约（没有使用函数调用，即发送者使用 <code>send</code> 或 <code>transfer</code>）， 但接收合约没有定义一个接收以太的函数或一个 payable 类型的 fallback 函数，会抛出一个异常， 将以太送回（这在Solidity v0.4.0之前是不同的）。因此，如果您想让您的合约接收以太， 您必须实现一个 receive 函数（不建议使用 payable 类型的 fallback 函数来接收以太， 因为它不会因为接口混乱而失败）。</p><p>警告</p><p>没有接收以太币功能的合约可以作为 <em>coinbase交易</em> （又称 <em>矿工区块奖励</em>）的接收者 或作为 <code>selfdestruct</code> 的目的地接收以太币。</p><p>合约不能对这样的以太币转移做出反应，因此也不能拒绝它们。 这是EVM的一个设计选择，Solidity无法绕过它。</p><p>这也意味着 <code>address(this).balance</code> 可以高于合约中 实现的一些手工记帐的总和（即在接收以太函数中更新的累加器）。</p><p>下面您可以看到一个使用 <code>receive</code> 函数的Sink合约的例子。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g6L+Z5Liq5ZCI57qm5Lya5L+d55WZ5omA5pyJ5Y+R6YCB57uZ5a6D55qE5Lul5aSq5biB77yM5rKh5pyJ5Yqe5rOV6L+U6L+Y44CCCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span><br>contract Sink &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Received</span>(<span class="hljs-params">address, <span class="hljs-built_in">uint</span></span>)</span>;<br>    receive() external payable &#123;<br>        <span class="hljs-function">emit <span class="hljs-title">Received</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Fallback-函数"><a href="#Fallback-函数" class="headerlink" title="Fallback 函数"></a>Fallback 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback"></a></h4><p>一个合约最多可以有一个 <code>fallback</code> 函数，使用 <code>fallback () external [payable]</code> 或 <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code> 来声明（都没有 <code>function</code> 关键字）。 这个函数必须具有 <code>external</code> 的函数可见性。 一个 fallback 函数可以被标记为 virtual，可以标记为 override，也可以有修饰器。</p><p>如果其他函数都不符合给定的函数签名，或者根本没有提供数据， 也没有 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太的函数</a>，那么fallback函数将在调用合约时执行。 fallback函数总是接收数据，但为了同时接收以太，它必须被标记为 <code>payable</code>。</p><p>如果使用带参数的版本， <code>input</code> 将包含发送给合约的全部数据（等于 <code>msg.data</code>）， 并可以在 <code>output</code> 中返回数据。返回的数据将不会被ABI编码。 相反，它将在没有修改的情况下返回（甚至没有填充）。</p><p>在最坏的情况下，如果一个可接收以太的fallback函数也被用来代替接收功能， 那么它只有2300燃料是可用的 （参见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太函数</a> 对这一含义的简要描述）。</p><p>像任何函数一样，只要有足够的燃料传递给它，fallback函数就可以执行复杂的操作。</p><p>警告</p><p>如果没有 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">receive 函数</a> 的存在， 一个标记为 <code>payable</code> 的 fallback 函数也会在普通的以太传输时执行。 如果您已经定义了一个 payable 类型的 fallback 函数， 我们仍建议您也定义一个 receive 函数接收以太，以区分以太传输和接口混淆的情况。</p><p>备注</p><p>如果您想对输入数据进行解码，您可以检查前四个字节的函数选择器， 然后您可以使用 <code>abi.decode</code> 与数组切片语法一起对ABI编码的数据进行解码： <code>(c, d) = abi.decode(input[4:], (uint256, uint256));</code> 注意，这只能作为最后的手段，应该使用适当的函数来代替。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyDmiYDmnInlj5HpgIHliLDmraTlkIjnuqbnmoTmtojmga/pg73kvJrosIPnlKjmraTlh73mlbDvvIjmsqHmnInlhbbku5blh73mlbDvvInjgIIKICAgIC8vIOWQkeivpeWQiOe6puWPkemAgeS7peWkquW4geWwhuW8lei1t+W8guW4uO+8jAogICAgLy8g5Zug5Li6ZmFsbGJhY2vlh73mlbDmsqHmnIkgYHBheWFibGVgIOS/rumlsOWZqOOAggogICAgZmFsbGJhY2soKSBleHRlcm5hbCB7IHggPSAxOyB9Cn0KCmNvbnRyYWN0IFRlc3RQYXlhYmxlIHsKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIC8vIOaJgOacieWPkemAgeWIsOatpOWQiOe6pueahOa2iOaBr+mDveS8muiwg+eUqOi/meS4quWHveaVsO+8jAogICAgLy8g6Zmk5LqG5pmu6YCa55qE5Lul5aSq5Lyg6L6T77yI6Zmk5LqGcmVjZWl2ZeWHveaVsO+8jOayoeacieWFtuS7luWHveaVsO+8ieOAggogICAgLy8g5Lu75L2V5a+56K+l5ZCI57qm55qE6Z2e56m655qE6LCD55So6YO95bCG5omn6KGMZmFsbGJhY2vlh73mlbDvvIjljbPkvb/ku6XlpKrkuI7osIPnlKjkuIDotbfooqvlj5HpgIHvvInjgIIKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8g6L+Z5Liq5Ye95pWw5piv5Li657qv5Lul5aSq5Lyg6L6T6ICM6LCD55So55qE77yMCiAgICAvLyDljbPkuLrmr4/kuIDkuKrluKbmnInnqbpjYWxsZGF0YeeahOiwg+eUqOOAggogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgeyB4ID0gMjsgeSA9IG1zZy52YWx1ZTsgfQp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgZnVuY3Rpb24gY2FsbFRlc3QoVGVzdCB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMeOAggoKICAgICAgICAvLyBhZGRyZXNzKHRlc3Qp5bCG5LiN5YWB6K6455u05o6l6LCD55SoIGBgc2VuZGBg77yMCiAgICAgICAgLy8g5Zug5Li6IGBgdGVzdGBgIOayoeacieWPr+aOpeaUtuS7peWkqueahGZhbGxiYWNr5Ye95pWw44CCCiAgICAgICAgLy8g5a6D5b+F6aG76KKr6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5omN5YWB6K646LCD55SoIGBgc2VuZGBg44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIHRlc3RQYXlhYmxlID0gcGF5YWJsZShhZGRyZXNzKHRlc3QpKTsKCiAgICAgICAgLy8g5aaC5p6c5pyJ5Lq65ZCR6K+l5ZCI57qm5Y+R6YCB5Lul5aSq5biB77yM6L2s6LSm5bCG5aSx6LSl77yM5Y2z6L+Z6YeM6L+U5ZueZmFsc2XjgIIKICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIOe7k+aenOaYryB0ZXN0Lngg562J5LqOIDHvvIx0ZXN0Lnkg562J5LqOIDDjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMe+8jHRlc3QueSDnrYnkuo4gMeOAggoKICAgICAgICAvLyDlpoLmnpzmnInkurrlkJHor6XlkIjnuqblj5HpgIHku6XlpKrluIHvvIxUZXN0UGF5YWJsZeeahHJlY2VpdmXlh73mlbDlsIbooqvosIPnlKjjgIIKICAgICAgICAvLyDnlLHkuo7or6Xlh73mlbDkvJrlhpnlhaXlrZjlgqjnqbrpl7TvvIzlroPpnIDopoHnmoTnh4Pmlpnmr5TnroDljZXnmoQgYGBzZW5kYGAg5oiWIGBgdHJhbnNmZXJgYCDopoHlpJrjgIIKICAgICAgICAvLyDnlLHkuo7ov5nkuKrljp/lm6DvvIzmiJHku6zlv4XpobvopoHkvb/nlKjkuIDkuKrkvY7nuqfliKvnmoTosIPnlKjjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyDnu5PmnpzmmK8gdGVzdC54IOetieS6jiAx77yMdGVzdC55IOetieS6jiAyIOS4quS7peWkquOAggoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Test &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用此函数（没有其他函数）。</span><br>    <span class="hljs-comment">// 向该合约发送以太币将引起异常，</span><br>    <span class="hljs-comment">// 因为fallback函数没有 `payable` 修饰器。</span><br>    fallback() external &#123; x = <span class="hljs-number">1</span>; &#125;<br>&#125;<br><br>contract TestPayable &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-keyword">uint</span> y;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用这个函数，</span><br>    <span class="hljs-comment">// 除了普通的以太传输（除了receive函数，没有其他函数）。</span><br>    <span class="hljs-comment">// 任何对该合约的非空的调用都将执行fallback函数（即使以太与调用一起被发送）。</span><br>    fallback() external payable &#123; x = <span class="hljs-number">1</span>; y = msg.value; &#125;<br><br>    <span class="hljs-comment">// 这个函数是为纯以太传输而调用的，</span><br>    <span class="hljs-comment">// 即为每一个带有空calldata的调用。</span><br>    receive() external payable &#123; x = <span class="hljs-number">2</span>; y = msg.value; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTest</span><span class="hljs-params">(Test test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1。</span><br><br>        <span class="hljs-comment">// address(test)将不允许直接调用 ``send``，</span><br>        <span class="hljs-comment">// 因为 ``test`` 没有可接收以太的fallback函数。</span><br>        <span class="hljs-comment">// 它必须被转换为 ``address payable`` 类型，才允许调用 ``send``。</span><br>        address payable testPayable = payable(address(test));<br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，转账将失败，即这里返回false。</span><br>        <span class="hljs-keyword">return</span> testPayable.send(<span class="hljs-number">2</span> ether);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTestPayable</span><span class="hljs-params">(TestPayable test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 0。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">1</span>&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 1。</span><br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，TestPayable的receive函数将被调用。</span><br>        <span class="hljs-comment">// 由于该函数会写入存储空间，它需要的燃料比简单的 ``send`` 或 ``transfer`` 要多。</span><br>        <span class="hljs-comment">// 由于这个原因，我们必须要使用一个低级别的调用。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">2</span> ether&#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 2 个以太。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#overload-function"></a></h3><p>一个合约可以有多个同名的，但参数类型不同的函数。 这个过程被称为 “重写”，也适用于继承的函数。 下面的例子显示了在合约 <code>A</code> 范围内对函数 <code>f</code> 的重写。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value, <span class="hljs-built_in">bool</span> really) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">if</span> (really)<br>            <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIOi/meauteS7o+eggeS4jeS8mue8luivkQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这段代码不会编译</span><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(B value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (B <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(address value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (address <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两个 <code>f</code> 函数重写最终都接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p><h4 id="重写解析和参数匹配"><a href="#重写解析和参数匹配" class="headerlink" title="重写解析和参数匹配"></a>重写解析和参数匹配<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id17"></a></h4><p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重写函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重写候选项。 如果一个候选都没有，解析失败。</p><p>备注</p><p>返回参数不作为重写解析的依据。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(uint8 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint8 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(uint256 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint256 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code> 也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为 <code>f(uint256)</code> 重写， 因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events"></a></h2><p>Solidity事件在EVM的日志功能之上给出了一个抽象。 应用程序可以通过Ethereum客户端的RPC接口订阅和监听这些事件。</p><p>事件是合约的可继承成员。当您调用它们时， 它们会导致参数被存储在交易的日志中–区块链中的一个特殊数据结构。 这些日志与合约的地址相关联，被纳入区块链， 只要有区块可以访问，就会留在那里（目前是永远，但 将来可能会改变）。 日志及其事件数据不能从合约内部访问（甚至不能从创建它们的合约访问）。</p><p>有可能要求为日志提供Merkle证明， 所以如果外部实体向合约提供这样的证明，它可以检查日志是否真的存在于区块链中。 由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p><p>您可以最多给三个参数添加 <code>indexed</code> 属性，将它们添加到一个特殊的数据结构中， 称为 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-events">“topics”</a>，而不是日志的数据部分。 一个topic只能容纳一个字（32字节），所以如果您为一个索引参数使用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#reference-types">引用类型</a>， 该值的Keccak-256哈希值将被存储为一个topic中。</p><p>所有没有 <code>indexed</code> 属性的参数都会被 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI 编码</a> 到日志的数据部分。</p><p>Topics允许您用来搜索事件，例如为特定的事件来过滤一系列的区块。 您用来也可以通过发出事件的合约的地址来过滤事件。</p><p>例如，下面的代码使用web3.js <code>subscribe(&quot;logs&quot;)</code> <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">方法</a> 来过滤与某一地址值相匹配的日志：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">fromBlock</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">address</span>: web3.eth.defaultAccount,<br>    <span class="hljs-attr">topics</span>: [<span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>&#125;;<br>web3.eth.subscribe(<span class="hljs-string">&#x27;logs&#x27;</span>, options, <span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;)<br>    .on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">log</span>);<br>    &#125;)<br>    .on(<span class="hljs-string">&quot;changed&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>除非您用 <code>anonymous</code> 指定符声明事件，否则事件的签名的哈希值是topic之一。 这意味着不可能通过名字来过滤特定的匿名事件， 您只能通过合约地址来过滤。匿名事件的优点是，它们的部署和调用都比较便宜。 它还允许您声明四个索引参数，而不是三个。</p><p>备注</p><p>由于交易日志只存储事件数据而不存储类型，因此您必须知道事件的类型， 包括哪个参数被索引以及事件是否是匿名的，以便正确解析数据。 特别的是，有可能用一个匿名事件 “伪造“ 另一个事件的签名。</p><h3 id="事件类型的成员方法"><a href="#事件类型的成员方法" class="headerlink" title="事件类型的成员方法"></a>事件类型的成员方法<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-15"></a></h3><ul><li><code>event.selector</code>： 对于非匿名事件，这是一个 <code>bytes32</code> 值， 包含事件签名的 <code>keccak256</code> 哈希值，在默认topic中使用。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id21"></a></h3><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyDkuovku7bmmK/nlKggYGVtaXRgIOWPkeWHuueahO+8jOWQjumdouaYr+S6i+S7tueahOWQjeensOWSjOaLrOWPt+mHjOeahOWPguaVsO+8iOWmguaenOacie+8ieOAggogICAgICAgIC8vIOS7u+S9lei/meagt+eahOiwg+eUqO+8iOeUmuiHs+aYr+a3seW6puW1jOWll++8iemDveWPr+S7pemAmui/h+i/h+a7pCBgRGVwb3NpdGAKICAgICAgICAvLyDku45KYXZhU2NyaXB0IEFQSeS4reajgOa1i+WHuuadpeOAggogICAgICAgIGVtaXQgRGVwb3NpdChtc2cuc2VuZGVyLCBpZCwgbXNnLnZhbHVlKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.21</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract ClientReceipt &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        address indexed <span class="hljs-keyword">from</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        bytes32 indexed id,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">uint</span> <span class="hljs-keyword">value</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>)</span>;<br><br>    <span class="hljs-function">function <span class="hljs-title">deposit</span>(<span class="hljs-params">bytes32 id</span>) <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// 事件是用 `emit` 发出的，后面是事件的名称和括号里的参数（如果有）。</span><br>        <span class="hljs-comment">// 任何这样的调用（甚至是深度嵌套）都可以通过过滤 `Deposit`</span><br>        <span class="hljs-comment">// 从JavaScript API中检测出来。</span><br>        <span class="hljs-function">emit <span class="hljs-title">Deposit</span>(<span class="hljs-params">msg.sender, id, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在JavaScript API中的使用方式如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> abi = <span class="hljs-comment">/* 由编译器产生的abi */</span>;<br><span class="hljs-keyword">var</span> ClientReceipt = web3.eth.contract(abi);<br><span class="hljs-keyword">var</span> clientReceipt = ClientReceipt.at(<span class="hljs-string">&quot;0x1234...ab67&quot;</span> <span class="hljs-comment">/* 地址 */</span>);<br><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit();<br><br><span class="hljs-comment">// 监视变化</span><br>depositEvent.watch(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>)&#123;<br>    <span class="hljs-comment">// 结果包含非索引的参数和给 `Deposit` 调用的 topics。</span><br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br><br><br><span class="hljs-comment">// 或者通过回调立即开始监视</span><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的输出看起来像下面这样（经过修剪）:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   &quot;returnValues&quot;: &#123;<br>       &quot;<span class="hljs-selector-tag">from</span>&quot;: <span class="hljs-string">&quot;0x1111…FFFFCCCC&quot;</span>,<br>       <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;0x50…sd5adb20&quot;</span>,<br>       <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;0x420042&quot;</span><br>   &#125;,<br>   &quot;raw&quot;: &#123;<br>       &quot;data&quot;: <span class="hljs-string">&quot;0x7f…91385&quot;</span>,<br>       <span class="hljs-string">&quot;topics&quot;</span>: [<span class="hljs-string">&quot;0xfd4…b4ead7&quot;</span>, <span class="hljs-string">&quot;0x7f…1a91385&quot;</span>]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="了解事件类型的其他资料"><a href="#了解事件类型的其他资料" class="headerlink" title="了解事件类型的其他资料"></a>了解事件类型的其他资料<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id22"></a></h3><ul><li><a href="https://github.com/web3/web3.js/blob/1.x/docs/web3-eth-contract.rst#events">JavaScript 文档</a></li><li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的使用实例</a></li><li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们</a></li></ul><h2 id="错误和恢复语句"><a href="#错误和恢复语句" class="headerlink" title="错误和恢复语句"></a>错误和恢复语句<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors"></a></h2><p>Solidity 中的错误提供了一种方便且省燃料的方式来向用户解释为什么一个操作会失败。 它们可以被定义在合约内部和外部（包括接口合约和库合约）。</p><p>它们必须与 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert-statement">恢复语句</a> 一起使用， 它导致当前调用中的所有变化被恢复，并将错误数据传回给调用者。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDovazotKbnmoTkvZnpop3kuI3otrPjgILpnIDopoEgYHJlcXVpcmVkYCDmlbDph4/kvYblj6rmnIkgYGF2YWlsYWJsZWAg5pWw6YeP5Y+v55So44CCCi8vLyBAcGFyYW0g5Y+v55So55qE5L2Z6aKd44CCCi8vLyBAcGFyYW0g6ZyA6KaB6KaB5rGC55qE6L2s5biQ6YeR6aKd44CCCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.4</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 转账的余额不足。需要 `required` 数量但只有 `available` 数量可用。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 可用的余额。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 需要要求的转帐金额。</span><br><span class="hljs-function">error <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">uint256 available, uint256 <span class="hljs-keyword">required</span></span>)</span>;<br><br>contract TestToken &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) balance;<br>    <span class="hljs-function">function <span class="hljs-title">transfer</span>(<span class="hljs-params">address to, uint256 amount</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; balance[msg.sender])<br>            <span class="hljs-function">revert <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                available: balance[msg.sender],</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">required</span>: amount</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span>)</span>;<br>        balance[msg.sender] -= amount;<br>        balance[to] += amount;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>错误不能被重写或覆盖，但是可以被继承。 只要作用域不同，同一个错误可以在多个地方定义。 错误的实例只能使用 <code>revert</code> 语句创建。</p><p>错误会创建数据，然后通过还原操作传递给调用者， 使其返回到链下组件或在 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#try-catch">try/catch 语句</a> 中捕获它。 需要注意的是，一个错误只能在来自外部调用时被捕获， 发生在内部调用或同一函数内的还原不能被捕获。</p><p>如果您不提供任何参数，错误只需要四个字节的数据， 您可以像上面一样使用 <a href="https://docs.soliditylang.org/zh-cn/latest/natspec-format.html#natspec">NatSpec 语法</a> 来进一步解释错误背后的原因， 这并不存储在链上。这使得这同时也是一个非常便宜和方便的错误报告功能。</p><p>更具体地说，一个错误实例在被ABI编码时， 其方式与对相同名称和类型的函数的调用相同， 然后作为 <code>revert</code> 操作码的返回数据。 这意味着数据由一个4字节的选择器和 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 数据组成。 选择器由错误类型的签名的keccak256-hash的前四个字节组成。</p><p>备注</p><p>一个合约有可能因为同名的不同错误而恢复， 甚至因为在不同地方定义的错误而使调用者无法区分。 对于外部来说，即ABI，只有错误的名称是相关的，而不是定义它的合约或文件。</p><p>如果您能定义 <code>error Error(string)</code>， 那么语句 <code>require(condition, &quot;description&quot;);</code> 将等同于 <code>if (!condition) revert Error(&quot;description&quot;)</code>。 但是请注意， <code>Error</code> 是一个内置类型，不能在用户提供的代码中定义。</p><p>同样，一个失败的 <code>assert</code> 或类似的条件将以一个内置的 <code>Panic(uint256)</code> 类型的错误来恢复。</p><p>备注</p><p>错误数据应该只被用来指示失败，而不是作为控制流的手段。 原因是内部调用的恢复数据默认是通过外部调用链传播回来的。 这意味着内部调用可以 ”伪造” 恢复数据，使它看起来像是来自调用它的合约。</p><h3 id="错误类型的成员"><a href="#错误类型的成员" class="headerlink" title="错误类型的成员"></a>错误类型的成员<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id25"></a></h3><ul><li><code>error.selector</code>： 一个包含错误类型的选择器的 <code>bytes4</code> 值。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17"></a></h2><p>Solidity支持多重继承，包括多态性。</p><p>多态性意味着函数调用（内部和外部）总是执行继承层次结构中最新继承的合约中的同名函数（和参数类型）。 但必须使用 <code>virtual</code> 和 <code>override</code> 关键字在层次结构中的每个函数上明确启用。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 以了解更多细节。</p><p>通过使用 <code>ContractName.functionName()</code> 明确指定合约， 可以在内部调用继承层次结构中更高的函数。 或者如果您想在扁平化的继承层次中调用高一级的函数（见下文）， 可以使用 <code>super.functionName()</code>。</p><p>当一个合约继承自其他合约时，在区块链上只创建一个单一的合约， 所有基础合约的代码被编译到创建的合约中。 这意味着对基础合约的所有内部函数的调用也只是使用内部函数调用 （ <code>super.f(..)</code> 将使用 JUMP 而不是消息调用）。</p><p>状态变量的阴影被认为是一个错误。 一个派生合约只能声明一个状态变量 <code>x</code>， 如果在它的任何基类中没有相同名称的可见状态变量。</p><p>总的来说，Solidity 的继承系统与 <a href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a> 非常相似，特别是关于多重继承方面，但也有一些 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance">不同之处</a>。</p><p>详细情况见下面的例子。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIOS9v+eUqCBgaXNgIOS7juWPpuS4gOS4quWQiOe6pua0vueUn+OAgua0vueUn+WQiOe6puWPr+S7peiuv+mXruaJgOaciemdnuengeacieaIkOWRmO+8jAovLyDljIXmi6zlhoXpg6jlh73mlbDlkoznirbmgIHlj5jph4/vvIzkvYbml6Dms5XpgJrov4cgYHRoaXNgIOadpeWklumDqOiuv+mXruOAggpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8g5YWz6ZSu5a2XIGB2aXJ0dWFsYCDmhI/lkbPnnYDor6Xlh73mlbDlj6/ku6XlnKjmtL7nlJ/nsbvkuK3mlLnlj5jlhbbooYzkuLrvvIjigJzph43lhpnigJ3vvInjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB2aXJ0dWFsIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIHNlbGZkZXN0cnVjdChvd25lcik7CiAgICB9Cn0KCgovLyDov5nkupvmir3osaHlkIjnuqbku4XnlKjkuo7nu5nnvJbor5Hlmajmj5DkvpvmjqXlj6PjgIIKLy8g5rOo5oSP5Ye95pWw5rKh5pyJ5Ye95pWw5L2T44CCCi8vIOWmguaenOS4gOS4quWQiOe6puayoeacieWunueOsOaJgOacieWHveaVsO+8jOWImeWPquiDveeUqOS9nOaOpeWPo+OAggphYnN0cmFjdCBjb250cmFjdCBDb25maWcgewogICAgZnVuY3Rpb24gbG9va3VwKHVpbnQgaWQpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGFkZHJlc3MgYWRyKTsKfQoKCmFic3RyYWN0IGNvbnRyYWN0IE5hbWVSZWcgewogICAgZnVuY3Rpb24gcmVnaXN0ZXIoYnl0ZXMzMiBuYW1lKSBwdWJsaWMgdmlydHVhbDsKICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSBwdWJsaWMgdmlydHVhbDsKfQoKCi8vIOWkmumHjee7p+aJv+aYr+WPr+iDveeahOOAguivt+azqOaEj++8jCBgT3duZWRgIOS5n+aYryBgRGVzdHJ1Y3RpYmxlYCDnmoTln7rnsbvvvIwKLy8g5L2G5Y+q5pyJ5LiA5LiqIGBPd25lZGAg5a6e5L6L77yI5bCx5YOPIEMrKyDkuK3nmoTomZrmi5/nu6fmib/vvInjgIIKY29udHJhY3QgTmFtZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSB7CiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWUpIHsKICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS5yZWdpc3RlcihuYW1lKTsKICAgIH0KCiAgICAvLyDlh73mlbDlj6/ku6Xooqvlj6bkuIDkuKrlhbfmnInnm7jlkIzlkI3np7Dlkoznm7jlkIzmlbDph48v57G75Z6L6L6T5YWl55qE5Ye95pWw6YeN5YaZ44CCCiAgICAvLyDlpoLmnpzph43lhpnlh73mlbDmnInkuI3lkIznsbvlnovnmoTovpPlh7rlj4LmlbDvvIzkvJrlr7zoh7TplJnor6/jgIIKICAgIC8vIOacrOWcsOWSjOWfuuS6jua2iOaBr+eahOWHveaVsOiwg+eUqOmDveS8muiAg+iZkei/meS6m+mHjeWGmeOAggogICAgLy8g5aaC5p6c5oKo5oOz6YeN5YaZ6L+Z5Liq5Ye95pWw77yM5oKo6ZyA6KaB5L2/55SoIGBvdmVycmlkZWAg5YWz6ZSu5a2X44CCCiAgICAvLyDlpoLmnpzmgqjmg7Porqnov5nkuKrlh73mlbDlho3mrKHooqvph43lhpnvvIzmgqjpnIDopoHlho3mjIflrpogYHZpcnR1YWxgIOWFs+mUruWtl+OAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgICAgIE5hbWVSZWcoY29uZmlnLmxvb2t1cCgxKSkudW5yZWdpc3RlcigpOwogICAgICAgICAgICAvLyDku43nhLblj6/ku6XosIPnlKjnibnlrprnmoTph43lhpnlh73mlbDjgIIKICAgICAgICAgICAgRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsKICAgICAgICB9CiAgICB9Cn0KCgovLyDlpoLmnpzmnoTpgKDlh73mlbDmjqXlj5flj4LmlbDvvIwKLy8g5YiZ6ZyA6KaB5Zyo5aOw5piO77yI5ZCI57qm55qE5p6E6YCg5Ye95pWw77yJ5pe25o+Q5L6b77yMCi8vIOaIluWcqOa0vueUn+WQiOe6pueahOaehOmAoOWHveaVsOS9jee9ruS7peS/rumlsOWZqOiwg+eUqOmjjuagvOaPkOS+m++8iOingeS4i+aWh++8ieOAggpjb250cmFjdCBQcmljZUZlZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSwgTmFtZWQoIkdvbGRGZWVkIikgewogICAgZnVuY3Rpb24gdXBkYXRlSW5mbyh1aW50IG5ld0luZm8pIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIGluZm8gPSBuZXdJbmZvOwogICAgfQoKICAgIC8vIOWcqOi/memHjO+8jOaIkeS7rOWPquaMh+WumuS6hiBgb3ZlcnJpZGVgIOiAjOayoeaciSBgdmlydHVhbGDjgIIKICAgIC8vIOi/meaEj+WRs+edgOS7jiBgUHJpY2VGZWVkYCDmtL7nlJ/lh7rmnaXnmoTlkIjnuqbkuI3og73lho3mlLnlj5ggYGRlc3Ryb3lgIOeahOihjOS4uuOAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShEZXN0cnVjdGlibGUsIE5hbWVkKSB7IE5hbWVkLmRlc3Ryb3koKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KCiAgICB1aW50IGluZm87Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br><br>contract Owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br><br><span class="hljs-comment">// 使用 `is` 从另一个合约派生。派生合约可以访问所有非私有成员，</span><br><span class="hljs-comment">// 包括内部函数和状态变量，但无法通过 `this` 来外部访问。</span><br>contract Destructible <span class="hljs-keyword">is</span> Owned &#123;<br>    <span class="hljs-comment">// 关键字 `virtual` 意味着该函数可以在派生类中改变其行为（“重写”）。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 这些抽象合约仅用于给编译器提供接口。</span><br><span class="hljs-comment">// 注意函数没有函数体。</span><br><span class="hljs-comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span><br><span class="hljs-keyword">abstract</span> contract Config &#123;<br>    <span class="hljs-function">function <span class="hljs-title">lookup</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> id</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">address adr</span>)</span>;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> contract NameReg &#123;<br>    <span class="hljs-function">function <span class="hljs-title">register</span>(<span class="hljs-params">bytes32 name</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>    <span class="hljs-function">function <span class="hljs-title">unregister</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">// 多重继承是可能的。请注意， `Owned` 也是 `Destructible` 的基类，</span><br><span class="hljs-comment">// 但只有一个 `Owned` 实例（就像 C++ 中的虚拟继承）。</span><br>contract Named <span class="hljs-keyword">is</span> Owned, Destructible &#123;<br>    constructor(bytes32 name) &#123;<br>        Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>        NameReg(config.lookup(<span class="hljs-number">1</span>)).register(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重写。</span><br>    <span class="hljs-comment">// 如果重写函数有不同类型的输出参数，会导致错误。</span><br>    <span class="hljs-comment">// 本地和基于消息的函数调用都会考虑这些重写。</span><br>    <span class="hljs-comment">// 如果您想重写这个函数，您需要使用 `override` 关键字。</span><br>    <span class="hljs-comment">// 如果您想让这个函数再次被重写，您需要再指定 `virtual` 关键字。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) &#123;<br>            Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>            NameReg(config.lookup(<span class="hljs-number">1</span>)).unregister();<br>            <span class="hljs-comment">// 仍然可以调用特定的重写函数。</span><br>            Destructible.destroy();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 如果构造函数接受参数，</span><br><span class="hljs-comment">// 则需要在声明（合约的构造函数）时提供，</span><br><span class="hljs-comment">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span><br>contract PriceFeed <span class="hljs-keyword">is</span> Owned, Destructible, Named(<span class="hljs-string">&quot;GoldFeed&quot;</span>) &#123;<br>    <span class="hljs-function">function <span class="hljs-title">updateInfo</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newInfo</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) info = newInfo;<br>    &#125;<br><br>    <span class="hljs-comment">// 在这里，我们只指定了 `override` 而没有 `virtual`。</span><br>    <span class="hljs-comment">// 这意味着从 `PriceFeed` 派生出来的合约不能再改变 `destroy` 的行为。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Destructible, Named</span>)</span> &#123; Named.destroy(); &#125;<br>    <span class="hljs-function">function <span class="hljs-title">get</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> r</span>)</span> &#123; <span class="hljs-keyword">return</span> info; &#125;<br><br>    <span class="hljs-built_in">uint</span> info;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在上面，我们调用 <code>Destructible.destroy()</code> 来 “转发” 销毁请求。 这样做的方式是有问题的，从下面的例子中可以看出：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgRmluYWwgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7IEJhc2UyLmRlc3Ryb3koKTsgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; Base2.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>Final.destroy()</code> 时会调用最后的派生重写函数 <code>Base2.destroy</code>， 但是会绕过 <code>Base1.destroy</code>， 解决这个问题的方法是使用 <code>super</code>：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgc3VwZXIuZGVzdHJveSgpOyB9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> super.destroy(); &#125;<br>&#125;<br><br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> super.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; super.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>Base2</code> 调用 <code>super</code> 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的上一个基类合约中调用这个函数， 所以它会调用 <code>Base1.destroy()</code> （注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, Destructible, ownerd）。 在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。</p><h3 id="函数重写-1"><a href="#函数重写-1" class="headerlink" title="函数重写"></a>函数重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding"></a></h3><p>如果基函数被标记为 <code>virtual</code>，则可以通过继承合约来改变其行为。 被重写的函数必须在函数头中使用 <code>override</code> 关键字。 重写函数只能将被重写函数的可见性从 <code>external</code> 改为 <code>public</code>。 可变性可以按照以下顺序改变为更严格的可变性。 <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 重写。 <code>view</code> 可以被 <code>pure</code> 重写。 <code>payable</code> 是一个例外，不能被改变为任何其他可变性。</p><p>下面的例子演示了改变函数可变性和可见性：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> external view</span> &#123;&#125;<br>&#125;<br><br>contract Middle <span class="hljs-keyword">is</span> Base &#123;&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Middle<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> pure</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于多重继承，必须在 <code>override</code> 关键字后明确指定定义同一函数的最多派生基类合约。 换句话说，您必须指定所有定义同一函数的基类合约， 并且还没有被另一个基类合约重写（在继承图的某个路径上）。 此外，如果一个合约从多个（不相关的）基类合约上继承了同一个函数，必须明确地重写它。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyDmtL7nlJ/oh6rlpJrkuKrlrprkuYkgZm9vKCkg5Ye95pWw55qE5Z+657G75ZCI57qm77yMCiAgICAvLyDmiYDku6XmiJHku6zlv4XpobvmmI7noa7lnLDph43lhpnlroMKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-comment">// 派生自多个定义 foo() 函数的基类合约，</span><br>    <span class="hljs-comment">// 所以我们必须明确地重写它</span><br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果函数被定义在一个共同的基类合约中， 或者在一个共同的基类合约中有一个独特的函数已经重写了所有其他的函数， 则不需要明确的函数重写指定符。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyDml6DpnIDmmI7noa7nmoTph43lhpkKY29udHJhY3QgRCBpcyBCLCBDIHt9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123; <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span>&#123;&#125; &#125;<br>contract B <span class="hljs-keyword">is</span> A &#123;&#125;<br>contract C <span class="hljs-keyword">is</span> A &#123;&#125;<br><span class="hljs-comment">// 无需明确的重写</span><br>contract D <span class="hljs-keyword">is</span> B, C &#123;&#125;<br></code></pre></td></tr></table></figure><p>更准确地说，如果有一个基类合约是该签名的所有重写路径的一部分， 并且（1）该基类合约实现了该函数，并且从当前合约到该基类合约的任何路径都没有提到具有该签名的函数， 或者（2）该基类合约没有实现该函数，并且从当前合约到该基类合约的所有路径中最多只有一个提到该函数， 那么就不需要重写从多个基类合约继承的函数（直接或间接）。</p><p>在这个意义上，一个签名的重写路径是一条继承图的路径， 它从所考虑的合约开始，到提到具有该签名的函数的合约结束， 而该签名没有重写。</p><p>如果您不把一个重写的函数标记为 <code>virtual</code>，派生合约就不能再改变该函数的行为。</p><p>备注</p><p>具有 <code>private</code> 可见性的函数不能是 <code>virtual</code>。</p><p>备注</p><p>在接口合约之外，没有实现的函数必须被标记为 <code>virtual</code>。 在接口合约中，所有的函数都被自动视为 <code>virtual</code>。</p><p>备注</p><p>从Solidity 0.8.8开始，当重写一个接口函数时， 不需要 <code>override</code> 关键字，除非该函数被定义在多个基础上。</p><p>如果函数的参数和返回类型与变量的getter函数匹配，公共状态变量可以重写为外部函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() external view <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br><br>contract B <span class="hljs-keyword">is</span> A<br>&#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> f;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>虽然公共状态变量可以重写外部函数，但它们本身不能被重写。</p><h3 id="修饰器重写"><a href="#修饰器重写" class="headerlink" title="修饰器重写"></a>修饰器重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding"></a></h3><p>函数修改器可以相互重写。 这与 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 的工作方式相同（除了对修改器没有重写）。 <code>virtual</code> 关键字必须用在被重写的修改器上， <code>override</code> 关键字必须用在重写的修改器上：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span></span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在多重继承的情况下，必须明确指定所有的直接基类合约。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor"></a></h3><p>构造函数是一个用 <code>constructor</code> 关键字声明的可选函数， 它在合约创建时被执行，您可以在这里运行合约初始化代码。</p><p>在构造函数代码执行之前，如果您用内联编程的方式初始化状态变量，则将其初始化为指定的值； 如果您不用内联编程的方式来初始化，则将其初始化为 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>。</p><p>构造函数运行后，合约的最终代码被部署到区块链上。 部署代码的燃料花费与代码长度成线性关系。 这段代码包括属于公共接口的所有函数，以及所有通过函数调用可以到达的函数。 但不包括构造函数代码或只从构造函数中调用的内部函数。</p><p>如果没有构造函数，合约将假定默认的构造函数， 相当于 <code>constructor() &#123;&#125;</code>。比如说：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=">open in Remix</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract A &#123;<br>    uint <span class="hljs-keyword">public</span> a;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uint a_</span>) &#123;<br>        a = a_;<br>    &#125;<br>&#125;<br><br>contract B is <span class="hljs-title function_">A</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以在构造函数中使用内部参数（例如，存储指针）。 在这种情况下，合约必须被标记为 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract">abstract</a>， 因为这些参数不能从外部分配有效的值，只能通过派生合约的构造函数来赋值。</p><p>警告</p><p>在0.4.22版本之前，构造函数被定义为与合约同名的函数。 这种语法已被废弃，在0.5.0版本中不再允许。</p><p>警告</p><p>在0.7.0版本之前，您必须指定构造函数的可见性为 <code>internal</code> 或 <code>public</code>。</p><h3 id="基本构造函数的参数"><a href="#基本构造函数的参数" class="headerlink" title="基本构造函数的参数"></a>基本构造函数的参数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21"></a></h3><p>所有基类合约的构造函数将按照下面解释的线性化规则被调用。 如果基类合约构造函数有参数，派生合约需要指定所有的参数。 这可以通过两种方式实现：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyDopoHkuYjnm7TmjqXlnKjnu6fmib/liJfooajkuK3mjIflrpouLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaIluiAhemAmui/h+a0vueUn+aehOmAoOWHveaVsOeahOS4gOS4qiAi5L+u5pS55ZmoIuKApuKApgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgeSkgQmFzZSh5ICogeSkge30KfQoKLy8g5oiW6ICF5bCG5ZCI57qm5aOw5piO5Li6YWJzdHJhY3TnsbvlnovigKbigKYKYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIOW5tuiuqeS4i+S4gOS4quWFt+S9k+eahOa0vueUn+WQiOe6puWvueWFtui/m+ihjOWIneWni+WMluOAggpjb250cmFjdCBEZXJpdmVkRnJvbURlcml2ZWQgaXMgRGVyaXZlZDMgewogICAgY29uc3RydWN0b3IoKSBCYXNlKDEwICsgMTApIHt9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base &#123;<br>    <span class="hljs-built_in">uint</span> x;<br>    constructor(<span class="hljs-built_in">uint</span> x_) &#123; x = x_; &#125;<br>&#125;<br><br><span class="hljs-comment">// 要么直接在继承列表中指定...</span><br><span class="hljs-function">contract Derived1 <span class="hljs-keyword">is</span> <span class="hljs-title">Base</span>(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span> &#123;<br>    constructor() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者通过派生构造函数的一个 &quot;修改器&quot;……</span><br>contract Derived2 <span class="hljs-keyword">is</span> Base &#123;<br>    constructor(<span class="hljs-built_in">uint</span> y) Base(y * y) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者将合约声明为abstract类型……</span><br><span class="hljs-keyword">abstract</span> contract Derived3 <span class="hljs-keyword">is</span> Base &#123;<br>&#125;<br><br><span class="hljs-comment">// 并让下一个具体的派生合约对其进行初始化。</span><br>contract DerivedFromDerived <span class="hljs-keyword">is</span> Derived3 &#123;<br>    constructor() Base(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一种方式是直接在继承列表中给出（ <code>is Base(7)</code> ）。 另一种是通过修改器作为派生构造函数的一部分被调用的方式（ <code>Base(y * y)</code> ）。 如果构造函数参数是一个常量，并且定义了合约的行为或描述了它，那么第一种方式更方便。 如果基类合约的构造函数参数依赖于派生合约的参数，则必须使用第二种方式。 参数必须在继承列表中或在派生构造函数中以修饰器的形式给出。 在两个地方都指定参数是一个错误。</p><p>如果一个派生合约没有指定其所有基类合约的构造函数的参数，那么它必须被声明为 abstract 类型。在这种情况下， 当另一个合约从它派生时，其他合约的继承列表或构造函数必须为所有没有指定参数的基类合约提供必要的参数 （否则，其他合约也必须被声明为 abstract 类型）。例如，在上面的代码片段中， 可以查看合约 <code>Derived3</code> 和 <code>DerivedFromDerived</code>。</p><h3 id="多重继承与线性化"><a href="#多重继承与线性化" class="headerlink" title="多重继承与线性化"></a>多重继承与线性化<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance"></a></h3><p>编程语言实现多重继承需要解决几个问题。 一个问题是 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a> 。 Solidity 借鉴了 Python 的方式并且使用 “<a href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>” 强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终实现我们所希望的唯一化的结果，但也使某些继承方式变为无效。 尤其是，基类在 <code>is</code> 后面的顺序很重要。 在下面的代码中， 您必须按照从 “最接近的基类”（most base-like）到 “最远的继承”（most derived）的顺序来指定所有的基类。 注意，这个顺序与Python中使用的顺序相反。</p><p>另一种简化的解释方式是，当一个函数被调用时， 它在不同的合约中被多次定义，给定的基类以深度优先的方式从右到左（Python中从左到右）进行搜索， 在第一个匹配处停止。如果一个基类合约已经被搜索过了，它就被跳过。</p><p>在下面的代码中，Solidity 会给出 “Linearization of inheritance graph impossible” 这样的错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8g6L+Z5q615Luj56CB5LiN5Lya57yW6K+RCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==">open in Remix</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>contract <span class="hljs-attribute">X</span> &#123;&#125;<br>contract <span class="hljs-selector-tag">A</span> is <span class="hljs-attribute">X</span> &#123;&#125;<br>// 这段代码不会编译<br>contract C is <span class="hljs-selector-tag">A</span>, <span class="hljs-attribute">X</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>代码编译出错的原因是 <code>C</code> 要求 <code>X</code> 重写 <code>A</code> （因为定义的顺序是 <code>A, X</code> ）， 但是 <code>A</code> 本身要求重写 <code>X</code>， 这是一种无法解决的冲突。</p><p>由于您必须明确地重写一个从多个基类合约继承的函数， 而没有唯一的重写，C3线性化在实践中不是太重要。</p><p>继承的线性化特别重要的一个领域是，当继承层次中存在多个构造函数时，也许不那么清楚。 构造函数将总是按照线性化的顺序执行，而不管它们的参数在继承合约的构造函数中是以何种顺序提供的。 比如说：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaehOmAoOWHveaVsOaMieS7peS4i+mhuuW6j+aJp+ihjO+8mgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8g5p6E6YCg5Ye95pWw5oyJ5Lul5LiL6aG65bqP5omn6KGM77yaCi8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyDmnoTpgKDlh73mlbDku43mjInku6XkuIvpobrluo/miafooYzvvJoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=">open in Remix</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br>contract <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base1</span><br><span class="hljs-comment">//  2 - Base2</span><br><span class="hljs-comment">//  3 - Derived1</span><br>contract <span class="hljs-title class_">Derived1</span> is <span class="hljs-title class_">Base1</span>, <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived2</span><br>contract <span class="hljs-title class_">Derived2</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base2</span>() <span class="hljs-title class_">Base1</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数仍按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived3</span><br>contract <span class="hljs-title class_">Derived3</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承有相同名字的不同类型成员"><a href="#继承有相同名字的不同类型成员" class="headerlink" title="继承有相同名字的不同类型成员"></a>继承有相同名字的不同类型成员<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id33"></a></h3><p>由于继承的关系，一个合约可能包含多个共享相同名称的定义，这种情况只有一种：</p><ul><li>函数重写。</li><li>重写virtual函数</li><li>通过状态变量获取器重写外部virtual函数。</li><li>重写virtual修饰符。</li><li>事件重写。</li></ul><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract"></a></h2><p>当合约中至少有一个函数没有被实现，或者合约没有为其所有的基本合约构造函数提供参数时， 合约必须被标记为 abstract。 即使不是这种情况，合约仍然可以被标记为 abstract， 例如，当您不打算直接创建合约时。 抽象（abstract）合约类似于 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interfaces">接口（interface）合约</a>， 但是接口（interface）合约可以声明的内容更加有限。</p><p>如下例所示，使用 <code>abstract</code> 关键字来声明一个抽象合约。 注意，这个合约需要被定义为 abstract，因为函数 <code>utterance()</code> 被声明了， 但没有提供实现（没有给出实现体 <code>&#123; &#125;</code>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的抽象合约不能被直接实例化。如果一个抽象合约本身实现了所有定义的功能，这也是可以的。 抽象合约作为基类的用法在下面的例子中显示：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br><br>contract Cat <span class="hljs-keyword">is</span> Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">override</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;miaow&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个合约继承自一个抽象合约，并且没有通过重写实现所有未实现的函数，那么它也需要被标记为抽象的。</p><p>注意，没有实现的函数与 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#function-types">函数类型</a> 不同，尽管它们的语法看起来非常相似。</p><p>没有实现内容的函数的例子（一个函数声明）：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span>;<br></code></pre></td></tr></table></figure><p>类型为函数类型的变量的声明实例：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span> <span class="hljs-title function_">foo</span>;<br></code></pre></td></tr></table></figure><p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自我记录， 促进了像 <a href="https://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a> 这样的模式， 并消除了代码的重复。抽象合约的作用与在接口中定义方法的作用相同。 它是抽象合约的设计者说 “我的任何孩子都必须实现这个方法” 的一种方式。</p><p>备注</p><p>抽象合约不能用一个未实现的virtual函数来重写一个已实现的virtual函数。</p><h2 id="接口（interface）合约"><a href="#接口（interface）合约" class="headerlink" title="接口（interface）合约"></a>接口（interface）合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interface"></a></h2><p>接口（interface）合约类似于抽象（abstract）合约，但是它们不能实现任何函数。并且还有进一步的限制：</p><ul><li>它们不能继承其他合约，但是它们可以继承其他接口合约。</li><li>在接口合约中所有声明的函数必须是 external 类型的，即使它们在合约中是 public 类型的。</li><li>它们不能声明构造函数。</li><li>它们不能声明状态变量。</li><li>它们不能声明修饰器。</li></ul><p>将来可能会解除这些里的某些限制。</p><p>接口合约基本上仅限于合约 ABI 可以表示的内容， 并且 ABI 和接口合约之间的转换应该不会丢失任何信息。</p><p>接口合约由它们自己的关键字表示：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> Token &#123;<br>    <span class="hljs-keyword">enum</span> TokenType &#123; Fungible, NonFungible &#125;<br>    <span class="hljs-keyword">struct</span> Coin &#123; <span class="hljs-built_in">string</span> obverse; <span class="hljs-built_in">string</span> reverse; &#125;<br>    <span class="hljs-built_in">function</span> transfer(address recipient, <span class="hljs-built_in">uint</span> amount) external;<br>&#125;<br></code></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口合约。</p><p>所有在接口合约中声明的函数都是隐式的 <code>virtual</code> 的类型， 任何重写它们的函数都不需要 <code>override</code> 关键字。 这并不自动意味着一个重写的函数可以被再次重写–这只有在重写的函数被标记为 <code>virtual</code> 时才可能。</p><p>接口合约可以从其他接口合约继承。这与普通的继承有着相同的规则。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyDlv4Xpobvph43mlrDlrprkuYl0ZXN077yM5Lul5L6/5pat6KiA54i257G755qE5ZCr5LmJ5piv5YW85a6555qE44CCCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentA</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentB</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SubInterface</span> <span class="hljs-keyword">is</span> ParentA, ParentB &#123;<br>    <span class="hljs-comment">// 必须重新定义test，以便断言父类的含义是兼容的。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">override</span><span class="hljs-params">(ParentA, ParentB)</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口合约和其他类似合约的结构中定义的类型可以从其他合约中访问： <code>Token.TokenType</code> 或 <code>Token.Coin</code>。</p><p>警告</p><p>接口合约从 <a href="https://docs.soliditylang.org/zh-cn/latest/050-breaking-changes.html">Solidity 0.5.0</a> 开始支持 <code>enum</code> 类型， 请确保pragma版本至少指定这个版本。</p><h2 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries"></a></h2><p>库合约与普通合约类似，但是它们只需要在特定的地址部署一次， 并且它们的代码可以通过 EVM 的 <code>DELEGATECALL</code> (Homestead 之前使用 <code>CALLCODE</code> 关键字)特性进行重用。 这意味着如果库函数被调用，它的代码在调用合约的上下文中执行， 即 <code>this</code> 指向调用合约，特别是可以访问调用合约的存储。 因为每个库合约都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。 如果库函数不修改状态（也就是说，如果它们是 <code>view</code> 或者 <code>pure</code> 函数）， 它们可以通过直接调用来使用（即不使用 <code>DELEGATECALL</code> 关键字）， 这是因为我们假定库合约是无状态的。 特别的是，销毁一个库合约是不可能的。</p><p>备注</p><p>在0.4.20版本之前，有可能通过规避Solidity的类型系统来破坏库合约。 从该版本开始，库合约包含一个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection">保护机制</a>， 不允许直接调用修改状态的函数（即没有 <code>DELEGATECALL</code> ）。</p><p>库合约可以看作是使用他们的合约的隐式的基类合约。 虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似 （如果 <code>L</code> 是库合约的话，可以使用 <code>L.f()</code> 调用库函数）。 当然，需要使用内部调用约定来调用内部函数，这意味着所有的内部类型都可以被传递， 类型 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存</a> 将被引用传递而不是复制。 为了在EVM中实现这一点，从合约中调用的内部库函数的代码和其中调用的所有函数将在编译时包含在调用合约中， 并使用常规的 <code>JUMP</code> 调用，而不是 <code>DELEGATECALL</code>。</p><p>备注</p><p>当涉及到公共函数时，继承的类比就失效了。 用 <code>L.f()</code> 调用公共库函数的结果是一个外部调用（准确地说，是 <code>DELEGATECALL</code> ）。 相反，当 <code>A.f()</code> 是当前合约的基类合约时， <code>A.f()</code> 是一个内部调用。</p><p>下面的示例说明如何使用库（但也请务必看看 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for">using for</a> 有一个实现 set 更好的例子）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOaIkeS7rOWumuS5ieS6huS4gOS4quaWsOeahOe7k+aehOS9k+aVsOaNruexu+Wei++8jOeUqOS6juWcqOiwg+eUqOWQiOe6puS4reS/neWtmOaVsOaNruOAggpzdHJ1Y3QgRGF0YSB7CiAgICBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7Cn0KCmxpYnJhcnkgU2V0IHsKICAgIC8vIOazqOaEj+esrOS4gOS4quWPguaVsOaYryDigJxzdG9yYWdlIHJlZmVyZW5jZeKAneexu+Wei++8jAogICAgLy8g5Zug5q2k5Zyo6LCD55So5Lit5Y+C5pWw5Lyg6YCS55qE5Y+q5piv5a6D55qE5a2Y5YKo5Zyw5Z2A6ICM5LiN5piv5YaF5a6544CCCiAgICAvLyDov5nmmK/lupPlh73mlbDnmoTkuIDkuKrnibnmgKfjgILlpoLmnpzor6Xlh73mlbDlj6/ku6Xooqvop4bkuLrlr7nosaHnmoTmlrnms5XvvIwKICAgIC8vIOWImeS5oOaDr+ensOesrOS4gOS4quWPguaVsOS4uiBgc2VsZmAg44CCCiAgICBmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5LiN5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDkuI3pnIDopoHlupPnmoTnibnlrprlrp7kvovlsLHlj6/ku6XosIPnlKjlupPlh73mlbDvvIwKICAgICAgICAvLyDlm6DkuLrlvZPliY3lkIjnuqblsLHmmK8g4oCcaW5zdGFuY2XigJ3jgIIKICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyDlpoLmnpzmiJHku6zmhL/mhI/vvIzmiJHku6zkuZ/lj6/ku6XlnKjov5nkuKrlkIjnuqbkuK3nm7TmjqXorr/pl64ga25vd25WYWx1ZXMuZmxhZ3PjgIIKfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br><span class="hljs-comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span><br>struct Data &#123;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags;<br>&#125;<br><br>library Set &#123;<br>    <span class="hljs-comment">// 注意第一个参数是 “storage reference”类型，</span><br>    <span class="hljs-comment">// 因此在调用中参数传递的只是它的存储地址而不是内容。</span><br>    <span class="hljs-comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，</span><br>    <span class="hljs-comment">// 则习惯称第一个参数为 `self` 。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">view</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>    &#125;<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 不需要库的特定实例就可以调用库函数，</span><br>        <span class="hljs-comment">// 因为当前合约就是 “instance”。</span><br>        <span class="hljs-keyword">require</span>(Set.insert(knownValues, value));<br>    &#125;<br>    <span class="hljs-comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，您不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。 函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p><p>调用 <code>Set.contains</code>， <code>Set.insert</code> 和 <code>Set.remove</code> 都被编译为对外部合约/库的调用（ <code>DELEGATECALL</code> ）。 如果使用库，请注意实际执行的是外部函数调用。 <code>msg.sender</code>， <code>msg.value</code> 和 <code>this</code> 在调用中将保留它们的值， （在 Homestead 之前，因为使用了 <code>CALLCODE</code> ，改变了 <code>msg.sender</code> 和 <code>msg.value</code>)。</p><p>下面的例子显示了如何使用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存中的类型</a> 和库合约中的内部函数， 以实现自定义类型，而没有外部函数调用的开销：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDns5/ns5XvvIzmiJHku6zlv4Xpobvlop7liqDkuIDkuKogbGltYgogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBhLCB1aW50IGluZGV4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gaW5kZXggPCBhLmxpbWJzLmxlbmd0aCA/IGEubGltYnNbaW5kZXhdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<br><br>struct <span class="hljs-type">bigint</span> &#123;<br>    uint[] limbs;<br>&#125;<br><br>library <span class="hljs-type">BigInt</span> &#123;<br>    <span class="hljs-keyword">function</span> fromUint(uint x) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](<span class="hljs-number">1</span>);<br>        r.limbs[<span class="hljs-number">0</span>] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">bigint</span> memory a, <span class="hljs-type">bigint</span> memory b) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](max(a.limbs.length, b.limbs.length));<br>        uint carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i) &#123;<br>            uint limbA = limb(a, i);<br>            uint limbB = limb(b, i);<br>            unchecked &#123;<br>                r.limbs[i] = limbA + limbB + carry;<br><br>                <span class="hljs-keyword">if</span> (limbA + limbB &lt; limbA || (limbA + limbB == <span class="hljs-keyword">type</span>(uint).max &amp;&amp; carry &gt; <span class="hljs-number">0</span>))<br>                    carry = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    carry = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            // 糟糕，我们必须增加一个 limb<br>            uint[] memory newLimbs = <span class="hljs-built_in">new</span> uint[](r.limbs.length + <span class="hljs-number">1</span>);<br>            uint i;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i)<br>                newLimbs[i] = r.limbs[i];<br>            newLimbs[i] = carry;<br>            r.limbs = newLimbs;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> limb(<span class="hljs-type">bigint</span> memory a, uint <span class="hljs-keyword">index</span>) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> &lt; a.limbs.length ? a.limbs[<span class="hljs-keyword">index</span>] : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> max(uint a, uint b) private pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">BigInt</span> <span class="hljs-keyword">for</span> <span class="hljs-type">bigint</span>;<br><br>    <span class="hljs-keyword">function</span> f() <span class="hljs-built_in">public</span> pure &#123;<br>        <span class="hljs-type">bigint</span> memory x = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-number">7</span>);<br>        <span class="hljs-type">bigint</span> memory y = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-keyword">type</span>(uint).max);<br>        <span class="hljs-type">bigint</span> memory z = x.<span class="hljs-keyword">add</span>(y);<br>        <span class="hljs-keyword">assert</span>(z.limb(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过将库合约的类型转换为 <code>address</code> 类型，即使用 <code>address(LibraryName)</code>，可以获得一个库的地址。</p><p>由于编译器不知道库合约的部署地址， 编译后的十六进制代码将包含 <code>__$30bbc0abd4d6364515865950d3e0d10953$__</code> 形式的占位符。 占位符是完全等同于库合约名的keccak256哈希值的34个字符的前缀，例如 <code>libraries/bigint.sol:BigInt</code>， 如果该库存储在 <code>libraries/</code> 目录下一个名为 <code>bigint.sol</code> 的文件中。 这样的字节码是不完整的，不应该被部署。占位符需要被替换成实际地址。 您可以在编译库的时候把它们传递给编译器，或者用链接器来更新已经编译好的二进制文件。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#library-linking">库链接</a>，了解如何使用命令行编译器进行链接。</p><p>与合约相比，库在以下方面受到限制：</p><ul><li>它们不能有状态变量</li><li>它们不能继承，也不能被继承</li><li>它们不能接收以太</li><li>它们不能被销毁</li></ul><p>(这些可能会在以后的时间里被解除)。</p><h3 id="库合约中的函数签名和选择器"><a href="#库合约中的函数签名和选择器" class="headerlink" title="库合约中的函数签名和选择器"></a>库合约中的函数签名和选择器<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-27"></a></h3><p>虽然对公共或外部库函数的外部调用是可能的，但这种调用的调用惯例被认为是 Solidity 内部的， 与常规 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">合约 ABI</a> 所指定的不一样。 外部库函数比外部合约函数支持更多的参数类型，例如递归结构和存储指针。 由于这个原因，用于计算4字节选择器的函数签名是按照内部命名模式计算的， 合约ABI中不支持的类型的参数使用内部编码。</p><p>签名中的类型使用了以下标识符：</p><ul><li>值类型、非存储的 <code>string</code> 和非存储的 <code>bytes</code> 使用与合约ABI中相同的标识符。</li><li>非存储数组类型遵循与合约ABI中相同的惯例，即 <code>&lt;type&gt;[]</code> 用于动态数组， <code>&lt;type&gt;[M]</code> 用于 <code>M</code> 元素的固定大小数组。</li><li>非存储结构体用其完全等同于的名称来指代，即 <code>C.S</code> 代表 <code>contract C &#123; struct S &#123; ... &#125; &#125;</code>。</li><li>存储指针映射使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code>， 其中 <code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 分别是映射的键和值类型的标识。</li><li>其他存储指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格，即 <code>storage</code>。</li></ul><p>参数的编码与普通合约ABI相同，除了存储指针， 它被编码为一个 <code>uint256</code> 值，指的是它们所指向的存储槽。</p><p>与合约ABI类似，选择器由签名的Keccak256-hash的前四个字节组成。 它的值可以通过使用 <code>.selector</code> 成员从 Solidity 获得，如下：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ada">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span>.<span class="hljs-number">14</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>library L &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(uint256) external &#123;&#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">g</span>() public pure returns (bytes4) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">L.f.selector</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection"></a></h3><p>正如介绍中提到的那样，如果库的代码是通过 <code>CALL</code> 来执行， 而不是 <code>DELEGATECALL</code> 或者 <code>CALLCODE</code>， 那么执行的结果会被恢复， 除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。</p><p>EVM没有提供一个直接的方法让合约检测它是否被使用 <code>CALL</code> 调用， 但是合约可以使用 <code>ADDRESS</code> 操作码来找出它当前运行的 “位置”。 生成的代码将这个地址与构造时使用的地址进行比较，以确定调用的模式。</p><p>更具体地说，一个库合约的运行时代码总是以 push 指令开始， 在编译时它是一个20字节的零。 当部署代码运行时，这个常数在内存中被当前地址所取代，这个修改后的代码被存储在合约中。 在运行时，这导致部署时的地址成为第一个被推入堆栈的常数， 对于任何非view和非pure函数，调度器代码会将当前地址与这个常数进行比较。</p><p>这意味着一个存储在链上的库合约的实际代码，与编译器报告的 <code>deployedBytecode</code> 的代码不同。</p><h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for"></a></h2><p>指令 <code>using A for B</code> 可以用来将函数（ <code>A</code>）作为操作符附加到用户定义的值类型， 或者作为任何类型（ <code>B</code>）的成员函数。 成员函数将它们被调用的对象作为第一个参数接收（像 Python 中的 <code>self</code> 变量）。 操作符函数将操作数作为参数接收。</p><p>它可以在文件级别或者在合约级别的合约内部有效。</p><p>第一部分， <code>A</code>，可以是以下之一：</p><ul><li>一个函数列表，可以选择性地分配操作符名称（例如 <code>using &#123;f, g as +, h, L.t&#125; for uint</code>）。 如果没有指定操作符，函数可以是库函数或自由函数，并作为成员函数附加到类型上。 否则，它必须是一个自由函数，并成为该类型上该操作符的定义。</li><li>一个库合约的名称（例如 <code>using L for uint</code> ）- 该库合约的所有非私有函数都作为成员函数附加在该类型上。</li></ul><p>在文件级别中，第二部分， <code>B</code>，必须是一个明确的类型（没有数据位置指定）。 在合约内部，您也可以用 <code>*</code> 代替类型（例如 <code>using L for *;</code> ）， 这样做的效果是，库合约 <code>L</code> 中所有的函数都会被附加到 <em>所有</em> 类型上。</p><p>如果您指定了一个库合约，那么该库合约中的 <em>所有</em> 非私有函数都会被附加到该类型上， 即使是那些第一个参数的类型与对象的类型不匹配的函数。 类型会在函数被调用的时候检查， 并执行函数重写解析。</p><p>如果您使用一个函数列表（例如 <code>using &#123;f, g, h, L.t&#125; for uint</code> ）， 那么类型（ <code>uint</code> ）必须可以隐式地转换为这些函数的第一个参数。 即使这些函数都没有被调用，也要进行这种检查。 请注意，只有当 <code>using for</code> 位于库合约内时，才能指定私有库函数。</p><p>如果您定义了一个操作符（例如 <code>using &#123;f as +&#125; for T</code>），那么类型（ <code>T</code>）必须是一个 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#user-defined-value-types">用户定义的值类型</a>，并且定义必须是一个 <code>pure</code> 函数。 操作符定义必须是全局的。 以下操作符可以用这种方式定义：</p><div class="table-container"><table><thead><tr><th>Category</th><th>Operator</th><th>Possible signatures</th></tr></thead><tbody><tr><td>Bitwise</td><td><code>&amp;</code></td><td><code>function (T, T) pure returns (T)</code></td></tr><tr><td>`</td><td>`</td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>^</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>~</code></td><td><code>function (T) pure returns (T)</code></td><td></td></tr><tr><td>Arithmetic</td><td><code>+</code></td><td><code>function (T, T) pure returns (T)</code></td></tr><tr><td><code>-</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>function (T) pure returns (T)</code></td><td></td><td></td></tr><tr><td><code>*</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>/</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>%</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td>Comparison</td><td><code>==</code></td><td><code>function (T, T) pure returns (bool)</code></td></tr><tr><td><code>!=</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&lt;</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&lt;=</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&gt;</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&gt;=</code></td><td><code>function (T, T) pure returns (bool)</code></td></tr></tbody></table></div><p>注意，一元和二元的 <code>-</code> 需要单独定义。 编译器会根据操作符的调用方式选择正确的定义。</p><p><code>using A for B;</code> 指令只在当前作用域（合约或当前模块/源单元）内有效， 包括其中所有的函数，在使用它的合约或模块之外没有任何效果。</p><p>当在文件级别使用该指令并应用于在同一文件中用户定义类型时， 可以在末尾添加 <code>global</code> 关键字。 这将使函数和操作符附加到该类型的任何可用位置（包括其他文件）， 而不仅仅是在 using 语句的范围内。</p><p>下面我们将使用文件级函数来重写 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries">库合约</a> 部分中的 set 示例。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyDnjrDlnKjmiJHku6znu5nov5nkuKrnsbvlnovpmYTliqDkuIrlh73mlbDjgIIKLy8g6ZmE5Yqg55qE5Ye95pWw5Y+v5Lul5Zyo5qih5Z2X55qE5YW25LuW6YOo5YiG5L2/55So44CCCi8vIOWmguaenOaCqOWvvOWFpeS6huivpeaooeWdl++8jAovLyDmgqjlv4XpobvlnKjpgqPph4zph43lpI11c2luZ+aMh+S7pO+8jOS+i+WmggovLyAgIGltcG9ydCAiZmxhZ3Muc29sIiBhcyBGbGFnczsKLy8gICB1c2luZyB7RmxhZ3MuaW5zZXJ0LCBGbGFncy5yZW1vdmUsIEZsYWdzLmNvbnRhaW5zfQovLyAgICAgZm9yIEZsYWdzLkRhdGE7CnVzaW5nIHtpbnNlcnQsIHJlbW92ZSwgY29udGFpbnN9IGZvciBEYXRhOwoKZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOS4jeWtmOWcqAogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHZpZXcKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIHJldHVybiBzZWxmLmZsYWdzW3ZhbHVlXTsKfQoKCmNvbnRyYWN0IEMgewogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIOi/memHjO+8jCBEYXRhIOexu+Wei+eahOaJgOacieWPmOmHj+mDveacieS4juS5i+ebuOWvueW6lOeahOaIkOWRmOWHveaVsOOAggogICAgICAgIC8vIOS4i+mdoueahOWHveaVsOiwg+eUqOWSjCBgU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpYCDnmoTmlYjmnpzlrozlhajnm7jlkIzjgIIKICAgICAgICByZXF1aXJlKGtub3duVmFsdWVzLmluc2VydCh2YWx1ZSkpOwogICAgfQp9">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>struct Data &#123; mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags; &#125;<br><span class="hljs-comment">// 现在我们给这个类型附加上函数。</span><br><span class="hljs-comment">// 附加的函数可以在模块的其他部分使用。</span><br><span class="hljs-comment">// 如果您导入了该模块，</span><br><span class="hljs-comment">// 您必须在那里重复using指令，例如</span><br><span class="hljs-comment">//   import &quot;flags.sol&quot; as Flags;</span><br><span class="hljs-comment">//   using &#123;Flags.insert, Flags.remove, Flags.contains&#125;</span><br><span class="hljs-comment">//     for Flags.Data;</span><br>using &#123;insert, remove, contains&#125; <span class="hljs-keyword">for</span> Data;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">view</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这里， Data 类型的所有变量都有与之相对应的成员函数。</span><br>        <span class="hljs-comment">// 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span><br>        <span class="hljs-keyword">require</span>(knownValues.insert(value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过这种方式来扩展内置类型。 在这个例子中，我们将使用一个库合约。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyDov5nlsIbmiafooYzlupPlkIjnuqbkuK3nmoTlh73mlbDosIPnlKgKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>library <span class="hljs-keyword">Search</span> &#123;<br>    <span class="hljs-keyword">function</span> indexOf(uint[] <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>        <span class="hljs-built_in">public</span><br>        <span class="hljs-keyword">view</span><br>        <span class="hljs-keyword">returns</span> (uint)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; self.length; i++)<br>            <span class="hljs-keyword">if</span> (self[i] == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>(uint).max;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">Search</span> <span class="hljs-keyword">for</span> uint[];<br><br>contract C &#123;<br>    uint[] data;<br><br>    <span class="hljs-keyword">function</span> append(uint <span class="hljs-keyword">value</span>) <span class="hljs-built_in">public</span> &#123;<br>        data.push(<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> replace(uint <span class="hljs-keyword">from</span>, uint <span class="hljs-keyword">to</span>) <span class="hljs-built_in">public</span> &#123;<br>        // 这将执行库合约中的函数调用<br>        uint <span class="hljs-keyword">index</span> = data.indexOf(<span class="hljs-keyword">from</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == <span class="hljs-keyword">type</span>(uint).max)<br>            data.push(<span class="hljs-keyword">to</span>);<br>        <span class="hljs-keyword">else</span><br>            data[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">to</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，所有的外部库调用实际都是EVM函数调用。 这意味着，如果传递内存或值类型，即使是 <code>self</code> 变量，也会执行复制。 只有在使用存储引用变量或调用内部库函数时，才不会执行复制。</p><p>另一个展示了如何为用户定义的类型定义一个自定义操作符的例子：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTk7Cgp0eXBlIFVGaXhlZDE2eDIgaXMgdWludDE2OwoKdXNpbmcgewogICAgYWRkIGFzICssCiAgICBkaXYgYXMgLwp9IGZvciBVRml4ZWQxNngyIGdsb2JhbDsKCnVpbnQzMiBjb25zdGFudCBTQ0FMRSA9IDEwMDsKCmZ1bmN0aW9uIGFkZChVRml4ZWQxNngyIGEsIFVGaXhlZDE2eDIgYikgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICByZXR1cm4gVUZpeGVkMTZ4Mi53cmFwKFVGaXhlZDE2eDIudW53cmFwKGEpICsgVUZpeGVkMTZ4Mi51bndyYXAoYikpOwp9CgpmdW5jdGlvbiBkaXYoVUZpeGVkMTZ4MiBhLCBVRml4ZWQxNngyIGIpIHB1cmUgcmV0dXJucyAoVUZpeGVkMTZ4MikgewogICAgdWludDMyIGEzMiA9IFVGaXhlZDE2eDIudW53cmFwKGEpOwogICAgdWludDMyIGIzMiA9IFVGaXhlZDE2eDIudW53cmFwKGIpOwogICAgdWludDMyIHJlc3VsdDMyID0gYTMyICogU0NBTEUgLyBiMzI7CiAgICByZXF1aXJlKHJlc3VsdDMyIDw9IHR5cGUodWludDE2KS5tYXgsICJEaXZpZGUgb3ZlcmZsb3ciKTsKICAgIHJldHVybiBVRml4ZWQxNngyLndyYXAodWludDE2KGEzMiAqIFNDQUxFIC8gYjMyKSk7Cn0KCmNvbnRyYWN0IE1hdGggewogICAgZnVuY3Rpb24gYXZnKFVGaXhlZDE2eDIgYSwgVUZpeGVkMTZ4MiBiKSBwdWJsaWMgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICAgICAgcmV0dXJuIChhICsgYikgLyBVRml4ZWQxNngyLndyYXAoMjAwKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.19</span>;<br><br><span class="hljs-keyword">type</span> UFixed16x2 <span class="hljs-keyword">is</span> uint16;<br><br><span class="hljs-keyword">using</span> &#123;<br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">as</span> +,<br>    div <span class="hljs-keyword">as</span> /<br>&#125; <span class="hljs-keyword">for</span> UFixed16x2 <span class="hljs-keyword">global</span>;<br><br>uint32 <span class="hljs-keyword">constant</span> SCALE = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));<br>&#125;<br><br><span class="hljs-keyword">function</span> div(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    uint32 a32 = UFixed16x2.unwrap(a);<br>    uint32 b32 = UFixed16x2.unwrap(b);<br>    uint32 result32 = a32 * SCALE / b32;<br>    require(result32 &lt;= <span class="hljs-keyword">type</span>(uint16).max, &quot;Divide overflow&quot;);<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(uint16(a32 * SCALE / b32));<br>&#125;<br><br>contract Math &#123;<br>    <span class="hljs-keyword">function</span> avg(UFixed16x2 a, UFixed16x2 b) <span class="hljs-built_in">public</span> pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>        <span class="hljs-keyword">return</span> (a + b) / UFixed16x2.wrap(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;合约&quot;&gt;&lt;a href=&quot;#合约&quot; class=&quot;headerlink&quot; title=&quot;合约&quot;&gt;&lt;/a&gt;合约&lt;a href=&quot;https://docs.soliditylang.org/zh-cn/latest/contracts.html#contract</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
