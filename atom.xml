<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengcookie</title>
  
  <subtitle>zhengcookie的个人博客</subtitle>
  <link href="https://www.zhengcookie.site/atom.xml" rel="self"/>
  
  <link href="https://www.zhengcookie.site/"/>
  <updated>2025-10-25T11:01:58.698Z</updated>
  <id>https://www.zhengcookie.site/</id>
  
  <author>
    <name>zhengcookie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Solidity智能合约零基础入门</title>
    <link href="https://www.zhengcookie.site/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://www.zhengcookie.site/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2025-10-19T14:17:53.000Z</published>
    <updated>2025-10-25T11:01:58.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h1><h2 id="模块一：启程-区块链与智能合约概念"><a href="#模块一：启程-区块链与智能合约概念" class="headerlink" title="模块一：启程 - 区块链与智能合约概念"></a>模块一：启程 - 区块链与智能合约概念</h2><p>比特币 vs 以太坊：为什么需要智能合约？</p><h3 id="比特币-vs-以太坊：为什么需要智能合约？"><a href="#比特币-vs-以太坊：为什么需要智能合约？" class="headerlink" title="比特币 vs 以太坊：为什么需要智能合约？"></a>比特币 vs 以太坊：为什么需要智能合约？</h3><p>比特币作为区块链技术的第一个成功应用，开创了去中心化数字货币的先河。它的核心功能是提供一种安全、透明且不可篡改的价值转移方式。然而，比特币的设计初衷是专注于支付和存储价值，其脚本语言（Script）虽然具有一定的可编程性，但功能较为有限，无法支持复杂的逻辑操作。<br>相比之下，以太坊在设计上引入了一个革命性的概念——<strong>智能合约</strong>。智能合约是一种运行在区块链上的程序代码，能够根据预设条件自动执行特定的操作。它使得以太坊不仅是一个去中心化的支付系统，更是一个通用的计算平台。通过智能合约，开发者可以构建各种去中心化应用（DApps），例如去中心化金融（DeFi）、非同质化代币（NFT）、去中心化自治组织（DAO）等。这种灵活性使以太坊成为区块链生态系统的核心支柱之一。<br>那么，为什么需要智能合约？智能合约的核心优势在于<strong>自动化执行</strong>和<strong>信任最小化</strong>。传统合约需要依赖第三方（如律师或仲裁机构）来确保执行，而智能合约通过代码直接定义规则并自动执行，无需中介参与。这不仅降低了交易成本，还提高了效率，同时减少了人为干预带来的风险。此外，智能合约的透明性和不可篡改性进一步增强了信任，使其在金融、供应链管理、身份认证等领域展现出巨大的潜力。</p><h3 id="什么是Gas？什么是交易？"><a href="#什么是Gas？什么是交易？" class="headerlink" title="什么是Gas？什么是交易？"></a>什么是Gas？什么是交易？</h3><h4 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h4><p>在以太坊网络中，<strong>Gas</strong> 是衡量执行智能合约或进行交易所需计算资源的单位。简单来说，Gas 是用户为使用以太坊网络支付的“燃料费”。每笔交易或智能合约的执行都需要消耗一定数量的 Gas，而 Gas 的价格由市场供需决定，通常以以太币（ETH）计价。<br>Gas 的存在有几个重要意义：</p><ol><li><strong>防止滥用网络资源</strong>：通过收取 Gas 费用，以太坊可以防止恶意用户发起无限循环或占用大量计算资源的操作。</li><li><strong>激励矿工&#x2F;验证者</strong>：Gas 费用作为奖励分配给矿工（在 PoW 机制下）或验证者（在 PoS 机制下），以保障网络的安全性和稳定性。</li><li><strong>动态调节网络负载</strong>：当网络拥堵时，用户可以通过提高 Gas 价格来优先处理自己的交易。</li></ol><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>在区块链语境中，<strong>交易</strong>是指任何改变区块链状态的操作。交易可以分为两类：</p><ol><li><strong>普通转账交易</strong>：指从一个账户向另一个账户转移加密货币（如 ETH）。</li><li><strong>智能合约交互交易</strong>：指调用智能合约中的函数，可能涉及复杂的数据处理或状态更新。<br>每笔交易都需要包含以下信息：</li></ol><ul><li>发送方地址</li><li>接收方地址（如果是普通转账）或智能合约地址（如果是合约交互）</li><li>转账金额（如果是普通转账）</li><li>Gas 限制（Gas Limit）：用户愿意为该交易支付的最大 Gas 数量</li><li>Gas 价格（Gas Price）：每单位 Gas 的价格<br>如果交易执行所需的 Gas 超过了用户设置的 Gas 限制，交易将失败，但已消耗的 Gas 不会退还。</li></ul><h3 id="开发环境搭建（FISCO-BCOS-Remix-IDE）"><a href="#开发环境搭建（FISCO-BCOS-Remix-IDE）" class="headerlink" title="开发环境搭建（FISCO-BCOS, Remix IDE）"></a>开发环境搭建（FISCO-BCOS, Remix IDE）</h3><p>为了在区块链上开发和部署智能合约，我们需要搭建合适的开发环境。以下是两种常用的工具：<strong>FISCO-BCOS</strong> 和 <strong>Remix IDE</strong>。</p><h4 id="FISCO-BCOS"><a href="#FISCO-BCOS" class="headerlink" title="FISCO-BCOS"></a>FISCO-BCOS</h4><p>FISCO-BCOS 是一个国产的区块链底层平台，专注于企业级应用场景。它支持联盟链模式，适合构建私有链或联盟链项目。以下是搭建 FISCO-BCOS 的基本步骤：</p><p><a href="https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html">https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html</a></p><h4 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h4><p>Remix 是一个基于浏览器的集成开发环境（IDE），专为以太坊智能合约开发设计。它的界面友好，功能强大，非常适合初学者和快速原型开发。以下是使用 Remix 的基本流程：</p><ol><li><strong>访问 Remix IDE</strong>：</li></ol><ul><li><ul><li>打开浏览器，访问 <a href="https://remix.ethereum.org/">Remix 官网</a>。</li></ul></li></ul><ol><li><strong>编写智能合约</strong>：</li></ol><ul><li><ul><li>在 Remix 的“File Explorer”区域新建一个 <code>.sol</code> 文件，例如 <code>MyContract.sol</code>。</li><li>编写 Solidity 代码，例如：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    uint public value;</span><br><span class="line">    function setValue(uint _value) public &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    function getValue() public view returns (uint) &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>编译合约</strong>：</li></ol><ul><li><ul><li>切换到“Solidity Compiler”标签页，选择适当的编译器版本并点击“Compile”。</li></ul></li></ul><ol><li><strong>部署合约</strong>：</li></ol><ul><li><ul><li>切换到“Deploy &amp; Run Transactions”标签页，选择 JavaScript VM（虚拟机）或其他环境（如 MetaMask）。</li><li>点击“Deploy”按钮将合约部署到测试网络。</li></ul></li></ul><ol><li><strong>测试合约</strong>：</li></ol><ul><li><ul><li>在“Deployed Contracts”区域，调用合约的函数（如 <code>setValue</code> 和 <code>getValue</code>）进行交互。</li></ul></li></ul><h2 id="模块二：Solidity基础语法"><a href="#模块二：Solidity基础语法" class="headerlink" title="模块二：Solidity基础语法"></a>模块二：Solidity基础语法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Solidity是一种合约导向编程语言，用于编写智能合约，运行在Ethereum虚拟机（EVM）上。本文档将为您介绍Solidity的基本语法和概念，帮助您快速上手智能合约开发。</p><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-functions">函数</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰器</a>、<a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-events">事件</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>、 和 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData; // 状态变量</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有效的状态变量类型参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#types">类型</a> 章节， 对状态变量可见性有可能的选择参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a> 。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // 函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#function-calls">函数调用</a> 可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a>）。</p><h4 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifiers">函数 </a>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; // 修饰器</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            &quot;Only seller can call this.&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // 事件</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events">事件</a>。</p><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>结构是可以将几个变量分组的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#structs">结构体</a>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // 结构</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#enums">枚举类型</a>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // 枚举</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p><code>bool</code> ：可能的取值为常数值 <code>true</code> 和 <code>false</code>。</p><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><code>int</code> &#x2F; <code>uint</code>: 分别表示有符号和无符号的不同位数的整型变量。 关键字 <code>uint8</code> 到 <code>uint256</code> （无符号整型，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>， 以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><h5 id="定长浮点型"><a href="#定长浮点型" class="headerlink" title="定长浮点型"></a>定长浮点型</h5><p>[^警告]: Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。</p><p><code>fixed</code> &#x2F; <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中， <code>M</code> 表示该类型占用的位数， <code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x18</code> 和 <code>fixed128x18</code> 的别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed constant PI = 3.14159265;</span><br><span class="line">fixed a = 1.2;</span><br><span class="line">ufixed constant PI = 3.14159265;</span><br><span class="line">ufixed a = 1.2;</span><br></pre></td></tr></table></figure><h5 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h5><p>地址类型有两种大致相同的类型：</p><ul><li><code>address</code>: 保存一个20字节的值（一个以太坊地址的大小）。</li><li><code>address payable</code>: 与 <code>address</code> 类型相同，但有额外的方法 <code>transfer</code> 和 <code>send</code>。</li></ul><p>这种区别背后的想法是， <code>address payable</code> 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 <code>address</code>，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address addr = 0x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990;</span><br><span class="line">address payable addr_pay = payable(0x8306300ffd616049FD7e4b0354a64Da835c1A81C);</span><br></pre></td></tr></table></figure><h5 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h5><p>值类型 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code> 代表从1到32的字节序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes32 public _byte32 = &quot;MiniSolidity&quot;; </span><br><span class="line"></span><br><span class="line">bytes1 public _byte = _byte32[0];</span><br></pre></td></tr></table></figure><h5 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。</p><p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code>0</code> 开始无符号整数值表示。</p><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 您可以得到给定枚举的最小值和最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.8;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() public &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span><br><span class="line">    // &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span><br><span class="line">    function getChoice() public view returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() public pure returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getLargestValue() public pure returns (ActionChoices) &#123;</span><br><span class="line">        return type(ActionChoices).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSmallestValue() public pure returns (ActionChoices) &#123;</span><br><span class="line">        return type(ActionChoices).min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 </p><p>类似的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125; &#123;modifier&#125; [pure|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><h1 id="模块三：核心概念与实战"><a href="#模块三：核心概念与实战" class="headerlink" title="模块三：核心概念与实战"></a>模块三：核心概念与实战</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>以太坊单位与地址。</p><p>支付与提现（payable, send, call）。</p><p>错误处理（require, assert, revert）。</p><h1 id="模块四：安全入门（重中之重！）"><a href="#模块四：安全入门（重中之重！）" class="headerlink" title="模块四：安全入门（重中之重！）"></a>模块四：安全入门（重中之重！）</h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>详解重入攻击及防护。</p><p>溢出保护（使用SafeMath库或Solidity 0.8+）。</p><p>权限控制（Ownable, AccessControl）。</p><h2 id="模块五：项目实战"><a href="#模块五：项目实战" class="headerlink" title="模块五：项目实战"></a>模块五：项目实战</h2><p>搭建一个完整的前端&#x2F;后端与合约交互。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程安排&quot;&gt;&lt;a href=&quot;#课程安排&quot; class=&quot;headerlink&quot; title=&quot;课程安排&quot;&gt;&lt;/a&gt;课程安排&lt;/h1&gt;&lt;h2 id=&quot;模块一：启程-区块链与智能合约概念&quot;&gt;&lt;a href=&quot;#模块一：启程-区块链与智能合约概念&quot; class=&quot;he</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第九周</title>
    <link href="https://www.zhengcookie.site/2025/09/13/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/09/13/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/</id>
    <published>2025-09-13T08:16:54.000Z</published>
    <updated>2025-10-01T04:54:48.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作内容与成果"><a href="#一、工作内容与成果" class="headerlink" title="一、工作内容与成果"></a>一、工作内容与成果</h2><p>本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：</p><p>（一）周一：后台界面优化工作</p><ol><li><p><strong>本地存储数据安全优化</strong>：针对后台界面，移除了通过 storage 本地存储模拟操作数据的方式。此优化有效避免了操作数据在本地透明可见的问题，提升了数据传输与存储的安全性，降低了数据被篡改或泄露的风险。</p></li><li><p><strong>核心业务逻辑调整</strong>：重点调整了后台作物管理与日志操作的核心逻辑。优化后，系统能够精准匹配对应地块的种子信息，确保作物数据与地块信息的关联性；同时，日志信息也能与具体操作场景、地块及作物数据准确对应，提升了后台数据管理的准确性与可读性，为后续数据查询与分析奠定基础。</p></li></ol><p>（二）周二：作物日志功能扩展</p><ol><li><p><strong>操作频次管控实现</strong>：为规范作物日志记录，新增作物日志每日操作限制规则，设定每种操作每日最多记录两次。该规则有效避免了日志数据冗余，保证了日志信息的简洁性与有效性，同时也符合农场日常运营中对作物操作的合理频次需求。</p></li><li><p><strong>日志生命周期管理</strong>：完善作物日志的生命周期逻辑，实现 “收获后自动删除日志，后续重新操作时添加新日志” 的功能。此举确保了日志信息与作物生长周期的同步性，避免了过期日志对数据管理的干扰，提升了日志数据的时效性。</p></li><li><p><strong>弱网环境数据保障</strong>：采用幂等性设计实现作物日志记录功能，在弱网、网络不流畅等不稳定环境下，能够有效防止重复添加日志数据，同时确保操作数据的完整性与准确性，提升了系统在复杂网络环境下的稳定性与可靠性。</p></li></ol><p>（三）周三：农场后台管理系统上线</p><ol><li><p><strong>管家日志管理功能</strong>：上线的农场后台管理系统中，新增管家后台日志记录功能，管家可通过系统的 “作物管理” 模块与 “每周日志” 模块，实时记录、查看与管理作物相关的操作日志，便于管家全面掌握作物生长过程中的关键操作，提升管理效率。</p></li><li><p><strong>种子图鉴管理功能</strong>：系统支持管家通过 “种子管理” 模块，上传、编辑与管理种子图鉴信息，包括种子品种、生长周期、适宜环境等关键数据。该功能为管家提供了统一的种子信息管理平台，便于规范种子信息管理，同时也为后续作物种植规划提供数据支持。</p></li><li><p><strong>订单查询管理功能</strong>：上线 “订单管理” 模块，管家可通过该模块快速查询所有订单信息，包括订单编号、订单类型、下单时间、订单状态等详细内容，支持按不同条件筛选查询，提升了订单信息的查询效率，便于管家及时跟进订单进度，保障农场运营的顺畅性。</p></li></ol><h3 id="二、核心工作成果"><a href="#二、核心工作成果" class="headerlink" title="二、核心工作成果"></a>二、核心工作成果</h3><p>本周聚焦农场相关系统完成三项关键工作：一是优化后台界面，移除 storage 本地存储模拟数据以强化安全，同时调整作物与日志逻辑，实现地块 - 种子 - 日志信息精准匹配；二是扩展作物日志功能，新增每日操作频次限制、收获后日志自动清理机制，并通过幂等设计解决弱网环境下数据重复问题；三是成功上线农场后台管理系统，为管家提供日志管理、种子图鉴上传、订单查询三大核心模块，满足日常管理需求。</p><h3 id="三、关键价值与亮点"><a href="#三、关键价值与亮点" class="headerlink" title="三、关键价值与亮点"></a>三、关键价值与亮点</h3><p>从安全性、实用性、稳定性三方面实现突破：安全层面，通过本地存储优化降低数据泄露风险，为系统数据安全奠定基础；实用层面，日志生命周期管理与后台系统功能模块，直接贴合农场运营场景，帮助管家提升数据管理与工作效率；稳定性层面，幂等设计的应用，有效应对复杂网络环境，保障操作数据的完整性，减少系统异常问题。</p><h3 id="四、后续行动方向"><a href="#四、后续行动方向" class="headerlink" title="四、后续行动方向"></a>四、后续行动方向</h3><p>后续将围绕 “优化体验、强化安全、拓展功能” 推进工作：优先收集管家使用反馈，迭代优化系统操作流程与功能漏洞；进一步完善数据安全体系，新增定期备份与恢复机制；结合农场实际需求调研新功能（如作物生长监控），同时持续监控系统性能，通过优化数据库、压缩资源等方式，确保系统长期稳定高效运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工作内容与成果&quot;&gt;&lt;a href=&quot;#一、工作内容与成果&quot; class=&quot;headerlink&quot; title=&quot;一、工作内容与成果&quot;&gt;&lt;/a&gt;一、工作内容与成果&lt;/h2&gt;&lt;p&gt;本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第八周</title>
    <link href="https://www.zhengcookie.site/2025/09/07/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/09/07/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/</id>
    <published>2025-09-07T12:22:49.000Z</published>
    <updated>2025-10-01T04:54:48.543Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。<br><strong>整体进展：</strong> ✅ <strong>核心闭环成功打通！</strong> 用户可完成<code>购买服务</code> -&gt; <code>播种</code> -&gt; <code>日常管理（浇水）</code> -&gt; <code>生成日志</code> -&gt; <code>收获</code> -&gt; <code>下单配送</code>的全流程。后台管理功能得到显著增强。</p><hr><h3 id="一、-每日开发详情"><a href="#一、-每日开发详情" class="headerlink" title="一、 每日开发详情"></a>一、 每日开发详情</h3><table><thead><tr><th align="left"><strong>日期</strong></th><th align="left"><strong>核心工作</strong></th><th align="left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td align="left"><strong>周一</strong></td><td align="left"><strong>后端服务开发</strong></td><td align="left">✅ <strong>下单服务</strong>：完成接收、处理、存储订单信息的后端逻辑。<br>✅ <strong>后台托管服务</strong>：实现分配管家处理任务及切换角色登录权限的功能。</td></tr><tr><td align="left"><strong>周二</strong></td><td align="left"><strong>后台管理系统开发</strong></td><td align="left">✅ <strong>订单管理页面</strong>：<br>  - 设计订单列表，可根据 <code>order_type</code> 动态展示信息。<br>  - 实现按类型、状态等条件的筛选功能。<br>  - 开发订单详情页，关联显示主表(<code>t_order</code>)与子表信息。<br>✅ <strong>托管日志集成</strong>：在作物管理界面中，可查看关联的托管服务日志。<br>✅ <strong>管家绑定</strong>：前端通过 <code>store</code> 中的用户ID查询并绑定 <code>caretaker_user_id</code>，管理作物。</td></tr><tr><td align="left"><strong>周三</strong></td><td align="left"><strong>前后端功能联调</strong></td><td align="left">✅ <strong>日志查看</strong>：点击作物即可显示相关管家的操作日志。<br>✅ <strong>订单管理</strong>：用户可查询并修改自己的订单信息。</td></tr><tr><td align="left"><strong>周四</strong></td><td align="left"><strong>功能优化与扩展</strong></td><td align="left">✅ <strong>修复前端显示</strong>：优化购买服务页面，为播种功能做准备。<br>✅ <strong>服务扩展</strong>：扩展下单服务，支持收获后生成配送订单的流程。<br>✅ <strong>界面优化</strong>：对订单列表的“待收获”界面进行了视觉和体验优化。</td></tr><tr><td align="left"><strong>周五</strong></td><td align="left"><strong>交互功能实现</strong></td><td align="left">✅ <strong>确认操作</strong>：实现前端确认操作（如浇水）的功能。<br>✅ <strong>日志记录</strong>：为浇水等操作生成两种日志：<br>  - <strong>用户操作日志</strong> (用户点击触发)<br>  - <strong>管家工作日志</strong> (管家后台记录)<br>✅ <strong>通知机制</strong>：管家可在后台管理系统中获取相关操作的通知和日志。</td></tr><tr><td align="left"><strong>周六</strong></td><td align="left"><strong>全链路测试与BUG修复</strong></td><td align="left">✅ <strong>核心闭环验证</strong>：成功测试并修复逻辑BUG，确保从购买到收获下单的全流程畅通。<br>✅ <strong>遗留问题定位</strong>：<br>  - <strong>问题一</strong>：手机端支付后可重复点击购买，需前端优化交互。<br>  - <strong>问题二</strong>：后台订单界面需集成第三方服务（如支付、物流），待确定方案。</td></tr></tbody></table><hr><h3 id="二、-核心业务流程与逻辑-本周重大进展"><a href="#二、-核心业务流程与逻辑-本周重大进展" class="headerlink" title="二、 核心业务流程与逻辑 (本周重大进展)"></a>二、 核心业务流程与逻辑 (本周重大进展)</h3><ol><li><p><strong>收获后处理逻辑（后端）</strong>：<br>当用户发起收获并成功创建配送单后，系统自动执行以下操作，确保数据状态准确：</p><ul><li><strong>清空地块</strong>：将对应地块的作物状态重置为 <code>empty</code>。</li><li><strong>扣减权益</strong>：<ul><li>对于<strong>次数型</strong>权益：将 <code>uses_left</code> (剩余次数) 减1。若次数用尽，则将权益状态置为 <code>consumed</code>。</li><li>对于<strong>时长型</strong>权益：不扣减次数，仅检查有效期。</li></ul></li><li><strong>更新权益状态</strong>：重新计算该地块的 <code>owned</code> 字段。只要仍有有效的<code>active</code>权益（次数未用完或未过期），<code>owned</code> 即为 <code>true</code>，否则为 <code>false</code>。</li></ul></li><li><p><strong>前端支付流程优化（已解决）</strong>：<br>修复了 <code>purchaseServicePackage</code> 函数中 <code>await</code> 与 <code>success</code> 回调混用导致的逻辑问题。</p><ul><li><strong>解决方案</strong>：重写该函数，采用纯 <code>async/await</code> 方式调用支付接口。支付成功后，<strong>立即调用后端接口刷新地块数据</strong>，并提交一个 <code>mutation</code> 来本地更新状态，确保UI显示及时、准确。</li></ul></li></ol><hr><h3 id="三、-待解决的问题与下周计划"><a href="#三、-待解决的问题与下周计划" class="headerlink" title="三、 待解决的问题与下周计划"></a>三、 待解决的问题与下周计划</h3><table><thead><tr><th align="left"><strong>问题描述</strong></th><th align="left"><strong>性质</strong></th><th align="left"><strong>可能解决方案&#x2F;下一步计划</strong></th></tr></thead><tbody><tr><td align="left"><strong>1. 移动端支付后可重复点击</strong></td><td align="left">前端交互BUG</td><td align="left">在支付请求发起后，禁用按钮并显示加载状态，直到收到明确的成功&#x2F;失败回调。</td></tr><tr><td align="left"><strong>2. 后台需集成第三方服务</strong></td><td align="left">技术方案调研</td><td align="left">调研并选择可靠的第三方服务提供商（如支付宝&#x2F;微信支付官方API、聚合支付平台、物流公司API），然后编写对接代码。</td></tr></tbody></table><p><strong>下周计划：</strong></p><ul><li><strong>解决遗留问题</strong>：优先修复移动端支付交互BUG，并启动第三方服务对接的调研与开发。</li><li><strong>功能增强</strong>：基于已打通的闭环，考虑添加更多作物管理操作（如施肥、除虫）、优化日志系统、设计更完善的管家通知中心。</li><li><strong>测试与部署</strong>：进行更全面的测试，准备将新功能部署至测试或生产环境。</li></ul><hr><h3 id="四、-本周工作回顾：核心业务闭环全面打通"><a href="#四、-本周工作回顾：核心业务闭环全面打通" class="headerlink" title="四、 本周工作回顾：核心业务闭环全面打通"></a><strong>四、 本周工作回顾：核心业务闭环全面打通</strong></h3><p>本周的核心工作是推动农场项目的<strong>完整业务流程实现</strong>与<strong>后台管理系统强化</strong>，并成功完成了端到端的测试验证。</p><ol><li><strong>后端服务建设</strong>：完成了<strong>下单服务</strong>与<strong>后台托管服务</strong>的开发，实现了订单的接收、处理、存储，以及管家的任务分配与权限管理。</li><li><strong>后台管理功能增强</strong>：开发了功能完善的订单管理页面（列表、筛选、详情）、托管服务日志记录模块，并实现了作物与管家的绑定管理。</li><li><strong>核心业务闭环验证</strong>：成功打通了“<strong>用户购买服务 -&gt; 播种 -&gt; 进行浇水等管理操作 -&gt; 自动生成日志 -&gt; 收获并创建配送单 -&gt; 地块状态重置</strong>”的完整业务流程，标志着项目最核心的功能链路已全部跑通。</li><li><strong>前端体验优化</strong>：修复了购买服务页面的显示问题，优化了订单界面，并重写了支付逻辑，确保了交互的准确性和数据的一致性。</li></ol><h3 id="五、-问题与反思：技术方案与细节处理需持续打磨"><a href="#五、-问题与反思：技术方案与细节处理需持续打磨" class="headerlink" title="五、 问题与反思：技术方案与细节处理需持续打磨"></a>五<strong>、 问题与反思：技术方案与细节处理需持续打磨</strong></h3><p>在开发过程中，也遇到并识别了一些亟待解决的问题，主要集中在交互细节和技术方案选型上。</p><ol><li><strong>移动端交互细节问题</strong>：手机端支付成功后，按钮状态未能及时重置，导致用户可重复点击，<strong>暴露了前端对连续请求控制的不足</strong>。这需要通过添加加载状态和按钮禁用机制来优化。</li><li><strong>外部集成技术方案待定</strong>：后台系统需要接入支付、物流等第三方服务，但目前<strong>尚未确定具体的技术选型和对接方案</strong>，这是下一步需要重点调研和决策的点。</li><li><strong>逻辑严谨性</strong>：在解决“收获后清空地块”等复杂业务逻辑时，意识到必须通过<strong>精准的后端逻辑</strong>（如扣减权益、状态更新）来保证数据一致性，而非依赖前端。</li></ol><h3 id="六、-下周计划：解决遗留问题，推进系统集成与优化"><a href="#六、-下周计划：解决遗留问题，推进系统集成与优化" class="headerlink" title="六、 下周计划：解决遗留问题，推进系统集成与优化"></a><strong>六、 下周计划：解决遗留问题，推进系统集成与优化</strong></h3><p>基于本周的进展和问题，下周的工作将围绕以下重点展开：</p><ol><li><strong>优先解决遗留问题</strong>：<ul><li>修复移动端支付交互BUG，增加防重复提交机制。</li><li>启动对第三方服务（如支付、物流API）的调研，并形成初步的集成方案。</li></ul></li><li><strong>功能增强与优化</strong>：<ul><li>在现有闭环基础上，规划并开发更多的作物管理操作（如施肥、除虫）。</li><li>优化日志系统和管家通知中心，提升用户体验和管理效率。</li></ul></li><li><strong>测试与部署准备</strong>：<ul><li>对已打通的全流程进行更全面的测试，准备将稳定版本部署至测试环境。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ &lt;strong&gt;核心闭环成功打通！&lt;/strong&gt; 用户可完成&lt;code&gt;购买服务&lt;/code&gt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第七周</title>
    <link href="https://www.zhengcookie.site/2025/08/30/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/08/30/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/</id>
    <published>2025-08-30T11:18:00.000Z</published>
    <updated>2025-10-01T04:54:48.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="周一：农场服务前端界面实现"><a href="#周一：农场服务前端界面实现" class="headerlink" title="周一：农场服务前端界面实现"></a><strong>周一：农场服务前端界面实现</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现托管服务操作流程：点击托管→选择种植物→确认收获→判断收获方式。  </li><li>搭建基础农场前端界面，完成用户交互逻辑。</li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>收获方式判断逻辑需与后端土地状态同步（未实时更新）。</li></ul><p><strong>解决方式</strong>：  </p><ul><li>添加前端定时查询地块状态，确保数据一致性。</li></ul><hr><h3 id="周二：订单生成与支付界面优化"><a href="#周二：订单生成与支付界面优化" class="headerlink" title="周二：订单生成与支付界面优化"></a><strong>周二：订单生成与支付界面优化</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>对接托管服务订单接口（<code>/orders/service</code>），生成订单并关联用户与地块数据。  </li><li>优化支付界面样式，使其更简洁清晰，支持后续扩展托管服务类型。  </li><li>实现土地及托管服务数据存储，支持详细查询。</li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>支付界面在不同设备上显示错位（移动端适配问题）。</li></ul><p><strong>解决方式</strong>：  </p><ul><li>使用响应式布局（CSS Flexbox+Media Query）快速修复。</li></ul><hr><h3 id="周三：扩展购买与播种功能"><a href="#周三：扩展购买与播种功能" class="headerlink" title="周三：扩展购买与播种功能"></a><strong>周三：扩展购买与播种功能</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>扩展托管服务购买功能（接口：<code>/farm/service/package/purchase</code>）。  </li><li>实现种子播种功能（接口：<code>/farm/plant</code>）并关联地块数据（接口：<code>/farm/plots</code>）。  </li><li>订单查询与支付状态联动（支付成功自动更新订单状态）。</li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>播种请求超时（地块数据量增大导致查询缓慢）。</li></ul><p><strong>解决方式</strong>：  </p><ul><li>为<code>/farm/plots</code>接口添加缓存机制（Redis缓存地块信息）。</li></ul><hr><h3 id="周四：后台管理系统开发"><a href="#周四：后台管理系统开发" class="headerlink" title="周四：后台管理系统开发"></a><strong>周四：后台管理系统开发</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现后台托管服务管理（增删改查）。  </li><li>开发作物管理模块（支持作物信息维护）。  </li><li>搭建每周日志记录功能（支持日志添加与查询）。  </li><li>完成种子管理基础功能（CRUD操作）。</li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>管家管理模块需对接若依权限系统，但账户体系不兼容。</li></ul><p><strong>解决方式</strong>：  </p><ul><li>暂独立开发管家管理模块，预留若依系统对接接口。</li></ul><hr><h3 id="周五：后台功能完善与权限隔离"><a href="#周五：后台功能完善与权限隔离" class="headerlink" title="周五：后台功能完善与权限隔离"></a><strong>周五：后台功能完善与权限隔离</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>完成托管服务、作物管理、每周日志、种子管理的完整增删改查功能。  </li><li>优化后台数据查询效率（添加数据库索引）。  </li><li>管家管理模块独立运行（暂未关联若依登录）。</li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>若依系统权限接口文档缺失，无法直接对接。</li></ul><p><strong>解决方式</strong>：  </p><ul><li>优先保证其他后台功能上线，管家管理采用若依账号过渡。</li></ul><hr><h3 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a><strong>本周总结</strong></h3><h4 id="1-独立完成内容"><a href="#1-独立完成内容" class="headerlink" title="1. 独立完成内容"></a><strong>1. 独立完成内容</strong></h4><ul><li>前端农场服务全流程（托管→支付→播种→收获）。  </li><li>订单与支付系统集成（微信支付+订单状态管理）。  </li><li>后台管理核心功能（作物、日志、种子、托管服务管理）。</li></ul><h4 id="2-主要挑战"><a href="#2-主要挑战" class="headerlink" title="2. 主要挑战"></a><strong>2. 主要挑战</strong></h4><ul><li><strong>支付合规性</strong>：订单号长度限制（32位）、HTTPS证书配置。  </li><li><strong>系统兼容性</strong>：管家模块与若依权限系统账户体系不匹配。  </li><li><strong>性能问题</strong>：地块数据量增大导致查询缓慢。</li></ul><h4 id="3-成长与改进"><a href="#3-成长与改进" class="headerlink" title="3. 成长与改进"></a><strong>3. 成长与改进</strong></h4><ul><li><strong>第三方集成经验</strong>：支付接口必须严格遵循字段规范（如订单号长度）。  </li><li><strong>解耦设计</strong>：模块化开发（如管家管理独立）降低系统耦合风险。  </li><li><strong>性能优化</strong>：引入缓存与数据库索引应对数据增长。</li></ul><h4 id="4-后续计划"><a href="#4-后续计划" class="headerlink" title="4. 后续计划"></a><strong>4. 后续计划</strong></h4><ul><li>补全若依系统对接文档，完成管家权限集成。  </li><li>统一接口响应格式，编写后端API文档。  </li><li>增加农场操作（播种、收获）的事务回滚机制。</li></ul><p><strong>总结</strong>：本周成功交付农场系统核心功能，但支付与权限集成暴露了<strong>预研不足</strong>的问题。后续类似项目需提前验证第三方接口（支付、登录）的合规性；  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;a href=&quot;#周一：农场服务前端界面实现&quot; class=&quot;headerlink&quot; title=&quot;周一：农场服务前端界面实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;周一：农场服务前端界面实现&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;完</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第六周</title>
    <link href="https://www.zhengcookie.site/2025/08/25/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/08/25/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/</id>
    <published>2025-08-25T15:01:50.000Z</published>
    <updated>2025-10-01T04:54:48.546Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）<br><strong>整体进展：</strong> ✅ 成功打通<code>HTTPS部署</code> -&gt; <code>微信支付</code> -&gt; <code>农场种植</code>全链路，项目进入可演示阶段。</p><hr><h3 id="一、-每日工作记录"><a href="#一、-每日工作记录" class="headerlink" title="一、 每日工作记录"></a><strong>一、 每日工作记录</strong></h3><table><thead><tr><th align="left"><strong>日期</strong></th><th align="left"><strong>核心工作</strong></th><th align="left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td align="left"><strong>周一</strong></td><td align="left"><strong>HTTPS服务配置</strong></td><td align="left">✅ <strong>前端</strong>：使用Nginx配置SSL证书，实现小程序前端页面的HTTPS安全访问。<br>✅ <strong>后端</strong>：在SpringBoot中配置SSL证书，使后端API支持HTTPS请求，为微信支付等安全接口打下基础。</td></tr><tr><td align="left"><strong>周二</strong></td><td align="left"><strong>微信支付集成</strong></td><td align="left">✅ 集成<strong>微信支付V2版</strong>，完成下单、回调等核心流程开发。<br>✅ 使用<strong>内网穿透</strong>工具模拟支付环境，初步测试通过。<br>⚠️ <strong>待办</strong>：退款功能暂未实现。</td></tr><tr><td align="left"><strong>周三</strong></td><td align="left"><strong>问题修复与设计</strong></td><td align="left">✅ <strong>修复支付Bug</strong>：深入分析并解决了官方文档中提及的“订单重复”问题，优化为首次<code>统一下单</code>、后续调用<code>jsapi</code>的稳定流程。<br>✅ <strong>数据库设计</strong>：为农场托管功能设计了<code>farms</code>（田地）、<code>crops</code>（种子）、<code>farmManagers</code>（农场管家）三张核心表，明确通过JWT鉴权来隔离用户数据。</td></tr><tr><td align="left"><strong>周四</strong></td><td align="left"><strong>农场服务开发</strong></td><td align="left">✅ 开发并部署核心农场后端服务，提供初步可用的RESTful API：<br>  - <code>POST /farm/plant</code>： <strong>种植接口</strong><br>  - <code>POST /farm/init</code>： <strong>初始化用户田地</strong><br>  - <code>POST /farm/listByUser</code>： <strong>获取用户田地信息</strong></td></tr><tr><td align="left"><strong>周五</strong></td><td align="left"><strong>联调与架构复盘</strong></td><td align="left">✅ 成功完成前端与农场服务的联调，可获取并展示用户种植数据。<br>✅ <strong>架构决策</strong>：确定使用<strong>混合云开发</strong>方案（自建MySQL + 云服务），兼顾了数据灵活性与开发效率。</td></tr></tbody></table><hr><h3 id="二、-本周最大的挑战与解决方案"><a href="#二、-本周最大的挑战与解决方案" class="headerlink" title="二、 本周最大的挑战与解决方案"></a><strong>二、 本周最大的挑战与解决方案</strong></h3><ul><li><strong>挑战：</strong> 技术选型在<strong>数据库扩展性</strong>与<strong>开发维护效率</strong>之间的权衡。纯微信云开发无法满足复杂的MySQL业务需求，而完全自建服务器运维成本较高。</li><li><strong>解决方案：</strong> 采用<strong>混合云架构</strong>。<ul><li><strong>核心业务数据</strong>（用户、订单、农场）：使用自建云服务器上的MySQL数据库，保证了对数据的完全控制和复杂查询能力。</li><li><strong>静态资源&#x2F;轻量功能</strong>：后续可考虑使用云开发平台的服务，提升开发速度与稳定性。</li></ul></li><li><strong>结果：</strong> 该方案既满足了当前业务的复杂度，又为未来部分功能的快速迭代提供了灵活性，速度与稳定性兼得。</li></ul><hr><h3 id="三、-本周工作带来的成长"><a href="#三、-本周工作带来的成长" class="headerlink" title="三、 本周工作带来的成长"></a><strong>三、 本周工作带来的成长</strong></h3><ol><li><strong>全链路能力提升：</strong> 从最基础的HTTPS配置，到复杂的支付业务、数据库设计，再到后端服务开发，独立打通了核心功能的全链路，对前后端协同开发的理解更加深刻。</li><li><strong>技术方案设计能力：</strong> 不再局限于实现功能，开始从<strong>架构角度</strong>思考问题（如混合云选型），学会了在多种技术方案中权衡利弊，选择最适合当前业务阶段的方案。</li><li><strong>文档驱动开发：</strong> 通过编写设计文档来理清逻辑，再着手编码，有效减少了开发过程中的反复和错误，提升了开发效率和质量。</li></ol><hr><h3 id="四、-反思与未来优化"><a href="#四、-反思与未来优化" class="headerlink" title="四、 反思与未来优化"></a><strong>四、 反思与未来优化</strong></h3><ul><li><strong>本周不足：</strong> 最初的方案设计对<strong>云原生</strong>和<strong>混合架构</strong>的考量不够深入，导致中途需要调整技术路线，产生了一定的学习成本。</li><li><strong>未来优化：</strong><ol><li><strong>架构设计</strong>：在项目初期，应更系统地评估各种技术方案（自建、纯云、混合云）的优缺点，制作详细的对比表格，避免后期切换。</li><li><strong>可维护性</strong>：虽然混合方案稳定，但未来可以考虑使用<strong>Docker容器化</strong>来部署MySQL和应用，提升环境一致性和迁移效率。</li><li><strong>功能完善</strong>：下一步需补全<strong>退款流程</strong>，并开始构建基于农场数据的<strong>商城购买与订单生成</strong>功能，最终完成商业闭环。</li></ol></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本周核心目标：&lt;/strong&gt; 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）&lt;br&gt;&lt;strong&gt;整体进展：&lt;/strong&gt; ✅ 成功打通&lt;code&gt;HTTPS部署&lt;/code&gt; -&amp;gt; &lt;code&gt;微信支付&lt;/code&gt; -&amp;g</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第五周</title>
    <link href="https://www.zhengcookie.site/2025/08/17/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/08/17/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/</id>
    <published>2025-08-16T16:04:11.000Z</published>
    <updated>2025-10-01T04:54:48.540Z</updated>
    
    <content type="html"><![CDATA[<hr><table><thead><tr><th>日期</th><th>核心工作</th><th>关键产出</th></tr></thead><tbody><tr><td><strong>周一</strong></td><td>后台系统技术选型与架构设计</td><td>✅ 选定 <strong>若依框架</strong> 搭建后台管理系统<br>✅ 完成 <strong>功能模块划分</strong> 及技术文档输出</td></tr><tr><td><strong>周二</strong></td><td>用户管理模块开发</td><td>✅ 实现用户信息 <strong>增删改查（CRUD）</strong> 全功能</td></tr><tr><td><strong>周三</strong></td><td>核心业务模块开发</td><td>✅ 完成 <strong>订单管理</strong> 业务流程设计<br>✅ 落地 <strong>土地管理</strong> CRUD 核心逻辑</td></tr><tr><td><strong>周四</strong></td><td>技术方案优化与问题修复</td><td>✅ 验证 <strong>微信云开发</strong> 替代方案可行性<br>✅ 修复 <strong>图片上传异常</strong> Bug（改用云存储+路径映射）</td></tr><tr><td><strong>周五</strong></td><td>混合架构设计与规划</td><td>✅ 制定 <strong>MySQL + 云数据库混合方案</strong><br>✅ 参与 <strong>后续原型扩展</strong> 技术讨论</td></tr></tbody></table><hr><h3 id="关键亮点说明："><a href="#关键亮点说明：" class="headerlink" title="关键亮点说明："></a>关键亮点说明：</h3><ol><li><p><strong>技术选型</strong>：  </p><ul><li>选择 <strong>若依框架</strong> → 节省60%基础模块开发时间  </li><li>放弃纯云开发 → 因 <strong>MySQL业务兼容性</strong> 不足</li></ul></li><li><p><strong>架构突破</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[微信小程序] --&gt; B&#123;云存储&#125;</span><br><span class="line">A --&gt; C[自建服务器]</span><br><span class="line">B --&gt; D[图片/文件]</span><br><span class="line">C --&gt; E[MySQL业务库]</span><br></pre></td></tr></table></figure><p><strong>混合架构价值</strong>：静态资源云化减压，核心数据自主可控</p></li></ol><hr><h3 id="一、独立完成事项-挑战与成长"><a href="#一、独立完成事项-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><table><thead><tr><th><strong>工作内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长收获</strong></th></tr></thead><tbody><tr><td><strong>1. 后台系统设计</strong><br> - 技术选型（若依框架）<br> - 功能模块规划文档</td><td>• 平衡开发效率与后期扩展性</td><td>• 选择 <strong>开源后台框架若依</strong>（集成权限管理&#x2F;代码生成）</td><td>✅ 掌握 <strong>快速搭建企业级后台</strong> 的方法论</td></tr><tr><td><strong>2. 核心模块开发</strong><br> - 用户管理（增删改查）<br> - 订单&#x2F;土地管理功能</td><td>• 数据库设计需兼容农场业务逻辑<br>• 字段关联性复杂</td><td>• 先画 <strong>ER图梳理数据关系</strong><br>• 用若依代码生成器快速实现基础CRUD</td><td>✅ 提升 <strong>业务模型抽象能力</strong><br>✅ 熟练 <strong>框架工具提效技巧</strong></td></tr><tr><td><strong>3. 技术方案优化</strong><br> - 尝试微信云开发<br> - 图片上传BUG修复</td><td>• 云开发与传统MySQL不兼容<br>• 图片路径存储异常</td><td>• 改用 <strong>混合云架构</strong>：<br>  - 核心业务用云服务器+MySQL<br>  - 图片&#x2F;文件用云存储</td><td>✅ 理解 <strong>混合云方案设计思维</strong><br>✅ 学会 <strong>根据场景灵活选型</strong></td></tr></tbody></table><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><ol><li><p><strong>「快 vs 稳」的博弈</strong>：  </p><blockquote><p>若依框架虽加速开发，但过度依赖其生成代码可能导致<strong>技术债积累</strong>（如订单扩展字段需手动调整），下次需预留20%自定义空间。  </p></blockquote></li><li><p><strong>云服务的双刃剑</strong>：  </p><blockquote><p>微信云开发适合轻量应用，但<strong>数据库生态封闭</strong>（不支持MySQL）成为硬伤，混合架构虽解燃眉之急，也带来运维复杂度。</p></blockquote></li></ol><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><ol><li><p><strong>技术选型更严谨</strong>：  </p><ul><li><p>制作 <strong>方案对比表</strong>（如下），避免试错成本：  </p><table><thead><tr><th>方案</th><th>扩展性</th><th>维护成本</th><th>适合场景</th></tr></thead><tbody><tr><td>自建MySQL</td><td>★★★★</td><td>中</td><td>复杂业务</td></tr><tr><td>纯微信云开发</td><td>★★</td><td>低</td><td>轻量工具类应用</td></tr><tr><td><strong>混合云</strong></td><td>★★★</td><td><strong>中高</strong></td><td><strong>中庸型项目</strong></td></tr></tbody></table></li><li><p>非核心功能（如图片上传）<strong>彻底云化</strong>，直接用云开发SDK。</p></li></ul></li><li><p><strong>建立原型验证机制</strong>：  </p><ul><li>重要模块（如订单状态机）先写 <strong>伪代码流程图</strong> 与产品确认，避免返工。</li></ul></li></ol><blockquote><p><strong>总结</strong>：本周深刻体会架构选型需考量 <strong>业务生命周期</strong>（短期效率 vs 长期扩展）。未来将坚持 <strong>“设计-原型-开发”三步走</strong>，让技术真正服务业务增长。  </p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;核心工作&lt;/th&gt;
&lt;th&gt;关键产出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;周一&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;后台系统技术选型与架构设计&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广州it工作第四周</title>
    <link href="https://www.zhengcookie.site/2025/08/10/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/08/10/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/</id>
    <published>2025-08-10T05:28:04.000Z</published>
    <updated>2025-10-01T04:54:48.561Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周一：</strong>  </p><ul><li>完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  </li><li><em>注意点：</em> 补充了状态字段设计。</li></ul><p><strong>周二：</strong>  </p><ul><li>构建订单系统：创建订单主表及详情表，实现：  <ul><li>JWT用户订单查询  </li><li>多状态分类（待支付&#x2F;待发货等）  </li><li>PageHelper分页（&gt;10自动分页，加载页面缓存进度）</li></ul></li><li><em>遗留问题：</em> 订单号长度仅20位（需32位）。</li></ul><p><strong>周三：</strong>  </p><ul><li>订单详情增强：调用土地接口展示租赁地块信息。  </li><li>前端隐患：<code>this.orderInfo.items[0]</code> 强耦合数据绑定。</li></ul><p><strong>周四：</strong>  </p><ul><li>订单状态管理：实现增删改查及状态流转（如取消订单同步释放土地）。  </li><li><em>优化：</em> 采用状态模式替代if-else链。</li></ul><p><strong>周五：</strong>  </p><ul><li>支付功能受阻：  <ol><li><strong>致命问题：</strong> 后端未配置HTTPS（微信支付强制要求）  </li><li><strong>设计缺陷：</strong> 订单号长度不符支付接口规范（20位≠32位）</li></ol></li><li><em>转向：</em> 启动手机号验证方案研究。</li></ul><p><strong>周六：</strong>  </p><ul><li>微信验证困局：  <ul><li>手机号快速验证失败（需企业认证）  </li><li><code>getUserProfile</code>仅获取基础信息（头像&#x2F;昵称）  </li><li>开放数据解密流程复杂且无进展</li></ul></li><li><em>结论：</em> 当前微信政策下，获取手机号一键登录不可行。</li></ul><hr><p><strong>核心卡点：</strong>  </p><ol><li><strong>支付环节：</strong> HTTPS缺失 + 订单号设计缺陷  </li><li><strong>微信生态：</strong> 政策收紧导致手机号获取路径封死</li></ol><h3 id="一、独立完成-挑战-成长"><a href="#一、独立完成-挑战-成长" class="headerlink" title="一、独立完成 &amp; 挑战 &amp; 成长"></a><strong>一、独立完成 &amp; 挑战 &amp; 成长</strong></h3><table><thead><tr><th><strong>事项</strong></th><th><strong>独立完成</strong></th><th><strong>最大挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长</strong></th></tr></thead><tbody><tr><td><strong>租地系统</strong></td><td>租赁表设计 + JWT用户绑定</td><td>状态字段缺失</td><td>快速补字段 + 关联订单状态</td><td>意识到<strong>数据扩展性</strong>的重要性</td></tr><tr><td><strong>订单中台</strong></td><td>双表创建 + 分页&#x2F;状态筛 + 状态机</td><td>订单号长度设计不足(20位)</td><td>重构为32位 UUID</td><td><strong>关键字段需预判业务需求</strong></td></tr><tr><td><strong>支付对接</strong></td><td>调用微信支付流程开发</td><td>1. 无HTTPS<br>2. 微信政策限制</td><td>转向备用方案（手机号验证）</td><td>第三方功能<strong>必须预研环境&#x2F;政策</strong></td></tr><tr><td><strong>微信集成</strong></td><td>实现<code>getUserProfile</code>基础授权</td><td>无法获取用户准确信息（政策封锁）</td><td>明确放弃，转为人工审核流程</td><td>学会<strong>在限制中寻找替代路径</strong></td></tr></tbody></table><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a><strong>二、本周工作思考</strong></h3><ol><li><strong>做得好的</strong>  <ul><li>基础功能闭环：租地→订单→状态流转全链路跑通  </li><li>快速响应问题：发现订单号缺陷应该立即重构</li></ul></li><li><strong>待改进的</strong>  <ul><li><strong>致命疏忽</strong>：支付未提前验证HTTPS&#x2F;字段规则 → 导致整块功能返工  </li><li><strong>过度乐观</strong>：低估微信政策限制（开发者权限）</li></ul></li><li><strong>核心认知</strong>  <blockquote><p><strong>“能开发” ≠ “能上线”</strong><br>第三方依赖的合规性（HTTPS&#x2F;政策）比代码更重要</p></blockquote></li></ol><hr><h3 id="三、未来同样机会的做法"><a href="#三、未来同样机会的做法" class="headerlink" title="三、未来同样机会的做法"></a><strong>三、未来同样机会的做法</strong></h3><ol><li><p><strong>预研四象限（首日必做）</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[技术]      [政策]      [环境]       [兼容性]  </span><br><span class="line">│          │          │            │  </span><br><span class="line">├─HTTPS?   ├─微信文档? ├─测试账号?   ├─字段长度?  </span><br><span class="line">└─SDK兼容  └─权限范围  └─域名备案    └─数据格式  </span><br></pre></td></tr></table></figure></li><li><p><strong>设计两原则</strong>  </p><ul><li><strong>字段设计</strong>：订单号&#x2F;金额等支付相关字段，直接对齐微信要求（32位&#x2F;UUID）  </li><li><strong>解耦开发</strong>：支付模块用模拟运行，便于替换（例：HTTPS未就绪时模拟支付）</li></ul></li><li><p><strong>政策应对</strong>  </p><ul><li>项目避免强依赖微信敏感接口（如手机号）</li></ul></li></ol><blockquote><p><strong>总结一句话</strong>：<br><strong>下次先花2小时跑通支付Demo+政策验证，再动手写业务代码。</strong><br>功能开发速度 ≠ 交付速度，预研省下的就是返工浪费的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;周一：&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;注意点：&lt;/em&gt; 补充了状态字段设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;周二：&lt;/strong&gt;  </summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第三周</title>
    <link href="https://www.zhengcookie.site/2025/08/02/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <id>https://www.zhengcookie.site/2025/08/02/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/</id>
    <published>2025-08-01T16:26:28.000Z</published>
    <updated>2025-10-01T04:54:48.558Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心目标：</strong> 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。</p><p><strong>本周主要进展：</strong></p><ol><li><p><strong>项目启动与基础搭建 (周一)：</strong></p><ul><li>用开发工具创建了小程序项目框架。</li><li><strong>首页：</strong> 实现了图片热区点击跳转（用<code>绝对定位</code>精确定位点击区域，<code>uni.switchTab</code>跳转底部菜单页）。</li><li><strong>公告栏：</strong> 暂时留空。</li><li><strong>我的农场：</strong> 开始设计核心玩法（比如种植收获逻辑）。</li><li><strong>个人中心：</strong> 画好了页面布局。</li><li>图片上传到<code>图床</code>，减小小程序安装包体积。</li></ul></li><li><p><strong>界面优化与农场互动 (周二)：</strong></p><ul><li><strong>首页：</strong> 用<code>媒体查询</code>让页面在不同尺寸手机上都好看（响应式布局）。</li><li><strong>我的农场：</strong> 用<code>Grid网格布局</code>做了9块整齐的地块。点击地块能弹出操作图片（比如选择种子）。</li><li><strong>个人中心：</strong> 本想做微信<code>一键登录</code>（获取手机号），但个人小程序权限不够。改用方案：用户授权获取微信<code>头像和昵称</code>绑定账号，登录成功后服务器返回一个<code>token</code>（身份令牌）存起来，代表用户已登录。</li></ul></li><li><p><strong>新增功能模块 (周三)：</strong></p><ul><li><strong>首页：</strong> 加了“马克农场”入口，点击后跳转新页面（用<code>uni.navigateTo</code>页面跳转）。</li><li><strong>个人中心：</strong> 增加了“设置”页面，可以修改个人信息。</li></ul></li><li><p><strong>核心登录功能实现 (周四)：</strong></p><ul><li><strong>个人中心：</strong><ul><li>实现了完整的微信登录流程：<ol><li>小程序获取临时登录凭证<code>code</code>。</li><li>把<code>code</code>发给我的后台服务器。</li><li>后台用<code>code</code>向微信服务器换取用户的<code>唯一标识(openid)</code>等信息。</li><li>后台查数据库：如果是新用户，就创建账号；老用户则读取信息。</li><li>后台生成<code>token</code>，连同用户信息一起返回给小程序。</li><li>小程序把<code>token</code>和用户信息存起来（<code>storage</code>），后续操作代表该用户。</li></ol></li><li><em>注：等小程序主体是企业后，可升级为手机号直接登录。</em></li></ul></li><li><strong>订单页：</strong> 实现了跳转到不同订单类型页的功能（在链接后面加<code>?type=...</code>传参）。解决了引入图标库时的兼容性问题。</li></ul></li><li><p><strong>用户信息保护与更新 (周五)：</strong></p><ul><li>完善登录后的安全措施：采用<code>JWT令牌</code>进行<code>鉴权</code>（验证身份）。<ul><li><strong>为什么选JWT？</strong> 主要因为它不需要<code>Cookie</code>，避免了<code>跨域(CORS)</code>问题，更方便不同服务器间协作。而且服务器不用存储用户登录状态（<code>无状态</code>），减轻负担。</li><li><strong>怎么用？</strong> 用户登录后拿到<code>JWT token</code>（就是周四的那个token）。当用户想修改头像昵称等需要登录的操作时，小程序在请求头里带上这个token（格式：<code>Authorization: Bearer &lt;你的token&gt;</code>）。后台收到请求后，先<code>验证token是否有效且合法</code>，验证通过了才允许修改用户信息。</li></ul></li><li>实现了登录后修改头像和昵称的功能。</li></ul></li></ol><p><strong>简单来说，这周：</strong> 搭好了小程序的基础架子，重点实现了用户<code>登录注册流程</code>（包括微信授权、后台验证、生成令牌JWT），完成了个人中心的主要功能（信息展示、设置、头像昵称修改），并开始为订单系统做跳转准备。技术上解决了图片优化、布局适配、登录授权、身份验证（JWT）等关键点。</p><p>以下是对本周工作的结构化复盘总结，结合实践与成长思考：</p><hr><h3 id="一、独立完成事项-挑战与成长"><a href="#一、独立完成事项-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><table><thead><tr><th><strong>完成内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>带来的成长</strong></th></tr></thead><tbody><tr><td><strong>1. 用户系统全流程搭建</strong><br> - 微信登录+JWT鉴权<br> - 头像&#x2F;昵称修改功能</td><td>• 个人小程序无法直接获取手机号<br>• JWT无状态鉴权首次实战</td><td>• 改用 <strong>Code→OpenID→Token</strong> 替代方案<br>• 研读JWT机制，设计 <strong>Bearer Token</strong> 请求头鉴权逻辑</td><td>✅ 掌握<strong>受限条件下的灵活架构能力</strong><br>✅ 理解<strong>无状态认证</strong>的设计优势与风险</td></tr><tr><td><strong>2. 农场交互核心模块</strong><br> - Grid九宫格布局<br> - 地块点击弹窗交互</td><td>• 动态弹窗与地块操作状态联动<br>• 多端样式适配</td><td>• 用 <strong>CSS变量+媒体查询</strong> 控制响应式<br>• <strong>事件委托</strong> 统一管理地块点击逻辑</td><td>✅ 强化 <strong>复杂交互前端设计能力</strong><br>✅ 提升 <strong>CSS3实战应用水平</strong></td></tr><tr><td><strong>3. 项目基建优化</strong><br> - 图床节省包体积<br> - 路由传参统一管理</td><td>• 图标库兼容性问题<br>• 路由跳转类型混乱</td><td>• <strong>源码调试+强制样式覆盖</strong> 解决依赖冲突<br>• 封装 <strong>路由工具函数</strong> 统一处理?type&#x3D;参数</td><td>✅ 学会 <strong>第三方库问题排查技巧</strong><br>✅ 养成 <strong>提前封装工具类</strong> 的习惯</td></tr></tbody></table><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><p><strong>1. 技术决策的价值</strong>：  </p><blockquote><p>选择JWT不仅解决了跨域问题，更让我意识到<strong>技术选型需服务业务场景</strong>——个人小程序无法用企业级登录方案时，用Token机制快速搭建安全认证体系是最优解。  </p></blockquote><p><strong>2. 限制催生创新</strong>：  </p><blockquote><p>微信API权限限制反而推动设计出更通用的 <strong>「Code+OpenID+DB」用户绑定流程</strong>，未来扩展手机号&#x2F;邮箱登录只需复用该流程。  </p></blockquote><p><strong>3. 技术债预警</strong>：  </p><blockquote><p>临时解决CSS兼容性的“hack手段”需在迭代中重构，<strong>开发效率与代码质量必须动态平衡</strong>。  </p></blockquote><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><p><strong>1. 前置设计更彻底</strong>：  </p><blockquote><ul><li>用<strong>流程图</strong>预先规划登录&#x2F;鉴权全链路（避免周四返工）  </li><li>订单系统数据库<strong>提前预留扩展字段</strong>（如<code>order_type</code>应对跳转传参）</li></ul></blockquote><p><strong>2. 技术方案分层验证</strong>：  </p><blockquote><ul><li>关键模块（如JWT）先写<strong>技术原型Demo</strong>再集成  </li><li>第三方库（uView）提前做<strong>兼容性测试矩阵</strong></li></ul></blockquote><p><strong>3. 自动化提效</strong>：  </p><blockquote><ul><li>用<strong>CI&#x2F;CD工具</strong>自动压缩图片上传图床  </li><li>编写<strong>路由配置生成脚本</strong>避免手写跳转参数</li></ul></blockquote><blockquote><p><strong>总结</strong>：未来需更注重<strong>前瞻性设计</strong>与<strong>可持续架构</strong>，让代码既能跑得快，更能跑得远。  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心目标：&lt;/strong&gt; 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周主要进展：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;项目启动与基础搭建 (周一)：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第二周：手撕验证码Session，给订单系统“安家落户”</title>
    <link href="https://www.zhengcookie.site/2025/07/27/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/"/>
    <id>https://www.zhengcookie.site/2025/07/27/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/</id>
    <published>2025-07-26T17:20:11.000Z</published>
    <updated>2025-10-01T04:54:48.565Z</updated>
    
    <content type="html"><![CDATA[<p><strong>核心任务：</strong> 独立完成车位项目订单系统后端接口、前端页面及数据库设计。</p><p><strong>本周开发纪实：</strong></p><ol><li><strong>周一：</strong> 复盘上周工作，为本周冲刺蓄力。</li><li><strong>周二：</strong> 承接新需求：<ul><li><strong>记住手机号：</strong> 提升用户体验。</li><li><strong>自定义弹窗：</strong> 实现灵活交互。</li><li><strong>价格需求：</strong> 核心业务逻辑。</li><li><strong>技术选型：</strong> 确定使用 <code>HttpSession</code> 存储 <code>手机号:验证码</code> 键值对，作为临时认证方案。</li></ul></li><li><strong>周三：</strong> 功能实现日<ul><li>完成“记住手机号” ✅</li><li>集成验证码登录 ✅ (<strong>注意点：</strong> 接口参数类型需严格匹配，<code>Session ID</code> 不一致会导致校验失败 - <em>已解决</em>)</li><li>实现协议勾选及自定义弹窗 ✅</li><li><strong>兼容性问题：</strong> 确认微信浏览器不支持 <code>datalist</code> 元素。 (<em>已找到替代方案-采用div来自定义下拉框</em>✅)</li></ul></li><li><strong>周四：</strong> 优化与设计<ul><li><strong>验证码生命周期优化：</strong> 将清除逻辑从固定5分钟 (<code>setInterval</code>)，升级为 <strong>登录成功即销毁</strong> 或 <strong>5分钟到期销毁</strong>，更贴合实际场景。</li><li><strong>数据库设计：</strong> 新增 <code>订单表 (order)</code>。<ul><li>关键设计：通过 <code>spot_id</code> 外键关联车位表。</li><li>决策说明：未直接复用车位表 <code>user_id</code> 字段 (因车位归属逻辑与订单用户逻辑存在差异)。</li></ul></li></ul></li><li><strong>周五：</strong> 数据库深化<ul><li>完善 <code>订单表</code> 结构，清晰记录交易信息。</li><li>设计 <code>优惠规则表 (discount_rule)</code>，定义车位关联的折扣类型与规则。 (<em>终于给优惠上了“户口本”</em>)</li></ul></li><li><strong>周六：</strong> 逻辑实现 &amp; 性能飞跃<ul><li>完成订单金额计算引擎，支持匹配优惠规则。</li><li><strong>接口性能重大优化：</strong><ul><li><strong>问题：</strong> 原有设计需两个接口拉取 <strong>全量用户车位数据</strong>，效率低下。</li><li><strong>方案：</strong> 重构为单一接口，精准查询 <strong>当前用户订单信息</strong>。</li><li><strong>成果：</strong> <strong>响应速度显著提升，数据库压力大幅降低。</strong> ( <em>成功给臃肿接口“瘦身”</em> )</li></ul></li></ul></li></ol><p><strong>本周总结与反思：</strong></p><ol><li><p><strong>主要成就与挑战：</strong></p><ul><li><strong>独立完成：</strong> 成功独立完成了车位及订单模块的后端接口开发、前端订单页面设计以及相关数据库设计。</li><li><strong>关键挑战：</strong> 如何在后端安全、有效地存储和验证用户专属的短信验证码，避免多用户共用同一验证码的风险。</li><li><strong>解决方案：</strong> 采用基于 <code>HttpSession</code> 的存储方案：<ul><li>Key: 用户手机号</li><li>Value: 对应的验证码</li><li>生命周期管理：用户成功登录后或 Session 超时（设置 5 分钟）自动销毁。</li></ul></li><li><strong>成长点：</strong> 深入理解了 <code>HttpSession</code> 机制在后端数据临时存储中的应用。</li></ul></li><li><p><strong>反思与改进点：</strong></p><ul><li><strong>需求理解：</strong> 未来开发前，应更深入地与客户&#x2F;产品沟通需求细节，以便更好地支持后续扩展性开发。</li><li><strong>数据库设计：</strong> 反思当前设计是否足够精细？例如 <code>user</code> 表可考虑增加 <code>user_type</code>、<code>created_at</code>、<code>last_login_at</code> 等字段增强功能性和可追溯性。</li><li><strong>设计文档：</strong> 意识到个人设计文档的详细度有待提高，需加强文档规范。</li></ul></li><li><p><strong>未来优化方向：</strong></p><ul><li><strong>沟通：</strong> 加强沟通，确保需求理解透彻，及时同步进展。</li><li><strong>数据库：</strong><ul><li>精细化核心表结构（如扩展 <code>user</code> 表字段）。</li><li>建立更清晰的表关系。</li></ul></li><li><strong>后端架构：</strong><ul><li>进行更清晰的分层设计（Controller &#x2F; Service &#x2F; Repository &#x2F; Entity）。</li><li>将车位管理、用户收藏等模块进行逻辑拆分，提高可维护性。</li></ul></li><li><strong>前端：</strong><ul><li>加强浏览器兼容性测试（如已发现的微信 <code>datalist</code> 问题）。</li><li>持续进行界面加载速度优化。</li></ul></li><li><strong>目标：</strong> 通过以上改进，全面提升开发效率、代码质量和系统健壮性，促进个人技术能力的成长。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;核心任务：&lt;/strong&gt; 独立完成车位项目订单系统后端接口、前端页面及数据库设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本周开发纪实：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;周一：&lt;/strong&gt; 复盘上周工作，为本周冲刺蓄力。&lt;/li</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>广漂码农第一周</title>
    <link href="https://www.zhengcookie.site/2025/07/19/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/"/>
    <id>https://www.zhengcookie.site/2025/07/19/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/</id>
    <published>2025-07-18T16:24:08.000Z</published>
    <updated>2025-10-01T04:54:48.554Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：新手村报到</strong><br>广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！</p><p><strong>Day 1: HTML星辰大海，打包是个误会？</strong><br>产品经理的原型图甩过来，先设计好文档没问题了再开干！祭出神器 <code>Cursor</code> + <code>Claude-3-Connect</code>，AI 辅助下吭哧吭哧撸完一堆纯 HTML 页面。AI 老哥贴心提示：“亲，打包上传哦~”。我信了！一头扎进打包工具的坑里折腾半天，汗流浃背。结果？<strong>发现特么的纯 HTML 直接扔服务器就能跑！</strong> 打包？打包了个寂寞！今日教训：AI 的话，也得结合上下文判断啊… (╯‵□′)╯︵┻━┻</p><p><strong>Day 2: SpringBoot 从零开始，CSDN 付费墙刺客！</strong><br>今日任务：搞后端 API 录入。第一次正经从零搭 <code>SpringBoot</code> 项目。IDEA 社区版 2023 有点坑，创建方式藏得深。CSDN 搜教程，好家伙，第一步就让装个插件，装完重启直接弹登录+<strong>付费订阅</strong>！真·知识付费刺客！果断弃坑。翻到良心文章指路：<a href="https://start.spring.io/">https://start.spring.io</a>，官方生成器真香！唯一小插曲：我 JDK 11 的“老环境”，伺候不了 SpringBoot 3 这位“新贵”，手动把版本和相关依赖<strong>降级到 2.x</strong>，世界终于清净。结论：CSDN 水文害人，官方文档&#x2F;工具永流传！</p><p><strong>Day 3: 宝塔端口玄学 &amp; “数字小孩”落户口！</strong><br>任务：把后端 API 部署上云服务器（宝塔面板）。一顿操作猛如虎：端口放行√，配置√。测试？<strong>死活连不上！</strong> CSDN 又跳出来“指点”：搞个随机域名数据库？一看还得付费固定域名？我信你个鬼！焦头烂额之际，<strong>猛然想起腾讯云还有个安全组！</strong> 火速添上端口规则，瞬间畅通！啊，这熟悉的安全感… (长舒一口气)</p><ul><li><strong>技术小悟：</strong> 跨域问题，不一定非搬 Nginx 大神。后端配个全局 <code>CORS</code>，指定好前端地址，也能愉快玩耍！省事！</li><li><strong>短信验证码插曲：</strong> 折腾半天接好了，但备案没过的号能发成功吗？心里有点虚，先当它行吧！</li></ul><p><strong>🌟 今日高光时刻 🌟</strong><br>今年我们团队的心血——<strong>“医疗健康问诊系统”</strong>，<strong>喜提国家版权局颁发的《计算机软件著作权登记证书》！</strong> 正式拥有了“<strong>数字小孩</strong>”的户口本！🎉</p><blockquote><p>感谢并肩作战的伙伴，<br>感谢每个改bug到天亮的自己。<br>——【医疗健康问诊系统】软著𝐆𝐞𝐭，未来可期！</p></blockquote><p><strong>Day 4: 切图仔の挣扎 vs 后端の从容（伪）</strong><br>实现一个“点击录入所有数据”的功能。纯 HTML + Vue 的组合，对我这个后端半吊子来说，操作 DOM 像在绣花… <strong>切图仔，属实不易！</strong> 顺带搞了车位收藏功能，数据库表设计修修补补好几回，勉强上线。<strong>结论：前端水太深，后端（的CRUD）才是俺的舒适区（暂时）！</strong></p><p><strong>Day 5: 数据库改改改，AI又救我狗命！</strong><br>搞车位收藏和抢购的多表查询。<strong>是的，我又双叒改数据库了！</strong> 最初设计图样图森破：想着一个车位记录，既能标记收藏又能记录谁买了，还绑 UserID。结果，“车位必须空闲”的规则和用户操作直接打架！卡壳半天，<strong>求助 AI 老哥</strong>，一语点醒：这设计有坑！火速重构，把状态、归属理清楚，功能终于跑通。<strong>教训：数据库设计，脑子得提前多绕几圈，少走弯路！</strong></p><p><strong>周记结尾：</strong><br>第一周，在疯狂踩坑、暴躁搜索、偶尔顿悟和一次巨大惊喜（软著！）中飞逝。从打包误会到安全组玄学，从被 CSDN 付费墙背刺到 AI 救场，从切图痛苦到改库狂魔… <strong>真实又酸爽！</strong> 见识了工具的便利与坑爹，体会了团队的温暖（和一起加班）。代码世界的大门刚推开一条缝，路还长，坑还多，但看着“数字小孩”上了户口，值了！下周，继续升级打怪！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：新手村报到&lt;/strong&gt;&lt;br&gt;广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Day 1: HTML星辰大海，打包是个误会？&lt;/stro</summary>
      
    
    
    
    <category term="工作心得" scheme="https://www.zhengcookie.site/categories/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="工作" scheme="https://www.zhengcookie.site/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链智能合约教程-医疗</title>
    <link href="https://www.zhengcookie.site/2025/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/"/>
    <id>https://www.zhengcookie.site/2025/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/</id>
    <published>2025-07-12T13:31:15.000Z</published>
    <updated>2025-10-01T04:54:48.513Z</updated>
    
    <content type="html"><![CDATA[<p>源码</p><p> <a href="https://zhengcookie.github.io/file/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/medical/%E5%8C%BB%E7%96%97/Main.sol">Main.sol</a> </p><p>以下是智能合约代码的逐段解析，按功能模块分类说明：</p><hr><h3 id="1-患者信息管理"><a href="#1-患者信息管理" class="headerlink" title="1. 患者信息管理"></a><strong>1. 患者信息管理</strong></h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Sick &#123;</span><br><span class="line">    address accountAddress; // 患者钱包地址</span><br><span class="line">    string name;            // 姓名</span><br><span class="line">    string sex;             // 性别</span><br><span class="line">    uint256 age;            // 年龄</span><br><span class="line">    uint256 id;             // 身份证号(主键)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint256 =&gt; Sick) public sicks;  // 身份证号→患者信息的映射</span><br><span class="line">uint256[] public sickIds;               // 所有患者身份证号列表</span><br></pre></td></tr></table></figure><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 创建患者档案 (需校验参数有效性)</span><br><span class="line">function createSick(...) public &#123;</span><br><span class="line">    // 参数校验...</span><br><span class="line">    sicks[identityNumber] = Sick(...);  // 存储信息</span><br><span class="line">    sickIds.push(identityNumber);       // 记录ID</span><br><span class="line">    emit SickCreated(...);              // 触发事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按身份证查询患者</span><br><span class="line">function getSickByIdentityNumber(...) public view returns (...) &#123;</span><br><span class="line">    require(sick.accountAddress != address(0)); // 校验存在性</span><br><span class="line">    return (sick.accountAddress, ...); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按钱包地址查询患者</span><br><span class="line">function getSickByAccountAddress(...) public view returns (...) &#123;</span><br><span class="line">    uint256 sickID = findSickIDByAccountAddress(accountAddr); // 内部遍历查找</span><br><span class="line">    return (sick.name, ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：地址→ID映射</span><br><span class="line">function findSickIDByAccountAddress(...) internal view returns (...) &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; sickIds.length; i++) &#123;</span><br><span class="line">        if (sicks[sickID].accountAddress == accountAddr) return sickID;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查患者是否存在</span><br><span class="line">function isSickExist(uint256 sickID) public view returns (bool) &#123;</span><br><span class="line">    return sicks[sickID].accountAddress != address(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取所有患者ID列表</span><br><span class="line">function getSicksList() public view returns (uint256[] memory) &#123;</span><br><span class="line">    return sickIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-预约挂号系统"><a href="#2-预约挂号系统" class="headerlink" title="2. 预约挂号系统"></a><strong>2. 预约挂号系统</strong></h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Appointment &#123;</span><br><span class="line">    string hospitalName; // 医院名称</span><br><span class="line">    string department;   // 科室名称</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint256 =&gt; Appointment) public sickAppointment; // 患者ID→预约信息</span><br></pre></td></tr></table></figure><h4 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建预约</span><br><span class="line">function createAppointment(...) public &#123;</span><br><span class="line">    require(isSickExist(sickID));          // 患者必须存在</span><br><span class="line">    sickAppointment[sickID] = Appointment(...); // 存储预约</span><br><span class="line">    emit AppointmentCreated(...);           // 触发事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询预约</span><br><span class="line">function getSickAppointment(...) public view returns (...) &#123;</span><br><span class="line">    require(bytes(appointment.hospitalName).length &gt; 0); // 校验存在性</span><br><span class="line">    return (appointment.hospitalName, ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除预约</span><br><span class="line">function deleteSickAppointment(uint256 sickID) public &#123;</span><br><span class="line">    delete sickAppointment[sickID];  // 清除预约记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-电子病历管理"><a href="#3-电子病历管理" class="headerlink" title="3. 电子病历管理"></a><strong>3. 电子病历管理</strong></h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct MedicalRecord &#123;</span><br><span class="line">    uint256 sickID;               // 患者ID</span><br><span class="line">    string hospitalName;          // 医院</span><br><span class="line">    string department;            // 科室</span><br><span class="line">    string doctorName;            // 医生姓名</span><br><span class="line">    string registrationInfo;      // 挂号信息</span><br><span class="line">    string pastMedicalHistory;    // 既往病史</span><br><span class="line">    string currentMedicalHistory; // 现病史</span><br><span class="line">    string isFilled;              // 是否完成(&quot;Yes&quot;/&quot;No&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据存储-2"><a href="#数据存储-2" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint256 =&gt; MedicalRecord) public sickMedicalRecords; // 患者ID→病历</span><br></pre></td></tr></table></figure><h4 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 创建空白病历</span><br><span class="line">function createMedicalRecord(...) public &#123;</span><br><span class="line">    sickMedicalRecords[sickID] = MedicalRecord(...);</span><br><span class="line">    emit MedicalRecordCreated(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 授权医生访问病历</span><br><span class="line">function authorizeDoctor(...) public &#123;</span><br><span class="line">    if (病历不存在) createMedicalRecord(...); // 自动创建空病历</span><br><span class="line">    sickMedicalRecords[sickID].doctorName = doctorName; // 设置医生</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新病历内容</span><br><span class="line">function updateMedicalRecord(...) public &#123;</span><br><span class="line">    medicalRecord.hospitalName = hospitalName; </span><br><span class="line">    medicalRecord.pastMedicalHistory = pastMedicalHistory; // 更新病史等</span><br><span class="line">    emit MedicalRecordUpdated(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询完整病历</span><br><span class="line">function getMedicalRecordByIdentityNumber(...) public view returns (...) &#123;</span><br><span class="line">    return (medicalRecord.hospitalName, ...); // 返回所有病历字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询特定科室的既往病史</span><br><span class="line">function getPastMedicalHistory(...) public view returns (...) &#123;</span><br><span class="line">    require(keccak256(科室)==keccak256(目标科室)); // 严格科室匹配</span><br><span class="line">    return medicalRecord.pastMedicalHistory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标记病历完成状态</span><br><span class="line">function endMedicalConsultation(...) public &#123;</span><br><span class="line">    medicalRecord.isFilled = mrtype; // 设置&quot;Yes&quot;/&quot;No&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查病历是否完成</span><br><span class="line">function isMedicalRecordFilled(...) public view returns (bool) &#123;</span><br><span class="line">    return keccak256(medicalRecord.isFilled) == keccak256(&quot;Yes&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约完整实现了患者档案管理、挂号预约、电子病历三大核心功能，构建了医疗数据上链的基础框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://zhengcookie.github.io/file/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/medical/%E5%8C%BB</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链赛题智能合约" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B5%9B%E9%A2%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://www.zhengcookie.site/2025/07/12/CSS/"/>
    <id>https://www.zhengcookie.site/2025/07/12/CSS/</id>
    <published>2025-07-11T20:10:39.000Z</published>
    <updated>2025-10-01T04:54:48.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>.classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref&#x3D;“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>内联样式：1000；</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>　（2）<strong>inline：</strong>元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者****区别如下：</strong></p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是****继承属性</strong></p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;第一章：&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;Hot!&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png" alt="img"></p><p>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong>如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p><p><strong>为什么要使用它们？</strong> </p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- link元素中的<span class="variable constant_">CSS</span>媒体查询 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span></span> </span><br><span class="line">&lt;!-- 样式表中的<span class="variable constant_">CSS</span>媒体查询 --&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">display</span>: none; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125; </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-<span class="attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-<span class="selector-tag">line</span>-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw&#x2F;vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw&#x2F;vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw&#x2F;vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;     <span class="comment">/* 自身 height 的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;    <span class="comment">/* 自身 width 的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位-1"><a href="#1-常见的CSS布局单位-1" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw&#x2F;vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw&#x2F;vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw&#x2F;vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景-1"><a href="#2-px、em、rem的区别及使用场景-1" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现-1"><a href="#3-两栏布局的实现-1" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-三栏布局的实现-1"><a href="#4-三栏布局的实现-1" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现-1"><a href="#5-水平垂直居中的实现-1" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;     <span class="comment">/* 自身 height 的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;    <span class="comment">/* 自身 width 的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？-1"><a href="#6-如何根据设计稿进行移动端适配？-1" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景-1"><a href="#7-对Flex布局的理解及其使用场景-1" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong></p><p>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="9-响应式设计的概念及基本原理"><a href="#9-响应式设计的概念及基本原理" class="headerlink" title="9. 响应式设计的概念及基本原理"></a>9. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *<span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级非定位后代元素。</p><p>（4）浮动盒：非定位浮动元素。</p><p>（5）行内盒：文档流内行内级非定位后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong>元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png" alt="img"></p><ul><li><strong>fixed：</strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png" alt="img"></p><ul><li><strong>absolute：</strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png" alt="img"></p><p>所以可以根据border这个特性来绘制三角形：</p><p><strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png" alt="img"></p><p><strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png" alt="img"></p><p><strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png" alt="img"></p><p><strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png" alt="img"></p><p><strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png" alt="img"></p><p>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png" alt="img"></p><p><strong>（1）实现圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span>/<span class="number">150px</span>; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">100%</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">50px</span> <span class="number">150px</span>; </span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">50px</span> <span class="number">150px</span>; </span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">50px</span> <span class="number">150px</span>; </span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">50px</span> <span class="number">150px</span>; </span><br></pre></td></tr></table></figure><p>为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。</p><p><strong>（2）实现半圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用元素的margin&#x2F;padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;trapezoid&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>（1）实现一个直角梯形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trapezoid</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1630773730069-a1bf7073-14ba-4665-9e5e-cf0aa0722235.png" alt="img"></p><p>（2）实现一个等腰梯形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trapezoid</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">40px</span> <span class="number">100px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>:none solid solid;</span><br><span class="line">  <span class="attribute">border-color</span>:transparent transparent red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1630773825580-c1821c13-4513-4462-9a13-73ad4a3ef6e6.png" alt="img"></p><h3 id="5-画一条0-5px的线"><a href="#5-画一条0-5px的线" class="headerlink" title="5. 画一条0.5px的线"></a>5. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-<span class="attribute">scale</span>=<span class="number">0.5</span>, minimum-<span class="attribute">scale</span>=<span class="number">0.5</span>, maximum-<span class="attribute">scale</span>=<span class="number">0.5</span>&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="6-设置小于12px的字体"><a href="#6-设置小于12px的字体" class="headerlink" title="6. 设置小于12px的字体"></a>6. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="7-如何解决-1px-问题？"><a href="#7-如何解决-1px-问题？" class="headerlink" title="7. 如何解决 1px 问题？"></a>7. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6&#x2F;7&#x2F;8 这系列的机型，输出的结果就是2：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS.assets/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.png" alt="img"></p><p>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。</p><p><strong>解决****1px 问题的三种思路：</strong></p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接把 1px 改成 1&#x2F;devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：<strong><strong>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的</strong></strong>宽和高都设置为目标元素的两倍，border值设为 1px。<strong><strong>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一</strong></strong>，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1&#x2F;2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、CSS基础&quot;&gt;&lt;a href=&quot;#一、CSS基础&quot; class=&quot;headerlink&quot; title=&quot;一、CSS基础&quot;&gt;&lt;/a&gt;一、CSS基础&lt;/h2&gt;&lt;h3 id=&quot;1-CSS选择器及其优先级&quot;&gt;&lt;a href=&quot;#1-CSS选择器及其优先级&quot; class</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="css" scheme="https://www.zhengcookie.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://www.zhengcookie.site/2025/07/12/HTML/"/>
    <id>https://www.zhengcookie.site/2025/07/12/HTML/</id>
    <published>2025-07-11T19:55:23.000Z</published>
    <updated>2025-10-01T04:54:48.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p><p>（1）src</p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =”js.<span class="property">js</span>”&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p><p>（2）href</p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=”common.<span class="property">css</span>” rel=”stylesheet”/&gt;</span><br></pre></td></tr></table></figure><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h2><p><strong>语义化是指****根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure><h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义****来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h2 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/HTML.assets/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="img"></p><p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h2 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li><li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop&#x3D;‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">poster</span>=<span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签</p><p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.flv&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/flv&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.mp4&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li><p>placeholder ：提示信息</p></li><li><p>autofocus ：自动获取焦点</p></li><li><p>autocomplete&#x3D;“on” 或者 autocomplete&#x3D;“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li><p>pattern&#x3D;” “ 里面写入想要的正则模式，例如手机号patte&#x3D;”^(+86)?\d{10}$”</p></li><li><p>multiple：可以选择多个文件或者多个邮箱</p></li><li><p>form&#x3D;” form表单的ID”</p></li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li><p>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</p></li><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high&#x2F;low：规定被视作高&#x2F;低的范围</li><li>max&#x2F;min：规定最大&#x2F;小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong></p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h2 id="9-对-web-worker-的理解"><a href="#9-对-web-worker-的理解" class="headerlink" title="9. 对 web worker 的理解"></a>9. 对 web worker 的理解</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong></p><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong></p><p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 </p><p>其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;1-src和href的区别&quot;&gt;&lt;a href=&quot;#1-src和href的区别&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="html" scheme="https://www.zhengcookie.site/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="https://www.zhengcookie.site/2025/07/12/javascript/"/>
    <id>https://www.zhengcookie.site/2025/07/12/javascript/</id>
    <published>2025-07-11T19:33:56.000Z</published>
    <updated>2025-10-01T04:54:48.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是****判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)</span><br></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。</span><br><span class="line"><span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line"><span class="number">100</span>: string   - 当前存储的数据指向一个字符串。</span><br><span class="line"><span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">  <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numberepsilon</span>(<span class="params">arg1,arg2</span>)&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(arg1 - arg2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numberepsilon</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-其他值到字符串的转换规则？"><a href="#11-其他值到字符串的转换规则？" class="headerlink" title="11. 其他值到字符串的转换规则？"></a>11. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="12-其他值到数字值的转换规则？"><a href="#12-其他值到数字值的转换规则？" class="headerlink" title="12. 其他值到数字值的转换规则？"></a>12. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="13-其他值到布尔类型的值的转换规则？"><a href="#13-其他值到布尔类型的值的转换规则？" class="headerlink" title="13. 其他值到布尔类型的值的转换规则？"></a>13. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p><p>• undefined</p><p>• null</p><p>• false</p><p>• +0、-0 和 NaN</p><p>• “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#15-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="15. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>15. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h3><ul><li>使用双等号（&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（&#x3D;&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-JavaScript-中如何进行隐式类型转换？"><a href="#17-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="17. JavaScript 中如何进行隐式类型转换？"></a>17. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@obj</span> 需要转换的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> 期望的结果类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ToPrimitive</span>(obj,type)</span><br></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>**type**</code><strong>为</strong><code>**number**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>**type**</code><strong>为</strong><code>**string**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">objToNumber</span> = value =&gt; <span class="title class_">Number</span>(value.<span class="title function_">valueOf</span>().<span class="title function_">toString</span>())</span><br><span class="line"><span class="title function_">objToNumber</span>([]) === <span class="number">0</span></span><br><span class="line"><span class="title function_">objToNumber</span>(&#123;&#125;) === <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>**+**</code><strong>操作符</strong><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"> <span class="number">1</span> + <span class="literal">false</span> <span class="comment">// 1 </span></span><br><span class="line"> <span class="number">1</span> + <span class="title class_">Symbol</span>() <span class="comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"> <span class="string">&#x27;1&#x27;</span> + <span class="literal">false</span> <span class="comment">// &#x27;1false&#x27;</span></span><br><span class="line"> <span class="literal">false</span> + <span class="literal">true</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol><li><code>**-**</code><strong>、</strong><code>*****</code><strong>、</strong><code>**\**</code><strong>操作符</strong><code>NaN</code>也是一个数字</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**==**</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span> <span class="comment">// &#x27;0&#x27;转为number为0</span></span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**&lt;**</code><strong>和</strong><code>**&gt;**</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">valueOf</span>() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;，现在是一个字符串了</span></span><br><span class="line"><span class="title class_">Number</span>(a.<span class="title function_">toString</span>()) <span class="comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span></span><br><span class="line"><span class="title class_">NaN</span> &gt; <span class="number">2</span> <span class="comment">//false，得出比较结果</span></span><br></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">valueOf</span>() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">b.<span class="title function_">valueOf</span>() <span class="comment">// 同理</span></span><br><span class="line">b.<span class="title function_">toString</span>() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong>块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">a</span>();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.<span class="title function_">b</span>();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">a</span>()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">b</span>()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fun1</span>();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">apply</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">bind</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  <span class="title function_">getArrow</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">   <span class="attr">getArrow</span>: <span class="keyword">function</span> <span class="title function_">getArrow</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">var</span> _this = <span class="variable language_">this</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对****对象实例的拷贝属于浅拷贝</strong>。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>])</span><br><span class="line"><span class="comment">// 1 [2, 3, 4] 5</span></span><br></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];</span><br><span class="line"><span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>**Math**</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h3 id="7-对对象与数组的解构的理解"><a href="#7-对对象与数组的解构的理解" class="headerlink" title="7. 对对象与数组的解构的理解"></a>7. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p><p><strong>1）数组的解构</strong></p><p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1616076913177-30749c84-8254-4543-a3e7-c2fb488a4228.png" alt="img"></p><p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1616076913186-eb8be693-9b19-48e5-bda5-9dbd7cc77ea6.png" alt="img"></p><p><strong>2）对象的解构</strong></p><p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1616076913314-53687a23-07ef-4a01-a78a-a0304f2b2826.png" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br></pre></td></tr></table></figure><h3 id="8-如何提取高度嵌套的对象里的指定属性？"><a href="#8-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="8. 如何提取高度嵌套的对象里的指定属性？"></a>8. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = school</span><br><span class="line"><span class="keyword">const</span> &#123; stu &#125; = classes</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = stu</span><br><span class="line">name <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="9-对-rest-参数的理解"><a href="#9-对-rest-参数的理解" class="headerlink" title="9. 对 rest 参数的理解"></a>9. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mutiple</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mutiple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mutiple</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mutiple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="10-ES6中模板语法与字符串处理"><a href="#10-ES6中模板语法与字符串处理" class="headerlink" title="10. ES6中模板语法与字符串处理"></a>10. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 正确输出，不存在报错</span></span><br></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(finalString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><ul><li><p><strong>存在性判定</strong>：在过去，当判断一个字符&#x2F;字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p></li><li><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">includes</span>(son) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><ul><li><strong>startsWith</strong>：判断字符串是否以某个&#x2F;某串字符开头：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;xixi&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><ul><li><strong>endsWith</strong>：判断字符串是否以某个&#x2F;某串字符结尾：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">  father.<span class="title function_">endsWith</span>(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.<span class="title function_">repeat</span>(<span class="number">3</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在</p><p>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p><p>例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 </p><p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong>给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong>动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong>设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>&#96;</td><td>&#96;</td><td>或</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table><h4 id="1-按位与运算符（-）"><a href="#1-按位与运算符（-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。</p><p>例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">   <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line"> = <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure><p>因此，3|5的值为7。</p><p>注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><p>因此，3^5的值为6。</p><p>异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p>运算规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p><p>例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span></span><br><span class="line">= <span class="number">1111</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p><p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span></span><br><span class="line">   = <span class="number">1111</span> <span class="number">1001</span></span><br><span class="line">反码：<span class="number">1000</span> <span class="number">0110</span></span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（"><a href="#5-左移运算符（" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p><p>设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。</p><p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-）"><a href="#6-右移运算符（-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><p>例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。</p><p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。</p><p>例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>) </span><br><span class="line">  arrArgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...<span class="variable language_">arguments</span>] </span><br><span class="line">    arrArgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p></li><li><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong></p><p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别： </p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li></ul><p>ES6 Module和CommonJS模块的共同点： </p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong>for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table><p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">__proto__</span>  <span class="comment">// Person.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>  <span class="comment">// Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">__proto__</span> <span class="comment">//Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">constructor</span> <span class="comment">// Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1605247722640-5bcb9156-a8b4-4d7c-83d7-9ff80930e1de.jpeg" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">iterate</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">           res.<span class="title function_">push</span>(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文&#x2F;作用域链&#x2F;闭包"></a>五、执行上下文&#x2F;作用域链&#x2F;闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">B</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>()</span><br><span class="line"><span class="title function_">B</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  ;(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">j</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong></p><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>**eval**</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">  <span class="title function_">second</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">first</span>();</span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line"><span class="comment">//先执行second(),在执行first()</span></span><br></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong></p><p>此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this&#x2F;call&#x2F;apply&#x2F;bind"></a>六、this&#x2F;call&#x2F;apply&#x2F;bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async&#x2F;Await 的区别"></a>2. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)<span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)<span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;)<span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async&#x2F;await"></a>（3）async&#x2F;await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func1</span>())</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1604021075237-8249a8df-3a28-4bca-9f22-02923aba8618.png" alt="img"></p><p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">func1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">// 30</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong></p><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>**new Promise()**</code><strong>来创建promise对象，但是也可以使用</strong><code>**promise.resolve**</code><strong>和</strong> <code>**promise.reject**</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">11</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 打印出11</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">   <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;我错了，请原谅俺！！&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testPromise</span>(<span class="params">ready</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;No thanks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="title function_">testPromise</span>(<span class="literal">true</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p><p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;first&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;second&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;second&#x27;</span>).<span class="title function_">success</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="comment">//结果为：[1,2,3] </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">reject</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="comment">//结果：2</span></span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,<span class="title function_">timeOutPromise</span>(<span class="number">5000</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">url</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">error,data</span>)&#123;</span><br><span class="line">      error &amp;&amp; <span class="title function_">reject</span>(error)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;./a.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data) </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">read</span>(data)  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）****Promise.all</strong></p><p><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,<span class="title function_">timeOutPromise</span>(<span class="number">5000</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async&#x2F;await 的理解"></a>7.  对async&#x2F;await 的理解</h3><p>async&#x2F;await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">testAsy</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/javascript.assets/1605099411873-d2eac25a-5d8c-4586-bc36-769bce79010e.png" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">testAsy</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)   <span class="comment">// hello world</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> <span class="title function_">getSomething</span>();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> <span class="title function_">testAsync</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testAsy</span>(<span class="params">x</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">resolve</span>(x);</span><br><span class="line">     &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAwt</span>(<span class="params"></span>)&#123;    </span><br><span class="line">  <span class="keyword">let</span> result =  <span class="keyword">await</span> <span class="title function_">testAsy</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);    <span class="comment">// 3秒钟之后出现hello world</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cuger&#x27;</span>)   <span class="comment">// 3秒钟之后出现cug</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testAwt</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cug&#x27;</span>)  <span class="comment">//立即输出cug</span></span><br></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async&#x2F;await的优势"></a>9.  async&#x2F;await的优势</h3><p>单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">takeLongTime</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step3</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">takeLongTime</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="title function_">step1</span>(time1)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">time2</span> =&gt;</span> <span class="title function_">step2</span>(time2))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">time3</span> =&gt;</span> <span class="title function_">step3</span>(time3))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doIt</span>();</span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> &#x3D; <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async&#x2F;await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> <span class="title function_">step1</span>(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> <span class="title function_">step2</span>(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">step3</span>(time3);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doIt</span>();</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async&#x2F;await对比Promise的优势"></a>10. async&#x2F;await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 </li><li>Promise传递中间值⾮常麻烦，⽽async&#x2F;await⼏乎是同步的写法，⾮常优雅 </li><li>错误处理友好，async&#x2F;await可以⽤成熟的try&#x2F;catch，Promise的错误捕获⾮常冗余 </li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p><p><strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.<span class="property">a</span> = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.<span class="property">a</span> = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.<span class="property">a</span> =  <span class="literal">null</span></span><br><span class="line"> obj2.<span class="property">a</span> =  <span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>**object**</code><strong>进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据类型&quot;&gt;&lt;a href=&quot;#一、数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型&quot;&gt;&lt;/a&gt;一、数据类型&lt;/h2&gt;&lt;h3 id=&quot;1-JavaScript有哪些数据类型，它们的区别？&quot;&gt;&lt;a href=&quot;#1-JavaScrip</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="javascript" scheme="https://www.zhengcookie.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>杂项</title>
    <link href="https://www.zhengcookie.site/2025/07/11/%E6%9D%82%E9%A1%B9/"/>
    <id>https://www.zhengcookie.site/2025/07/11/%E6%9D%82%E9%A1%B9/</id>
    <published>2025-07-11T13:48:34.000Z</published>
    <updated>2025-10-01T04:54:48.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="存储storage-中的状态变量储存结构"><a href="#存储storage-中的状态变量储存结构" class="headerlink" title="存储storage 中的状态变量储存结构"></a>存储storage 中的状态变量储存结构</h2><p>静态大小的变量（除 映射mapping 和动态数组之外的所有类型）都从位置 <code>0</code> 开始连续放置在 存储storage 中。如果可能的话，存储需求少于 32 字节的多个变量会被打包到一个 存储插槽storage slot 中，规则如下：</p><ul><li>存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。</li><li>基本类型仅使用存储它们所需的字节。</li><li>如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。</li><li>结构（struct）和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。</li></ul><p>警告</p><p>使用小于 32 字节的元素时，你的合约的 gas 使用量可能高于使用 32 字节的元素时。这是因为 以太坊虚拟机Ethereum Virtual Machine(EVM) 每次会操作 32 个字节， 所以如果元素比 32 字节小，以太坊虚拟机Ethereum Virtual Machine(EVM) 必须使用更多的操作才能将其大小缩减到到所需的大小。</p><p>仅当你处理 存储插槽storage slot 中的值时候，使用缩减大小的参数才是有益的。因为编译器会将多个元素打包到一个 存储插槽storage slot 中， 从而将多个读或写合并到一次对存储的操作中。而在处理函数参数或 内存memory 中的值时，因为编译器不会打包这些值，所以没有什么益处。</p><p>最后，为了允许 以太坊虚拟机Ethereum Virtual Machine(EVM) 对此进行优化，请确保你对 存储storage 中的变量和 <code>struct</code> 成员的书写顺序允许它们被紧密地打包。 例如，按照 <code>uint128，uint128，uint256</code> 的顺序声明你的存储变量，而不是 <code>uint128，uint256，uint128</code>， 因为前者只占用两个 存储插槽storage slot，而后者将占用三个。</p><p>结构和数组中的元素都是顺序存储的，就像它们被明确给定的那样。</p><p>由于 映射mapping 和动态数组的大小是不可预知的，所以我们使用 Keccak-256 哈希计算来找到具体数值或数组数据的起始位置。 这些起始位置本身的数值总是会占满堆栈插槽。</p><p>映射mapping 或动态数组本身会根据上述规则来在某个位置 <code>p</code> 处占用一个（未填充的）存储中的插槽（或递归地将该规则应用到 映射mapping 的 映射mapping 或数组的数组）。 对于动态数组，此插槽中会存储数组中元素的数量（字节数组和字符串在这里是一个例外，见下文）。对于 映射mapping ，该插槽未被使用（但它仍是需要的， 以使两个相同的 映射mapping 在彼此之后会使用不同的散列分布）。数组的数据会位于 <code>keccak256(p)</code>； 映射mapping 中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值又是一个非基本类型，则通过添加 <code>keccak256(k . p)</code> 作为偏移量来找到位置。</p><p>如果 <code>bytes</code> 和 <code>string</code> 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。如果数据长度超出 31 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</p><p>所以对于以下合约片段:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data[4][9].b</code> 的位置将是 <code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1</code>。</p><h2 id="内存memory-中的存储结构"><a href="#内存memory-中的存储结构" class="headerlink" title="内存memory 中的存储结构"></a>内存memory 中的存储结构</h2><p>Solidity 保留了 4 个 32 字节的插槽（slot）：</p><ul><li><code>0x00</code> - <code>0x3f</code>：用于保存方法（函数）哈希的临时空间</li><li><code>0x40</code> - <code>0x5f</code>：当前已分配的 内存memory 大小（又名，空闲 内存memory 指针）</li><li><code>0x60</code> - <code>0x7f</code>：0 值插槽</li></ul><p>临时空间可以在语句之间使用（即在内联汇编之中）。0 值插槽则用来对动态内存数组进行初始化，且永远不会写入数据（因而可用的初始内存指针为 <code>0x80</code>）。</p><p>Solidity 总会把新对象保存在空闲 内存memory 指针的位置，所以这段内存实际上从来不会空闲（在未来可能会修改这个机制）。</p><p>警告</p><p>Solidity 中有一些操作需要大于 64 字节的临时内存区域，因此这种数据无法保存到临时空间里。它们将被放置在空闲内存指向的位置，但由于这种数据的生命周期较短，这个指针不会即时更新。这部分内存可能会被清零也可能不会。所以我们不应该期望这些所谓的空闲内存总会被清零。</p><p>尽管使用 <code>msize</code> 来到达非零内存区域是个好主意，然而非临时性地使用这样的指针，而不更新可用内存指针也会产生有害的结果。</p><h2 id="调用数据存储结构"><a href="#调用数据存储结构" class="headerlink" title="调用数据存储结构"></a>调用数据存储结构</h2><p>当从一个账户调用已部署的 Solidity 合约时，调用数据的格式被认为会遵循 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi">ABI 说明</a>。 根据 ABI 说明的规定，参数需要被整理为 32 字节的倍数。而内部函数调用会使用不同规则。</p><h2 id="内部机制-清理变量"><a href="#内部机制-清理变量" class="headerlink" title="内部机制 - 清理变量"></a>内部机制 - 清理变量</h2><p>如果一个数值不足 256 位，那么在某些情况下，不足的位必须被清除。 Solidity 编译器设计用于在执行任何操作之前清除这些剩余位中可能会造成不利影响的潜在垃圾。 例如，因为 内存memory 中的内容可以用于计算散列或作为消息调用的数据发送，所以在向 内存memory 写入数值之前，需要清除剩余的位。 同样，在向 存储storage 中保存数据之前，剩余的位也需要清除，否则就会看到被混淆的数值。</p><p>另一方面，如果接下来的操作不会被影响，那我们就不用清除这些位的数据。例如，因为任何非零值都会被 <code>JUMPI</code> 指令视为 <code>true</code>， 所以在布尔数据用做 <code>JUMPI</code> 的条件之前，我们就不用清除它们。</p><p>除了以上设计原理之外，Solidity 编译器在把输入数据加载到堆栈时会对它们进行清除剩余位的处理。</p><p>不同的数据类型有不同的清除无效值的规则：</p><table><thead><tr><th>类型</th><th>合法数值</th><th>无效值会导致</th></tr></thead><tbody><tr><td>n 个成员的 enum</td><td>0 到 n - 1</td><td>exception</td></tr><tr><td>bool</td><td>0 或 1</td><td>1</td></tr><tr><td>signed integers</td><td>以符号开头的 字（32字节）</td><td>目前会直接打包； 未来会抛出 exception</td></tr><tr><td>unsigned integers</td><td>高位补 0</td><td>目前会直接打包； 未来会抛出 exception</td></tr></tbody></table><h2 id="内部机制-优化器"><a href="#内部机制-优化器" class="headerlink" title="内部机制 - 优化器"></a>内部机制 - 优化器</h2><p>Solidity 优化器是在汇编语言级别工作的，所以它可以并且也被其他语言所使用。它通过 <code>JUMP</code> 和 <code>JUMPDEST</code> 语句将指令集序列分割为基础的代码块。在这些代码块内的指令集会被分析，并且对堆栈、内存或存储的每个修改都会被记录为表达式，这些表达式由一个指令和基本上是指向其他表达式的参数列表所组成。现在，主要的想法就是找到始终相等的表达式（在每个输入上）并将它们组合到一个表达式类中。优化器首先尝试在已知的表达式列表中查找每个新表达式。如果这不起作用，表达式会以 <code>constant + constant = sum_of_constants</code> 或 <code>X * 1 = X</code> 这样的规则进行简化。由于这是递归完成的，所以在我们知道第二个因子是一个更复杂的表达式，且此表达式总是等于 1 的情况下，也可以应用后一个规则。对存储和内存上某个具体位置的修改必须删除有关存储和内存位置的认知，这里边的区别并不为人所知：如果我们先在 x 位置写入，然后在 y 位置写入，且都是输入变量，则第二个可能会覆盖第一个，所以我们实际上并不知道在写入到 y 位置之后在 x 位置存储了什么。另一方面，如果对表达式 x - y 的简化，其结果为非零常数，那么我们知道我们可以保持关于 x 位置存储内容的认知。</p><p>在这个过程结束时，我们会知道最后哪些表达式必须在栈上，并且会得到一个修改内存和存储的列表。该信息与基本代码块一起存储并用来链接它们。此外，关于栈、存储和内存的配置信息会被转发到下一个代码块。如果我们知道所有 <code>JUMP</code> 和 <code>JUMPI</code> 指令的目标，我们就可以构建一个完整的程序流程图。 如果只有一个我们不知道的目标（原则上可能发生，跳转目标可以基于输入来计算），我们必须消除关于代码块输入状态的所有信息，因为它可能是未知的 <code>JUMP</code> 目标。如果一个 <code>JUMPI</code> 的条件等于一个常量，它将被转换为无条件跳转。</p><p>作为最后一步，每个块中的代码都会被完全重新生成。然后会从代码块的结尾处在栈上的表达式开始创建依赖关系图，且不是该图组成部分的每个操作实质上都会被丢弃。现在，生成的代码将按照原始代码中的顺序对内存和存储进行修改（舍弃不需要的修改），最终，生成需要在栈中的当前位置保存的所有值。</p><p>这些步骤适用于每个基本代码块，如果代码块较小，则新生成的代码将用作替换。如果一个基本代码块在 <code>JUMPI</code> 处被分割，且在分析过程中被评估为一个常数，则会根据常量的值来替换 <code>JUMPI</code>，因此，类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 7;</span><br><span class="line">data[7] = 9;</span><br><span class="line">if (data[x] != x + 2)</span><br><span class="line">  return 2;</span><br><span class="line">else</span><br><span class="line">  return 1;</span><br></pre></td></tr></table></figure><p>的代码也就被简化地编译为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[7] = 9;</span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>即使原始代码中包含一个跳转。</p><h2 id="源代码映射"><a href="#源代码映射" class="headerlink" title="源代码映射"></a>源代码映射</h2><p>作为 AST 输出的一部分，编译器提供 AST 中相应节点所代表的源代码范围。这可以用于多种用途，比如从用于报告错误的 AST 静态分析工具到可以突出显示局部变量及其用途的调试工具。</p><p>此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。对于在字节码级别上运行的静态分析工具以及在调试器中显示源代码中的当前位置或处理断点，这都是同样重要的。</p><p>这两种源映射都使用整数标识符来引用源文件。这些是通常称为 <code>“sourceList”</code> 的源文件列表的常规数组索引，它们是 combined-json 和 json &#x2F; npm 编译器输出的一部分。</p><p>注解</p><p>在指令没有与任何特定的代码文件关联的情况下，源代码映射会将 <code>-1</code> 赋值给一个整数标识符。这会在字节码阶段发生，源于由编译器生成的内联汇编语句。</p><p>AST 内的源代码映射使用以下表示法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure><p>其中，<code>s</code> 是源代码文件中范围起始处的字节偏移量，<code>l</code> 是源代码范围的长度（以字节为单位），<code>f</code> 是上述源代码索引。</p><p>针对字节码的源代码映射的编码方式更加复杂：它是由 <code>;</code> 分隔的 <code>s:l:f:j</code> 列表。每个元素都对应一条指令，即不能使用字节偏移量，但必须使用指令偏移量（push 指令长于一个字节）。字段 <code>s</code>，<code>l</code> 和 <code>f</code> 如上所述，<code>j</code> 可以是 <code>i</code>，<code>o</code> 或 <code>-</code>，表示一个跳转指令是否进入一个函数、是否从一个函数返回或者是否是一个常规跳转的一部分，例如一个循环。</p><p>为了压缩这些源代码映射，特别是对字节码的映射，我们将使用以下规则：</p><blockquote><ul><li>如果一个字段为空，则使用前一个元素中对应位置的值。</li><li>如果缺少 <code>:</code>，则后续所有字段都被视为空。</li></ul></blockquote><p>这意味着以下的源代码映射是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure><h2 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h2><ul><li>可以使用 <code>delete</code> 来删除数组中的所有元素。</li><li>对 struct 中的元素使用更短的数据类型，并对它们进行排序，以便将短数据类型组合在一起。这可以降低 gas 消耗，因为多个 <code>SSTORE</code> 操作可能会被合并成一个（<code>SSTORE</code> 消耗 5000 或 20000 的 gas，所以这应该是你想要优化的）。使用 gas 估算器（启用优化器）来检查！</li><li>将你的状态变量设置为 public ——编译器会为你自动创建 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">getters</a> 。</li><li>如果你最终需要在函数开始位置检查很多输入条件或者状态变量的值，你可以尝试使用 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifiers">函数 </a>。</li><li>如果你的合约有一个 <code>send</code> 函数，但你想要使用内置的 send 函数，你可以使用 <code>address(contractVariable).send(amount)</code>。</li><li>使用一个赋值语句就可以初始化 struct：<code>x = MyStruct(&#123;a: 1, b: 2&#125;);</code></li></ul><p>注解</p><p>如果存储结构具有“紧打包（tightly packed）”，可以用分开的赋值语句来初始化：<code>x.a = 1; x.b = 2;</code>。这样可以使优化器更容易地一次性更新存储，使赋值的开销更小。</p><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><h3 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h3><p>以下是按评估顺序列出的操作符优先级。</p><table><thead><tr><th>优先级</th><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td><em>1</em></td><td>后置自增和自减</td><td><code>++</code>, <code>--</code></td></tr><tr><td>创建类型实例</td><td><code>new &lt;typename&gt;</code></td><td></td></tr><tr><td>数组元素</td><td><code>&lt;array&gt;[&lt;index&gt;]</code></td><td></td></tr><tr><td>访问成员</td><td><code>&lt;object&gt;.&lt;member&gt;</code></td><td></td></tr><tr><td>函数调用</td><td><code>&lt;func&gt;(&lt;args...&gt;)</code></td><td></td></tr><tr><td>小括号</td><td><code>(&lt;statement&gt;)</code></td><td></td></tr><tr><td><em>2</em></td><td>前置自增和自减</td><td><code>++</code>, <code>--</code></td></tr><tr><td>一元运算的加和减</td><td><code>+</code>, <code>-</code></td><td></td></tr><tr><td>一元操作符</td><td><code>delete</code></td><td></td></tr><tr><td>逻辑非</td><td><code>!</code></td><td></td></tr><tr><td>按位非</td><td><code>~</code></td><td></td></tr><tr><td><em>3</em></td><td>乘方</td><td><code>**</code></td></tr><tr><td><em>4</em></td><td>乘、除和模运算</td><td><code>*</code>, <code>/</code>, <code>%</code></td></tr><tr><td><em>5</em></td><td>算术加和减</td><td><code>+</code>, <code>-</code></td></tr><tr><td><em>6</em></td><td>移位操作符</td><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td></tr><tr><td><em>7</em></td><td>按位与</td><td><code>&amp;</code></td></tr><tr><td><em>8</em></td><td>按位异或</td><td><code>^</code></td></tr><tr><td><em>9</em></td><td>按位或</td><td>&#96;</td></tr><tr><td><em>10</em></td><td>非等操作符</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td></tr><tr><td><em>11</em></td><td>等于操作符</td><td><code>==</code>, <code>!=</code></td></tr><tr><td><em>12</em></td><td>逻辑与</td><td><code>&amp;&amp;</code></td></tr><tr><td><em>13</em></td><td>逻辑或</td><td>&#96;</td></tr><tr><td><em>14</em></td><td>三元操作符</td><td><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td></tr><tr><td><em>15</em></td><td>赋值操作符</td><td><code>=</code>, &#96;</td></tr><tr><td><em>16</em></td><td>逗号</td><td><code>,</code></td></tr></tbody></table><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li><code>abi.encode(...) returns (bytes)</code>： <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi">ABI</a> - 对给定参数进行编码</li><li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode">紧打包编码</a></li><li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi">ABI</a> - 对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li><li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li><li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 <code>blockhash(uint blockNumber)</code> 代替</li><li><code>block.coinbase</code> （<code>address</code>）：挖出当前区块的矿工的地址</li><li><code>block.difficulty</code> （<code>uint</code>）：当前区块的难度值</li><li><code>block.gaslimit</code> （<code>uint</code>）：当前区块的 gas 上限</li><li><code>block.number</code> （<code>uint</code>）：当前区块的区块号</li><li><code>block.timestamp</code> （<code>uint</code>）：当前区块的时间戳</li><li><code>gasleft() returns (uint256)</code>：剩余的 gas</li><li><code>msg.data</code> （<code>bytes</code>）：完整的 calldata</li><li><code>msg.gas</code> （<code>uint</code>）：剩余的 gas - 自 0.4.21 版本开始已经不推荐使用，由 <code>gesleft()</code> 代替</li><li><code>msg.sender</code> （<code>address</code>）：消息发送方（当前调用）</li><li><code>msg.value</code> （<code>uint</code>）：随消息发送的 wei 的数量</li><li><code>now</code> （<code>uint</code>）：当前区块的时间戳（等价于 <code>block.timestamp</code>）</li><li><code>tx.gasprice</code> （<code>uint</code>）：交易的 gas price</li><li><code>tx.origin</code> （<code>address</code>）：交易发送方（完整调用链上的原始发送方）</li><li><code>assert(bool condition)</code>：如果条件值为 <code>false</code> 则中止执行并回退所有状态变更（用做内部错误）</li><li><code>require(bool condition)</code>：如果条件值为 <code>false</code> 则中止执行并回退所有状态变更（用做异常输入或外部组件错误）</li><li><code>require(bool condition, string message)</code>：如果条件值为 <code>false</code> 则中止执行并回退所有状态变更（用做异常输入或外部组件错误），可以同时提供错误消息</li><li><code>revert()</code>：中止执行并回复所有状态变更</li><li><code>revert(string message)</code>：中止执行并回复所有状态变更，可以同时提供错误消息</li><li><code>blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希——仅可用于最新的 256 个区块</li><li><code>keccak256(...) returns (bytes32)</code>：计算 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode">紧打包编码</a> 的 Ethereum-SHA-3（Keccak-256）哈希</li><li><code>sha3(...) returns (bytes32)</code>：等价于 <code>keccak256</code></li><li><code>sha256(...) returns (bytes32)</code>：计算 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode">紧打包编码</a> 的 SHA-256 哈希</li><li><code>ripemd160(...) returns (bytes20)</code>：计算 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode">紧打包编码</a> 的 RIPEMD-160 哈希</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：基于椭圆曲线签名找回与指定公钥关联的地址，发生错误的时候返回 0</li><li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算 <code>(x + y) % k</code> 的值，其中加法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本开始会加入对 <code>k != 0</code> 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code> 作为参数检查，译者注）。</li><li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算 <code>(x * y) % k</code> 的值，其中乘法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本开始会加入对 <code>k != 0</code> 的 assert（即会在此函数开头执行 <code>assert(k != 0);</code> 作为参数检查，译者注）。</li><li><code>this</code> （类型为当前合约的变量）：当前合约实例，可以准确地转换为 <code>address</code></li><li><code>super</code>：当前合约的上一级继承关系的合约</li><li><code>selfdestruct(address recipient)</code>：销毁当前合约，把余额发送到给定地址</li><li><code>suicide(address recipient)</code>：与 <code>selfdestruct</code> 等价，但已不推荐使用</li><li><code>&lt;address&gt;.balance</code> （<code>uint256</code>）： <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#address">地址类型</a> 的余额，以 Wei 为单位</li><li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：向 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#address">地址类型</a> 发送给定数量的 Wei，失败时返回 <code>false</code></li><li><code>&lt;address&gt;.transfer(uint256 amount)</code>：向 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#address">地址类型</a> 发送给定数量的 Wei，失败时会把错误抛出（throw）</li></ul><p>注解</p><p>不要用 <code>block.timestamp</code>、<code>now</code> 或者 <code>blockhash</code> 作为随机种子，除非你明确知道你在做什么。</p><p>时间戳和区块哈希都可以在一定程度上被矿工所影响。如果你用哈希值作为随机种子，那么例如挖矿团体中的坏人就可以使用给定的哈希来执行一个赌场功能，如果他们没赢钱，他们可以简单地换一个哈希再试。</p><p>当前区块的时间戳必须比前一个区块的时间戳大，但唯一可以确定的就是它会是权威链（主链或者主分支）上两个连续区块时间戳之间的一个数值。</p><p>注解</p><p>出于扩展性的原因，你无法取得所有区块的哈希。只有最新的 256 个区块的哈希可以拿到，其他的都将为 0。</p><h3 id="函数可见性说明符"><a href="#函数可见性说明符" class="headerlink" title="函数可见性说明符"></a>函数可见性说明符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &lt;visibility specifier&gt; returns (bool) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public</code>：内部、外部均可见（参考为存储&#x2F;状态变量创建 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#getter-functions">getter 函数</a>）</li><li><code>private</code>：仅在当前合约内可见</li><li><code>external</code>：仅在外部可见（仅可修饰函数）——就是说，仅可用于消息调用（即使在合约内调用，也只能通过 <code>this.func</code> 的方式）</li><li><code>internal</code>：仅在内部可见（也就是在当前 Solidity 源代码文件内均可见，不仅限于当前合约内，译者注）</li></ul><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><ul><li><code>pure</code> 修饰函数时：不允许修改或访问状态——但目前并不是强制的。</li><li><code>view</code> 修饰函数时：不允许修改状态——但目前不是强制的。</li><li><code>payable</code> 修饰函数时：允许从调用中接收 以太币Ether 。</li><li><code>constant</code> 修饰状态变量时：不允许赋值（除初始化以外），不会占据 存储插槽storage slot 。</li><li><code>constant</code> 修饰函数时：与 <code>view</code> 等价。</li><li><code>anonymous</code> 修饰事件时：不把事件签名作为 topic 存储。</li><li><code>indexed</code> 修饰事件时：将参数作为 topic 存储。</li></ul><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>以下是 Solidity 的保留字，未来可能会变为语法的一部分：</p><p><code>abstract</code>, <code>after</code>, <code>alias</code>, <code>apply</code>, <code>auto</code>, <code>case</code>, <code>catch</code>, <code>copyof</code>, <code>default</code>, <code>define</code>, <code>final</code>, <code>immutable</code>, <code>implements</code>, <code>in</code>, <code>inline</code>, <code>let</code>, <code>macro</code>, <code>match</code>, <code>mutable</code>, <code>null</code>, <code>of</code>, <code>override</code>, <code>partial</code>, <code>promise</code>, <code>reference</code>, <code>relocatable</code>, <code>sealed</code>, <code>sizeof</code>, <code>static</code>, <code>supports</code>, <code>switch</code>, <code>try</code>, <code>type</code>, <code>typedef</code>, <code>typeof</code>, <code>unchecked</code>.</p><h3 id="语法表"><a href="#语法表" class="headerlink" title="语法表"></a>语法表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &#x27;;&#x27; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &#x27;pragma&#x27; Identifier ([^;]+) &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">ImportDirective = &#x27;import&#x27; StringLiteral (&#x27;as&#x27; Identifier)? &#x27;;&#x27;</span><br><span class="line">        | &#x27;import&#x27; (&#x27;*&#x27; | Identifier) (&#x27;as&#x27; Identifier)? &#x27;from&#x27; StringLiteral &#x27;;&#x27;</span><br><span class="line">        | &#x27;import&#x27; &#x27;&#123;&#x27; Identifier (&#x27;as&#x27; Identifier)? ( &#x27;,&#x27; Identifier (&#x27;as&#x27; Identifier)? )* &#x27;&#125;&#x27; &#x27;from&#x27; StringLiteral &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &#x27;contract&#x27; | &#x27;library&#x27; | &#x27;interface&#x27; ) Identifier</span><br><span class="line">                     ( &#x27;is&#x27; InheritanceSpecifier (&#x27;,&#x27; InheritanceSpecifier )* )?</span><br><span class="line">                     &#x27;&#123;&#x27; ContractPart* &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &#x27;(&#x27; Expression ( &#x27;,&#x27; Expression )* &#x27;)&#x27; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &#x27;public&#x27; | &#x27;internal&#x27; | &#x27;private&#x27; | &#x27;constant&#x27; )* Identifier (&#x27;=&#x27; Expression)? &#x27;;&#x27;</span><br><span class="line">UsingForDeclaration = &#x27;using&#x27; Identifier &#x27;for&#x27; (&#x27;*&#x27; | TypeName) &#x27;;&#x27;</span><br><span class="line">StructDefinition = &#x27;struct&#x27; Identifier &#x27;&#123;&#x27;</span><br><span class="line">                     ( VariableDeclaration &#x27;;&#x27; (VariableDeclaration &#x27;;&#x27;)* ) &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &#x27;modifier&#x27; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &#x27;(&#x27; ExpressionList? &#x27;)&#x27; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &#x27;function&#x27; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &#x27;external&#x27; | &#x27;public&#x27; | &#x27;internal&#x27; | &#x27;private&#x27; )*</span><br><span class="line">                     ( &#x27;returns&#x27; ParameterList )? ( &#x27;;&#x27; | Block )</span><br><span class="line">EventDefinition = &#x27;event&#x27; Identifier EventParameterList &#x27;anonymous&#x27;? &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &#x27;enum&#x27; Identifier &#x27;&#123;&#x27; EnumValue? (&#x27;,&#x27; EnumValue)* &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">ParameterList = &#x27;(&#x27; ( Parameter (&#x27;,&#x27; Parameter)* )? &#x27;)&#x27;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &#x27;(&#x27; ( EventParameter (&#x27;,&#x27; EventParameter )* )? &#x27;)&#x27;</span><br><span class="line">EventParameter = TypeName &#x27;indexed&#x27;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &#x27;(&#x27; ( FunctionTypeParameter (&#x27;,&#x27; FunctionTypeParameter )* )? &#x27;)&#x27;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &#x27;.&#x27; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &#x27;mapping&#x27; &#x27;(&#x27; ElementaryTypeName &#x27;=&gt;&#x27; TypeName &#x27;)&#x27;</span><br><span class="line">ArrayTypeName = TypeName &#x27;[&#x27; Expression? &#x27;]&#x27;</span><br><span class="line">FunctionTypeName = &#x27;function&#x27; FunctionTypeParameterList ( &#x27;internal&#x27; | &#x27;external&#x27; | StateMutability )*</span><br><span class="line">                   ( &#x27;returns&#x27; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &#x27;memory&#x27; | &#x27;storage&#x27; | &#x27;calldata&#x27;</span><br><span class="line">StateMutability = &#x27;pure&#x27; | &#x27;constant&#x27; | &#x27;view&#x27; | &#x27;payable&#x27;</span><br><span class="line"></span><br><span class="line">Block = &#x27;&#123;&#x27; Statement* &#x27;&#125;&#x27;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &#x27;if&#x27; &#x27;(&#x27; Expression &#x27;)&#x27; Statement ( &#x27;else&#x27; Statement )?</span><br><span class="line">WhileStatement = &#x27;while&#x27; &#x27;(&#x27; Expression &#x27;)&#x27; Statement</span><br><span class="line">PlaceholderStatement = &#x27;_&#x27;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &#x27;for&#x27; &#x27;(&#x27; (SimpleStatement)? &#x27;;&#x27; (Expression)? &#x27;;&#x27; (ExpressionStatement)? &#x27;)&#x27; Statement</span><br><span class="line">InlineAssemblyStatement = &#x27;assembly&#x27; StringLiteral? InlineAssemblyBlock</span><br><span class="line">DoWhileStatement = &#x27;do&#x27; Statement &#x27;while&#x27; &#x27;(&#x27; Expression &#x27;)&#x27;</span><br><span class="line">Continue = &#x27;continue&#x27;</span><br><span class="line">Break = &#x27;break&#x27;</span><br><span class="line">Return = &#x27;return&#x27; Expression?</span><br><span class="line">Throw = &#x27;throw&#x27;</span><br><span class="line">EmitStatement = &#x27;emit&#x27; FunctionCall</span><br><span class="line">VariableDefinition = (&#x27;var&#x27; IdentifierList | VariableDeclaration | &#x27;(&#x27; VariableDeclaration? (&#x27;,&#x27; VariableDeclaration? )* &#x27;)&#x27; ) ( &#x27;=&#x27; Expression )?</span><br><span class="line">IdentifierList = &#x27;(&#x27; ( Identifier? &#x27;,&#x27; )* Identifier? &#x27;)&#x27;</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&#x27;++&#x27; | &#x27;--&#x27;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &#x27;(&#x27; Expression &#x27;)&#x27;</span><br><span class="line">  | (&#x27;!&#x27; | &#x27;~&#x27; | &#x27;delete&#x27; | &#x27;++&#x27; | &#x27;--&#x27; | &#x27;+&#x27; | &#x27;-&#x27;) Expression</span><br><span class="line">  | Expression &#x27;**&#x27; Expression</span><br><span class="line">  | Expression (&#x27;*&#x27; | &#x27;/&#x27; | &#x27;%&#x27;) Expression</span><br><span class="line">  | Expression (&#x27;+&#x27; | &#x27;-&#x27;) Expression</span><br><span class="line">  | Expression (&#x27;&lt;&lt;&#x27; | &#x27;&gt;&gt;&#x27;) Expression</span><br><span class="line">  | Expression &#x27;&amp;&#x27; Expression</span><br><span class="line">  | Expression &#x27;^&#x27; Expression</span><br><span class="line">  | Expression &#x27;|&#x27; Expression</span><br><span class="line">  | Expression (&#x27;&lt;&#x27; | &#x27;&gt;&#x27; | &#x27;&lt;=&#x27; | &#x27;&gt;=&#x27;) Expression</span><br><span class="line">  | Expression (&#x27;==&#x27; | &#x27;!=&#x27;) Expression</span><br><span class="line">  | Expression &#x27;&amp;&amp;&#x27; Expression</span><br><span class="line">  | Expression &#x27;||&#x27; Expression</span><br><span class="line">  | Expression &#x27;?&#x27; Expression &#x27;:&#x27; Expression</span><br><span class="line">  | Expression (&#x27;=&#x27; | &#x27;|=&#x27; | &#x27;^=&#x27; | &#x27;&amp;=&#x27; | &#x27;&lt;&lt;=&#x27; | &#x27;&gt;&gt;=&#x27; | &#x27;+=&#x27; | &#x27;-=&#x27; | &#x27;*=&#x27; | &#x27;/=&#x27; | &#x27;%=&#x27;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &#x27;,&#x27; Expression )*</span><br><span class="line">NameValueList = Identifier &#x27;:&#x27; Expression ( &#x27;,&#x27; Identifier &#x27;:&#x27; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &#x27;(&#x27; FunctionCallArguments &#x27;)&#x27;</span><br><span class="line">FunctionCallArguments = &#x27;&#123;&#x27; NameValueList? &#x27;&#125;&#x27;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &#x27;new&#x27; TypeName</span><br><span class="line">MemberAccess = Expression &#x27;.&#x27; Identifier</span><br><span class="line">IndexAccess = Expression &#x27;[&#x27; Expression? &#x27;]&#x27;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &#x27;true&#x27; | &#x27;false&#x27;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&#x27; &#x27; NumberUnit)?</span><br><span class="line">NumberUnit = &#x27;wei&#x27; | &#x27;szabo&#x27; | &#x27;finney&#x27; | &#x27;ether&#x27;</span><br><span class="line">           | &#x27;seconds&#x27; | &#x27;minutes&#x27; | &#x27;hours&#x27; | &#x27;days&#x27; | &#x27;weeks&#x27; | &#x27;years&#x27;</span><br><span class="line">HexLiteral = &#x27;hex&#x27; (&#x27;&quot;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;&quot;&#x27; | &#x27;\&#x27;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;\&#x27;&#x27;)</span><br><span class="line">StringLiteral = &#x27;&quot;&#x27; ([^&quot;\r\n\\] | &#x27;\\&#x27; .)* &#x27;&quot;&#x27;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &#x27;0x&#x27; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &#x27;.&#x27; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &#x27;(&#x27; ( Expression? ( &#x27;,&#x27; Expression? )*  )? &#x27;)&#x27;</span><br><span class="line">                | &#x27;[&#x27; ( Expression  ( &#x27;,&#x27; Expression  )*  )? &#x27;]&#x27;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &#x27;address&#x27; | &#x27;bool&#x27; | &#x27;string&#x27; | &#x27;var&#x27;</span><br><span class="line">                   | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &#x27;int&#x27; | &#x27;int8&#x27; | &#x27;int16&#x27; | &#x27;int24&#x27; | &#x27;int32&#x27; | &#x27;int40&#x27; | &#x27;int48&#x27; | &#x27;int56&#x27; | &#x27;int64&#x27; | &#x27;int72&#x27; | &#x27;int80&#x27; | &#x27;int88&#x27; | &#x27;int96&#x27; | &#x27;int104&#x27; | &#x27;int112&#x27; | &#x27;int120&#x27; | &#x27;int128&#x27; | &#x27;int136&#x27; | &#x27;int144&#x27; | &#x27;int152&#x27; | &#x27;int160&#x27; | &#x27;int168&#x27; | &#x27;int176&#x27; | &#x27;int184&#x27; | &#x27;int192&#x27; | &#x27;int200&#x27; | &#x27;int208&#x27; | &#x27;int216&#x27; | &#x27;int224&#x27; | &#x27;int232&#x27; | &#x27;int240&#x27; | &#x27;int248&#x27; | &#x27;int256&#x27;</span><br><span class="line"></span><br><span class="line">Uint = &#x27;uint&#x27; | &#x27;uint8&#x27; | &#x27;uint16&#x27; | &#x27;uint24&#x27; | &#x27;uint32&#x27; | &#x27;uint40&#x27; | &#x27;uint48&#x27; | &#x27;uint56&#x27; | &#x27;uint64&#x27; | &#x27;uint72&#x27; | &#x27;uint80&#x27; | &#x27;uint88&#x27; | &#x27;uint96&#x27; | &#x27;uint104&#x27; | &#x27;uint112&#x27; | &#x27;uint120&#x27; | &#x27;uint128&#x27; | &#x27;uint136&#x27; | &#x27;uint144&#x27; | &#x27;uint152&#x27; | &#x27;uint160&#x27; | &#x27;uint168&#x27; | &#x27;uint176&#x27; | &#x27;uint184&#x27; | &#x27;uint192&#x27; | &#x27;uint200&#x27; | &#x27;uint208&#x27; | &#x27;uint216&#x27; | &#x27;uint224&#x27; | &#x27;uint232&#x27; | &#x27;uint240&#x27; | &#x27;uint248&#x27; | &#x27;uint256&#x27;</span><br><span class="line"></span><br><span class="line">Byte = &#x27;byte&#x27; | &#x27;bytes&#x27; | &#x27;bytes1&#x27; | &#x27;bytes2&#x27; | &#x27;bytes3&#x27; | &#x27;bytes4&#x27; | &#x27;bytes5&#x27; | &#x27;bytes6&#x27; | &#x27;bytes7&#x27; | &#x27;bytes8&#x27; | &#x27;bytes9&#x27; | &#x27;bytes10&#x27; | &#x27;bytes11&#x27; | &#x27;bytes12&#x27; | &#x27;bytes13&#x27; | &#x27;bytes14&#x27; | &#x27;bytes15&#x27; | &#x27;bytes16&#x27; | &#x27;bytes17&#x27; | &#x27;bytes18&#x27; | &#x27;bytes19&#x27; | &#x27;bytes20&#x27; | &#x27;bytes21&#x27; | &#x27;bytes22&#x27; | &#x27;bytes23&#x27; | &#x27;bytes24&#x27; | &#x27;bytes25&#x27; | &#x27;bytes26&#x27; | &#x27;bytes27&#x27; | &#x27;bytes28&#x27; | &#x27;bytes29&#x27; | &#x27;bytes30&#x27; | &#x27;bytes31&#x27; | &#x27;bytes32&#x27;</span><br><span class="line"></span><br><span class="line">Fixed = &#x27;fixed&#x27; | ( &#x27;fixed&#x27; [0-9]+ &#x27;x&#x27; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &#x27;ufixed&#x27; | ( &#x27;ufixed&#x27; [0-9]+ &#x27;x&#x27; [0-9]+ )</span><br><span class="line"></span><br><span class="line">InlineAssemblyBlock = &#x27;&#123;&#x27; AssemblyItem* &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">AssemblyLocalBinding = &#x27;let&#x27; Identifier &#x27;:=&#x27; FunctionalAssemblyExpression</span><br><span class="line">AssemblyAssignment = ( Identifier &#x27;:=&#x27; FunctionalAssemblyExpression ) | ( &#x27;=:&#x27; Identifier )</span><br><span class="line">AssemblyLabel = Identifier &#x27;:&#x27;</span><br><span class="line">FunctionalAssemblyExpression = Identifier &#x27;(&#x27; AssemblyItem? ( &#x27;,&#x27; AssemblyItem )* &#x27;)&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;杂项&quot;&gt;&lt;a href=&quot;#杂项&quot; class=&quot;headerlink&quot; title=&quot;杂项&quot;&gt;&lt;/a&gt;杂项&lt;/h1&gt;&lt;h2 id=&quot;存储storage-中的状态变量储存结构&quot;&gt;&lt;a href=&quot;#存储storage-中的状态变量储存结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Solidity汇编</title>
    <link href="https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/"/>
    <id>https://www.zhengcookie.site/2025/07/10/Solidity%E6%B1%87%E7%BC%96/</id>
    <published>2025-07-10T13:32:30.000Z</published>
    <updated>2025-10-01T04:54:48.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Solidity汇编"><a href="#Solidity汇编" class="headerlink" title="Solidity汇编"></a>Solidity汇编</h1><p>Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。 由于 EVM 是基于栈的虚拟机，因此通常很难准确地定位栈内插槽（存储位置）的地址，并为操作码提供正确的栈内位置来获取参数。 Solidity 的内联汇编试图通过提供以下特性来解决这个问题以及手工编写汇编代码时可能出现的问题：</p><ul><li>函数风格操作码： <code>mul(1, add(2, 3))</code> 而不是 <code>push1 3 push1 2 add push1 1 mul</code></li><li>汇编局部变量： <code>let x := add(2, 3) let y := mload(0x40) x := add(x, y)</code></li><li>可以访问外部变量： <code>function f(uint x) public &#123; assembly &#123; x := sub(x, 1) &#125; &#125;</code></li><li>标签： <code>let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li><li>循环： <code>for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123; y := mul(2, y) &#125;</code></li><li>if 语句： <code>if slt(x, 0) &#123; x := sub(0, x) &#125;</code></li><li>switch 语句： <code>switch x case 0 &#123; y := mul(x, 2) &#125; default &#123; y := 0 &#125;</code></li><li>函数调用： <code>function f(x) -&gt; y &#123; switch x case 0 &#123; y := 1 &#125; default &#123; y := mul(x, f(sub(x, 1))) &#125;  &#125;</code></li></ul><p>现在我们详细讲解内联汇编语言。</p><p>警告</p><p>内联汇编是一种在底层访问以太坊虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性。</p><p>注解</p><p>TODO：写出在内联汇编中作用域规则的细微差别，以及在使用库合约的内部函数时产生的复杂性。此外，还要编写有关编译器定义的符号。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面例子展示了一个库合约的代码，它可以取得另一个合约的代码，并将其加载到一个 <code>bytes</code> 变量中。 这对于“常规 Solidity”来说是根本不可能的，汇编库合约则可以通过这种方式来增强语言特性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // 获取代码大小，这需要汇编语言</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // 分配输出字节数组 – 这也可以不用汇编语言来实现</span><br><span class="line">            // 通过使用 o_code = new bytes（size）</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // 包括补位在内新的“memory end”</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // 把长度保存到内存中</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // 实际获取代码，这需要汇编语言</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在优化器无法生成高效代码的情况下，内联汇编也可能更有好处。请注意，由于编译器无法对汇编语句进行相关的检查，所以编写汇编代码肯定更加困难； 因此只有在处理一些相对复杂的问题时才需要使用它，并且你需要明确知道自己要做什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // 因为目前的优化器在访问数组时无法移除边界检查，</span><br><span class="line">    // 所以这个函数的执行效率比较低。</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们知道我们只能在数组范围内访问数组元素，所以我们可以在内联汇编中不做边界检查。</span><br><span class="line">    // 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，</span><br><span class="line">    // 所以我们在访问数组元素时需要加入 0x20 作为偏移量。</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 和上面一样，但在内联汇编内完成整个代码。</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // 取得数组长度（前 32 字节）</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // 略过长度字段。</span><br><span class="line">           //</span><br><span class="line">           // 保持临时变量以便它可以在原地增加。</span><br><span class="line">           //</span><br><span class="line">           // 注意：对 _data 数值的增加将导致 _data 在这个汇编语句块之后不再可用。</span><br><span class="line">           //      因为无法再基于 _data 来解析后续的数组数据。</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // 迭代到数组数据结束</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, mul(len, 0x20)) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>和 Solidity 一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 <code>//</code> 和 <code>/* */</code> 来进行注释。 内联汇编程序由 <code>assembly &#123; ... &#125;</code> 来标记，在这些大括号内可以使用以下内容（更多详细信息请参阅后面部分）。</p><blockquote><ul><li>字面常数，也就是 <code>0x123</code>、<code>42</code> 或 <code>&quot;abc&quot;</code> （不超过 32 个字符的字符串）</li><li>操作码（在“instruction style”内），比如 <code>mload sload dup1 sstore</code>，操作码列表请看后面</li><li>函数风格操作码，比如 <code>add(1，mlod(0))</code></li><li>标签，比如 <code>name:</code></li><li>变量声明，比如 <code>let x := 7</code>、<code>let x := add(y, 3)</code> 或者 <code>let x</code> （初始值将被置为 empty(0)）</li><li>标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 <code>jump(name)</code>、<code>3 x add</code></li><li>赋值（在“instruction style”内），比如 <code>3 =: x</code></li><li>函数风格赋值，比如 <code>x := add(y，3)</code></li><li>一些控制局部变量作用域的语句块，比如 <code>&#123;let x := 3 &#123; let y := add(x，1) &#125;&#125;</code></li></ul></blockquote><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不是以太坊虚拟机的详细描述，但下边的列表可以作为操作码参考。</p><p>如果一个操作码需要参数（总是来自堆栈顶部），它们会在括号中给出。请注意：参数顺序可以看作是在非函数风格中逆序（下面会解释）。 标有 <code>-</code> 的操作码不会向栈中压入（push）数据，标有 <code>*</code> 的操作码有特殊操作，而所有其他操作码都只会将一个数据压入（push）栈中。 用 <code>F</code>、<code>H</code>、<code>B</code> 或 <code>C</code> 标记的操作码代表它们从 Frontier、Homestead、Byzantium 或 Constantinople 开始被引入。 Constantinople 目前仍在计划中，所以标记为 <code>C</code> 的指令目前都会导致一个非法指令异常。</p><p>在下表中，<code>mem[a...b)</code> 表示从位置 <code>a</code> 开始至（不包括）位置 <code>b</code> 的内存字节数，<code>storage[p]</code> 表示位置 <code>p</code> 处的存储内容。</p><p><code>pushi</code> 和 <code>jumpdest</code> 这两个操作码不能直接用。</p><p>在语法表中，操作码是作为预定义标识符提供的。</p><table><thead><tr><th>Instruction</th><th></th><th></th><th>Explanation</th></tr></thead><tbody><tr><td>stop</td><td>-</td><td>F</td><td>停止执行，与 return(0,0) 等价</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>add(x, y)</td><td></td><td>F</td><td>x + y</td></tr><tr><td>sub(x, y)</td><td></td><td>F</td><td>x - y</td></tr><tr><td>mul(x, y)</td><td></td><td>F</td><td>x * y</td></tr><tr><td>div(x, y)</td><td></td><td>F</td><td>x &#x2F; y</td></tr><tr><td>sdiv(x, y)</td><td></td><td>F</td><td>x &#x2F; y，以二进制补码作为符号</td></tr><tr><td>mod(x, y)</td><td></td><td>F</td><td>x % y</td></tr><tr><td>smod(x, y)</td><td></td><td>F</td><td>x % y，以二进制补码作为符号</td></tr><tr><td>exp(x, y)</td><td></td><td>F</td><td>x 的 y 次幂</td></tr><tr><td>not(x)</td><td></td><td>F</td><td>~x，对 x 按位取反</td></tr><tr><td>lt(x, y)</td><td></td><td>F</td><td>如果 x &lt; y 为 1，否则为 0</td></tr><tr><td>gt(x, y)</td><td></td><td>F</td><td>如果 x &gt; y 为 1，否则为 0</td></tr><tr><td>slt(x, y)</td><td></td><td>F</td><td>如果 x &lt; y 为 1，否则为 0，以二进制补码作为符号</td></tr><tr><td>sgt(x, y)</td><td></td><td>F</td><td>如果 x &gt; y 为 1，否则为 0，以二进制补码作为符号</td></tr><tr><td>eq(x, y)</td><td></td><td>F</td><td>如果 x &#x3D;&#x3D; y 为 1，否则为 0</td></tr><tr><td>iszero(x)</td><td></td><td>F</td><td>如果 x &#x3D;&#x3D; 0 为 1，否则为 0</td></tr><tr><td>and(x, y)</td><td></td><td>F</td><td>x 和 y 的按位与</td></tr><tr><td>or(x, y)</td><td></td><td>F</td><td>x 和 y 的按位或</td></tr><tr><td>xor(x, y)</td><td></td><td>F</td><td>x 和 y 的按位异或</td></tr><tr><td>byte(n, x)</td><td></td><td>F</td><td>x 的第 n 个字节，这个索引是从 0 开始的</td></tr><tr><td>shl(x, y)</td><td></td><td>C</td><td>将 y 逻辑左移 x 位</td></tr><tr><td>shr(x, y)</td><td></td><td>C</td><td>将 y 逻辑右移 x 位</td></tr><tr><td>sar(x, y)</td><td></td><td>C</td><td>将 y 算术右移 x 位</td></tr><tr><td>addmod(x, y, m)</td><td></td><td>F</td><td>任意精度的 (x + y) % m</td></tr><tr><td>mulmod(x, y, m)</td><td></td><td>F</td><td>任意精度的 (x * y) % m</td></tr><tr><td>signextend(i, x)</td><td></td><td>F</td><td>对 x 的最低位到第 (i * 8 + 7) 进行符号扩展</td></tr><tr><td>keccak256(p, n)</td><td></td><td>F</td><td>keccak(mem[p…(p + n)))</td></tr><tr><td>jump(label)</td><td>-</td><td>F</td><td>跳转到标签 &#x2F; 代码位置</td></tr><tr><td>jumpi(label, cond)</td><td>-</td><td>F</td><td>如果条件为非零，跳转到标签</td></tr><tr><td>pc</td><td></td><td>F</td><td>当前代码位置</td></tr><tr><td>pop(x)</td><td>-</td><td>F</td><td>删除（弹出）栈顶的 x 个元素</td></tr><tr><td>dup1 … dup16</td><td></td><td>F</td><td>将栈内第 i 个元素（从栈顶算起）复制到栈顶</td></tr><tr><td>swap1 … swap16</td><td>*</td><td>F</td><td>将栈顶元素和其下第 i 个元素互换</td></tr><tr><td>mload(p)</td><td></td><td>F</td><td>mem[p…(p + 32))</td></tr><tr><td>mstore(p, v)</td><td>-</td><td>F</td><td>mem[p…(p + 32)) :&#x3D; v</td></tr><tr><td>mstore8(p, v)</td><td>-</td><td>F</td><td>mem[p] :&#x3D; v &amp; 0xff （仅修改一个字节）</td></tr><tr><td>sload(p)</td><td></td><td>F</td><td>storage[p]</td></tr><tr><td>sstore(p, v)</td><td>-</td><td>F</td><td>storage[p] :&#x3D; v</td></tr><tr><td>msize</td><td></td><td>F</td><td>内存大小，即最大可访问内存索引</td></tr><tr><td>gas</td><td></td><td>F</td><td>执行可用的 gas</td></tr><tr><td>address</td><td></td><td>F</td><td>当前合约 &#x2F; 执行上下文的地址</td></tr><tr><td>balance(a)</td><td></td><td>F</td><td>地址 a 的余额，以 wei 为单位</td></tr><tr><td>caller</td><td></td><td>F</td><td>调用发起者（不包括 <code>delegatecall</code>）</td></tr><tr><td>callvalue</td><td></td><td>F</td><td>随调用发送的 Wei 的数量</td></tr><tr><td>calldataload(p)</td><td></td><td>F</td><td>位置 p 的调用数据（32 字节）</td></tr><tr><td>calldatasize</td><td></td><td>F</td><td>调用数据的字节数大小</td></tr><tr><td>calldatacopy(t, f, s)</td><td>-</td><td>F</td><td>从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t</td></tr><tr><td>codesize</td><td></td><td>F</td><td>当前合约 &#x2F; 执行上下文地址的代码大小</td></tr><tr><td>codecopy(t, f, s)</td><td>-</td><td>F</td><td>从代码的位置 f 开始拷贝 s 个字节到内存的位置 t</td></tr><tr><td>extcodesize(a)</td><td></td><td>F</td><td>地址 a 的代码大小</td></tr><tr><td>extcodecopy(a, t, f, s)</td><td>-</td><td>F</td><td>和 codecopy(t, f, s) 类似，但从地址 a 获取代码</td></tr><tr><td>returndatasize</td><td></td><td>B</td><td>最后一个 returndata 的大小</td></tr><tr><td>returndatacopy(t, f, s)</td><td>-</td><td>B</td><td>从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t</td></tr><tr><td>create(v, p, s)</td><td></td><td>F</td><td>用 mem[p…(p + s)) 中的代码创建一个新合约、发送 v wei 并返回 新地址</td></tr><tr><td>create2(v, n, p, s)</td><td></td><td>C</td><td>用 mem[p…(p + s)) 中的代码，在地址 keccak256(<address> . n . keccak256(mem[p…(p + s))) 上 创建新合约、发送 v wei 并返回新地址</td></tr><tr><td>call(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>使用 mem[in…(in + insize)) 作为输入数据， 提供 g gas 和 v wei 对地址 a 发起消息调用， 输出结果数据保存在 mem[out…(out + outsize))， 发生错误（比如 gas 不足）时返回 0，正确结束返回 1</td></tr><tr><td>callcode(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>与 <code>call</code> 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文</td></tr><tr><td>delegatecall(g, a, in, insize, out, outsize)</td><td></td><td>F</td><td>与 <code>callcode</code> 等价且保留 <code>caller</code> 和 <code>callvalue</code></td></tr><tr><td>staticcall(g, a, in, insize, out, outsize)</td><td></td><td>F</td><td>与 <code>call(g, a, 0, in, insize, out, outsize)</code> 等价 但不允许状态修改</td></tr><tr><td>return(p, s)</td><td>-</td><td>F</td><td>终止运行，返回 mem[p…(p + s)) 的数据</td></tr><tr><td>revert(p, s)</td><td>-</td><td>B</td><td>终止运行，撤销状态变化，返回 mem[p…(p + s)) 的数据</td></tr><tr><td>selfdestruct(a)</td><td>-</td><td>F</td><td>终止运行，销毁当前合约并且把资金发送到地址 a</td></tr><tr><td>invalid</td><td>-</td><td>F</td><td>以无效指令终止运行</td></tr><tr><td>log0(p, s)</td><td>-</td><td>F</td><td>以 mem[p…(p + s)) 的数据产生不带 topic 的日志</td></tr><tr><td>log1(p, s, t1)</td><td>-</td><td>F</td><td>以 mem[p…(p + s)) 的数据和 topic t1 产生日志</td></tr><tr><td>log2(p, s, t1, t2)</td><td>-</td><td>F</td><td>以 mem[p…(p + s)) 的数据和 topic t1、t2 产生日志</td></tr><tr><td>log3(p, s, t1, t2, t3)</td><td>-</td><td>F</td><td>以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 产生日志</td></tr><tr><td>log4(p, s, t1, t2, t3, t4)</td><td>-</td><td>F</td><td>以 mem[p…(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志</td></tr><tr><td>origin</td><td></td><td>F</td><td>交易发起者地址</td></tr><tr><td>gasprice</td><td></td><td>F</td><td>交易所指定的 gas 价格</td></tr><tr><td>blockhash(b)</td><td></td><td>F</td><td>区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块</td></tr><tr><td>coinbase</td><td></td><td>F</td><td>当前的挖矿收益者地址</td></tr><tr><td>timestamp</td><td></td><td>F</td><td>从当前 epoch 开始的当前区块时间戳（以秒为单位）</td></tr><tr><td>number</td><td></td><td>F</td><td>当前区块号</td></tr><tr><td>difficulty</td><td></td><td>F</td><td>当前区块难度</td></tr><tr><td>gaslimit</td><td></td><td>F</td><td>当前区块的 gas 上限</td></tr></tbody></table><h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 <code>PUSHi</code> 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure><h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>你可以像使用字节码那样在操作码之后键入操作码。例如，把 <code>3</code> 与内存位置 <code>0x80</code> 处的数据相加就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure><p>由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure><p>函数风格表达式内不能使用指令风格的写法，即 <code>1 2 mstore(0x80, add)</code> 是无效汇编语句， 它必须写成 <code>mstore(0x80, add(2, 1))</code> 这种形式。对于不带参数的操作码，括号可以省略。</p><p>注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。</p><h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p>通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 <code>x</code> 所使用的存储槽，你可以使用 <code>x_slot</code>，并用的 <code>x_offset</code> 获取其字节偏移量。</p><p>在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。</p><p>对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为：</p><blockquote><ul><li>调用者压入 <code>return label</code>、<code>arg1</code>、<code>arg2</code>、…、<code>argn</code></li><li>被调用方返回 <code>ret1</code>、<code>ret2</code>、…、<code>retm</code></li></ul></blockquote><p>这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p>如果你访问一个实际数据位数小于 256 位的数据类型（比如 <code>uint64</code>、<code>address</code>、<code>bytes16</code> 或 <code>byte</code>）， 不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。 安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要： <code>uint32 x = f(); assembly &#123; x := and(x, 0xffffffff) /* now use x */ &#125;</code> 要清空有符号类型，你可以使用 <code>signextend</code> 操作码。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>注解</p><p>标签已经不推荐使用。请使用函数、循环、if 或 switch 语句。</p><p>EVM 汇编的另一个问题是 jump 和 jumpi 函数使用绝对地址，这些绝对地址很容易改变。 Solidity 内联汇编提供了标签，以便更容易地使用 jump。注意，标签具有底层特征，使用循环、if 和 switch 指令（参见下文）而不使用标签也能写出高效汇编代码。 以下代码用来计算斐波那契数列中的一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：只有汇编程序知道当前栈高度时，才能自动访问堆栈变量。如果 jump 源和目标的栈高度不同，访问将失败。 虽然我们可以这么使用 jump，但在这种情况下，你不应该去访问任何栈里的变量（即使是汇编变量）。</p><p>此外，栈高度分析器还可以通过操作码（而不是根据控制流）检查代码操作码，因此在下面的情况下，汇编程序对标签 <code>two</code> 处的堆栈高度会产生错误的印象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // 这里的栈高度是 2（因为我们压入了 x 和 7），</span><br><span class="line">        // 但因为汇编程序是按顺序读取代码的，</span><br><span class="line">        // 它会认为栈高度是 1。</span><br><span class="line">        // 在这里访问栈变量 x 会导致错误。</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // 把某个数据压入栈中</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="汇编局部变量声明"><a href="#汇编局部变量声明" class="headerlink" title="汇编局部变量声明"></a>汇编局部变量声明</h3><p>你可以使用 <code>let</code> 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 <code>&#123;...&#125;</code> 块中可见。 下面发生的事情应该是：<code>let</code> 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 <code>0</code>，但它也可以是一个复杂的函数风格表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y 会在这里被“清除”</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v 会在这里被“清除”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。</p><p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>变量 := 值</code>），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（<code>=: 变量</code>），则仅从栈顶部获取数据。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // 作为变量声明的函数风格赋值</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p>指令风格的赋值已经不推荐。</p><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><p>if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码主体的花括号是必需的。</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>作为“if&#x2F;else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 <code>default</code> 的默认情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Case 列表里面不需要大括号，但 case 主体需要。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。</p><p>下面例子是计算某个内存区域中的数值总和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。</p><p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 <code>return</code> 语句。</p><p>如果调用会返回多个值的函数，则必须使用 <code>a，b：= f(x)</code> 或 <code>let a，b：= f(x)</code> 的方式把它们赋值到一个元组。</p><p>下面例子通过平方和乘法实现了幂运算函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>内联汇编语言可能具有相当高级的外观，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。</p><h3 id="Solidity-惯例"><a href="#Solidity-惯例" class="headerlink" title="Solidity 惯例"></a>Solidity 惯例</h3><p>与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 <code>uint24</code>。为了提高效率，大多数算术运算只将它们视为 256 位数字， 仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。</p><p>Solidity 以一种非常简单的方式管理内存：在 <code>0x40</code> 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。</p><p>内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 <code>0x60</code> 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。</p><p>在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 <code>byte[]</code> 都是这样，只有 <code>bytes</code> 和 <code>string</code> 不是这样）。 多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。</p><p>警告</p><p>静态内存数组没有长度字段，但很快就会增加，这是为了可以更好地进行静态数组和动态数组之间的转换，所以请不要依赖这点。</p><h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作 Solidity 编译器的中间语言。在这种意义下，它试图实现以下几个目标：</p><p>1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。</p><p>为了实现第一个和最后一个目标，汇编提供了高级结构：如 <code>for</code> 循环、<code>if</code> 语句、<code>switch</code> 语句和函数调用。 应该可以编写不使用明确的 <code>SWAP</code>、<code>DUP</code>、<code>JUMP</code> 和 <code>JUMPI</code> 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 <code>mul(add(x, y), 7)</code> 的函数风格语句优于如 <code>7 y x add mul</code> 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。</p><p>第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、…）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。</p><p>作用域：在其中声明的标识符（标签、变量、函数、汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。 即使它们在作用范围内，越过函数边界访问局部变量也是非法的。阴影化是禁止的。在声明之前不能访问局部变量，但标签、函数和汇编是可以的。 汇编是特殊的语句块，例如用于返回运行时代码或创建合约等。在子汇编外部的汇编语句块中声明的标示符在子汇编中全都不可见。</p><p>如果控制流经过块尾部，则会插入与在当前语句块中声明的局部变量数量相匹配的 pop 指令。无论何时引用局部变量，代码生成器都需要知道在当前栈的相对位置， 因此，需要跟踪当前所谓的栈高度。由于所有在语句块内声明的局部变量都会在语句块结束时被清楚，所以语句块前后的栈高度应该相同。如果情况并非如此，则会发出警告。</p><p>使用 <code>switch</code>、<code>for</code> 和函数应该可以编写复杂的代码，而无需手工调用 <code>jump</code> 或 <code>jumpi</code>。这将允许改进的形式化验证和优化更简单地分析控制流程。</p><p>此外，如果允许手动跳转，计算栈高度将会更加复杂。栈中所有局部变量的位置都需要明确知晓，否则在语句块结束时就无法自动获得局部变量的引用从而正确地清除它们。</p><p>例子：</p><p>我们将参考一个从 Solidity 到汇编指令的实例。考虑以下 Solidity 程序的运行时字节码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会生成如下汇编指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // 保存“空闲内存指针”</span><br><span class="line">  // 函数选择器</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // 内存分配器</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // 合约函数</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="汇编语法"><a href="#汇编语法" class="headerlink" title="汇编语法"></a>汇编语法</h3><p>解析器任务如下：</p><ul><li>将字节流转换为符号流，丢弃 C ++ 风格的注释（对源代码引用存在特殊注释，我们这里不解释它）。</li><li>根据下面的语法，将符号流转换为 AST。</li><li>注册语句块中定义的标识符（注释到 AST 节点），并注明变量从哪个地方开始可以访问。</li></ul><p>汇编词法分析器遵循由 Solidity 自己定义的规则。</p><p>空格用于分隔所有符号，它由空格字符、制表符和换行符组成。注释格式是常规的 JavaScript&#x2F;C++ 风格，并被解释为空格。</p><p>Grammar:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &#x27;&#123;&#x27; AssemblyItem* &#x27;&#125;&#x27;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &#x27;break&#x27; |</span><br><span class="line">    &#x27;continue&#x27; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &#x27;(&#x27; ( AssemblyExpression ( &#x27;,&#x27; AssemblyExpression )* )? &#x27;)&#x27;</span><br><span class="line">AssemblyLocalDefinition = &#x27;let&#x27; IdentifierOrList ( &#x27;:=&#x27; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &#x27;:=&#x27; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &#x27;(&#x27; IdentifierList &#x27;)&#x27;</span><br><span class="line">IdentifierList = Identifier ( &#x27;,&#x27; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &#x27;=:&#x27; Identifier</span><br><span class="line">LabelDefinition = Identifier &#x27;:&#x27;</span><br><span class="line">AssemblyIf = &#x27;if&#x27; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &#x27;switch&#x27; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &#x27;default&#x27; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &#x27;case&#x27; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &#x27;function&#x27; Identifier &#x27;(&#x27; IdentifierList? &#x27;)&#x27;</span><br><span class="line">    ( &#x27;-&gt;&#x27; &#x27;(&#x27; IdentifierList &#x27;)&#x27; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &#x27;for&#x27; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &#x27;assembly&#x27; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &#x27;hex&#x27; (&#x27;&quot;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;&quot;&#x27; | &#x27;\&#x27;&#x27; ([0-9a-fA-F]&#123;2&#125;)* &#x27;\&#x27;&#x27;)</span><br><span class="line">StringLiteral = &#x27;&quot;&#x27; ([^&quot;\r\n\\] | &#x27;\\&#x27; .)* &#x27;&quot;&#x27;</span><br><span class="line">HexNumber = &#x27;0x&#x27; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure><p><a href="https://server.ethicalads.io/proxy/click/8844/0197f487-583b-7b92-8add-23c726895a6c/"><strong>Document Extraction for Developers</strong> Transform docs into structured data with Sensible. <strong>Try for free →</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Solidity汇编&quot;&gt;&lt;a href=&quot;#Solidity汇编&quot; class=&quot;headerlink&quot; title=&quot;Solidity汇编&quot;&gt;&lt;/a&gt;Solidity汇编&lt;/h1&gt;&lt;p&gt;Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合约</title>
    <link href="https://www.zhengcookie.site/2025/07/09/%E5%90%88%E7%BA%A6/"/>
    <id>https://www.zhengcookie.site/2025/07/09/%E5%90%88%E7%BA%A6/</id>
    <published>2025-07-09T11:00:01.000Z</published>
    <updated>2025-10-01T04:54:48.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><p>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</p><h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h2><p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。</p><p>一些集成开发环境，例如 <a href="https://remix.ethereum.org/">Remix</a>, 通过使用一些用户界面元素使创建过程更加流畅。 在以太坊上编程创建合约最好使用 JavaScript API <a href="https://github.com/ethereum/web3.js">web3.js</a>。 现在，我们已经有了一个叫做 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的方法能够更容易的创建合约。</p><p>创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi">ABI 编码</a> 传递，但是如果你使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    // TokenCreator 是如下定义的合约类型.</span><br><span class="line">    // 不创建新合约的话，也可以引用它。</span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    // 这是注册 creator 和设置名称的构造函数。</span><br><span class="line">    function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">        // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。</span><br><span class="line">        // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，</span><br><span class="line">        // 因为合约本身还不存在。</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        // 从 `address` 到 `TokenCreator` ，是做显式的类型转换</span><br><span class="line">        // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。</span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(bytes32 newName) public &#123;</span><br><span class="line">        // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，</span><br><span class="line">        // 所以这里的比较是可行的。</span><br><span class="line">        if (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address newOwner) public &#123;</span><br><span class="line">        // 只有当前所有者才能发送 token。</span><br><span class="line">        if (msg.sender != owner) return;</span><br><span class="line">        // 我们也想询问 creator 是否可以发送。</span><br><span class="line">        // 请注意，这里调用了一个下面定义的合约中的函数。</span><br><span class="line">        // 如果调用失败（比如，由于 gas 不足），会立即停止执行。</span><br><span class="line">        if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    function createToken(bytes32 name)</span><br><span class="line">       public</span><br><span class="line">       returns (OwnedToken tokenAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建一个新的 Token 合约并且返回它的地址。</span><br><span class="line">        // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为</span><br><span class="line">        // 这是在 ABI 中可用的最接近的类型。</span><br><span class="line">        return new OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(OwnedToken tokenAddress, bytes32 name)  public &#123;</span><br><span class="line">        // 同样，`tokenAddress` 的外部类型也是 `address` 。</span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isTokenTransferOK(address currentOwner, address newOwner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bool ok)</span><br><span class="line">    &#123;</span><br><span class="line">        // 检查一些任意的情况。</span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见性和-getter-函数"><a href="#可见性和-getter-函数" class="headerlink" title="可见性和 getter 函数"></a>可见性和 getter 函数</h2><p>由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 <code>external</code> ，<code>public</code> ，<code>internal</code> 或者 <code>private</code>，默认情况下函数类型为 <code>public</code>。 对于状态变量，不能设置为 <code>external</code> ，默认是 <code>internal</code> 。</p><ul><li><p><code>external</code> ：</p><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code> 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。</p></li><li><p><code>public</code> ：</p><p>public 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量， 会自动生成一个 getter 函数（见下面）。</p></li><li><p><code>internal</code> ：</p><p>这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</p></li><li><p><code>private</code> ：</p><p>private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p></li></ul><p>注解</p><p>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</p><p>可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的例子中，<code>D</code> 可以调用 <code>c.getData（）</code> 来获取状态存储中 <code>data</code> 的值，但不能调用 <code>f</code> 。 合约 <code>E</code> 继承自 <code>C</code> ，因此可以调用 <code>compute</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码编译错误</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    function f(uint a) private returns(uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">    function getData() public returns(uint) &#123; return data; &#125;</span><br><span class="line">    function compute(uint a, uint b) internal returns (uint) &#123; return a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    function readData() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint local = c.f(7); // 错误：成员 `f` 不可见</span><br><span class="line">        c.setData(3);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(3, 5); // 错误：成员 `compute` 不可见</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">    function g() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter-函数"><a href="#Getter-函数" class="headerlink" title="Getter 函数"></a>Getter 函数</h3><p>编译器自动为所有 <strong>public</strong> 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 <code>data</code> 的函数， 该函数不会接收任何参数并返回一个 <code>uint</code> ，即状态变量 <code>data</code> 的值。可以在声明时完成状态变量的初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getter 函数具有外部可见性。如果在内部访问 getter（即没有 <code>this.</code> ），它被认为一个状态变量。 如果它是外部访问的（即用 <code>this.</code> ），它被认为为一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data;</span><br><span class="line">    function x() public &#123;</span><br><span class="line">        data = 3; // 内部访问</span><br><span class="line">        uint val = this.data(); // 外部访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个例子稍微复杂一些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将会生成以下形式的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。</p><h2 id="函数-修饰器modifier"><a href="#函数-修饰器modifier" class="headerlink" title="函数 修饰器modifier"></a>函数 修饰器modifier</h2><p>使用 修饰器modifier 可以轻松改变函数的行为。 例如，它们可以在执行函数之前自动检查某个条件。 修饰器modifier 是合约的可继承属性， 并可能被派生合约覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // 这个合约只定义一个修饰器，但并未使用： 它将会在派生合约中用到。</span><br><span class="line">    // 修饰器所修饰的函数体会被插入到特殊符号 _; 的位置。</span><br><span class="line">    // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `close` 函数，</span><br><span class="line">    // 只有在合约里保存的 owner 调用 `close` 函数，才会生效。</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // 修改器可以接收参数：</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span><br><span class="line">    // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一个函数有多个 修饰器modifier，它们之间以空格隔开，修饰器modifier 会依次检查执行。</p><p>警告</p><p>在早期的 Solidity 版本中，有 修饰器modifier 的函数，<code>return</code> 语句的行为表现不同。</p><p>修饰器modifier 或函数体中显式的 return 语句仅仅跳出当前的 修饰器modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 修饰器modifier 中的定义的 “_” 之后继续执行。</p><p>修饰器modifier 的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 修饰器modifier 中均可见。 在 修饰器modifier 中引入的符号在函数中不可见（可能被重载改变）。</p><h2 id="Constant-状态变量"><a href="#Constant-状态变量" class="headerlink" title="Constant 状态变量"></a>Constant 状态变量</h2><p>状态变量可以被声明为 <code>constant</code>。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 <code>now</code>, <code>this.balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.gas</code> ） 或对外部合约的调用来给它们赋值都是不允许的。 在内存分配上有边界效应（side-effect）的表达式是允许的，但对其他内存对象产生边界效应的表达式则不行。 内建（built-in）函数 <code>keccak256</code>，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code> 和 <code>mulmod</code> 是允许的（即使他们确实会调用外部合约）。</p><p>允许带有边界效应的内存分配器的原因是这将允许构建复杂的对象，比如查找表（lookup-table）。 此功能尚未完全可用。</p><p>编译器不会为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式（这将可能被优化器计算为实际的某个值）。</p><p>不是所有类型的状态变量都支持用 constant 来修饰，当前支持的仅有值类型和字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="View-函数"><a href="#View-函数" class="headerlink" title="View 函数"></a>View 函数</h3><p>可以将函数声明为 <code>view</code> 类型，这种情况下要保证不修改状态。</p><p>下面的语句被认为是修改状态：</p><ol><li>修改状态变量。</li><li><a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events">产生事件</a>。</li><li><a href="https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#creating-contracts">创建其它合约</a>。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送以太币。</li><li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含特定操作码的内联汇编。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public view returns (uint) &#123;</span><br><span class="line">        return a * (b + 42) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p><code>constant</code> 是 <code>view</code> 的别名。</p><p>注解</p><p>Getter 方法被标记为 <code>view</code>。</p><p>警告</p><p>编译器没有强制 <code>view</code> 方法不能修改状态。</p><h3 id="Pure-函数"><a href="#Pure-函数" class="headerlink" title="Pure 函数"></a>Pure 函数</h3><p>函数可以声明为 <code>pure</code> ，在这种情况下，承诺不读取或修改状态。</p><p>除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取：</p><ol><li>读取状态变量。</li><li>访问 <code>this.balance</code> 或者 <code>&lt;address&gt;.balance</code>。</li><li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>警告</p><p>编译器没有强制 <code>pure</code> 方法不能读取状态。</p><h3 id="Fallback-函数"><a href="#Fallback-函数" class="headerlink" title="Fallback 函数"></a>Fallback 函数</h3><p>合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值。 如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。</p><p>除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 <code>payable</code>。 如果不存在这样的函数，则合约不能通过常规交易接收以太币。</p><p>在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。</p><p>具体来说，以下操作会消耗比 fallback 函数更多的 gas：</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量 gas 的外部函数</li><li>发送以太币</li></ul><p>请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。</p><p>注解</p><p>即使 fallback 函数不能有参数，仍然可以使用 <code>msg.data</code> 来获取随调用提供的任何有效数据。</p><p>警告</p><p>一个没有定义 fallback 函数的合约，直接接收以太币（没有函数调用，即使用 <code>send</code> 或 <code>transfer</code>）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。所以如果你想让你的合约接收以太币，必须实现 fallback 函数。</p><p>警告</p><p>一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 <code>selfdestruct</code> 的目标来接收以太币。</p><p>一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。</p><p>这也意味着 <code>this.balance</code> 可以高于合约中实现的一些手工记帐的总和（即在 fallback 函数中更新的累加器）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。</span><br><span class="line">    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符</span><br><span class="line">    function() public &#123; x = 1; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span><br><span class="line">contract Sink &#123;</span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    function callTest(Test test) public &#123;</span><br><span class="line">        test.call(0xabcdef01); // 不存在的哈希</span><br><span class="line">        // 导致 test.x 变成 == 1。</span><br><span class="line">        // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。</span><br><span class="line">        // test.send(2 ether）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>合约可以具有多个不同参数的同名函数。这也适用于继承函数。以下示例展示了合约 <code>A</code> 中的重载函数 <code>f</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint _in) public pure returns (uint out) &#123;</span><br><span class="line">        out = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint _in, bytes32 _key) public pure returns (uint out) &#123;</span><br><span class="line">        out = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码无法编译</span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个 <code>f</code> 函数重载都接受了 ABI 的地址类型，虽然它们在 Solidity 中被认为是不同的。</p><h4 id="重载解析和参数匹配"><a href="#重载解析和参数匹配" class="headerlink" title="重载解析和参数匹配"></a>重载解析和参数匹配</h4><p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。如果一个候选都没有，解析失败。</p><p>注解</p><p>返回参数不作为重载解析的依据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code> 也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为 <code>f(uint256)</code> 重载，因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件允许我们方便地使用 EVM 的日志基础设施。 我们可以在 dapp 的用户界面中监听事件，EVM 的日志机制可以反过来“调用”用来监听事件的 Javascript 回调函数。</p><p>事件在合约中可被继承。当他们被调用时，会使参数被存储到交易的日志中 —— 一种区块链中的特殊数据结构。 这些日志与地址相关联，被并入区块链中，只要区块可以访问就一直存在（在 Frontier 和 Homestead 版本中会被永久保存，在 Serenity 版本中可能会改动)。 日志和事件在合约内不可直接被访问（甚至是创建日志的合约也不能访问）。</p><p>对日志的 SPV（Simplified Payment Verification）证明是可能的，如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在于区块链中。 但需要留意的是，由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p><p>最多三个参数可以接收 <code>indexed</code> 属性，从而使它们可以被搜索：在用户界面上可以使用 indexed 参数的特定值来进行过滤。</p><p>如果数组（包括 <code>string</code> 和 <code>bytes</code>）类型被标记为索引项，则它们的 keccak-256 哈希值会被作为 topic 保存。</p><p>除非你用 <code>anonymous</code> 说明符声明事件，否则事件签名的哈希值是 topic 之一。 同时也意味着对于匿名事件无法通过名字来过滤。</p><p>所有非索引参数都将存储在日志的数据部分中。</p><p>注解</p><p>索引参数本身不会被保存。你只能搜索它们的值（来确定相应的日志数据是否存在），而不能获取它们的值本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。</span><br><span class="line">        Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 JavaScript API 调用事件的用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi 由编译器产生 */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* 地址 */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// 监视变化</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // 结果包括对 `Deposit` 的调用参数在内的各种信息。</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 或者通过回调立即开始观察</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="日志的底层接口"><a href="#日志的底层接口" class="headerlink" title="日志的底层接口"></a>日志的底层接口</h3><p>通过函数 <code>log0</code>，<code>log1</code>， <code>log2</code>， <code>log3</code> 和 <code>log4</code> 可以访问日志机制的底层接口。 <code>logi</code> 接受 <code>i + 1</code> 个 <code>bytes32</code> 类型的参数。其中第一个参数会被用来做为日志的数据部分， 其它的会做为 topic。上面的事件调用可以以相同的方式执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的长十六进制数的计算方法是 <code>keccak256(&quot;Deposit(address,hash256,uint256)&quot;)</code>，即事件的签名。</p><h3 id="其它学习事件机制的资源"><a href="#其它学习事件机制的资源" class="headerlink" title="其它学习事件机制的资源"></a>其它学习事件机制的资源</h3><ul><li><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript 文档</a></li><li><a href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件使用例程</a></li><li><a href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">如何在 js 中访问它们</a></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过复制包括多态的代码，Solidity 支持多重继承。</p><p>所有的函数调用都是虚拟的，这意味着最远的派生函数会被调用，除非明确给出合约名称。</p><p>当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约的代码被复制到创建的合约中。</p><p>总的来说，Solidity 的继承系统与 <a href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a> ，非常 相似，特别是多重继承方面。</p><p>下面的例子进行了详细的说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量，</span><br><span class="line">// 但无法通过 this 来外部访问。</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这些抽象合约仅用于给编译器提供接口。</span><br><span class="line">// 注意函数没有函数体。</span><br><span class="line">// 如果一个合约没有实现所有函数，则只能用作接口。</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 可以多重继承。请注意，owned 也是 mortal 的基类，</span><br><span class="line">// 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span><br><span class="line">    // 如果重载函数有不同类型的输出参数，会导致错误。</span><br><span class="line">    // 本地和基于消息的函数调用都会考虑这些重载。</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // 仍然可以调用特定的重载函数。</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果构造函数接受参数，</span><br><span class="line">// 则需要在声明（合约的构造函数）时提供，</span><br><span class="line">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在上边的代码中，我们调用 <code>mortal.kill()</code> 来“转发”销毁请求。 这样做法是有问题的，在下面的例子中可以看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* 清除操作 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* 清除操作 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>Final.kill()</code> 时会调用最远的派生重载函数 <code>Base2.kill</code>，但是会绕过 <code>Base1.kill</code>， 主要是因为它甚至都不知道 <code>Base1</code> 的存在。解决这个问题的方法是使用 <code>super</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* 清除操作 1 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* 清除操作 2 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Base2</code> 调用 <code>super</code> 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的下一个基类合约中调用这个函数，所以它会调用 <code>Base1.kill()</code> （注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, mortal, ownerd）。 在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。</p><h3 id="基类构造函数的参数"><a href="#基类构造函数的参数" class="headerlink" title="基类构造函数的参数"></a>基类构造函数的参数</h3><p>派生合约需要提供基类构造函数需要的所有参数。这可以通过两种方式来完成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法直接在继承列表中调用基类构造函数（<code>is Base(7)</code>）。 另一种方法是像 修饰器modifier 使用方法一样， 作为派生合约构造函数定义头的一部分，（<code>Base(_y * _y)</code>)。 如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。 如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。 如果像这个简单的例子一样，两个地方都用到了，优先使用 修饰器modifier 风格的参数。</p><h3 id="多重继承与线性化"><a href="#多重继承与线性化" class="headerlink" title="多重继承与线性化"></a>多重继承与线性化</h3><p>编程语言实现多重继承需要解决几个问题。 一个问题是 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a>。 Solidity 借鉴了 Python 的方式并且使用“ <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a> ”强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终反映为我们所希望的唯一化的结果，但也使某些继承方式变为无效。尤其是，基类在 <code>is</code> 后面的顺序很重要。 在下面的代码中，Solidity 会给出“ Linearization of inheritance graph impossible ”这样的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码编译出错</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure><p>代码编译出错的原因是 <code>C</code> 要求 <code>X</code> 重写 <code>A</code> （因为定义的顺序是 <code>A, X</code> ）， 但是 <code>A</code> 本身要求重写 <code>X</code>，无法解决这种冲突。</p><p>可以通过一个简单的规则来记忆： 以从“最接近的基类”（most base-like）到“最远的继承”（most derived）的顺序来指定所有的基类。</p><h3 id="继承有相同名字的不同类型成员"><a href="#继承有相同名字的不同类型成员" class="headerlink" title="继承有相同名字的不同类型成员"></a>继承有相同名字的不同类型成员</h3><p>当继承导致一个合约具有相同名字的函数和 修饰器modifier 时，这会被认为是一个错误。 当事件和 修饰器modifier 同名，或者函数和事件同名时，同样会被认为是一个错误。 有一种例外情况，状态变量的 getter 可以覆盖一个 public 函数。</p><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>合约函数可以缺少实现，如下例所示（请注意函数声明头由 <code>;</code> 结尾）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些合约无法成功编译（即使它们除了未实现的函数还包含其他已经实现了的函数），但他们可以用作基类合约:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数，那么它本身就是抽象的。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p><ol><li>无法继承其他合约或接口。</li><li>无法定义构造函数。</li><li>无法定义变量。</li><li>无法定义结构体</li><li>无法定义枚举。</li></ol><p>将来可能会解除这里的某些限制。</p><p>接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。</p><p>接口由它们自己的关键字表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    function transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口。</p><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>库与合约类似，它们只需要在特定的地址部署一次，并且它们的代码可以通过 EVM 的 <code>DELEGATECALL</code> (Homestead 之前使用 <code>CALLCODE</code> 关键字)特性进行重用。 这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，即 <code>this</code> 指向调用合约，特别是可以访问调用合约的存储。 因为每个库都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。 因为我们假定库是无状态的，所以如果它们不修改状态（也就是说，如果它们是 <code>view</code> 或者 <code>pure</code> 函数）， 库函数仅可以通过直接调用来使用（即不使用 <code>DELEGATECALL</code> 关键字）， 特别是，除非能规避 Solidity 的类型系统，否则是不可能销毁任何库的。</p><p>库可以看作是使用他们的合约的隐式的基类合约。虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似 （如果 <code>L</code> 是库的话，可以使用 <code>L.f()</code> 调用库函数）。此外，就像库是基类合约一样，对所有使用库的合约，库的 <code>internal</code> 函数都是可见的。 当然，需要使用内部调用约定来调用内部函数，这意味着所有内部类型，内存类型都是通过引用而不是复制来传递。 为了在 EVM 中实现这些，内部库函数的代码和从其中调用的所有函数都在编译阶段被拉取到调用合约中，然后使用一个 <code>JUMP</code> 调用来代替 <code>DELEGATECALL</code>。</p><p>下面的示例说明如何使用库（但也请务必看看 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#using-for">using for</a> 有一个实现 set 更好的例子）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。</span><br><span class="line">  // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // 已经存在</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // 不存在</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // 不需要库的特定实例就可以调用库函数，</span><br><span class="line">        // 因为当前合约就是“instance”。</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。 函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p><p>调用 <code>Set.contains</code>，<code>Set.insert</code> 和 <code>Set.remove</code> 都被编译为外部调用（ <code>DELEGATECALL</code> ）。 如果使用库，请注意实际执行的是外部函数调用。 <code>msg.sender</code>， <code>msg.value</code> 和 <code>this</code> 在调用中将保留它们的值， （在 Homestead 之前，因为使用了 <code>CALLCODE</code>，改变了 <code>msg.sender</code> 和 <code>msg.value</code>)。</p><p>以下示例展示了如何在库中使用内存类型和内部函数来实现自定义类型，而无需支付外部函数调用的开销：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // 太差了，我们需要增加一个 limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器无法知道库的部署位置，我们需要通过链接器将这些地址填入最终的字节码中 （请参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/using-the-compiler.html#commandline-compiler">使用命令行编译器</a> 以了解如何使用命令行编译器来链接字节码）。 如果这些地址没有作为参数传递给编译器，编译后的十六进制代码将包含 <code>__Set______</code> 形式的占位符（其中 <code>Set</code> 是库的名称）。 可以手动填写地址来将那 40 个字符替换为库合约地址的十六进制编码。</p><p>与合约相比，库的限制：</p><ul><li>没有状态变量</li><li>不能够继承或被继承</li><li>不能接收以太币</li></ul><p>（将来有可能会解除这些限制）</p><h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护</h3><p>如果库的代码是通过 <code>CALL</code> 来执行，而不是 <code>DELEGATECALL</code> 或者 <code>CALLCODE</code> 那么执行的结果会被回退， 除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。</p><p>EVM 没有为合约提供检测是否使用 <code>CALL</code> 的直接方式，但是合约可以使用 <code>ADDRESS</code> 操作码找出正在运行的“位置”。 生成的代码通过比较这个地址和构造时的地址来确定调用模式。</p><p>更具体地说，库的运行时代码总是从一个 push 指令开始，它在编译时是 20 字节的零。当部署代码运行时，这个常数 被内存中的当前地址替换，修改后的代码存储在合约中。在运行时，这导致部署时地址是第一个被 push 到堆栈上的常数， 对于任何 non-view 和 non-pure 函数，调度器代码都将对比当前地址与这个常数是否一致。</p><h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h2><p>指令 <code>using A for B;</code> 可用于附加库函数（从库 <code>A</code>）到任何类型（<code>B</code>）。 这些函数将接收到调用它们的对象作为它们的第一个参数（像 Python 的 <code>self</code> 变量）。</p><p><code>using A for *;</code> 的效果是，库 <code>A</code> 中的函数被附加在任意的类型上。</p><p>在这两种情况下，所有函数都会被附加一个参数，即使它们的第一个参数类型与对象的类型不匹配。 函数调用和重载解析时才会做类型检查。</p><p><code>using A for B;</code> 指令仅在当前作用域有效，目前仅限于在当前合约中，后续可能提升到全局范围。 通过引入一个模块，不需要再添加代码就可以使用包括库函数在内的数据类型。</p><p>让我们用这种方式将 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#libraries">库</a> 中的 set 例子重写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// 这是和之前一样的代码，只是没有注释。</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // 已经存在</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // 不存在</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // 这里是关键的修改</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        // 这里， Set.Data 类型的所有变量都有与之相对应的成员函数。</span><br><span class="line">        // 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以像这样扩展基本类型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return uint(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint _old, uint _new) public &#123;</span><br><span class="line">        // 执行库函数调用</span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        if (index == uint(-1))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        else</span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，所有库调用都是实际的 EVM 函数调用。这意味着如果传递内存或值类型，都将产生一个副本，即使是 <code>self</code> 变量。 使用存储引用变量是唯一不会发生拷贝的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;合约&quot;&gt;&lt;a href=&quot;#合约&quot; class=&quot;headerlink&quot; title=&quot;合约&quot;&gt;&lt;/a&gt;合约&lt;/h1&gt;&lt;p&gt;Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="https://www.zhengcookie.site/2025/07/08/vue/"/>
    <id>https://www.zhengcookie.site/2025/07/08/vue/</id>
    <published>2025-07-08T07:13:08.000Z</published>
    <updated>2025-10-01T04:54:48.515Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1621612367141-93b24efc-8b06-4c10-8259-586cd8c6c5d5.webp" alt="img"></p><h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1620128979608-f7465ffc-9411-43e3-a6bc-96ab44dd77df.png" alt="img"></p><h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1618656573096-ebdc520c-5d60-4d12-ad04-5df4ebbb5fe7.png" alt="img"></p><h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1603814137582-5a9aa62f-0045-4272-bef0-447dedb25596.png" alt="img"></p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1603814104939-8c8ac923-735d-4476-937a-cb1f795ffe84.png" alt="img"></p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><p><strong>对于Watch：</strong></p><ul><li><p>它不支持缓存，数据变化时，它就会触发相应的操作</p></li><li><p>支持异步监听</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</p></li><li><p>当一个属性发生变化时，就需要执行相应的操作</p></li><li><p>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</p></li><li><ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><strong>总结：</strong></p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><p><strong>运用场景：</strong> </p><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 </p><p><strong>不同点：</strong> </p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在LocalStorage &#x2F; SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p><p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行</p><p>被包裹在keep-alive中的组件的状态将会被保留：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/kepp-alive&gt;</span><br></pre></td></tr></table></figure><p><strong>router.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../src/views/xxx.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code> ：只会触发一次。</li></ul><h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul><h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul><h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong></p><p>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">//$event 指代当前触发的事件对象;</span></span><br><span class="line"><span class="language-xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="language-xml">//$event.target.value 就是当前dom的value值;</span></span><br><span class="line"><span class="language-xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="language-xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure><p><strong>（2）作用在组件上</strong></p><p>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p><p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong>因此父组件 v-model 语法糖本质上可以修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :value=<span class="string">&quot;message&quot;</span>  @input=<span class="string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">onmessage</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。</p><h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p><h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p><strong>（1）****keep-alive</strong></p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><p><strong>（2）keep-alive 的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">patternTypes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt; = [<span class="title class_">String</span>, <span class="title class_">RegExp</span>, <span class="title class_">Array</span>] <span class="comment">// 接收：字符串，正则，数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  <span class="attr">abstract</span>: <span class="literal">true</span>, <span class="comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: patternTypes, <span class="comment">// 匹配的组件，缓存</span></span><br><span class="line">    <span class="attr">exclude</span>: patternTypes, <span class="comment">// 不去匹配的组件，不缓存</span></span><br><span class="line">    <span class="attr">max</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>], <span class="comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁缓存cache的组件实例</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">      <span class="title function_">pruneCacheEntry</span>(<span class="variable language_">this</span>.<span class="property">cache</span>, key, <span class="variable language_">this</span>.<span class="property">keys</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// prune 削减精简[v.]</span></span><br><span class="line">    <span class="comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span></span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="title function_">matches</span>(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">pruneCache</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> !<span class="title function_">matches</span>(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>render函数：</strong></p><ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li><li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li><li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span> () &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFirstComponentChild</span> (<span class="params">children: ?<span class="built_in">Array</span>&lt;VNode&gt;</span>): ?<span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(c) &amp;&amp; (<span class="title function_">isDef</span>(c.<span class="property">componentOptions</span>) || <span class="title function_">isAsyncPlaceholder</span>(c))) &#123;</span><br><span class="line">      <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> <span class="comment">// 获取默认插槽</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vnode</span>: <span class="title class_">VNode</span> = <span class="title function_">getFirstComponentChild</span>(slot)<span class="comment">// 获取第一个子组件</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">componentOptions</span>: ?<span class="title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="property">componentOptions</span> <span class="comment">// 组件参数</span></span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 是否有组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: ?string = <span class="title function_">getComponentName</span>(componentOptions) <span class="comment">// 获取组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      (include &amp;&amp; (!name || !<span class="title function_">matches</span>(include, name))) ||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; <span class="title function_">matches</span>(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 如果不匹配当前组件的名字和include以及exclude</span></span><br><span class="line">      <span class="comment">// 那么直接返回组件的实例</span></span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取这个组件的key</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">key</span>: ?string = vnode.<span class="property">key</span> == <span class="literal">null</span></span><br><span class="line">      <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      ? componentOptions.<span class="property">Ctor</span>.<span class="property">cid</span> + (componentOptions.<span class="property">tag</span> ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      : vnode.<span class="property">key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="comment">// LRU缓存策略执行</span></span><br><span class="line">      vnode.<span class="property">componentInstance</span> = cache[key].<span class="property">componentInstance</span> <span class="comment">// 组件初次渲染的时候componentInstance为undefined</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// make current key freshest</span></span><br><span class="line">      <span class="title function_">remove</span>(keys, key)</span><br><span class="line">      keys.<span class="title function_">push</span>(key)</span><br><span class="line">      <span class="comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span></span><br><span class="line">      <span class="comment">// 使用时间间隔最长的一个</span></span><br><span class="line">      cache[key] = vnode</span><br><span class="line">      keys.<span class="title function_">push</span>(key)</span><br><span class="line">      <span class="comment">// prune oldest entry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">max</span> &amp;&amp; keys.<span class="property">length</span> &gt; <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">max</span>)) &#123;</span><br><span class="line">        <span class="title function_">pruneCacheEntry</span>(cache, keys[<span class="number">0</span>], keys, <span class="variable language_">this</span>.<span class="property">_vnode</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将组件的keepAlive属性设置为true</span></span><br><span class="line">    vnode.<span class="property">data</span>.<span class="property">keepAlive</span> = <span class="literal">true</span> <span class="comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p><p><strong>实现步骤：</strong></p><ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li></ol><ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul><ol><li>最后将这个组件的 keepAlive 设置为 true</li></ol><p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p><p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p><p><strong>首次渲染</strong></p><ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initLifecycle</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.<span class="property">parent</span></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123; <span class="comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span></span><br><span class="line">    <span class="keyword">while</span> (parent.<span class="property">$options</span>.<span class="property">abstract</span> &amp;&amp; parent.<span class="property">$parent</span>) &#123;</span><br><span class="line">      parent = parent.<span class="property">$parent</span></span><br><span class="line">    &#125;</span><br><span class="line">    parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$parent</span> = parent</span><br><span class="line">  vm.<span class="property">$root</span> = parent ? parent.<span class="property">$root</span> : vm</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$children</span> = []</span><br><span class="line">  vm.<span class="property">$refs</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">_watcher</span> = <span class="literal">null</span></span><br><span class="line">  vm.<span class="property">_inactive</span> = <span class="literal">null</span></span><br><span class="line">  vm.<span class="property">_directInactive</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isDestroyed</span> = <span class="literal">false</span></span><br><span class="line">  vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vdom/create-component</span></span><br><span class="line"><span class="title function_">init</span> (<span class="attr">vnode</span>: <span class="title class_">VNodeWithData</span>, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.<span class="property">componentInstance</span> &amp;&amp;</span><br><span class="line">      !vnode.<span class="property">componentInstance</span>.<span class="property">_isDestroyed</span> &amp;&amp;</span><br><span class="line">      vnode.<span class="property">data</span>.<span class="property">keepAlive</span></span><br><span class="line">    ) &#123; <span class="comment">// componentInstance在初次是undefined!!!</span></span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">mountedNode</span>: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.<span class="title function_">prepatch</span>(mountedNode, mountedNode) <span class="comment">// prepatch函数执行的是组件更新的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.<span class="property">componentInstance</span> = <span class="title function_">createComponentInstanceForVnode</span>(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p><p><strong>（4）LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。</p><p>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是**”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ </p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p><p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据的操作...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p><h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="title function_">data</span> () &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">return</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">obj</span>: &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="attr">a</span>: <span class="string">&#x27;obj.a&#x27;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="attr">methods</span>: &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="title function_">addObjB</span> () &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">b</span> = <span class="string">&#x27;obj.b&#x27;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addObjB</span> () (</span><br><span class="line">   <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;obj.b&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。</p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1604019269329-d88e91cf-b33d-4b2d-b014-e5739e9b7dbc.png" alt="img"></p><p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">// 实现 arrayMethods.__proto__ === Array.prototype</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto);</span><br><span class="line"><span class="comment">// 需要进行功能拓展的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&quot;push&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;splice&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reverse&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// 缓存原生数组方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行并缓存原生数组功能</span></span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="comment">// 响应式处理</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span>;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">    <span class="comment">// push、unshift会新增索引，所以要手动observer</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted);<span class="comment">// 获取插入的值，并设置响应式监听</span></span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>();<span class="comment">// 通知依赖更新</span></span><br><span class="line">    <span class="comment">// 返回原生数组方法的执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><strong>区别：</strong></p><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1609521413572-54d0bd0f-8ed6-4438-997a-c890e4cd9c5e.jpeg" alt="img"></p><h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p><p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将模板编译为render函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template,options<span class="comment">//省略&#125;, this)</span></span><br></pre></td></tr></table></figure><p>CompileToFunctions中的主要逻辑如下∶</p><p><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br></pre></td></tr></table></figure><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul><p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p><p><strong>（2）对静态节点做优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">optimize</span>(ast,options)</span><br></pre></td></tr></table></figure><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p><p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p><p><strong>（3）生成代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br></pre></td></tr></table></figure><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p><h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong></p><p>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1609518480272-8cb1af01-a4a8-4d54-91bb-5546aafac510.jpeg" alt="img"></p><p><strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!child.<span class="property">_base</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(child.<span class="property">extends</span>) &#123;</span><br><span class="line">        parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">extends</span>, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child.<span class="property">mixins</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++)&#123;</span><br><span class="line">            parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p><strong>只能通过</strong> <code>**$emit**</code> <strong>派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p><h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defieneReactive</span> (<span class="params">obj, key, val</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。</p><p><strong>（1）Dep</strong></p><p>Dep是整个依赖收集的核心，其关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> target;</span><br><span class="line">  subs;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span> (sub) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeSub</span> (sub) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">sub</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subds</span>.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; subs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p><p><strong>（2）Watcher</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  getter;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params">vm, expression</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = expression;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span> () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>);</span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addDep</span> (dep)&#123;</span><br><span class="line">        ...</span><br><span class="line">    dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="params">_target</span>) &#123;</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p><p><strong>（3）过程</strong></p><p>在实例化 Vue 时，依赖收集的相关过程如下∶</p><p>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。</p><p>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent)</span><br></pre></td></tr></table></figure><p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p><p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p><h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p><p><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React &#x3D;&#x3D;&gt; Create React APP</li><li>Vue &#x3D;&#x3D;&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React &#x3D;&#x3D;&gt; React Native</li><li>Vue &#x3D;&#x3D;&gt; Weex</li></ul><h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li></ul><h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arr</span>, <span class="number">0</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变数组</span></span><br><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变对象</span></span><br></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">splice</span>()、 <span class="title function_">push</span>()、<span class="title function_">pop</span>()、<span class="title function_">shift</span>()、<span class="title function_">unshift</span>()、<span class="title function_">sort</span>()、<span class="title function_">reverse</span>()</span><br></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul><h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p><p>SSR的优势：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>SSR的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking&#x2F;Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">    <span class="attr">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Component</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Component</span>().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">SuperComponent</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">Component</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SuperComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SuperComponent</span>().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点**?**"></a>42. <strong>MVVM</strong>的优缺点**?**</h3><p>优点: </p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 </li><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 </li><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li></ul><p>缺点: </p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 </li><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 </li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li></ul><h3 id="43-v-if和v-for哪个优先级更高？如果同时出现，应如何优化？"><a href="#43-v-if和v-for哪个优先级更高？如果同时出现，应如何优化？" class="headerlink" title="43. v-if和v-for哪个优先级更高？如果同时出现，应如何优化？"></a>43. <strong>v-if<strong><strong>和</strong></strong>v-for哪个优先级更高？如果同时出现，应如何优化？</strong></h3><p>v-for优先于v-if被解析，如果同时出现，每次渲染都会<strong>先执行循环再判断条件</strong>，无论如何循环都不可避免，浪费了性能。</p><p>要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。</p><h3 id="44-对Vue组件化的理解"><a href="#44-对Vue组件化的理解" class="headerlink" title="44. 对Vue组件化的理解"></a>44. 对Vue组件化的理解</h3><ol><li>组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；</li><li>组件化开发能大幅提高应用开发效率、测试性、复用性等；</li><li>组件使用按分类有：页面组件、业务组件、通用组件；</li><li>vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue；</li><li>vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能；</li><li>组件应该是高内聚、低耦合的；</li><li>遵循单向数据流的原则。</li></ol><h3 id="45-对vue设计原则的理解"><a href="#45-对vue设计原则的理解" class="headerlink" title="45. 对vue设计原则的理解"></a>45. 对vue设计原则的理解</h3><ol><li><strong>渐进式JavaScript框架</strong>：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。</li><li><strong>易用性</strong>：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。</li><li><strong>灵活性</strong>：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。</li><li><strong>高效性：</strong>超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。</li></ol><h3 id="46-常见的Vue性能优化方法"><a href="#46-常见的Vue性能优化方法" class="headerlink" title="46. 常见的Vue性能优化方法"></a>46. 常见的Vue性能优化方法</h3><ol><li>路由懒加载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; routes: [</span><br><span class="line">  &#123; path: &#x27;/foo&#x27;, component: () =&gt; import(&#x27;./Foo.vue&#x27;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>keep-alive缓存页面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ol><li>使用v-show复用DOM</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">     &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt;</span><br><span class="line">     &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt;</span><br><span class="line">        &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt;</span><br><span class="line">        &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">     &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><ol><li>v-for 遍历避免同时使用 v-if</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt;</span><br><span class="line">&#123;&#123; user.name &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; </span><br><span class="line">  computed: &#123;</span><br><span class="line">activeUsers: function () &#123;</span><br><span class="line">return this.users.filter(function (user) &#123; </span><br><span class="line">        return user.isActive</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>长列表性能优化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化</span><br><span class="line">export default &#123; </span><br><span class="line">data: () =&gt; (&#123;</span><br><span class="line">users: []</span><br><span class="line">&#125;),</span><br><span class="line">async created() &#123;</span><br><span class="line">const users = await axios.get(&quot;/api/users&quot;); </span><br><span class="line">this.users = Object.freeze(users);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</span><br><span class="line">&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt;</span><br><span class="line">&lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line"> &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot;/&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/recycle-scroller&gt;</span><br></pre></td></tr></table></figure><ol><li>事件的销毁</li></ol><p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">this.timer = setInterval(this.refresh, 2000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123; </span><br><span class="line">clearInterval(this.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>图片懒加载</li></ol><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure><ol><li>第三方插件按需引入</li></ol><p>像element-ui这样的第三方组件库可以按需引入避免体积太大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(Button) Vue.use(Select)</span><br></pre></td></tr></table></figure><ol><li>无状态的组件标记为函数式组件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">&lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; props: [&#x27;value&#x27;] &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>子组件分隔</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ChildComp/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; </span><br><span class="line">    components: &#123;</span><br><span class="line">ChildComp: &#123; </span><br><span class="line">        methods: &#123;</span><br><span class="line">heavy () &#123; /* 耗时任务 */ &#125;</span><br><span class="line">&#125;,</span><br><span class="line">render (h) &#123;</span><br><span class="line">return h(&#x27;div&#x27;, this.heavy())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>变量本地化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt;</span><br><span class="line">&#123;&#123; result &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; heavy &#125; from &#x27;@/utils&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123; </span><br><span class="line">  props: [&#x27;start&#x27;], </span><br><span class="line">  computed: &#123;</span><br><span class="line">base () &#123; </span><br><span class="line">      return 42 </span><br><span class="line">    &#125;, </span><br><span class="line">    result () &#123;</span><br><span class="line">const base = this.base // 不要频繁引用this.base</span><br><span class="line">let result = this.start</span><br><span class="line">for (let i = 0; i &lt; 1000; i++) &#123; </span><br><span class="line">        result += heavy(base)</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="47-v-model的实现原理"><a href="#47-v-model的实现原理" class="headerlink" title="47. v-model的实现原理"></a>47. v-model的实现原理</h3><p>vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。</p><p>实现原理：</p><ul><li>v-bind绑定响应数据</li><li>触发input事件并传递数据</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// 等价于：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;text = $event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">// 组件中使用：</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">:value</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">// 根据v-model原理模拟：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ipt1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ipt2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ipt1=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ipt2=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    ipt1.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        ipt2.<span class="property">value</span>=ipt1.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </p><ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li><strong>created****（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li><li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p><h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><p>1.父组件 beforeCreate</p><p>2.父组件 created</p><p>3.父组件 beforeMount</p><p>4.子组件 beforeCreate</p><p>5.子组件 created</p><p>6.子组件 beforeMount</p><p>7.子组件 mounted</p><p>8.父组件 mounted</p><p><strong>更新过程：</strong></p><ol><li>父组件 beforeUpdate</li></ol><p>2.子组件 beforeUpdate</p><p>3.子组件 updated</p><p>4.父组件 updated</p><p><strong>销毁过程：</strong></p><ol><li>父组件 beforeDestroy</li></ol><p>2.子组件 beforeDestroy</p><p>3.子组件 destroyed</p><p>4.父组件 destoryed</p><h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p><h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  &#x2F;  $emit"></a>（1） props  &#x2F;  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:msg</span>=<span class="string">&quot;msgData&quot;</span> <span class="attr">:fn</span>=<span class="string">&quot;myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> son <span class="keyword">from</span> <span class="string">&quot;./son.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: father,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">msgData</span>: <span class="string">&quot;父组件数据&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vue&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        son</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>: <span class="string">&quot;son&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;fn&quot;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">onEmitIndex</span>=<span class="string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;comArticle&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; comArticle &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">articleList</span>: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onEmitIndex</span>(<span class="params">idx</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">currentIndex</span> = idx</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;articles&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emitIndex</span>(<span class="params">index</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;onEmitIndex&#x27;</span>, index) <span class="comment">// 触发父组件的方法，并传递参数index</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit &#x2F; $on）"></a>（2）eventBus事件总线（$emit &#x2F; $on）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p><p><strong>（1）创建事件中心管理组件之间的通信</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure><p><strong>（2）发送事件</strong></p><p>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">first-com</span>&gt;</span><span class="tag">&lt;/<span class="name">first-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">second-com</span>&gt;</span><span class="tag">&lt;/<span class="name">second-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> firstCom <span class="keyword">from</span> <span class="string">&#x27;./firstCom.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> secondCom <span class="keyword">from</span> <span class="string">&#x27;./secondCom.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; firstCom, secondCom &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在<code>firstCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>加法<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;<span class="title class_">EventBus</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span> <span class="comment">// 引入事件中心</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">num</span>:<span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">EventBus</span>.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">num</span>:<span class="variable language_">this</span>.<span class="property">num</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>（3）接收事件</strong></p><p>在<code>secondCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; <span class="title class_">EventBus</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">EventBus</span>.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">count</span> = <span class="variable language_">this</span>.<span class="property">count</span> + param.<span class="property">num</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide&#x2F; inject）"></a>（3）依赖注入（provide&#x2F; inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">num</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;num&#x27;</span>]</span><br></pre></td></tr></table></figure><p>还可以这样写，这样写就可以访问父组件中的所有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">num</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（3）ref-refs"><a href="#（3）ref-refs" class="headerlink" title="（3）ref &#x2F; $refs"></a>（3）ref &#x2F; $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">sayHello</span> () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">mounted</span> () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="property">name</span>);  <span class="comment">// JavaScript</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="title function_">sayHello</span>();  <span class="comment">// hello</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent &#x2F; $children"></a>（4）$parent &#x2F; $children</h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">parentVal</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">msg</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello_world&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">change</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 获取到子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="property">message</span> = <span class="string">&#x27;JavaScript&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。</p><p><strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs &#x2F; $listeners"></a>（5）$attrs &#x2F; $listeners</h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><p>A组件（<code>APP.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        //此处监听了两个事件，可以在B组件或者C组件中直接触发 </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">child1</span> <span class="attr">:p-child1</span>=<span class="string">&quot;child1&quot;</span> <span class="attr">:p-child2</span>=<span class="string">&quot;child2&quot;</span> @<span class="attr">test1</span>=<span class="string">&quot;onTest1&quot;</span> @<span class="attr">test2</span>=<span class="string">&quot;onTest2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child1</span> <span class="keyword">from</span> <span class="string">&#x27;./Child1.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; <span class="title class_">Child1</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">onTest1</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1 running&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">onTest2</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test2 running&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>B组件（<code>Child1.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">child2</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child2</span> <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild1&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>: &#123; <span class="title class_">Child2</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;test1&#x27;</span>); <span class="comment">// 触发APP.vue中的test1方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>C 组件 (<code>Child2.vue</code>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild2&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;test2&#x27;</span>);<span class="comment">// 触发APP.vue中的test2方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul><h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li><li>使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 $parent&#x2F;$refs 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><p>非懒加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/list.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（1）方案一(常用)：使用箭头函数+import动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（2）方案二：使用箭头函数+require动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r就是resolve</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = r =&gt; <span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="built_in">require</span>(<span class="string">&#x27;@/components/list&#x27;</span>)), <span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">List</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="2-路由的hash和history模式的区别"><a href="#2-路由的hash和history模式的区别" class="headerlink" title="2. 路由的hash和history模式的区别"></a>2. 路由的hash和history模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p><h4 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h4><p><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="http://www.abc.com/#/vue%EF%BC%8C%E5%AE%83%E7%9A%84hash%E5%80%BC%E5%B0%B1%E6%98%AF%60#/vue%60%E3%80%82">http://www.abc.com/#/vue，它的hash值就是`#/vue`。</a></p><p><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">oldURL</span>, event.<span class="property">newURL</span>);</span><br><span class="line"><span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p><h4 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h4><p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</p><p><strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="http://abc.com/user/id%E3%80%82%E7%9B%B8%E6%AF%94hash%E6%A8%A1%E5%BC%8F%E6%9B%B4%E5%8A%A0%E5%A5%BD%E7%9C%8B%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8Chistory%E6%A8%A1%E5%BC%8F%E9%9C%80%E8%A6%81%E5%90%8E%E5%8F%B0%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E3%80%82%E5%A6%82%E6%9E%9C%E5%90%8E%E5%8F%B0%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%97%B6%E4%BC%9A%E8%BF%94%E5%9B%9E404%E3%80%82">http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</a></p><p><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p><p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h4><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用。</li><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul><p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p><h3 id="3-如何获取页面的hash变化"><a href="#3-如何获取页面的hash变化" class="headerlink" title="3. 如何获取页面的hash变化"></a>3. 如何获取页面的hash变化</h3><p><strong>（1）监听$route的变化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听,当路由发生变化的时候执行</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">$route</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">val, oldVal</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 深度观察监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>（2）window.location.hash读取#值</strong></p><p>window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p><h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. $route 和$router 的区别"></a>4. $route 和$router 的区别</h3><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><p><strong>（1）param方式</strong></p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递的方式：在path后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2）路由跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;users&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">uname</span>:wade&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user/&#x27;</span> + wade)</span><br></pre></td></tr></table></figure><p>3）参数获取</p><p>通过 <code>$route.params.userid</code> 获取传递的值</p><p><strong>（2）query方式</strong></p><ul><li>配置路由格式：<code>/router</code>，也就是普通配置</li><li>传递的方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：<code>/route?id=123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在router-link 标签上以对象的形式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：写成按钮以点击事件形式</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="title function_">profileClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;kobi&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">198</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）跳转方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user?uname=&#x27;</span> + jsmes)</span><br></pre></td></tr></table></figure><p>3）获取参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过$route.<span class="property">query</span> 获取传递的值</span><br></pre></td></tr></table></figure><h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p><p>为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><ol><li>全局路由钩子</li></ol><p>全局有三个路由钩子;</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ul><p>具体使用∶</p><ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> ifInfo = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$common</span>.<span class="title function_">getSession</span>(<span class="string">&#x27;userData&#x27;</span>);  <span class="comment">// 判断是否登录的存储信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ifInfo) &#123; </span><br><span class="line">        <span class="comment">// sessionStorage里没有储存user信息    </span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//如果是登录页面路径，就直接next()      </span></span><br><span class="line">            <span class="title function_">next</span>();    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">//不然就跳转到登录      </span></span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">warning</span>(<span class="string">&quot;请重新登录！&quot;</span>);     </span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$loginUrl</span>;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">next</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 跳转之后滚动条回到顶部  </span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>单个路由独享钩子</li></ol><p><strong>beforeEnter</strong></p><p>如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,        </span><br><span class="line">        <span class="attr">component</span>: login,        </span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;          </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;即将进入登录页面&#x27;</span>)          </span><br><span class="line">            <span class="title function_">next</span>()        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li>组件内钩子</li></ol><p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p><p>这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;      </span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">target</span> =&gt;</span> &#123;        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&#x27;/classProcess&#x27;</span>) &#123;          </span><br><span class="line">            target.<span class="property">isFromProcess</span> = <span class="literal">true</span>        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、Vue路由钩子在生命周期函数的体现</p><ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫beforeRouteLeave</li><li>调用局前置守卫∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发DOM更新（mounted）。</li><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><ol><li>触发钩子的完整顺序</li></ol><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问&#x2F;操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。 </li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h3 id="7-Vue-router跳转和location-href有什么区别"><a href="#7-Vue-router跳转和location-href有什么区别" class="headerlink" title="7. Vue-router跳转和location.href有什么区别"></a>7. Vue-router跳转和location.href有什么区别</h3><ul><li>使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul><h3 id="8-params和query的区别"><a href="#8-params和query的区别" class="headerlink" title="8. params和query的区别"></a>8. params和query的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p><p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p><h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul><li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p><p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p><p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p><ul><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li><li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li></ul><p>为了解决这个问题，前端路由出现了。</p><p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p><p>那么如何实现这个目的呢？首先要解决两个问题：</p><ul><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li><li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ul><p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p><ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul><h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1609522434579-ff590978-32e1-4cf5-bbbd-d8caf932f8d6.png" alt="img"></p><p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 </p><p><strong>（1）核心流程中的主要功能：</strong></p><ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><p><strong>（2）各模块在核心流程中的主要功能：</strong></p><ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><p><strong>总结：</strong></p><p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。</p><h3 id="2-Vuex中action和mutation的区别"><a href="#2-Vuex中action和mutation的区别" class="headerlink" title="2. Vuex中action和mutation的区别"></a>2. Vuex中action和mutation的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span> (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++      <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而Action类似于mutation，不同点在于：</p><ul><li>Action 可以包含任意异步操作。</li><li>Action 提交的是 mutation，而不是直接变更状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span> (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span> (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><p>所以，两者的不同点如下：</p><ul><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li><li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li><li>在视图更新时，先触发actions，actions再触发mutation</li><li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li></ul><h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><p><strong>（1）最重要的区别</strong></p><ul><li>vuex存储在内存中</li><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li></ul><p><strong>（2）应用场景</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><li>Vuex能做到数据的响应式，localstorage不能</li></ul><p><strong>（3）永久性</strong></p><p>刷新页面时vuex存储的值会丢失，localstorage不会。</p><p><strong>注意：</strong>对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p><h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p><p><strong>（2）共同思想</strong></p><ul><li>单—的数据源 </li><li>变化可以预测</li></ul><p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;</p><p>形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p><h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p><p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p><p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p><h3 id="6-Vuex有哪几种属性？"><a href="#6-Vuex有哪几种属性？" class="headerlink" title="6. Vuex有哪几种属性？"></a>6. Vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><ul><li>state &#x3D;&gt; 基本数据(数据源存放地)</li><li>getters &#x3D;&gt; 从基本数据派生出来的数据</li><li>mutations &#x3D;&gt; 提交更改数据的方法，同步</li><li>actions &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。</li><li>modules &#x3D;&gt; 模块化Vuex</li></ul><h3 id="7-Vuex和单纯的全局对象有什么区别？"><a href="#7-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex和单纯的全局对象有什么区别？"></a>7. Vuex和单纯的全局对象有什么区别？</h3><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li></ul><h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h3 id="9-Vuex的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    strict:true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-如何在组件中批量使用Vuex的getter属性"><a href="#10-如何在组件中批量使用Vuex的getter属性" class="headerlink" title="10. 如何在组件中批量使用Vuex的getter属性"></a>10. 如何在组件中批量使用Vuex的getter属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;total&#x27;</span>,<span class="string">&#x27;discountTotal&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-如何在组件中重复使用Vuex的mutation"><a href="#11-如何在组件中重复使用Vuex的mutation" class="headerlink" title="11. 如何在组件中重复使用Vuex的mutation"></a>11. 如何在组件中重复使用Vuex的mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p><h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0有什么更新"><a href="#1-Vue3-0有什么更新" class="headerlink" title="1. Vue3.0有什么更新"></a>1. Vue3.0有什么更新</h3><p><strong>（1）监测机制的改变</strong></p><ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul><p><strong>（2）只能监测属性，不能监测对象</strong></p><ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p><strong>（3）模板</strong></p><ul><li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul><p><strong>（4）对象式的组件声明方式</strong></p><ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul><p><strong>（5）其它方面的更改</strong></p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h3 id="2-defineProperty和proxy的区别"><a href="#2-defineProperty和proxy的区别" class="headerlink" title="2. defineProperty和proxy的区别"></a>2. defineProperty和proxy的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。这样当追踪数据发生变化时，setter 会被自动调用。</p><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>但是这样做有以下问题：</p><ol><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li><li>无法监控到数组下标和长度的变化。</li></ol><p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p><ol><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li></ol><h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p> Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ </p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li></ul><h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4.  Vue 3.0 中的 Vue Composition API？"></a>4.  Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p><ol><li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li><li>Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li></ol><p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p><p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Count: &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      count.<span class="property">value</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="comment">// 对应于Vue2中的mounted声明周期</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;component mounted!&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      count,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      increment</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p><h3 id="5-Composition-API与React-Hook很像，区别是什么"><a href="#5-Composition-API与React-Hook很像，区别是什么" class="headerlink" title="5. Composition API与React Hook很像，区别是什么"></a>5. Composition API与React Hook很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p><ul><li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li><li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li><li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li></ul><h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong></p><p>看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM</strong> <strong>-&gt;</strong> <strong>生成 CSSOM</strong> <strong>-&gt;</strong> <strong>Layout</strong> <strong>-&gt;</strong> <strong>Paint</strong> <strong>-&gt;</strong> <strong>Compiler</strong></p><p>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p><ul><li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li><li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li></ul><p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。</p><p><strong>（2）跨平台</strong></p><p>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p><h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul><li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li><li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li></ul><h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li>匹配时，找到相同的子节点，递归比较子节点</li></ul><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="6-Vue中key的作用"><a href="#6-Vue中key的作用" class="headerlink" title="6. Vue中key的作用"></a>6. Vue中key的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p><ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><h3 id="7-为什么不建议用index作为key"><a href="#7-为什么不建议用index作为key" class="headerlink" title="7. 为什么不建议用index作为key?"></a>7. 为什么不建议用index作为key?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://zhengcookie.github.io/file/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue/1621612367141-93b24efc-8b06-4c10-8259-586c</summary>
      
    
    
    
    <category term="前端面试题" scheme="https://www.zhengcookie.site/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="vue" scheme="https://www.zhengcookie.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>表达式和控制结构</title>
    <link href="https://www.zhengcookie.site/2025/07/08/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://www.zhengcookie.site/2025/07/08/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2025-07-08T06:36:03.000Z</published>
    <updated>2025-10-01T04:54:48.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入参数和输出参数"><a href="#输入参数和输出参数" class="headerlink" title="输入参数和输出参数"></a>输入参数和输出参数</h2><p>与 Javascript 一样，函数可能需要参数作为输入; 而与 Javascript 和 C 不同的是，它们可能返回任意数量的参数作为输出。</p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同。但是有一个例外，未使用的参数可以省略参数名。 例如，如果我们希望合约接受有两个整数形参的函数的外部调用，我们会像下面这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function taker(uint _a, uint _b) public pure &#123;</span><br><span class="line">        // 用 _a 和 _b 实现相关功能.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数的声明方式在关键词 <code>returns</code> 之后，与输入参数的声明方式相同。 例如，如果我们需要返回两个结果：两个给定整数的和与积，我们应该写作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function arithmetics(uint _a, uint _b)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint o_sum, uint o_product)</span><br><span class="line">    &#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出参数名可以被省略。输出值也可以使用 <code>return</code> 语句指定。 <code>return</code> 语句也可以返回多值，参阅：ref:multi-return。 返回的输出参数被初始化为 0；如果它们没有被显式赋值，它们就会一直为 0。</p><p>输入参数和输出参数可以在函数体中用作表达式。因此，它们也可用在等号左边被赋值。</p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>JavaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 <code>switch</code> 和 <code>goto</code>。 因此 Solidity 中有 <code>if</code>，<code>else</code>，<code>while</code>，<code>do</code>，<code>for</code>，<code>break</code>，<code>continue</code>，<code>return</code>，<code>? :</code> 这些与在 C 或者 JavaScript 中表达相同语义的关键词。</p><p>用于表示条件的括号 <em>不可以</em> 被省略，单语句体两边的花括号可以被省略。</p><p>注意，与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 <code>if (1) &#123; ... &#125;</code> 的写法在 Solidity 中 <em>无效</em> 。</p><p>返回多个值</p><hr><p>当一个函数有多个输出参数时， <code>return (v0, v1, ...,vn)</code> 写法可以返回多个值。不过元素的个数必须与输出参数的个数相同。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g(uint a) public pure returns (uint ret) &#123; return f(); &#125;</span><br><span class="line">    function f() internal pure returns (uint ret) &#123; return g(7) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数调用在 EVM 中被解释为简单的跳转。这样做的效果就是当前内存不会被清除，也就是说，通过内部调用在函数之间传递内存引用是非常有效的。</p><h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>表达式 <code>this.g(8);</code> 和 <code>c.g(2);</code> （其中 <code>c</code> 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来被“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。</p><p>如果想要调用其他合约的函数，需要外部调用。对于一个外部调用，所有的函数参数都需要被复制到内存。</p><p>当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项 <code>.value()</code> 和 <code>.gas()</code> 指定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>payable</code> 修饰符要用于修饰 <code>info</code>，否则，.value() 选项将不可用。</p><p>注意，表达式 <code>InfoFeed(addr)</code> 进行了一个的显式类型转换，说明”我们知道给定地址的合约类型是 <code>InfoFeed</code> “并且这不会执行构造函数。 显式类型转换需要谨慎处理。绝对不要在一个你不清楚类型的合约上执行函数调用。</p><p>我们也可以直接使用 <code>function setFeed(InfoFeed _feed) &#123; feed = _feed; &#125;</code> 。 注意一个事实，<code>feed.info.value(10).gas(800)</code> 只（局部地）设置了与函数调用一起发送的 Wei 值和 gas 的数量，只有最后的圆括号执行了真正的调用。</p><p>如果被调函数所在合约不存在（也就是账户中不包含代码）或者被调用合约本身抛出异常或者 gas 用完等，函数调用会抛出异常。</p><p>警告</p><p>任何与其他合约的交互都会强加潜在危险，尤其是在不能预先知道合约代码的情况下。 当前合约将控制权移交给被调用合约，而被调用合约可能做任何事。即使被调用合约从一个已知父合约继承，继承的合约也只需要有一个正确的接口就可以了。 被调用合约的实现可以完全任意，因此会带来危险。此外，请小心万一它再调用你系统中的其他合约，或者甚至在第一次调用返回之前返回到你的调用合约。 这意味着被调用合约可以通过它自己的函数改变调用合约的状态变量。。一个建议的函数写法是，例如，在你合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入 (reentrancy) 所影响</p><h3 id="具名调用和匿名函数参数"><a href="#具名调用和匿名函数参数" class="headerlink" title="具名调用和匿名函数参数"></a>具名调用和匿名函数参数</h3><p>如果它们被包含在 <code>&#123;&#125;</code> 中，函数调用参数也可以按照任意顺序由名称给出， 如以下示例中所示。参数列表必须按名称与函数声明中的参数列表相符，但可以按任意顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint key, uint value) public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // 具名参数</span><br><span class="line">        f(&#123;value: 2, key: 3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略函数参数名称"><a href="#省略函数参数名称" class="headerlink" title="省略函数参数名称"></a>省略函数参数名称</h3><p>未使用参数的名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 省略参数名称</span><br><span class="line">    function func(uint k, uint) public pure returns(uint) &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-new-创建合约"><a href="#通过-new-创建合约" class="headerlink" title="通过 new 创建合约"></a>通过 <code>new</code> 创建合约</h2><p>使用关键字 <code>new</code> 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // 将作为合约 C 构造函数的一部分执行</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">                //随合约的创建发送 ether</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如示例中所示，使用 <code>.value（）</code> 选项创建 <code>D</code> 的实例时可以转发 Ether，但是不可能限制 gas 的数量。如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。</p><h2 id="表达式计算顺序"><a href="#表达式计算顺序" class="headerlink" title="表达式计算顺序"></a>表达式计算顺序</h2><p>表达式的计算顺序不是特定的（更准确地说，表达式树中某节点的字节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。该规则只能保证语句按顺序执行，布尔表达式的短路执行。更多相关信息，请参阅：<a href="https://solidity-cn.readthedocs.io/zh/develop/miscellaneous.html#order">操作符优先级</a>。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="解构赋值和返回多值"><a href="#解构赋值和返回多值" class="headerlink" title="解构赋值和返回多值"></a>解构赋值和返回多值</h3><p>Solidity 内部允许元组 (tuple) 类型，也就是一个在编译时元素数量固定的对象列表，列表中的元素可以是不同类型的对象。这些元组可以用来同时返回多个数值，也可以用它们来同时给多个新声明的变量或者既存的变量（或通常的 LValues）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;0.4.23 &lt;0.5.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        //基于返回的元组来声明变量并赋值</span><br><span class="line">        (uint x, bool b, uint y) = f();</span><br><span class="line">        //交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        //元组的末尾元素可以省略（这也适用于变量声明）。</span><br><span class="line">        (data.length,,) = f(); // 将长度设置为 7</span><br><span class="line">        //省略元组中末尾元素的写法，仅可以在赋值操作的左侧使用，除了这个例外：</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        //(1,) 是指定单元素元组的唯一方法，因为 (1)</span><br><span class="line">        //相当于 1。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p>直到 0.4.24 版本，给具有更少的元素数的元组赋值都可以可能的，无论是在左边还是右边（比如在最后空出若干元素）。现在，这已经不推荐了，赋值操作的两边应该具有相同个数的组成元素。</p><h3 id="数组和结构体的复杂性"><a href="#数组和结构体的复杂性" class="headerlink" title="数组和结构体的复杂性"></a>数组和结构体的复杂性</h3><p>赋值语义对于像数组和结构体这样的非值类型来说会有些复杂。 为状态变量 <em>赋值</em> 经常会创建一个独立副本。另一方面，对局部变量的赋值只会为基本类型（即 32 字节以内的静态类型）创建独立的副本。如果结构体或数组（包括 <code>bytes</code> 和 <code>string</code>）被从状态变量分配给局部变量，局部变量将保留对原始状态变量的引用。对局部变量的第二次赋值不会修改状态变量，只会改变引用。赋值给局部变量的成员（或元素）则 <em>改变</em> 状态变量。</p><h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>变量声明后将有默认初始值，其初始值字节表示全部为零。任何类型变量的“默认值”是其对应类型的典型“零状态”。例如， <code>bool</code> 类型的默认值是 <code>false</code> 。 <code>uint</code> 或 <code>int</code> 类型的默认值是 <code>0</code> 。对于静态大小的数组和 <code>bytes1</code> 到 <code>bytes32</code> ，每个单独的元素将被初始化为与其类型相对应的默认值。 最后，对于动态大小的数组， <code>bytes</code> 和 <code>string</code> 类型，其默认缺省值是一个空数组或字符串。</p><p>Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：变量将会从它们被声明之后可见，直到一对 <code>&#123; &#125;</code> 块的结束。作为一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。</p><p>那些定义在代码块之外的变量，比如函数、合约、自定义类型等等，并不会影响它们的作用域特性。这意味着你可以在实际声明状态变量的语句之前就使用它们，并且递归地调用函数。</p><p>基于以上的规则，下边的例子不会出现编译警告，因为那两个变量虽然名字一样，但却在不同的作用域里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;0.4.24;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function minimalScoping() pure public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为 C99 作用域规则的特例，请注意在下边的例子里，第一次对 <code>x</code> 的赋值会改变上一层中声明的变量值。如果外层声明的变量被“影子化”（就是说被在内部作用域中由一个同名变量所替代）你会得到一个警告。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;0.4.24;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        uint x = 1;</span><br><span class="line">        &#123;</span><br><span class="line">            x = 2; // 这个赋值会影响在外层声明的变量</span><br><span class="line">            uint x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; // x has value 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>警告</p><blockquote><p>在 Solidity 0.5.0 之前的版本，作用域规则都沿用了 Javascript 的规则，即一个变量可以声明在函数的任意位置，都可以使他在整个函数范围内可见。而这种规则会从 0.5.0 版本起被打破。从 0.5.0 版本开始，下面例子中的代码段会导致编译错误。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 这将无法编译通过</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;0.4.24;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        x = 2;</span><br><span class="line">        uint x;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理：Assert-Require-Revert-and-Exceptions"><a href="#错误处理：Assert-Require-Revert-and-Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert and Exceptions"></a>错误处理：Assert, Require, Revert and Exceptions</h2><p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。 便利函数 <code>assert</code> 和 <code>require</code> 可用于检查条件并在条件不满足时抛出异常。<code>assert</code> 函数只能用于测试内部错误，并检查非变量。 <code>require</code> 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。 如果使用得当，分析工具可以评估你的合约，并标示出那些会使 <code>assert</code> 失败的条件和函数调用。 正常工作的代码不会导致一个 assert 语句的失败；如果这发生了，那就说明出现了一个需要你修复的 bug。</p><p>还有另外两种触发异常的方法：<code>revert</code> 函数可以用来标记错误并恢复当前的调用。 <code>revert</code> 调用中包含有关错误的详细信息是可能的，这个消息会被返回给调用者。已经不推荐的关键字 <code>throw</code> 也可以用来替代 <code>revert()</code> （但无法返回错误消息）。</p><p>注解</p><p>从 0.4.13 版本开始，<code>throw</code> 这个关键字被弃用，并且将来会被逐渐淘汰。</p><p>当子调用发生异常时，它们会自动“冒泡”（即重新抛出异常）。这个规则的例外是 <code>send</code> 和低级函数 <code>call</code> ， <code>delegatecall</code> 和 <code>callcode</code> –如果这些函数发生异常，将返回 false ，而不是“冒泡”。</p><p>警告</p><p>作为 EVM 设计的一部分，如果被调用合约帐户不存在，则低级函数 <code>call</code> ， <code>delegatecall</code> 和 <code>callcode</code> 将返回 success。因此如果需要使用低级函数时，必须在调用之前检查被调用合约是否存在。</p><p>异常捕获还未实现</p><p>在下例中，你可以看到如何轻松使用<code>require</code>检查输入条件以及如何使用<code>assert</code>检查内部错误，注意，你可以给 <code>require</code> 提供一个消息字符串，而 <code>assert</code> 不行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0, &quot;Even value required.&quot;);</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">                    //由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下列情况将会产生一个 <code>assert</code> 式异常：</p><ol><li>如果你访问数组的索引太大或为负数（例如 <code>x[i]</code> 其中 <code>i &gt;= x.length</code> 或 <code>i &lt; 0</code>）。</li><li>如果你访问固定长度 <code>bytesN</code> 的索引太大或为负数。</li><li>如果你用零当除数做除法或模运算（例如 <code>5 / 0</code> 或 <code>23 % 0</code> ）。</li><li>如果你移位负数位。</li><li>如果你将一个太大或负数值转换为一个枚举类型。</li><li>如果你调用内部函数类型的零初始化变量。</li><li>如果你调用 <code>assert</code> 的参数（表达式）最终结算为 false。</li></ol><p>下列情况将会产生一个 <code>require</code> 式异常：</p><ol><li>调用 <code>throw</code> 。</li><li>如果你调用 <code>require</code> 的参数（表达式）最终结算为 <code>false</code> 。</li><li>如果你通过消息调用调用某个函数，但该函数没有正确结束（它耗尽了 gas，没有匹配函数，或者本身抛出一个异常），上述函数不包括低级别的操作 <code>call</code> ， <code>send</code> ， <code>delegatecall</code> 或者 <code>callcode</code> 。低级操作不会抛出异常，而通过返回 <code>false</code> 来指示失败。</li><li>如果你使用 <code>new</code> 关键字创建合约，但合约没有正确创建（请参阅上条有关”未正确完成“的定义）。</li><li>如果你对不包含代码的合约执行外部函数调用。</li><li>如果你的合约通过一个没有 <code>payable</code> 修饰符的公有函数（包括构造函数和 fallback 函数）接收 Ether。</li><li>如果你的合约通过公有 getter 函数接收 Ether 。</li><li>如果 <code>.transfer()</code> 失败。</li></ol><p>在内部， Solidity 对一个 <code>require</code> 式的异常执行回退操作（指令 <code>0xfd</code> ）并执行一个无效操作（指令 <code>0xfe</code> ）来引发 <code>assert</code> 式异常。 在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。 因为我们想保留交易的原子性，所以最安全的做法是回退所有更改并使整个交易（或至少是调用）不产生效果。 请注意， <code>assert</code> 式异常消耗了所有可用的调用 gas ，而从 Metropolis 版本起 <code>require</code> 式的异常不会消耗任何 gas。</p><p>下边的例子展示了如何在 revert 和 require 中使用错误字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.22;</span><br><span class="line"></span><br><span class="line">contract VendingMachine &#123;</span><br><span class="line">    function buy(uint amount) payable &#123;</span><br><span class="line">        if (amount &gt; msg.value / 2 ether)</span><br><span class="line">            revert(&quot;Not enough Ether provided.&quot;);</span><br><span class="line">        // 下边是等价的方法来做同样的检查：</span><br><span class="line">        require(</span><br><span class="line">            amount &lt;= msg.value / 2 ether,</span><br><span class="line">            &quot;Not enough Ether provided.&quot;</span><br><span class="line">        );</span><br><span class="line">        // 执行购买操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提供的字符串应该是经过 <a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi">ABI 编码</a> 之后的，因为它实际上是调用了 <code>Error(string)</code> 函数。在上边的例子里，<code>revert(&quot;Not enough Ether provided.&quot;);</code> 会产生如下的十六进制错误返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x08c379a0                                                         // Error(string) 的函数选择器</span><br><span class="line">0x0000000000000000000000000000000000000000000000000000000000000020 // 数据的偏移量（32）</span><br><span class="line">0x000000000000000000000000000000000000000000000000000000000000001a // 字符串长度（26）</span><br><span class="line">0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // 字符串数据（&quot;Not enough Ether provided.&quot; 的 ASCII 编码，26字节）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;输入参数和输出参数&quot;&gt;&lt;a href=&quot;#输入参数和输出参数&quot; class=&quot;headerlink&quot; title=&quot;输入参数和输出参数&quot;&gt;&lt;/a&gt;输入参数和输出参数&lt;/h2&gt;&lt;p&gt;与 Javascript 一样，函数可能需要参数作为输入; 而与 Javascrip</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单位与全局变量</title>
    <link href="https://www.zhengcookie.site/2025/07/06/%E5%8D%95%E4%BD%8D%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>https://www.zhengcookie.site/2025/07/06/%E5%8D%95%E4%BD%8D%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</id>
    <published>2025-07-06T14:46:53.000Z</published>
    <updated>2025-10-01T04:54:48.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以太币Ether-单位"><a href="#以太币Ether-单位" class="headerlink" title="以太币Ether 单位"></a>以太币Ether 单位</h2><p>以太币Ether 单位之间的换算就是在数字后边加上 <code>wei</code> ， <code>gwei</code> 或 <code>ether</code> 来实现的，如果后面没有单位，缺省为 wei。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(1 wei == 1);</span><br><span class="line">assert(1 gwei == 1e9);</span><br><span class="line">assert(1 ether == 1e18);</span><br></pre></td></tr></table></figure><p>货币单位后缀的的效果相当于乘以10的幂。</p><p>注解</p><p>从0.7.0开始 <code>finney</code> 和 <code>szabo</code> 被移除了。 译者注：gwei 在solidity 0.6.11 中添加，因此在0.6.11之前的版本中不可用。</p><h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>秒是缺省时间单位，在时间单位之间，数字后面带有 <code>seconds</code>、 <code>minutes</code>、 <code>hours</code>、 <code>days</code> 和 <code>weeks</code> 的可以进行换算，基本换算关系如下：</p><ul><li><code>1 == 1 seconds</code></li><li><code>1 minutes == 60 seconds</code></li><li><code>1 hours == 60 minutes</code></li><li><code>1 days == 24 hours</code></li><li><code>1 weeks == 7 days</code></li></ul><p>由于闰秒造成的每年不都是 365 天、每天不都是 24 小时 <a href="https://en.wikipedia.org/wiki/Leap_second">leap seconds</a>，所以如果你要使用这些单位计算日期和时间，请注意这个问题。因为闰秒是无法预测的，所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。</p><p>注解</p><p><code>years</code> 已经在 0.5.0 版本去除了，因为闰年的原因。</p><p>这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) public &#123;</span><br><span class="line">    if (block.timestamp &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊变量和函数"><a href="#特殊变量和函数" class="headerlink" title="特殊变量和函数"></a>特殊变量和函数</h2><p>在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。</p><p>注解</p><p>译者注： 为了方便理解，可以把这些变量和函数理解为Solidity 语言层面的（原生） API 。</p><h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul><li><code>blockhash(uint blockNumber) returns (bytes32)</code>：指定区块的区块哈希 —— 仅可用于最新的 256 个区块且不包括当前区块，否则返回 0 。</li><li><code>block.basefee</code> (<code>uint</code>): 当前区块的基础费用，参考： (<a href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>)</li><li><code>block.chainid</code> (<code>uint</code>): 当前链 id</li><li><code>block.coinbase</code> ( <code>address</code> ): 挖出当前区块的矿工地址</li><li><code>block.difficulty</code> ( <code>uint</code> ): 当前区块难度</li><li><code>block.gaslimit</code> ( <code>uint</code> ): 当前区块 gas 限额</li><li><code>block.number</code> ( <code>uint</code> ): 当前区块号</li><li><code>block.timestamp</code> ( <code>uint</code>): 自 unix epoch 起始当前区块以秒计的时间戳</li><li><code>gasleft() returns (uint256)</code> ：剩余的 gas</li><li><code>msg.data</code> ( <code>bytes</code> ): 完整的 calldata</li><li><code>msg.sender</code> ( <code>address</code> ): 消息发送者（当前调用）</li><li><code>msg.sig</code> ( <code>bytes4</code> ): calldata 的前 4 字节（也就是函数标识符）</li><li><code>msg.value</code> ( <code>uint</code> ): 随消息发送的 wei 的数量</li><li><code>tx.gasprice</code> (<code>uint</code>): 交易的 gas 价格</li><li><code>tx.origin</code> ( <code>address</code> ): 交易发起者（完全的调用链）</li></ul><p>注解</p><p>对于每一个<strong>外部函数</strong>调用，包括 <code>msg.sender</code> 和 <code>msg.value</code> 在内所有 <code>msg</code> 成员的值都会变化。这里包括对库函数的调用。</p><h3 id="ABI-编码及解码函数"><a href="#ABI-编码及解码函数" class="headerlink" title="ABI 编码及解码函数"></a>ABI 编码及解码函数</h3><ul><li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: 对给定的数据进行ABI解码，而数据的类型在括号中第二个参数给出 。 例如: <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li><li><code>abi.encode(...) returns (bytes)</code>： <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi">ABI</a> - 对给定参数进行编码</li><li><code>abi.encodePacked(...) returns (bytes)</code>：对给定参数执行 <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi-packed-mode">紧打包编码</a> ，注意，可以不明确打包编码。</li><li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>： <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi">ABI</a> - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回</li><li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>：等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li><li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>: 使用tuple类型参数ABI 编码调用 <code>functionPointer</code> 。执行完整的类型检查, 确保类型匹配函数签名。结果和 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code> 一致。</li></ul><h3 id="bytes-成员函数"><a href="#bytes-成员函数" class="headerlink" title="bytes 成员函数"></a>bytes 成员函数</h3><ul><li><code>bytes.concat(...) returns (bytes memory)</code>: <a href="https://learnblockchain.cn/docs/solidity/types.html#bytes-concat">Concatenates variable number of bytes and bytes1, …, bytes32 arguments to one byte array</a></li></ul><h3 id="string-成员函数"><a href="#string-成员函数" class="headerlink" title="string 成员函数"></a>string 成员函数</h3><ul><li><code>string.concat(...) returns (string memory)</code>: <a href="https://learnblockchain.cn/docs/solidity/types.html#string-concat">Concatenates variable number of string arguments to one string array</a></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>可以参阅专门的章节 <a href="https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require">assert and require</a> 参阅有关错误处理以及何时使用哪个函数的更多详细信息。</p><ul><li><p><code>assert(bool condition)</code></p><p>如果不满足条件，则会导致Panic 错误，则撤销状态更改 - 用于检查内部错误。</p></li><li><p><code>require(bool condition)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。</p></li><li><p><code>require(bool condition, string memory message)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。</p></li><li><p><code>revert()</code></p><p>终止运行并撤销状态更改。</p></li><li><p><code>revert(string memory reason)</code></p><p>终止运行并撤销状态更改，可以同时提供一个解释性的字符串。</p></li></ul><h3 id="数学和密码学函数"><a href="#数学和密码学函数" class="headerlink" title="数学和密码学函数"></a>数学和密码学函数</h3><ul><li><p><code>addmod(uint x, uint y, uint k) returns (uint)</code></p><p>计算 <code>(x + y) % k</code>，加法会在任意精度下执行，并且加法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code>k != 0</code> 的校验（assert）。</p></li><li><p><code>mulmod(uint x, uint y, uint k) returns (uint)</code></p><p>计算 <code>(x * y) % k</code>，乘法会在任意精度下执行，并且乘法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code>k != 0</code> 的校验（assert）。</p></li><li><p><code>keccak256((bytes memory) returns (bytes32)</code></p><p>计算 Keccak-256 哈希。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha256(bytes memory) returns (bytes32)</span><br></pre></td></tr></table></figure><p>计算参数的 SHA-256 哈希。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ripemd160(bytes memory) returns (bytes20)</span><br></pre></td></tr></table></figure><p>计算参数的 RIPEMD-160 哈希。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</span><br></pre></td></tr></table></figure><p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。</p><p>函数参数对应于 ECDSA签名的值:</p><ul><li><code>r</code> &#x3D; 签名的前 32 字节</li><li><code>s</code> &#x3D; 签名的第2个32 字节</li><li><code>v</code> &#x3D; 签名的最后一个字节</li></ul><p><code>ecrecover</code> 返回一个 <code>address</code>, 而不是 <code>address payable</code> 。他们之前的转换参考 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">address payable</a> ，如果需要转移资金到恢复的地址。</p><p>可进一步参考 <a href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">使用案例</a> 。</p><h3 id="地址成员"><a href="#地址成员" class="headerlink" title="地址成员"></a>地址成员</h3><ul><li><p><code>&lt;address&gt;.balance</code> (<code>uint256</code>)</p><p>以 Wei 为单位的 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 的余额。</p></li><li><p><code>&lt;address&gt;.code</code> (<code>bytes memory</code>)</p><p>在 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 上的代码(可以为空)</p></li><li><p><code>&lt;address&gt;.codehash</code> (<code>bytes32</code>)</p><p><a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 的codehash</p></li><li><p><code>&lt;address payable&gt;.transfer(uint256 amount)</code></p><p>向 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 发送数量为 amount 的 Wei，失败时抛出异常，使用固定（不可调节）的 2300 gas 的矿工费。</p></li><li><p><code>&lt;address payable&gt;.send(uint256 amount) returns (bool)</code></p><p>向 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 发送数量为 amount 的 Wei，失败时返回 <code>false</code>，发送 2300 gas 的矿工费用，不可调节。</p></li><li><p><code>&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的有效载荷（payload）发出低级 <code>CALL</code> 调用，返回成功状态及返回数据，发送所有可用 gas，也可以调节 gas。</p></li><li><p><code>&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的有效载荷 发出低级 <code>DELEGATECALL</code> 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。 发出低级函数 <code>DELEGATECALL</code>，失败时返回 <code>false</code>，发送所有可用 gas，可调节。</p></li><li><p><code>&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的有效载荷 发出低级 <code>STATICALL</code> 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。</p></li></ul><p>更多信息，参考 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a> 部分</p><h3 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h3><ul><li><p><code>this</code> (当前的合约类型)</p><p>当前合约，可以显示转换为 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a>。</p></li><li><p><code>selfdestruct(address payable recipient)</code></p><p>销毁合约，并把余额发送到指定 <a href="https://learnblockchain.cn/docs/solidity/types.html#address">地址类型 Address</a>。请注意， <code>selfdestruct</code> 具有从EVM继承的一些特性：</p></li></ul><p> - 接收合约的 receive 函数 不会执行。  - 合约仅在交易结束时才真正被销毁，并且 <code>revert</code> 可能会“撤消”销毁。</p><p>此外，当前合约内的所有函数都可以被直接调用，包括当前函数</p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>表达式 <code>type(X)</code> 可用于检索参数 <code>X</code> 的类型信息。 目前，此功能还比较有限( <code>X</code> 仅能是合约和整型)，但是未来应该会扩展。</p><p>用于合约类型 <code>C</code> 支持以下属性:</p><ul><li><p><code>type(C).name</code>:</p><p>获得合约名</p></li><li><p><code>type(C).creationCode</code>:</p><p>获得包含创建合约字节码的内存字节数组。它可以在内联汇编中构建自定义创建例程，尤其是使用 <code>create2</code> 操作码。 不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</p></li><li><p><code>type(C).runtimeCode</code></p><p>获得合约的运行时字节码的内存字节数组。这是通常由 <code>C</code> 的构造函数部署的代码。 如果 <code>C</code> 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 <code>.creationCode</code> 有相同的限制，不能在合约本身或派生的合约访问此属性。 因为会引起循环引用。</p></li></ul><p>除上面的属性, 下面的属性在接口类型<code>I</code>下可使用:</p><ul><li><p><code>type(I).interfaceId</code>:</p><p>返回接口<code>I</code> 的 <code>bytes4</code> 类型的接口 ID，接口 ID 参考： <a href="https://learnblockchain.cn/docs/eips/eip-165.html">EIP-165</a> 定义的， 接口 ID 被定义为 <code>XOR</code> （异或） 接口内所有的函数的函数选择器（除继承的函数。</p></li></ul><p>对于整型 <code>T</code> 有下面的属性可访问：</p><ul><li><p><code>type(T).min</code></p><p><code>T</code> 的最小值。</p></li><li><p><code>type(T).max</code></p><p><code>T</code> 的最大值。</p></li></ul><h2 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h2><p>以下是保留关键字，可能是将来的语法中的一部分：</p><p><code>after</code>, <code>alias</code>, <code>apply</code>, <code>auto</code>, <code>byte</code>, <code>case</code>, <code>copyof</code>, <code>default</code>, <code>define</code>, <code>final</code>, <code>implements</code>, <code>in</code>, <code>inline</code>, <code>let</code>, <code>macro</code>, <code>match</code>, <code>mutable</code>, <code>null</code>, <code>of</code>, <code>partial</code>, <code>promise</code>, <code>reference</code>, <code>relocatable</code>, <code>sealed</code>, <code>sizeof</code>, <code>static</code>, <code>supports</code>, <code>switch</code>, <code>typedef</code>, <code>typeof</code>, <code>var</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;以太币Ether-单位&quot;&gt;&lt;a href=&quot;#以太币Ether-单位&quot; class=&quot;headerlink&quot; title=&quot;以太币Ether 单位&quot;&gt;&lt;/a&gt;以太币Ether 单位&lt;/h2&gt;&lt;p&gt;以太币Ether 单位之间的换算就是在数字后边加上 &lt;code&gt;we</summary>
      
    
    
    
    <category term="区块链" scheme="https://www.zhengcookie.site/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链智能合约语法" scheme="https://www.zhengcookie.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
