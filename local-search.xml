<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Solidity智能合约零基础入门</title>
    <link href="/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2025/10/19/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h1><h2 id="模块一：启程-区块链与智能合约概念"><a href="#模块一：启程-区块链与智能合约概念" class="headerlink" title="模块一：启程 - 区块链与智能合约概念"></a>模块一：启程 - 区块链与智能合约概念</h2><p>比特币 vs 以太坊：为什么需要智能合约？</p><h3 id="比特币-vs-以太坊：为什么需要智能合约？"><a href="#比特币-vs-以太坊：为什么需要智能合约？" class="headerlink" title="比特币 vs 以太坊：为什么需要智能合约？"></a>比特币 vs 以太坊：为什么需要智能合约？</h3><p>比特币作为区块链技术的第一个成功应用，开创了去中心化数字货币的先河。它的核心功能是提供一种安全、透明且不可篡改的价值转移方式。然而，比特币的设计初衷是专注于支付和存储价值，其脚本语言（Script）虽然具有一定的可编程性，但功能较为有限，无法支持复杂的逻辑操作。<br>相比之下，以太坊在设计上引入了一个革命性的概念——<strong>智能合约</strong>。智能合约是一种运行在区块链上的程序代码，能够根据预设条件自动执行特定的操作。它使得以太坊不仅是一个去中心化的支付系统，更是一个通用的计算平台。通过智能合约，开发者可以构建各种去中心化应用（DApps），例如去中心化金融（DeFi）、非同质化代币（NFT）、去中心化自治组织（DAO）等。这种灵活性使以太坊成为区块链生态系统的核心支柱之一。<br>那么，为什么需要智能合约？智能合约的核心优势在于<strong>自动化执行</strong>和<strong>信任最小化</strong>。传统合约需要依赖第三方（如律师或仲裁机构）来确保执行，而智能合约通过代码直接定义规则并自动执行，无需中介参与。这不仅降低了交易成本，还提高了效率，同时减少了人为干预带来的风险。此外，智能合约的透明性和不可篡改性进一步增强了信任，使其在金融、供应链管理、身份认证等领域展现出巨大的潜力。</p><h3 id="什么是Gas？什么是交易？"><a href="#什么是Gas？什么是交易？" class="headerlink" title="什么是Gas？什么是交易？"></a>什么是Gas？什么是交易？</h3><h4 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h4><p>在以太坊网络中，<strong>Gas</strong> 是衡量执行智能合约或进行交易所需计算资源的单位。简单来说，Gas 是用户为使用以太坊网络支付的“燃料费”。每笔交易或智能合约的执行都需要消耗一定数量的 Gas，而 Gas 的价格由市场供需决定，通常以以太币（ETH）计价。<br>Gas 的存在有几个重要意义：</p><ol><li><strong>防止滥用网络资源</strong>：通过收取 Gas 费用，以太坊可以防止恶意用户发起无限循环或占用大量计算资源的操作。</li><li><strong>激励矿工/验证者</strong>：Gas 费用作为奖励分配给矿工（在 PoW 机制下）或验证者（在 PoS 机制下），以保障网络的安全性和稳定性。</li><li><strong>动态调节网络负载</strong>：当网络拥堵时，用户可以通过提高 Gas 价格来优先处理自己的交易。</li></ol><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>在区块链语境中，<strong>交易</strong>是指任何改变区块链状态的操作。交易可以分为两类：</p><ol><li><strong>普通转账交易</strong>：指从一个账户向另一个账户转移加密货币（如 ETH）。</li><li><strong>智能合约交互交易</strong>：指调用智能合约中的函数，可能涉及复杂的数据处理或状态更新。<br>每笔交易都需要包含以下信息：</li></ol><ul><li>发送方地址</li><li>接收方地址（如果是普通转账）或智能合约地址（如果是合约交互）</li><li>转账金额（如果是普通转账）</li><li>Gas 限制（Gas Limit）：用户愿意为该交易支付的最大 Gas 数量</li><li>Gas 价格（Gas Price）：每单位 Gas 的价格<br>如果交易执行所需的 Gas 超过了用户设置的 Gas 限制，交易将失败，但已消耗的 Gas 不会退还。</li></ul><h3 id="开发环境搭建（FISCO-BCOS-Remix-IDE）"><a href="#开发环境搭建（FISCO-BCOS-Remix-IDE）" class="headerlink" title="开发环境搭建（FISCO-BCOS, Remix IDE）"></a>开发环境搭建（FISCO-BCOS, Remix IDE）</h3><p>为了在区块链上开发和部署智能合约，我们需要搭建合适的开发环境。以下是两种常用的工具：<strong>FISCO-BCOS</strong> 和 <strong>Remix IDE</strong>。</p><h4 id="FISCO-BCOS"><a href="#FISCO-BCOS" class="headerlink" title="FISCO-BCOS"></a>FISCO-BCOS</h4><p>FISCO-BCOS 是一个国产的区块链底层平台，专注于企业级应用场景。它支持联盟链模式，适合构建私有链或联盟链项目。以下是搭建 FISCO-BCOS 的基本步骤：</p><p><a href="https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html">https://fisco-bcos-doc.readthedocs.io/zh-cn/latest/index.html</a></p><h4 id="Remix-IDE"><a href="#Remix-IDE" class="headerlink" title="Remix IDE"></a>Remix IDE</h4><p>Remix 是一个基于浏览器的集成开发环境（IDE），专为以太坊智能合约开发设计。它的界面友好，功能强大，非常适合初学者和快速原型开发。以下是使用 Remix 的基本流程：</p><ol><li><strong>访问 Remix IDE</strong>：</li></ol><ul><li><ul><li>打开浏览器，访问 <a href="https://remix.ethereum.org/">Remix 官网</a>。</li></ul></li></ul><ol><li><strong>编写智能合约</strong>：</li></ol><ul><li><ul><li>在 Remix 的“File Explorer”区域新建一个 <code>.sol</code> 文件，例如 <code>MyContract.sol</code>。</li><li>编写 Solidity 代码，例如：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract MyContract &#123;<br>    uint public value;<br>    function setValue(uint _value) public &#123;<br>        value = _value;<br>    &#125;<br>    function getValue() public view returns (uint) &#123;<br>        return value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>编译合约</strong>：</li></ol><ul><li><ul><li>切换到“Solidity Compiler”标签页，选择适当的编译器版本并点击“Compile”。</li></ul></li></ul><ol><li><strong>部署合约</strong>：</li></ol><ul><li><ul><li>切换到“Deploy &amp; Run Transactions”标签页，选择 JavaScript VM（虚拟机）或其他环境（如 MetaMask）。</li><li>点击“Deploy”按钮将合约部署到测试网络。</li></ul></li></ul><ol><li><strong>测试合约</strong>：</li></ol><ul><li><ul><li>在“Deployed Contracts”区域，调用合约的函数（如 <code>setValue</code> 和 <code>getValue</code>）进行交互。</li></ul></li></ul><h2 id="模块二：Solidity基础语法"><a href="#模块二：Solidity基础语法" class="headerlink" title="模块二：Solidity基础语法"></a>模块二：Solidity基础语法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Solidity是一种合约导向编程语言，用于编写智能合约，运行在Ethereum虚拟机（EVM）上。本文档将为您介绍Solidity的基本语法和概念，帮助您快速上手智能合约开发。</p><h3 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构</h3><p>在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-functions">函数</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰器</a>、<a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-events">事件</a>、 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>、 和 <a href="https://solidity-cn.readthedocs.io/zh/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量是永久地存储在合约存储中的值。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleStorage &#123;<br>    <span class="hljs-built_in">uint</span> storedData; <span class="hljs-comment">// 状态变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有效的状态变量类型参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#types">类型</a> 章节， 对状态变量可见性有可能的选择参阅 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a> 。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是合约中代码的可执行单元。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123; <span class="hljs-comment">// 函数</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#function-calls">函数调用</a> 可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#visibility-and-getters">可见性和 getter 函数</a>）。</p><h4 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器</h4><p>函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifiers">函数 </a>）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.22</span>;<br><br>contract Purchase &#123;<br>    address <span class="hljs-keyword">public</span> seller;<br><br>    <span class="hljs-function">modifier <span class="hljs-title">onlySeller</span>()</span> &#123; <span class="hljs-comment">// 修饰器</span><br>        require(<br>            msg.sender == seller,<br>            <span class="hljs-string">&quot;Only seller can call this.&quot;</span><br>        );<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">abort</span>() <span class="hljs-keyword">public</span> onlySeller</span> &#123; <span class="hljs-comment">// Modifier usage</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.21</span>;<br>contract SimpleAuction &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">address bidder, <span class="hljs-built_in">uint</span> amount</span>)</span>; <span class="hljs-comment">// 事件</span><br><br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">emit <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>; <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events">事件</a>。</p><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>结构是可以将几个变量分组的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#structs">结构体</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Ballot &#123;<br>    <span class="hljs-keyword">struct</span> Voter &#123; <span class="hljs-comment">// 结构</span><br>        <span class="hljs-built_in">uint</span> weight;<br>        <span class="hljs-built_in">bool</span> voted;<br>        address <span class="hljs-built_in">delegate</span>;<br>        <span class="hljs-built_in">uint</span> vote;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 <a href="https://solidity-cn.readthedocs.io/zh/develop/types.html#enums">枚举类型</a>）。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    <span class="hljs-keyword">enum</span> State &#123; Created, Locked, Inactive &#125; <span class="hljs-comment">// 枚举</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p><code>bool</code> ：可能的取值为常数值 <code>true</code> 和 <code>false</code>。</p><p>运算符：</p><ul><li><code>!</code> (逻辑非)</li><li><code>&amp;&amp;</code> (逻辑与, “and”)</li><li><code>||</code> (逻辑或, “or”)</li><li><code>==</code> (等于)</li><li><code>!=</code> (不等于)</li></ul><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。 就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> / <code>false</code> ， 那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><code>int</code> / <code>uint</code>: 分别表示有符号和无符号的不同位数的整型变量。 关键字 <code>uint8</code> 到 <code>uint256</code> （无符号整型，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>， 以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> (异或)， <code>~</code> (位取反)</li><li>移位运算符： <code>&lt;&lt;</code> （左移）， <code>&gt;&gt;</code> （右移）</li><li>算数运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code> （只适用于有符号的整数）， <code>*</code>， <code>/</code>， <code>%</code> (取余)， <code>**</code> (幂)</li></ul><p>对于一个整数类型 <code>X</code>，您可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 来访问该类型代表的最小值和最大值。</p><h5 id="定长浮点型"><a href="#定长浮点型" class="headerlink" title="定长浮点型"></a>定长浮点型</h5><blockquote id="fn_警告"><sup>警告</sup>. Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。<a href="#reffn_警告" title="Jump back to footnote [警告] in the text."> &#8617;</a></blockquote><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中， <code>M</code> 表示该类型占用的位数， <code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x18</code> 和 <code>fixed128x18</code> 的别名。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>fixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>ufixed constant PI <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265</span><span class="hljs-comment">;</span><br>ufixed a <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回值是布尔型）</li><li>算术运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code> (取余数)</li></ul><h5 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h5><p>地址类型有两种大致相同的类型：</p><ul><li><code>address</code>: 保存一个20字节的值（一个以太坊地址的大小）。</li><li><code>address payable</code>: 与 <code>address</code> 类型相同，但有额外的方法 <code>transfer</code> 和 <code>send</code>。</li></ul><p>这种区别背后的想法是， <code>address payable</code> 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 <code>address</code>，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">address addr <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990<span class="hljs-comment">;</span><br>address payable addr_pay <span class="hljs-operator">=</span> payable(<span class="hljs-number">0</span>x8306300ffd616049FD7e4b0354a64Da835c1A81C)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><ul><li><code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> 和 <code>&gt;</code></li></ul><h5 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h5><p>值类型 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code> 代表从1到32的字节序列。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bytes32 public _byte32 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MiniSolidity&quot;</span><span class="hljs-comment">; </span><br><br>bytes1 public _byte <span class="hljs-operator">=</span> _byte32[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>运算符：</p><p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> (返回 <code>bool</code>)</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li><li>索引访问： 如果 <code>x</code> 是 <code>bytesI</code> 类型，那么当 <code>0 &lt;= k &lt; I</code> 时， <code>x[k]</code> 返回第 <code>k</code> 个字节（只读）。</li></ul><p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型）， 它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p><p>成员变量：</p><ul><li><code>.length</code> 表示这个字节数组的长度（只读）.</li></ul><h5 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。</p><p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code>0</code> 开始无符号整数值表示。</p><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 您可以得到给定枚举的最小值和最大值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br>contract test &#123;<br>    <span class="hljs-built_in">enum</span> ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;<br>    ActionChoices choice;<br>    ActionChoices constant defaultChoice = ActionChoices.GoStraight;<br><br>    <span class="hljs-function">function <span class="hljs-title">setGoStraight</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        choice = ActionChoices.GoStraight;<br>    &#125;<br><br>    <span class="hljs-comment">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span><br>    <span class="hljs-comment">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span><br>    <span class="hljs-function">function <span class="hljs-title">getChoice</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> choice;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getDefaultChoice</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">uint</span>(defaultChoice);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getLargestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).max;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getSmallestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 </p><p>类似的格式如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> &lt;<span class="hljs-keyword">function</span> <span class="hljs-type">name</span>&gt; (&lt;parameter <span class="hljs-keyword">types</span>&gt;) &#123;<span class="hljs-type">internal</span>|<span class="hljs-keyword">external</span>|<span class="hljs-built_in">public</span>|private&#125; &#123;modifier&#125; [pure|<span class="hljs-keyword">view</span>|payable] [<span class="hljs-keyword">returns</span> (&lt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">types</span>&gt;)]<br></code></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Solidity 中，相比于值类型，引用类型更复杂，通常包括占用更多内存的数组和结构体。当处理这些复杂的引用类型时，需要谨慎考虑它们的数据位置。</p><p>所有引用类型（如数组和结构体）都具有一个 “数据位置” 属性，指明数据是存储在内存中还是存储中。大多数情况下，数据位置有默认值，但可以通过在类型名后加 <code>storage</code> 或 <code>memory</code> 来显式指定。</p><ul><li><strong>memory</strong>：用于临时存储，数据在执行完后会被销毁。</li><li><strong>storage</strong>：用于持久保存，数据会永久保存，直到被修改或删除。</li><li><strong>calldata</strong>：只读，常用于存储外部函数的参数。</li></ul><h6 id="默认数据位置："><a href="#默认数据位置：" class="headerlink" title="默认数据位置："></a>默认数据位置：</h6><ul><li>函数参数（包括返回参数）的默认位置是 <strong>内存 (memory)</strong>。</li><li>局部变量的默认位置是 <strong>存储 (storage)</strong>。</li><li>状态变量的数据位置强制为 <strong>存储 (storage)</strong>。</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity ^0.8.0;<br>contract C &#123;<br>    // 我们选择使用string类型，这里使用storage。<br>    // 需要注意的是，在该位置时默认数据为storage，这个可以忽略<br>    // 这是因为状态变量不需要指定数据位置，默认为storage<br>    string public x;<br>    // memoryArray 的数据存储位置是 memory<br>    // 我们也可以给他的数据存储位置为 calldata<br>    function f(string memory memoryString) public&#123;<br>      // memoryString = &quot;hello&quot;<br>       x = memoryString;<br>    &#125;<br>    // calldata<br>    // memory<br>    function g(string calldata ) external &#123;<br>    &#125;<br>    // storage<br>    function h(string storage ) internal  &#123;    <br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="数据位置的重要性"><a href="#数据位置的重要性" class="headerlink" title="数据位置的重要性"></a>数据位置的重要性</h6><p>数据位置影响赋值行为：</p><ul><li>在 <strong>存储 (storage)</strong> 和 <strong>内存 (memory)</strong> 之间赋值会创建新的拷贝。</li><li><strong>存储 (storage)</strong>进行 赋值时，只会传递引用，不会创建新副本。</li><li><strong>内存 (memory)</strong> 之间的赋值通常不会创建新副本，因为它们共享相同的数据。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>强制指定的数据位置</strong>：<ul><li>外部函数,也就是<code>external</code>，形参的数据位置可以为 <code>calldata</code>，也可以为<code>memory</code>，但是绝对不是<code>storage</code>，<code>public</code>同理。</li><li>状态变量为 <code>storage</code>，也可以指定函数形参的数据位置为<code>storage</code>，不过基本上只能在内部函数<code>internal</code>执行。</li></ul></li><li><strong>默认数据位置</strong>：<ul><li>函数参数（包括返回参数）为 <code>memory</code>，也可以为<code>calldata</code>。</li><li>其他局部变量为 <code>storage</code>。</li></ul></li></ul><hr><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>Solidity 支持两种类型的数组：固定长度数组和动态数组。</p><p>一个元素类型为 <code>T</code>，固定长度为 <code>k</code> 的数组可以声明为 <code>T[k]</code>， 而动态数组声明为 <code>T[]</code>。</p><p><strong>固定长度数组</strong>:<code>uint[5]</code>,<code>uint[2][5]</code> …</p><p><strong>动态数组</strong>:<code>uint[]</code>,<code>uint[][5]</code> …</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[5] a = [1,2,3,4,5]; // 5 element array<br>uint[5] b;<br>uint[] c;<br>uint[] d = [1,2,3,4,5];<br></code></pre></td></tr></table></figure><p><strong>索引</strong>: 对元素中的一个数据进行定位，数组索引从0开始，访问一个数组中的其中一个元素，访问时的下标顺序与声明时相反。访问一个超过它的末端的数组会导致一个失败的断言。 </p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnOne() public view returns (uint)&#123;<br>    return d[0];//返回第一个元素<br>&#125;    <br>function returntwo() public view returns (uint)&#123;<br>    return d[1];//返回第二个元素<br>&#125;    <br></code></pre></td></tr></table></figure><p><strong>数组成员</strong>:</p><ul><li><p><strong>length</strong>:</p><p>数组有 <code>length</code> 成员变量表示当前数组的长度。一经创建， 内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时数组的参数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function returnLength() public view returns (uint)&#123;<br>    return d.length;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push()</code> 的成员函数， 您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用， 因此可以像 <code>x.push().t = 2</code> 或 <code>x.push() = b</code> 那样使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>     c.push();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>push(x)</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push(x)</code> 的成员函数， 您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function add(uint x) public&#123;<br>d.push(x);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>pop()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>pop()</code> 的成员函数， 您可以用它来从数组的末端移除一个元素。 这也隐含地在被删除的元素上调用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete">delete</a>。该函数不返回任何东西。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function del() public&#123;<br>    d.pop(); //删除末尾<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建内存数组</strong>:具有动态长度的内存数组可以使用 <code>new</code> 操作符创建。 与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code>.push</code> 成员函数不可用）。 您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p><p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a> 进行初始化。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function createMemoryArray(uint len) public view returns (uint[] memory)&#123;<br>       uint[] memory arr = new uint[](len); //创建长度为len的内存数组<br>       arr[0] = 1;<br>       arr[1] = 2;<br>       return arr;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>数组切片</strong>: <code>x[start:end]</code></p><p>数组切片是对一个数组的连续部分的预览。 它们被写成 <code>x[start:end]</code>，其中 <code>start</code> 和 <code>end</code> 是表达式， 结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code>x[start]</code>， 最后一个元素是 <code>x[end - 1]</code>。</p><p>如果 <code>start</code> 大于 <code>end</code>，或者 <code>end</code> 大于数组的长度， 就会出现异常。</p><p><code>start</code> 和 <code>end</code> 都是可选的： <code>start</code> 默认为 <code>0</code>， <code>end</code> 默认为数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function get(uint[] calldata arr) public view returns (uint[] calldata)&#123;<br>      return arr[:6];<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>数组元素</strong>：数组元素可以是任何类型，包括映射或结构体。 并适用于类型的一般限制，映射只能存储在 <code>storage</code> 数据位置,下面是一些特殊的数组。</p><p><strong>bytes</strong></p><p><code>bytes</code> 类似于 <code>bytes1[]</code>， 但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。</p><p>您应该使用 <code>bytes</code> 而不是 <code>bytes1[]</code>，因为它更便宜， 因为在 <code>memory</code> 中使用 <code>bytes1[]</code> 会在元素之间增加31个填充字节。  一般来说，对于任意长度的原始字节数据使用 <code>bytes</code>，对于任意长度的字符串（UTF-8）数据使用 <code>string</code>。 如果您能将长度限制在一定的字节数，使用 <code>bytes1</code> 到 <code>bytes32</code> 中的一种值类型，因为它们更便宜。</p><p>函数:  <code>bytes.concat</code></p><p><code>bytes.concat</code> 函数可以连接任意数量的 <code>bytes</code> 或 <code>bytes1 ... bytes32</code> 值。 该函数返回一个单一的 <code>bytes memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用字符串参数或其他不能隐式转换为 <code>bytes</code> 的类型， 您需要先将它们转换为 <code>bytes</code> 或 <code>bytes1</code> /…/ <code>bytes32</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>string</strong></p><p><code>string</code> 与 <code>bytes</code> 相同，但不允许用长度或索引来访问。</p><p>Solidity没有字符串操作函数，但有第三方的字符串库。 可以用 <code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code> 来比较两个字符串的keccak256-hash，用 <code>string.concat(s1, s2)</code> 来连接两个字符串。</p><p>函数: <code>string.concat</code></p><p>可以使用 <code>string.concat</code> 连接任意数量的 <code>string</code> 值。 该函数返回一个单一的 <code>string memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用不能隐式转换为 <code>string</code> 的其他类型的参数，您需要先将它们转换为 <code>string</code>。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract C&#123;<br>    bytes public Bytes = &quot;abc&quot;;<br>    bytes public Bytes2 = &quot;efg&quot;;<br>    string public s = &quot;Storage&quot;;<br>    string public d = &quot;Memory&quot;;<br>    bool public keccak = <br>    keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(d));<br>    string public stringConcat = string.concat(s,d,string(Bytes),string(Bytes2));<br>    bytes public concatBytes = bytes.concat(Bytes,Bytes2,bytes(s),bytes(d));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>Solidity 支持通过结构体定义新类型。</p><p><code>示例</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract Struct&#123;<br>    struct user&#123;<br>        string name;<br>        uint age;<br>        string email;<br>    &#125;<br>    // function add(string memory name, uint age, string memory email)<br>    // public view returns (user memory)&#123;<br>    //     user memory newUser = user(name, age, email);<br>    //     return newUser;<br>    // &#125;<br>    user user1;<br>    function add(string memory name, uint age, string memory email)<br>    external&#123;<br>        user storage newUser = user1;<br>        newUser.name =&quot;hello&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="结构体的赋值和访问"><a href="#结构体的赋值和访问" class="headerlink" title="结构体的赋值和访问"></a>结构体的赋值和访问</h6><ul><li><strong>存储结构体</strong>：当结构体赋值给局部变量时，并不会复制数据，而是传递引用。</li><li><strong>成员访问</strong>：可以直接访问结构体的成员，例如 <code>campaigns[campaignID].amount = 0;</code>。</li></ul><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><h5 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h5><p><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择Solidity内置的值类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。下面这个例子会报错，因为<code>_KeyType</code>使用了我们自定义的结构体：</p><p><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</p><p><strong>规则3</strong>：如果映射声明为<code>public</code>，那么Solidity会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</p><p><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</p><h5 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h5><p><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</p><p><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。<a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage</a>)</p><p><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</p><h5 id="在Remix上验证-以-Mapping-sol为例"><a href="#在Remix上验证-以-Mapping-sol为例" class="headerlink" title="在Remix上验证 (以 Mapping.sol为例)"></a>在Remix上验证 (以 <code>Mapping.sol</code>为例)</h5><p>映射示例 1 部署</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/69dd365d690ea6ed3c8368f45a16d25a.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632090332-1f40dddf-c031-4692-8317-b15bc0d2d49e.jpeg" alt="img"></p><p>映射示例 3 key-value pair</p><p><img src="https://cdn.jsdelivr.net/gh/zhengcookie/tuchuang@main/img/1763632088903-2bf9034a-c080-4d04-a18e-5cef2ce4ae1d.jpeg" alt="img"></p><h1 id="模块三：核心概念与实战"><a href="#模块三：核心概念与实战" class="headerlink" title="模块三：核心概念与实战"></a>模块三：核心概念与实战</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>以太坊单位与地址。</p><p>支付与提现（payable, send, call）。</p><p>错误处理（require, assert, revert）。</p><h1 id="模块四：安全入门（重中之重！）"><a href="#模块四：安全入门（重中之重！）" class="headerlink" title="模块四：安全入门（重中之重！）"></a>模块四：安全入门（重中之重！）</h1><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p>详解重入攻击及防护。</p><p>溢出保护（使用SafeMath库或Solidity 0.8+）。</p><p>权限控制（Ownable, AccessControl）。</p><h2 id="模块五：项目实战"><a href="#模块五：项目实战" class="headerlink" title="模块五：项目实战"></a>模块五：项目实战</h2><p>搭建一个完整的前端/后端与合约交互。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第九周</title>
    <link href="/2025/09/13/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/"/>
    <url>/2025/09/13/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B9%9D%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、工作内容与成果"><a href="#一、工作内容与成果" class="headerlink" title="一、工作内容与成果"></a>一、工作内容与成果</h2><p>本周围绕农场相关系统的优化、功能扩展及上线展开工作，具体内容与成果如下：</p><p>（一）周一：后台界面优化工作</p><ol><li><p><strong>本地存储数据安全优化</strong>：针对后台界面，移除了通过 storage 本地存储模拟操作数据的方式。此优化有效避免了操作数据在本地透明可见的问题，提升了数据传输与存储的安全性，降低了数据被篡改或泄露的风险。</p></li><li><p><strong>核心业务逻辑调整</strong>：重点调整了后台作物管理与日志操作的核心逻辑。优化后，系统能够精准匹配对应地块的种子信息，确保作物数据与地块信息的关联性；同时，日志信息也能与具体操作场景、地块及作物数据准确对应，提升了后台数据管理的准确性与可读性，为后续数据查询与分析奠定基础。</p></li></ol><p>（二）周二：作物日志功能扩展</p><ol><li><p><strong>操作频次管控实现</strong>：为规范作物日志记录，新增作物日志每日操作限制规则，设定每种操作每日最多记录两次。该规则有效避免了日志数据冗余，保证了日志信息的简洁性与有效性，同时也符合农场日常运营中对作物操作的合理频次需求。</p></li><li><p><strong>日志生命周期管理</strong>：完善作物日志的生命周期逻辑，实现 “收获后自动删除日志，后续重新操作时添加新日志” 的功能。此举确保了日志信息与作物生长周期的同步性，避免了过期日志对数据管理的干扰，提升了日志数据的时效性。</p></li><li><p><strong>弱网环境数据保障</strong>：采用幂等性设计实现作物日志记录功能，在弱网、网络不流畅等不稳定环境下，能够有效防止重复添加日志数据，同时确保操作数据的完整性与准确性，提升了系统在复杂网络环境下的稳定性与可靠性。</p></li></ol><p>（三）周三：农场后台管理系统上线</p><ol><li><p><strong>管家日志管理功能</strong>：上线的农场后台管理系统中，新增管家后台日志记录功能，管家可通过系统的 “作物管理” 模块与 “每周日志” 模块，实时记录、查看与管理作物相关的操作日志，便于管家全面掌握作物生长过程中的关键操作，提升管理效率。</p></li><li><p><strong>种子图鉴管理功能</strong>：系统支持管家通过 “种子管理” 模块，上传、编辑与管理种子图鉴信息，包括种子品种、生长周期、适宜环境等关键数据。该功能为管家提供了统一的种子信息管理平台，便于规范种子信息管理，同时也为后续作物种植规划提供数据支持。</p></li><li><p><strong>订单查询管理功能</strong>：上线 “订单管理” 模块，管家可通过该模块快速查询所有订单信息，包括订单编号、订单类型、下单时间、订单状态等详细内容，支持按不同条件筛选查询，提升了订单信息的查询效率，便于管家及时跟进订单进度，保障农场运营的顺畅性。</p></li></ol><h3 id="二、核心工作成果"><a href="#二、核心工作成果" class="headerlink" title="二、核心工作成果"></a>二、核心工作成果</h3><p>本周聚焦农场相关系统完成三项关键工作：一是优化后台界面，移除 storage 本地存储模拟数据以强化安全，同时调整作物与日志逻辑，实现地块 - 种子 - 日志信息精准匹配；二是扩展作物日志功能，新增每日操作频次限制、收获后日志自动清理机制，并通过幂等设计解决弱网环境下数据重复问题；三是成功上线农场后台管理系统，为管家提供日志管理、种子图鉴上传、订单查询三大核心模块，满足日常管理需求。</p><h3 id="三、关键价值与亮点"><a href="#三、关键价值与亮点" class="headerlink" title="三、关键价值与亮点"></a>三、关键价值与亮点</h3><p>从安全性、实用性、稳定性三方面实现突破：安全层面，通过本地存储优化降低数据泄露风险，为系统数据安全奠定基础；实用层面，日志生命周期管理与后台系统功能模块，直接贴合农场运营场景，帮助管家提升数据管理与工作效率；稳定性层面，幂等设计的应用，有效应对复杂网络环境，保障操作数据的完整性，减少系统异常问题。</p><h3 id="四、后续行动方向"><a href="#四、后续行动方向" class="headerlink" title="四、后续行动方向"></a>四、后续行动方向</h3><p>后续将围绕 “优化体验、强化安全、拓展功能” 推进工作：优先收集管家使用反馈，迭代优化系统操作流程与功能漏洞；进一步完善数据安全体系，新增定期备份与恢复机制；结合农场实际需求调研新功能（如作物生长监控），同时持续监控系统性能，通过优化数据库、压缩资源等方式，确保系统长期稳定高效运行。</p>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第八周</title>
    <link href="/2025/09/07/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/"/>
    <url>/2025/09/07/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AB%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现从购买、种植、管理到收获的完整农场业务闭环，并完善后台管理功能。<br><strong>整体进展：</strong> ✅ <strong>核心闭环成功打通！</strong> 用户可完成<code>购买服务</code> -&gt; <code>播种</code> -&gt; <code>日常管理（浇水）</code> -&gt; <code>生成日志</code> -&gt; <code>收获</code> -&gt; <code>下单配送</code>的全流程。后台管理功能得到显著增强。</p><hr><h3 id="一、-每日开发详情"><a href="#一、-每日开发详情" class="headerlink" title="一、 每日开发详情"></a>一、 每日开发详情</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>后端服务开发</strong></td><td style="text-align:left">✅ <strong>下单服务</strong>：完成接收、处理、存储订单信息的后端逻辑。<br>✅ <strong>后台托管服务</strong>：实现分配管家处理任务及切换角色登录权限的功能。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>后台管理系统开发</strong></td><td style="text-align:left">✅ <strong>订单管理页面</strong>：<br>  - 设计订单列表，可根据 <code>order_type</code> 动态展示信息。<br>  - 实现按类型、状态等条件的筛选功能。<br>  - 开发订单详情页，关联显示主表(<code>t_order</code>)与子表信息。<br>✅ <strong>托管日志集成</strong>：在作物管理界面中，可查看关联的托管服务日志。<br>✅ <strong>管家绑定</strong>：前端通过 <code>store</code> 中的用户ID查询并绑定 <code>caretaker_user_id</code>，管理作物。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>前后端功能联调</strong></td><td style="text-align:left">✅ <strong>日志查看</strong>：点击作物即可显示相关管家的操作日志。<br>✅ <strong>订单管理</strong>：用户可查询并修改自己的订单信息。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>功能优化与扩展</strong></td><td style="text-align:left">✅ <strong>修复前端显示</strong>：优化购买服务页面，为播种功能做准备。<br>✅ <strong>服务扩展</strong>：扩展下单服务，支持收获后生成配送订单的流程。<br>✅ <strong>界面优化</strong>：对订单列表的“待收获”界面进行了视觉和体验优化。</td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>交互功能实现</strong></td><td style="text-align:left">✅ <strong>确认操作</strong>：实现前端确认操作（如浇水）的功能。<br>✅ <strong>日志记录</strong>：为浇水等操作生成两种日志：<br>  - <strong>用户操作日志</strong> (用户点击触发)<br>  - <strong>管家工作日志</strong> (管家后台记录)<br>✅ <strong>通知机制</strong>：管家可在后台管理系统中获取相关操作的通知和日志。</td></tr><tr><td style="text-align:left"><strong>周六</strong></td><td style="text-align:left"><strong>全链路测试与BUG修复</strong></td><td style="text-align:left">✅ <strong>核心闭环验证</strong>：成功测试并修复逻辑BUG，确保从购买到收获下单的全流程畅通。<br>✅ <strong>遗留问题定位</strong>：<br>  - <strong>问题一</strong>：手机端支付后可重复点击购买，需前端优化交互。<br>  - <strong>问题二</strong>：后台订单界面需集成第三方服务（如支付、物流），待确定方案。</td></tr></tbody></table></div><hr><h3 id="二、-核心业务流程与逻辑-本周重大进展"><a href="#二、-核心业务流程与逻辑-本周重大进展" class="headerlink" title="二、 核心业务流程与逻辑 (本周重大进展)"></a>二、 核心业务流程与逻辑 (本周重大进展)</h3><ol><li><p><strong>收获后处理逻辑（后端）</strong>：<br>当用户发起收获并成功创建配送单后，系统自动执行以下操作，确保数据状态准确：</p><ul><li><strong>清空地块</strong>：将对应地块的作物状态重置为 <code>empty</code>。</li><li><strong>扣减权益</strong>：<ul><li>对于<strong>次数型</strong>权益：将 <code>uses_left</code> (剩余次数) 减1。若次数用尽，则将权益状态置为 <code>consumed</code>。</li><li>对于<strong>时长型</strong>权益：不扣减次数，仅检查有效期。</li></ul></li><li><strong>更新权益状态</strong>：重新计算该地块的 <code>owned</code> 字段。只要仍有有效的<code>active</code>权益（次数未用完或未过期），<code>owned</code> 即为 <code>true</code>，否则为 <code>false</code>。</li></ul></li><li><p><strong>前端支付流程优化（已解决）</strong>：<br>修复了 <code>purchaseServicePackage</code> 函数中 <code>await</code> 与 <code>success</code> 回调混用导致的逻辑问题。</p><ul><li><strong>解决方案</strong>：重写该函数，采用纯 <code>async/await</code> 方式调用支付接口。支付成功后，<strong>立即调用后端接口刷新地块数据</strong>，并提交一个 <code>mutation</code> 来本地更新状态，确保UI显示及时、准确。</li></ul></li></ol><hr><h3 id="三、-待解决的问题与下周计划"><a href="#三、-待解决的问题与下周计划" class="headerlink" title="三、 待解决的问题与下周计划"></a>三、 待解决的问题与下周计划</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>问题描述</strong></th><th style="text-align:left"><strong>性质</strong></th><th style="text-align:left"><strong>可能解决方案/下一步计划</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>1. 移动端支付后可重复点击</strong></td><td style="text-align:left">前端交互BUG</td><td style="text-align:left">在支付请求发起后，禁用按钮并显示加载状态，直到收到明确的成功/失败回调。</td></tr><tr><td style="text-align:left"><strong>2. 后台需集成第三方服务</strong></td><td style="text-align:left">技术方案调研</td><td style="text-align:left">调研并选择可靠的第三方服务提供商（如支付宝/微信支付官方API、聚合支付平台、物流公司API），然后编写对接代码。</td></tr></tbody></table></div><p><strong>下周计划：</strong></p><ul><li><strong>解决遗留问题</strong>：优先修复移动端支付交互BUG，并启动第三方服务对接的调研与开发。</li><li><strong>功能增强</strong>：基于已打通的闭环，考虑添加更多作物管理操作（如施肥、除虫）、优化日志系统、设计更完善的管家通知中心。</li><li><strong>测试与部署</strong>：进行更全面的测试，准备将新功能部署至测试或生产环境。</li></ul><hr><h3 id="四、-本周工作回顾：核心业务闭环全面打通"><a href="#四、-本周工作回顾：核心业务闭环全面打通" class="headerlink" title="四、 本周工作回顾：核心业务闭环全面打通"></a><strong>四、 本周工作回顾：核心业务闭环全面打通</strong></h3><p>本周的核心工作是推动农场项目的<strong>完整业务流程实现</strong>与<strong>后台管理系统强化</strong>，并成功完成了端到端的测试验证。</p><ol><li><strong>后端服务建设</strong>：完成了<strong>下单服务</strong>与<strong>后台托管服务</strong>的开发，实现了订单的接收、处理、存储，以及管家的任务分配与权限管理。</li><li><strong>后台管理功能增强</strong>：开发了功能完善的订单管理页面（列表、筛选、详情）、托管服务日志记录模块，并实现了作物与管家的绑定管理。</li><li><strong>核心业务闭环验证</strong>：成功打通了“<strong>用户购买服务 -&gt; 播种 -&gt; 进行浇水等管理操作 -&gt; 自动生成日志 -&gt; 收获并创建配送单 -&gt; 地块状态重置</strong>”的完整业务流程，标志着项目最核心的功能链路已全部跑通。</li><li><strong>前端体验优化</strong>：修复了购买服务页面的显示问题，优化了订单界面，并重写了支付逻辑，确保了交互的准确性和数据的一致性。</li></ol><h3 id="五、-问题与反思：技术方案与细节处理需持续打磨"><a href="#五、-问题与反思：技术方案与细节处理需持续打磨" class="headerlink" title="五、 问题与反思：技术方案与细节处理需持续打磨"></a>五<strong>、 问题与反思：技术方案与细节处理需持续打磨</strong></h3><p>在开发过程中，也遇到并识别了一些亟待解决的问题，主要集中在交互细节和技术方案选型上。</p><ol><li><strong>移动端交互细节问题</strong>：手机端支付成功后，按钮状态未能及时重置，导致用户可重复点击，<strong>暴露了前端对连续请求控制的不足</strong>。这需要通过添加加载状态和按钮禁用机制来优化。</li><li><strong>外部集成技术方案待定</strong>：后台系统需要接入支付、物流等第三方服务，但目前<strong>尚未确定具体的技术选型和对接方案</strong>，这是下一步需要重点调研和决策的点。</li><li><strong>逻辑严谨性</strong>：在解决“收获后清空地块”等复杂业务逻辑时，意识到必须通过<strong>精准的后端逻辑</strong>（如扣减权益、状态更新）来保证数据一致性，而非依赖前端。</li></ol><h3 id="六、-下周计划：解决遗留问题，推进系统集成与优化"><a href="#六、-下周计划：解决遗留问题，推进系统集成与优化" class="headerlink" title="六、 下周计划：解决遗留问题，推进系统集成与优化"></a><strong>六、 下周计划：解决遗留问题，推进系统集成与优化</strong></h3><p>基于本周的进展和问题，下周的工作将围绕以下重点展开：</p><ol><li><strong>优先解决遗留问题</strong>：<ul><li>修复移动端支付交互BUG，增加防重复提交机制。</li><li>启动对第三方服务（如支付、物流API）的调研，并形成初步的集成方案。</li></ul></li><li><strong>功能增强与优化</strong>：<ul><li>在现有闭环基础上，规划并开发更多的作物管理操作（如施肥、除虫）。</li><li>优化日志系统和管家通知中心，提升用户体验和管理效率。</li></ul></li><li><strong>测试与部署准备</strong>：<ul><li>对已打通的全流程进行更全面的测试，准备将稳定版本部署至测试环境。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第七周</title>
    <link href="/2025/08/30/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/"/>
    <url>/2025/08/30/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%83%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="周一：农场服务前端界面实现"><a href="#周一：农场服务前端界面实现" class="headerlink" title="周一：农场服务前端界面实现"></a><strong>周一：农场服务前端界面实现</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现托管服务操作流程：点击托管→选择种植物→确认收获→判断收获方式。  </li><li>搭建基础农场前端界面，完成用户交互逻辑。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>收获方式判断逻辑需与后端土地状态同步（未实时更新）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>添加前端定时查询地块状态，确保数据一致性。  </li></ul><hr><h3 id="周二：订单生成与支付界面优化"><a href="#周二：订单生成与支付界面优化" class="headerlink" title="周二：订单生成与支付界面优化"></a><strong>周二：订单生成与支付界面优化</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>对接托管服务订单接口（<code>/orders/service</code>），生成订单并关联用户与地块数据。  </li><li>优化支付界面样式，使其更简洁清晰，支持后续扩展托管服务类型。  </li><li>实现土地及托管服务数据存储，支持详细查询。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>支付界面在不同设备上显示错位（移动端适配问题）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>使用响应式布局（CSS Flexbox+Media Query）快速修复。  </li></ul><hr><h3 id="周三：扩展购买与播种功能"><a href="#周三：扩展购买与播种功能" class="headerlink" title="周三：扩展购买与播种功能"></a><strong>周三：扩展购买与播种功能</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>扩展托管服务购买功能（接口：<code>/farm/service/package/purchase</code>）。  </li><li>实现种子播种功能（接口：<code>/farm/plant</code>）并关联地块数据（接口：<code>/farm/plots</code>）。  </li><li>订单查询与支付状态联动（支付成功自动更新订单状态）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>播种请求超时（地块数据量增大导致查询缓慢）。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>为<code>/farm/plots</code>接口添加缓存机制（Redis缓存地块信息）。  </li></ul><hr><h3 id="周四：后台管理系统开发"><a href="#周四：后台管理系统开发" class="headerlink" title="周四：后台管理系统开发"></a><strong>周四：后台管理系统开发</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>实现后台托管服务管理（增删改查）。  </li><li>开发作物管理模块（支持作物信息维护）。  </li><li>搭建每周日志记录功能（支持日志添加与查询）。  </li><li>完成种子管理基础功能（CRUD操作）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>管家管理模块需对接若依权限系统，但账户体系不兼容。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>暂独立开发管家管理模块，预留若依系统对接接口。  </li></ul><hr><h3 id="周五：后台功能完善与权限隔离"><a href="#周五：后台功能完善与权限隔离" class="headerlink" title="周五：后台功能完善与权限隔离"></a><strong>周五：后台功能完善与权限隔离</strong></h3><p><strong>完成工作</strong>：  </p><ul><li>完成托管服务、作物管理、每周日志、种子管理的完整增删改查功能。  </li><li>优化后台数据查询效率（添加数据库索引）。  </li><li>管家管理模块独立运行（暂未关联若依登录）。  </li></ul><p><strong>遇到的问题</strong>：  </p><ul><li>若依系统权限接口文档缺失，无法直接对接。  </li></ul><p><strong>解决方式</strong>：  </p><ul><li>优先保证其他后台功能上线，管家管理采用若依账号过渡。  </li></ul><hr><h3 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a><strong>本周总结</strong></h3><h4 id="1-独立完成内容"><a href="#1-独立完成内容" class="headerlink" title="1. 独立完成内容"></a><strong>1. 独立完成内容</strong></h4><ul><li>前端农场服务全流程（托管→支付→播种→收获）。  </li><li>订单与支付系统集成（微信支付+订单状态管理）。  </li><li>后台管理核心功能（作物、日志、种子、托管服务管理）。  </li></ul><h4 id="2-主要挑战"><a href="#2-主要挑战" class="headerlink" title="2. 主要挑战"></a><strong>2. 主要挑战</strong></h4><ul><li><strong>支付合规性</strong>：订单号长度限制（32位）、HTTPS证书配置。  </li><li><strong>系统兼容性</strong>：管家模块与若依权限系统账户体系不匹配。  </li><li><strong>性能问题</strong>：地块数据量增大导致查询缓慢。  </li></ul><h4 id="3-成长与改进"><a href="#3-成长与改进" class="headerlink" title="3. 成长与改进"></a><strong>3. 成长与改进</strong></h4><ul><li><strong>第三方集成经验</strong>：支付接口必须严格遵循字段规范（如订单号长度）。  </li><li><strong>解耦设计</strong>：模块化开发（如管家管理独立）降低系统耦合风险。  </li><li><strong>性能优化</strong>：引入缓存与数据库索引应对数据增长。  </li></ul><h4 id="4-后续计划"><a href="#4-后续计划" class="headerlink" title="4. 后续计划"></a><strong>4. 后续计划</strong></h4><ul><li>补全若依系统对接文档，完成管家权限集成。  </li><li>统一接口响应格式，编写后端API文档。  </li><li>增加农场操作（播种、收获）的事务回滚机制。  </li></ul><p><strong>总结</strong>：本周成功交付农场系统核心功能，但支付与权限集成暴露了<strong>预研不足</strong>的问题。后续类似项目需提前验证第三方接口（支付、登录）的合规性；  </p>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第六周</title>
    <link href="/2025/08/25/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/"/>
    <url>/2025/08/25/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%85%AD%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>本周核心目标：</strong> 实现小程序核心交易与农场种植闭环（支付功能 + 农场后端服务）<br><strong>整体进展：</strong> ✅ 成功打通<code>HTTPS部署</code> -&gt; <code>微信支付</code> -&gt; <code>农场种植</code>全链路，项目进入可演示阶段。</p><hr><h3 id="一、-每日工作记录"><a href="#一、-每日工作记录" class="headerlink" title="一、 每日工作记录"></a><strong>一、 每日工作记录</strong></h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th style="text-align:left"><strong>核心工作</strong></th><th style="text-align:left"><strong>关键产出与细节</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>周一</strong></td><td style="text-align:left"><strong>HTTPS服务配置</strong></td><td style="text-align:left">✅ <strong>前端</strong>：使用Nginx配置SSL证书，实现小程序前端页面的HTTPS安全访问。<br>✅ <strong>后端</strong>：在SpringBoot中配置SSL证书，使后端API支持HTTPS请求，为微信支付等安全接口打下基础。</td></tr><tr><td style="text-align:left"><strong>周二</strong></td><td style="text-align:left"><strong>微信支付集成</strong></td><td style="text-align:left">✅ 集成<strong>微信支付V2版</strong>，完成下单、回调等核心流程开发。<br>✅ 使用<strong>内网穿透</strong>工具模拟支付环境，初步测试通过。<br>⚠️ <strong>待办</strong>：退款功能暂未实现。</td></tr><tr><td style="text-align:left"><strong>周三</strong></td><td style="text-align:left"><strong>问题修复与设计</strong></td><td style="text-align:left">✅ <strong>修复支付Bug</strong>：深入分析并解决了官方文档中提及的“订单重复”问题，优化为首次<code>统一下单</code>、后续调用<code>jsapi</code>的稳定流程。<br>✅ <strong>数据库设计</strong>：为农场托管功能设计了<code>farms</code>（田地）、<code>crops</code>（种子）、<code>farmManagers</code>（农场管家）三张核心表，明确通过JWT鉴权来隔离用户数据。</td></tr><tr><td style="text-align:left"><strong>周四</strong></td><td style="text-align:left"><strong>农场服务开发</strong></td><td style="text-align:left">✅ 开发并部署核心农场后端服务，提供初步可用的RESTful API：<br>  - <code>POST /farm/plant</code>： <strong>种植接口</strong><br>  - <code>POST /farm/init</code>： <strong>初始化用户田地</strong><br>  - <code>POST /farm/listByUser</code>： <strong>获取用户田地信息</strong></td></tr><tr><td style="text-align:left"><strong>周五</strong></td><td style="text-align:left"><strong>联调与架构复盘</strong></td><td style="text-align:left">✅ 成功完成前端与农场服务的联调，可获取并展示用户种植数据。<br>✅ <strong>架构决策</strong>：确定使用<strong>混合云开发</strong>方案（自建MySQL + 云服务），兼顾了数据灵活性与开发效率。</td></tr></tbody></table></div><hr><h3 id="二、-本周最大的挑战与解决方案"><a href="#二、-本周最大的挑战与解决方案" class="headerlink" title="二、 本周最大的挑战与解决方案"></a><strong>二、 本周最大的挑战与解决方案</strong></h3><ul><li><strong>挑战：</strong> 技术选型在<strong>数据库扩展性</strong>与<strong>开发维护效率</strong>之间的权衡。纯微信云开发无法满足复杂的MySQL业务需求，而完全自建服务器运维成本较高。</li><li><strong>解决方案：</strong> 采用<strong>混合云架构</strong>。<ul><li><strong>核心业务数据</strong>（用户、订单、农场）：使用自建云服务器上的MySQL数据库，保证了对数据的完全控制和复杂查询能力。</li><li><strong>静态资源/轻量功能</strong>：后续可考虑使用云开发平台的服务，提升开发速度与稳定性。</li></ul></li><li><strong>结果：</strong> 该方案既满足了当前业务的复杂度，又为未来部分功能的快速迭代提供了灵活性，速度与稳定性兼得。</li></ul><hr><h3 id="三、-本周工作带来的成长"><a href="#三、-本周工作带来的成长" class="headerlink" title="三、 本周工作带来的成长"></a><strong>三、 本周工作带来的成长</strong></h3><ol><li><strong>全链路能力提升：</strong> 从最基础的HTTPS配置，到复杂的支付业务、数据库设计，再到后端服务开发，独立打通了核心功能的全链路，对前后端协同开发的理解更加深刻。</li><li><strong>技术方案设计能力：</strong> 不再局限于实现功能，开始从<strong>架构角度</strong>思考问题（如混合云选型），学会了在多种技术方案中权衡利弊，选择最适合当前业务阶段的方案。</li><li><strong>文档驱动开发：</strong> 通过编写设计文档来理清逻辑，再着手编码，有效减少了开发过程中的反复和错误，提升了开发效率和质量。</li></ol><hr><h3 id="四、-反思与未来优化"><a href="#四、-反思与未来优化" class="headerlink" title="四、 反思与未来优化"></a><strong>四、 反思与未来优化</strong></h3><ul><li><strong>本周不足：</strong> 最初的方案设计对<strong>云原生</strong>和<strong>混合架构</strong>的考量不够深入，导致中途需要调整技术路线，产生了一定的学习成本。</li><li><strong>未来优化：</strong><ol><li><strong>架构设计</strong>：在项目初期，应更系统地评估各种技术方案（自建、纯云、混合云）的优缺点，制作详细的对比表格，避免后期切换。</li><li><strong>可维护性</strong>：虽然混合方案稳定，但未来可以考虑使用<strong>Docker容器化</strong>来部署MySQL和应用，提升环境一致性和迁移效率。</li><li><strong>功能完善</strong>：下一步需补全<strong>退款流程</strong>，并开始构建基于农场数据的<strong>商城购买与订单生成</strong>功能，最终完成商业闭环。</li></ol></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第五周</title>
    <link href="/2025/08/17/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/"/>
    <url>/2025/08/17/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%BA%94%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><div class="table-container"><table><thead><tr><th>日期</th><th>核心工作</th><th>关键产出</th></tr></thead><tbody><tr><td><strong>周一</strong></td><td>后台系统技术选型与架构设计</td><td>✅ 选定 <strong>若依框架</strong> 搭建后台管理系统<br>✅ 完成 <strong>功能模块划分</strong> 及技术文档输出</td></tr><tr><td><strong>周二</strong></td><td>用户管理模块开发</td><td>✅ 实现用户信息 <strong>增删改查（CRUD）</strong> 全功能</td></tr><tr><td><strong>周三</strong></td><td>核心业务模块开发</td><td>✅ 完成 <strong>订单管理</strong> 业务流程设计<br>✅ 落地 <strong>土地管理</strong> CRUD 核心逻辑</td></tr><tr><td><strong>周四</strong></td><td>技术方案优化与问题修复</td><td>✅ 验证 <strong>微信云开发</strong> 替代方案可行性<br>✅ 修复 <strong>图片上传异常</strong> Bug（改用云存储+路径映射）</td></tr><tr><td><strong>周五</strong></td><td>混合架构设计与规划</td><td>✅ 制定 <strong>MySQL + 云数据库混合方案</strong><br>✅ 参与 <strong>后续原型扩展</strong> 技术讨论</td></tr></tbody></table></div><hr><h3 id="关键亮点说明："><a href="#关键亮点说明：" class="headerlink" title="关键亮点说明："></a>关键亮点说明：</h3><ol><li><p><strong>技术选型</strong>：  </p><ul><li>选择 <strong>若依框架</strong> → 节省60%基础模块开发时间  </li><li>放弃纯云开发 → 因 <strong>MySQL业务兼容性</strong> 不足  </li></ul></li><li><p><strong>架构突破</strong>：  </p><pre><code class=" mermaid">graph LRA[微信小程序] --&gt; B&#123;云存储&#125;A --&gt; C[自建服务器]B --&gt; D[图片/文件]C --&gt; E[MySQL业务库]</code></pre><p><strong>混合架构价值</strong>：静态资源云化减压，核心数据自主可控  </p></li></ol><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>工作内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长收获</strong></th></tr></thead><tbody><tr><td><strong>1. 后台系统设计</strong><br> - 技术选型（若依框架）<br> - 功能模块规划文档</td><td>• 平衡开发效率与后期扩展性</td><td>• 选择 <strong>开源后台框架若依</strong>（集成权限管理/代码生成）</td><td>✅ 掌握 <strong>快速搭建企业级后台</strong> 的方法论</td></tr><tr><td><strong>2. 核心模块开发</strong><br> - 用户管理（增删改查）<br> - 订单/土地管理功能</td><td>• 数据库设计需兼容农场业务逻辑<br>• 字段关联性复杂</td><td>• 先画 <strong>ER图梳理数据关系</strong><br>• 用若依代码生成器快速实现基础CRUD</td><td>✅ 提升 <strong>业务模型抽象能力</strong><br>✅ 熟练 <strong>框架工具提效技巧</strong></td></tr><tr><td><strong>3. 技术方案优化</strong><br> - 尝试微信云开发<br> - 图片上传BUG修复</td><td>• 云开发与传统MySQL不兼容<br>• 图片路径存储异常</td><td>• 改用 <strong>混合云架构</strong>：<br>  - 核心业务用云服务器+MySQL<br>  - 图片/文件用云存储</td><td>✅ 理解 <strong>混合云方案设计思维</strong><br>✅ 学会 <strong>根据场景灵活选型</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><ol><li><p><strong>「快 vs 稳」的博弈</strong>：  </p><blockquote><p>若依框架虽加速开发，但过度依赖其生成代码可能导致<strong>技术债积累</strong>（如订单扩展字段需手动调整），下次需预留20%自定义空间。  </p></blockquote></li><li><p><strong>云服务的双刃剑</strong>：  </p><blockquote><p>微信云开发适合轻量应用，但<strong>数据库生态封闭</strong>（不支持MySQL）成为硬伤，混合架构虽解燃眉之急，也带来运维复杂度。  </p></blockquote></li></ol><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><ol><li><p><strong>技术选型更严谨</strong>：  </p><ul><li><p>制作 <strong>方案对比表</strong>（如下），避免试错成本：<br>| 方案         | 扩展性 | 维护成本 | 适合场景       |<br>| —————— | ——— | ———— | ——————— |<br>| 自建MySQL    | ★★★★   | 中       | 复杂业务       |<br>| 纯微信云开发 | ★★     | 低       | 轻量工具类应用 |<br>| <strong>混合云</strong>   | ★★★    | <strong>中高</strong> | <strong>中庸型项目</strong> |</p></li><li><p>非核心功能（如图片上传）<strong>彻底云化</strong>，直接用云开发SDK。  </p></li></ul></li><li><p><strong>建立原型验证机制</strong>：  </p><ul><li>重要模块（如订单状态机）先写 <strong>伪代码流程图</strong> 与产品确认，避免返工。  </li></ul></li></ol><blockquote><p><strong>总结</strong>：本周深刻体会架构选型需考量 <strong>业务生命周期</strong>（短期效率 vs 长期扩展）。未来将坚持 <strong>“设计-原型-开发”三步走</strong>，让技术真正服务业务增长。  </p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州it工作第四周</title>
    <link href="/2025/08/10/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <url>/2025/08/10/%E5%B9%BF%E5%B7%9Eit%E5%B7%A5%E4%BD%9C%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>周一：</strong>  </p><ul><li>完成租地功能：设计租赁信息表，JWT鉴权后创建租赁记录。  </li><li><em>注意点：</em> 补充了状态字段设计。</li></ul><p><strong>周二：</strong>  </p><ul><li>构建订单系统：创建订单主表及详情表，实现：  <ul><li>JWT用户订单查询  </li><li>多状态分类（待支付/待发货等）  </li><li>PageHelper分页（&gt;10自动分页，加载页面缓存进度）  </li></ul></li><li><em>遗留问题：</em> 订单号长度仅20位（需32位）。</li></ul><p><strong>周三：</strong>  </p><ul><li>订单详情增强：调用土地接口展示租赁地块信息。  </li><li>前端隐患：<code>this.orderInfo.items[0]</code> 强耦合数据绑定。  </li></ul><p><strong>周四：</strong>  </p><ul><li>订单状态管理：实现增删改查及状态流转（如取消订单同步释放土地）。  </li><li><em>优化：</em> 采用状态模式替代if-else链。  </li></ul><p><strong>周五：</strong>  </p><ul><li>支付功能受阻：  <ol><li><strong>致命问题：</strong> 后端未配置HTTPS（微信支付强制要求）  </li><li><strong>设计缺陷：</strong> 订单号长度不符支付接口规范（20位≠32位）  </li></ol></li><li><em>转向：</em> 启动手机号验证方案研究。  </li></ul><p><strong>周六：</strong>  </p><ul><li>微信验证困局：  <ul><li>手机号快速验证失败（需企业认证）  </li><li><code>getUserProfile</code>仅获取基础信息（头像/昵称）  </li><li>开放数据解密流程复杂且无进展  </li></ul></li><li><em>结论：</em> 当前微信政策下，获取手机号一键登录不可行。  </li></ul><hr><p><strong>核心卡点：</strong>  </p><ol><li><strong>支付环节：</strong> HTTPS缺失 + 订单号设计缺陷  </li><li><strong>微信生态：</strong> 政策收紧导致手机号获取路径封死</li></ol><h3 id="一、独立完成-amp-挑战-amp-成长"><a href="#一、独立完成-amp-挑战-amp-成长" class="headerlink" title="一、独立完成 &amp; 挑战 &amp; 成长"></a><strong>一、独立完成 &amp; 挑战 &amp; 成长</strong></h3><div class="table-container"><table><thead><tr><th><strong>事项</strong></th><th><strong>独立完成</strong></th><th><strong>最大挑战</strong></th><th><strong>克服方式</strong></th><th><strong>成长</strong></th></tr></thead><tbody><tr><td><strong>租地系统</strong></td><td>租赁表设计 + JWT用户绑定</td><td>状态字段缺失</td><td>快速补字段 + 关联订单状态</td><td>意识到<strong>数据扩展性</strong>的重要性</td></tr><tr><td><strong>订单中台</strong></td><td>双表创建 + 分页/状态筛 + 状态机</td><td>订单号长度设计不足(20位)</td><td>重构为32位 UUID</td><td><strong>关键字段需预判业务需求</strong></td></tr><tr><td><strong>支付对接</strong></td><td>调用微信支付流程开发</td><td>1. 无HTTPS<br>2. 微信政策限制</td><td>转向备用方案（手机号验证）</td><td>第三方功能<strong>必须预研环境/政策</strong></td></tr><tr><td><strong>微信集成</strong></td><td>实现<code>getUserProfile</code>基础授权</td><td>无法获取用户准确信息（政策封锁）</td><td>明确放弃，转为人工审核流程</td><td>学会<strong>在限制中寻找替代路径</strong></td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a><strong>二、本周工作思考</strong></h3><ol><li><strong>做得好的</strong>  <ul><li>基础功能闭环：租地→订单→状态流转全链路跑通  </li><li>快速响应问题：发现订单号缺陷应该立即重构  </li></ul></li><li><strong>待改进的</strong>  <ul><li><strong>致命疏忽</strong>：支付未提前验证HTTPS/字段规则 → 导致整块功能返工  </li><li><strong>过度乐观</strong>：低估微信政策限制（开发者权限）  </li></ul></li><li><strong>核心认知</strong>  <blockquote><p><strong>“能开发” ≠ “能上线”</strong><br>第三方依赖的合规性（HTTPS/政策）比代码更重要  </p></blockquote></li></ol><hr><h3 id="三、未来同样机会的做法"><a href="#三、未来同样机会的做法" class="headerlink" title="三、未来同样机会的做法"></a><strong>三、未来同样机会的做法</strong></h3><ol><li><p><strong>预研四象限（首日必做）</strong>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[技术]</span>      <span class="hljs-selector-attr">[政策]</span>      <span class="hljs-selector-attr">[环境]</span>       <span class="hljs-selector-attr">[兼容性]</span>  <br>│          │          │            │  <br>├─HTTPS?   ├─微信文档? ├─测试账号?   ├─字段长度?  <br>└─SDK兼容  └─权限范围  └─域名备案    └─数据格式  <br></code></pre></td></tr></table></figure></li><li><p><strong>设计两原则</strong>  </p><ul><li><strong>字段设计</strong>：订单号/金额等支付相关字段，直接对齐微信要求（32位/UUID）  </li><li><strong>解耦开发</strong>：支付模块用模拟运行，便于替换（例：HTTPS未就绪时模拟支付）  </li></ul></li><li><p><strong>政策应对</strong>  </p><ul><li>项目避免强依赖微信敏感接口（如手机号）  </li></ul></li></ol><blockquote><p><strong>总结一句话</strong>：<br><strong>下次先花2小时跑通支付Demo+政策验证，再动手写业务代码。</strong><br>功能开发速度 ≠ 交付速度，预研省下的就是返工浪费的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广漂码农第三周</title>
    <link href="/2025/08/02/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <url>/2025/08/02/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>核心目标：</strong> 独立搭建农场小程序的订单系统（包括后台接口、前端页面和数据库）。</p><p><strong>本周主要进展：</strong></p><ol><li><p><strong>项目启动与基础搭建 (周一)：</strong></p><ul><li>用开发工具创建了小程序项目框架。</li><li><strong>首页：</strong> 实现了图片热区点击跳转（用<code>绝对定位</code>精确定位点击区域，<code>uni.switchTab</code>跳转底部菜单页）。</li><li><strong>公告栏：</strong> 暂时留空。</li><li><strong>我的农场：</strong> 开始设计核心玩法（比如种植收获逻辑）。</li><li><strong>个人中心：</strong> 画好了页面布局。</li><li>图片上传到<code>图床</code>，减小小程序安装包体积。</li></ul></li><li><p><strong>界面优化与农场互动 (周二)：</strong></p><ul><li><strong>首页：</strong> 用<code>媒体查询</code>让页面在不同尺寸手机上都好看（响应式布局）。</li><li><strong>我的农场：</strong> 用<code>Grid网格布局</code>做了9块整齐的地块。点击地块能弹出操作图片（比如选择种子）。</li><li><strong>个人中心：</strong> 本想做微信<code>一键登录</code>（获取手机号），但个人小程序权限不够。改用方案：用户授权获取微信<code>头像和昵称</code>绑定账号，登录成功后服务器返回一个<code>token</code>（身份令牌）存起来，代表用户已登录。</li></ul></li><li><p><strong>新增功能模块 (周三)：</strong></p><ul><li><strong>首页：</strong> 加了“马克农场”入口，点击后跳转新页面（用<code>uni.navigateTo</code>页面跳转）。</li><li><strong>个人中心：</strong> 增加了“设置”页面，可以修改个人信息。</li></ul></li><li><p><strong>核心登录功能实现 (周四)：</strong></p><ul><li><strong>个人中心：</strong><ul><li>实现了完整的微信登录流程：<ol><li>小程序获取临时登录凭证<code>code</code>。</li><li>把<code>code</code>发给我的后台服务器。</li><li>后台用<code>code</code>向微信服务器换取用户的<code>唯一标识(openid)</code>等信息。</li><li>后台查数据库：如果是新用户，就创建账号；老用户则读取信息。</li><li>后台生成<code>token</code>，连同用户信息一起返回给小程序。</li><li>小程序把<code>token</code>和用户信息存起来（<code>storage</code>），后续操作代表该用户。</li></ol></li><li><em>注：等小程序主体是企业后，可升级为手机号直接登录。</em></li></ul></li><li><strong>订单页：</strong> 实现了跳转到不同订单类型页的功能（在链接后面加<code>?type=...</code>传参）。解决了引入图标库时的兼容性问题。</li></ul></li><li><p><strong>用户信息保护与更新 (周五)：</strong></p><ul><li>完善登录后的安全措施：采用<code>JWT令牌</code>进行<code>鉴权</code>（验证身份）。<ul><li><strong>为什么选JWT？</strong> 主要因为它不需要<code>Cookie</code>，避免了<code>跨域(CORS)</code>问题，更方便不同服务器间协作。而且服务器不用存储用户登录状态（<code>无状态</code>），减轻负担。</li><li><strong>怎么用？</strong> 用户登录后拿到<code>JWT token</code>（就是周四的那个token）。当用户想修改头像昵称等需要登录的操作时，小程序在请求头里带上这个token（格式：<code>Authorization: Bearer &lt;你的token&gt;</code>）。后台收到请求后，先<code>验证token是否有效且合法</code>，验证通过了才允许修改用户信息。</li></ul></li><li>实现了登录后修改头像和昵称的功能。</li></ul></li></ol><p><strong>简单来说，这周：</strong> 搭好了小程序的基础架子，重点实现了用户<code>登录注册流程</code>（包括微信授权、后台验证、生成令牌JWT），完成了个人中心的主要功能（信息展示、设置、头像昵称修改），并开始为订单系统做跳转准备。技术上解决了图片优化、布局适配、登录授权、身份验证（JWT）等关键点。</p><p>以下是对本周工作的结构化复盘总结，结合实践与成长思考：</p><hr><h3 id="一、独立完成事项-amp-挑战与成长"><a href="#一、独立完成事项-amp-挑战与成长" class="headerlink" title="一、独立完成事项 &amp; 挑战与成长"></a>一、独立完成事项 &amp; 挑战与成长</h3><div class="table-container"><table><thead><tr><th><strong>完成内容</strong></th><th><strong>挑战</strong></th><th><strong>克服方式</strong></th><th><strong>带来的成长</strong></th></tr></thead><tbody><tr><td><strong>1. 用户系统全流程搭建</strong><br> - 微信登录+JWT鉴权<br> - 头像/昵称修改功能</td><td>• 个人小程序无法直接获取手机号<br>• JWT无状态鉴权首次实战</td><td>• 改用 <strong>Code→OpenID→Token</strong> 替代方案<br>• 研读JWT机制，设计 <strong>Bearer Token</strong> 请求头鉴权逻辑</td><td>✅ 掌握<strong>受限条件下的灵活架构能力</strong><br>✅ 理解<strong>无状态认证</strong>的设计优势与风险</td></tr><tr><td><strong>2. 农场交互核心模块</strong><br> - Grid九宫格布局<br> - 地块点击弹窗交互</td><td>• 动态弹窗与地块操作状态联动<br>• 多端样式适配</td><td>• 用 <strong>CSS变量+媒体查询</strong> 控制响应式<br>• <strong>事件委托</strong> 统一管理地块点击逻辑</td><td>✅ 强化 <strong>复杂交互前端设计能力</strong><br>✅ 提升 <strong>CSS3实战应用水平</strong></td></tr><tr><td><strong>3. 项目基建优化</strong><br> - 图床节省包体积<br> - 路由传参统一管理</td><td>• 图标库兼容性问题<br>• 路由跳转类型混乱</td><td>• <strong>源码调试+强制样式覆盖</strong> 解决依赖冲突<br>• 封装 <strong>路由工具函数</strong> 统一处理?type=参数</td><td>✅ 学会 <strong>第三方库问题排查技巧</strong><br>✅ 养成 <strong>提前封装工具类</strong> 的习惯</td></tr></tbody></table></div><hr><h3 id="二、本周工作思考"><a href="#二、本周工作思考" class="headerlink" title="二、本周工作思考"></a>二、本周工作思考</h3><p><strong>1. 技术决策的价值</strong>：  </p><blockquote><p>选择JWT不仅解决了跨域问题，更让我意识到<strong>技术选型需服务业务场景</strong>——个人小程序无法用企业级登录方案时，用Token机制快速搭建安全认证体系是最优解。  </p></blockquote><p><strong>2. 限制催生创新</strong>：  </p><blockquote><p>微信API权限限制反而推动设计出更通用的 <strong>「Code+OpenID+DB」用户绑定流程</strong>，未来扩展手机号/邮箱登录只需复用该流程。  </p></blockquote><p><strong>3. 技术债预警</strong>：  </p><blockquote><p>临时解决CSS兼容性的“hack手段”需在迭代中重构，<strong>开发效率与代码质量必须动态平衡</strong>。  </p></blockquote><hr><h3 id="三、若重来我会如何做？"><a href="#三、若重来我会如何做？" class="headerlink" title="三、若重来我会如何做？"></a>三、若重来我会如何做？</h3><p><strong>1. 前置设计更彻底</strong>：  </p><blockquote><ul><li>用<strong>流程图</strong>预先规划登录/鉴权全链路（避免周四返工）  </li><li>订单系统数据库<strong>提前预留扩展字段</strong>（如<code>order_type</code>应对跳转传参）  </li></ul></blockquote><p><strong>2. 技术方案分层验证</strong>：  </p><blockquote><ul><li>关键模块（如JWT）先写<strong>技术原型Demo</strong>再集成  </li><li>第三方库（uView）提前做<strong>兼容性测试矩阵</strong>  </li></ul></blockquote><p><strong>3. 自动化提效</strong>：  </p><blockquote><ul><li>用<strong>CI/CD工具</strong>自动压缩图片上传图床  </li><li>编写<strong>路由配置生成脚本</strong>避免手写跳转参数  </li></ul><p><strong>总结</strong>：未来需更注重<strong>前瞻性设计</strong>与<strong>可持续架构</strong>，让代码既能跑得快，更能跑得远。  </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广漂码农第二周：手撕验证码Session，给订单系统“安家落户”</title>
    <link href="/2025/07/27/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/"/>
    <url>/2025/07/27/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%BA%8C%E5%91%A8%EF%BC%9A%E6%89%8B%E6%92%95%E9%AA%8C%E8%AF%81%E7%A0%81Session%EF%BC%8C%E7%BB%99%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%AE%89%E5%AE%B6%E8%90%BD%E6%88%B7%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p><strong>核心任务：</strong> 独立完成车位项目订单系统后端接口、前端页面及数据库设计。</p><p><strong>本周开发纪实：</strong></p><ol><li><strong>周一：</strong> 复盘上周工作，为本周冲刺蓄力。</li><li><strong>周二：</strong> 承接新需求：<ul><li><strong>记住手机号：</strong> 提升用户体验。</li><li><strong>自定义弹窗：</strong> 实现灵活交互。</li><li><strong>价格需求：</strong> 核心业务逻辑。</li><li><strong>技术选型：</strong> 确定使用 <code>HttpSession</code> 存储 <code>手机号:验证码</code> 键值对，作为临时认证方案。</li></ul></li><li><strong>周三：</strong> 功能实现日<ul><li>完成“记住手机号” ✅</li><li>集成验证码登录 ✅ (<strong>注意点：</strong> 接口参数类型需严格匹配，<code>Session ID</code> 不一致会导致校验失败 - <em>已解决</em>)</li><li>实现协议勾选及自定义弹窗 ✅</li><li><strong>兼容性问题：</strong> 确认微信浏览器不支持 <code>datalist</code> 元素。 (<em>已找到替代方案-采用div来自定义下拉框</em>✅)</li></ul></li><li><strong>周四：</strong> 优化与设计<ul><li><strong>验证码生命周期优化：</strong> 将清除逻辑从固定5分钟 (<code>setInterval</code>)，升级为 <strong>登录成功即销毁</strong> 或 <strong>5分钟到期销毁</strong>，更贴合实际场景。</li><li><strong>数据库设计：</strong> 新增 <code>订单表 (order)</code>。<ul><li>关键设计：通过 <code>spot_id</code> 外键关联车位表。</li><li>决策说明：未直接复用车位表 <code>user_id</code> 字段 (因车位归属逻辑与订单用户逻辑存在差异)。</li></ul></li></ul></li><li><strong>周五：</strong> 数据库深化<ul><li>完善 <code>订单表</code> 结构，清晰记录交易信息。</li><li>设计 <code>优惠规则表 (discount_rule)</code>，定义车位关联的折扣类型与规则。 (<em>终于给优惠上了“户口本”</em>)</li></ul></li><li><strong>周六：</strong> 逻辑实现 &amp; 性能飞跃<ul><li>完成订单金额计算引擎，支持匹配优惠规则。</li><li><strong>接口性能重大优化：</strong><ul><li><strong>问题：</strong> 原有设计需两个接口拉取 <strong>全量用户车位数据</strong>，效率低下。</li><li><strong>方案：</strong> 重构为单一接口，精准查询 <strong>当前用户订单信息</strong>。</li><li><strong>成果：</strong> <strong>响应速度显著提升，数据库压力大幅降低。</strong> ( <em>成功给臃肿接口“瘦身”</em> )</li></ul></li></ul></li></ol><p><strong>本周总结与反思：</strong></p><ol><li><p><strong>主要成就与挑战：</strong></p><ul><li><strong>独立完成：</strong> 成功独立完成了车位及订单模块的后端接口开发、前端订单页面设计以及相关数据库设计。</li><li><strong>关键挑战：</strong> 如何在后端安全、有效地存储和验证用户专属的短信验证码，避免多用户共用同一验证码的风险。</li><li><strong>解决方案：</strong> 采用基于 <code>HttpSession</code> 的存储方案：<ul><li>Key: 用户手机号</li><li>Value: 对应的验证码</li><li>生命周期管理：用户成功登录后或 Session 超时（设置 5 分钟）自动销毁。</li></ul></li><li><strong>成长点：</strong> 深入理解了 <code>HttpSession</code> 机制在后端数据临时存储中的应用。</li></ul></li><li><p><strong>反思与改进点：</strong></p><ul><li><strong>需求理解：</strong> 未来开发前，应更深入地与客户/产品沟通需求细节，以便更好地支持后续扩展性开发。</li><li><strong>数据库设计：</strong> 反思当前设计是否足够精细？例如 <code>user</code> 表可考虑增加 <code>user_type</code>、<code>created_at</code>、<code>last_login_at</code> 等字段增强功能性和可追溯性。</li><li><strong>设计文档：</strong> 意识到个人设计文档的详细度有待提高，需加强文档规范。</li></ul></li><li><p><strong>未来优化方向：</strong></p><ul><li><strong>沟通：</strong> 加强沟通，确保需求理解透彻，及时同步进展。</li><li><strong>数据库：</strong><ul><li>精细化核心表结构（如扩展 <code>user</code> 表字段）。</li><li>建立更清晰的表关系。</li></ul></li><li><strong>后端架构：</strong><ul><li>进行更清晰的分层设计（Controller / Service / Repository / Entity）。</li><li>将车位管理、用户收藏等模块进行逻辑拆分，提高可维护性。</li></ul></li><li><strong>前端：</strong><ul><li>加强浏览器兼容性测试（如已发现的微信 <code>datalist</code> 问题）。</li><li>持续进行界面加载速度优化。</li></ul></li><li><strong>目标：</strong> 通过以上改进，全面提升开发效率、代码质量和系统健壮性，促进个人技术能力的成长。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广漂码农第一周</title>
    <link href="/2025/07/19/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/"/>
    <url>/2025/07/19/%E5%B9%BF%E6%BC%82%E7%A0%81%E5%86%9C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%9A%E8%B8%A9%E5%9D%91%EF%BC%8C%E6%94%B9%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%96%9C%E6%8F%90-%E6%95%B0%E5%AD%97%E5%B0%8F%E5%AD%A9%E6%88%B7%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>前言：新手村报到</strong><br>广漂第一个月，终于上岸！入职第一天，抱着对职场前辈的敬畏（以及怕露怯的紧张），做足准备踏入新战场。记录下这一周，主打一个真实！</p><p><strong>Day 1: HTML星辰大海，打包是个误会？</strong><br>产品经理的原型图甩过来，先设计好文档没问题了再开干！祭出神器 <code>Cursor</code> + <code>Claude-3-Connect</code>，AI 辅助下吭哧吭哧撸完一堆纯 HTML 页面。AI 老哥贴心提示：“亲，打包上传哦~”。我信了！一头扎进打包工具的坑里折腾半天，汗流浃背。结果？<strong>发现特么的纯 HTML 直接扔服务器就能跑！</strong> 打包？打包了个寂寞！今日教训：AI 的话，也得结合上下文判断啊… (╯‵□′)╯︵┻━┻</p><p><strong>Day 2: SpringBoot 从零开始，CSDN 付费墙刺客！</strong><br>今日任务：搞后端 API 录入。第一次正经从零搭 <code>SpringBoot</code> 项目。IDEA 社区版 2023 有点坑，创建方式藏得深。CSDN 搜教程，好家伙，第一步就让装个插件，装完重启直接弹登录+<strong>付费订阅</strong>！真·知识付费刺客！果断弃坑。翻到良心文章指路：<a href="https://start.spring.io">https://start.spring.io</a>，官方生成器真香！唯一小插曲：我 JDK 11 的“老环境”，伺候不了 SpringBoot 3 这位“新贵”，手动把版本和相关依赖<strong>降级到 2.x</strong>，世界终于清净。结论：CSDN 水文害人，官方文档/工具永流传！</p><p><strong>Day 3: 宝塔端口玄学 &amp; “数字小孩”落户口！</strong><br>任务：把后端 API 部署上云服务器（宝塔面板）。一顿操作猛如虎：端口放行√，配置√。测试？<strong>死活连不上！</strong> CSDN 又跳出来“指点”：搞个随机域名数据库？一看还得付费固定域名？我信你个鬼！焦头烂额之际，<strong>猛然想起腾讯云还有个安全组！</strong> 火速添上端口规则，瞬间畅通！啊，这熟悉的安全感… (长舒一口气)</p><ul><li><strong>技术小悟：</strong> 跨域问题，不一定非搬 Nginx 大神。后端配个全局 <code>CORS</code>，指定好前端地址，也能愉快玩耍！省事！</li><li><strong>短信验证码插曲：</strong> 折腾半天接好了，但备案没过的号能发成功吗？心里有点虚，先当它行吧！</li></ul><p><strong>🌟 今日高光时刻 🌟</strong><br>今年我们团队的心血——<strong>“医疗健康问诊系统”</strong>，<strong>喜提国家版权局颁发的《计算机软件著作权登记证书》！</strong> 正式拥有了“<strong>数字小孩</strong>”的户口本！🎉</p><blockquote><p>感谢并肩作战的伙伴，<br>感谢每个改bug到天亮的自己。<br>——【医疗健康问诊系统】软著𝐆𝐞𝐭，未来可期！</p></blockquote><p><strong>Day 4: 切图仔の挣扎 vs 后端の从容（伪）</strong><br>实现一个“点击录入所有数据”的功能。纯 HTML + Vue 的组合，对我这个后端半吊子来说，操作 DOM 像在绣花… <strong>切图仔，属实不易！</strong> 顺带搞了车位收藏功能，数据库表设计修修补补好几回，勉强上线。<strong>结论：前端水太深，后端（的CRUD）才是俺的舒适区（暂时）！</strong></p><p><strong>Day 5: 数据库改改改，AI又救我狗命！</strong><br>搞车位收藏和抢购的多表查询。<strong>是的，我又双叒改数据库了！</strong> 最初设计图样图森破：想着一个车位记录，既能标记收藏又能记录谁买了，还绑 UserID。结果，“车位必须空闲”的规则和用户操作直接打架！卡壳半天，<strong>求助 AI 老哥</strong>，一语点醒：这设计有坑！火速重构，把状态、归属理清楚，功能终于跑通。<strong>教训：数据库设计，脑子得提前多绕几圈，少走弯路！</strong></p><p><strong>周记结尾：</strong><br>第一周，在疯狂踩坑、暴躁搜索、偶尔顿悟和一次巨大惊喜（软著！）中飞逝。从打包误会到安全组玄学，从被 CSDN 付费墙背刺到 AI 救场，从切图痛苦到改库狂魔… <strong>真实又酸爽！</strong> 见识了工具的便利与坑爹，体会了团队的温暖（和一起加班）。代码世界的大门刚推开一条缝，路还长，坑还多，但看着“数字小孩”上了户口，值了！下周，继续升级打怪！</p><hr>]]></content>
    
    
    <categories>
      
      <category>工作心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链智能合约教程-医疗</title>
    <link href="/2025/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/"/>
    <url>/2025/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-%E5%8C%BB%E7%96%97/</url>
    
    <content type="html"><![CDATA[<p>源码</p><p> <a href="https://zhengcookie.github.io\file\区块链\智能合约\medical\医疗\Main.sol">Main.sol</a> </p><p>以下是智能合约代码的逐段解析，按功能模块分类说明：</p><hr><h3 id="1-患者信息管理"><a href="#1-患者信息管理" class="headerlink" title="1. 患者信息管理"></a><strong>1. 患者信息管理</strong></h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Sick &#123;<br>    address accountAddress; // 患者钱包地址<br>    string name;            // 姓名<br>    string sex;             // 性别<br>    uint256 age;            // 年龄<br>    uint256 id;             // 身份证号(主键)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Sick) public sicks;  // 身份证号→患者信息的映射<br>uint256[] public sickIds;               // 所有患者身份证号列表<br></code></pre></td></tr></table></figure><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建患者档案 (需校验参数有效性)<br>function createSick(...) public &#123;<br>    // 参数校验...<br>    sicks[identityNumber] = Sick(...);  // 存储信息<br>    sickIds.push(identityNumber);       // 记录ID<br>    emit SickCreated(...);              // 触发事件<br>&#125;<br><br>// 按身份证查询患者<br>function getSickByIdentityNumber(...) public view returns (...) &#123;<br>    require(sick.accountAddress != address(0)); // 校验存在性<br>    return (sick.accountAddress, ...); <br>&#125;<br><br>// 按钱包地址查询患者<br>function getSickByAccountAddress(...) public view returns (...) &#123;<br>    uint256 sickID = findSickIDByAccountAddress(accountAddr); // 内部遍历查找<br>    return (sick.name, ...);<br>&#125;<br><br>// 辅助函数：地址→ID映射<br>function findSickIDByAccountAddress(...) internal view returns (...) &#123;<br>    for (uint256 i = 0; i &lt; sickIds.length; i++) &#123;<br>        if (sicks[sickID].accountAddress == accountAddr) return sickID;<br>    &#125;<br>    return 0;<br>&#125;<br><br>// 检查患者是否存在<br>function isSickExist(uint256 sickID) public view returns (bool) &#123;<br>    return sicks[sickID].accountAddress != address(0);<br>&#125;<br><br>// 获取所有患者ID列表<br>function getSicksList() public view returns (uint256[] memory) &#123;<br>    return sickIds;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-预约挂号系统"><a href="#2-预约挂号系统" class="headerlink" title="2. 预约挂号系统"></a><strong>2. 预约挂号系统</strong></h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct Appointment &#123;<br>    string hospitalName; // 医院名称<br>    string department;   // 科室名称<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; Appointment) public sickAppointment; // 患者ID→预约信息<br></code></pre></td></tr></table></figure><h4 id="核心功能-1"><a href="#核心功能-1" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建预约<br>function createAppointment(...) public &#123;<br>    require(isSickExist(sickID));          // 患者必须存在<br>    sickAppointment[sickID] = Appointment(...); // 存储预约<br>    emit AppointmentCreated(...);           // 触发事件<br>&#125;<br><br>// 查询预约<br>function getSickAppointment(...) public view returns (...) &#123;<br>    require(bytes(appointment.hospitalName).length &gt; 0); // 校验存在性<br>    return (appointment.hospitalName, ...);<br>&#125;<br><br>// 删除预约<br>function deleteSickAppointment(uint256 sickID) public &#123;<br>    delete sickAppointment[sickID];  // 清除预约记录<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-电子病历管理"><a href="#3-电子病历管理" class="headerlink" title="3. 电子病历管理"></a><strong>3. 电子病历管理</strong></h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a><strong>结构体定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">struct MedicalRecord &#123;<br>    uint256 sickID;               // 患者ID<br>    string hospitalName;          // 医院<br>    string department;            // 科室<br>    string doctorName;            // 医生姓名<br>    string registrationInfo;      // 挂号信息<br>    string pastMedicalHistory;    // 既往病史<br>    string currentMedicalHistory; // 现病史<br>    string isFilled;              // 是否完成(&quot;Yes&quot;/&quot;No&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据存储-2"><a href="#数据存储-2" class="headerlink" title="数据存储"></a><strong>数据存储</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint256 =&gt; MedicalRecord) public sickMedicalRecords; // 患者ID→病历<br></code></pre></td></tr></table></figure><h4 id="核心功能-2"><a href="#核心功能-2" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 创建空白病历<br>function createMedicalRecord(...) public &#123;<br>    sickMedicalRecords[sickID] = MedicalRecord(...);<br>    emit MedicalRecordCreated(...);<br>&#125;<br><br>// 授权医生访问病历<br>function authorizeDoctor(...) public &#123;<br>    if (病历不存在) createMedicalRecord(...); // 自动创建空病历<br>    sickMedicalRecords[sickID].doctorName = doctorName; // 设置医生<br>&#125;<br><br>// 更新病历内容<br>function updateMedicalRecord(...) public &#123;<br>    medicalRecord.hospitalName = hospitalName; <br>    medicalRecord.pastMedicalHistory = pastMedicalHistory; // 更新病史等<br>    emit MedicalRecordUpdated(...);<br>&#125;<br><br>// 查询完整病历<br>function getMedicalRecordByIdentityNumber(...) public view returns (...) &#123;<br>    return (medicalRecord.hospitalName, ...); // 返回所有病历字段<br>&#125;<br><br>// 查询特定科室的既往病史<br>function getPastMedicalHistory(...) public view returns (...) &#123;<br>    require(keccak256(科室)==keccak256(目标科室)); // 严格科室匹配<br>    return medicalRecord.pastMedicalHistory;<br>&#125;<br><br>// 标记病历完成状态<br>function endMedicalConsultation(...) public &#123;<br>    medicalRecord.isFilled = mrtype; // 设置&quot;Yes&quot;/&quot;No&quot;<br>&#125;<br><br>// 检查病历是否完成<br>function isMedicalRecordFilled(...) public view returns (bool) &#123;<br>    return keccak256(medicalRecord.isFilled) == keccak256(&quot;Yes&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>该合约完整实现了患者档案管理、挂号预约、电子病历三大核心功能，构建了医疗数据上链的基础框架。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链赛题智能合约</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2025/07/12/CSS/"/>
    <url>/2025/07/12/CSS/</url>
    
    <content type="html"><![CDATA[<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><div class="table-container"><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>.classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref=“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table></div><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>内联样式：1000；</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><div class="table-container"><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table></div><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>　（2）<strong>inline：</strong>元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><strong>transform: scale(0,0)</strong>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者**</strong>区别如下：**</p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是**</strong>继承属性**</p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<span class="hljs-attribute">color</span>: red&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png" alt="img"></p><p>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong>如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p><p><strong>为什么要使用它们？</strong> </p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.css&quot;</span> /&gt;</span></span> <br>&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; </span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: none; </span></span><br><span class="language-css"><span class="language-xml">  &#125; </span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示<br><span class="hljs-attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行<br></code></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;            // 溢出隐藏<br><span class="hljs-attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示<br><span class="hljs-attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。<br>-webkit-<span class="hljs-attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp:<span class="hljs-number">3</span>;        // 显示的行数<br></code></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位-1"><a href="#1-常见的CSS布局单位-1" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景-1"><a href="#2-px、em、rem的区别及使用场景-1" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现-1"><a href="#3-两栏布局的实现-1" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-三栏布局的实现-1"><a href="#4-三栏布局的实现-1" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现-1"><a href="#5-水平垂直居中的实现-1" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？-1"><a href="#6-如何根据设计稿进行移动端适配？-1" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景-1"><a href="#7-对Flex布局的理解及其使用场景-1" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong></p><p>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="9-响应式设计的概念及基本原理"><a href="#9-响应式设计的概念及基本原理" class="headerlink" title="9. 响应式设计的概念及基本原理"></a>9. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attr">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\200B&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>  &#125;<br>  <span class="hljs-selector-class">.clearfix</span>&#123;<br>    *<span class="hljs-attribute">zoom</span>: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clear</span>:none|left|right|both<br></code></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。 </li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br> <br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">left</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">right</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级非定位后代元素。</p><p>（4）浮动盒：非定位浮动元素。</p><p>（5）行内盒：文档流内行内级非定位后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><div class="table-container"><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table></div><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong>元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png" alt="img"></p><ul><li><strong>fixed：</strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png" alt="img"></p><ul><li><strong>absolute：</strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png" alt="img"></p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: orange blue red green;<br>&#125;<br></code></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png" alt="img"></p><p>所以可以根据border这个特性来绘制三角形：</p><p><strong>（1）三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png" alt="img"></p><p><strong>（2）三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png" alt="img"></p><p><strong>（3）三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png" alt="img"></p><p><strong>（4）三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png" alt="img"></p><p><strong>（5）三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png" alt="img"></p><p>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-top-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png" alt="img"></p><p><strong>（1）实现圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>在使用border-radius时，使用50%和100%都可以得到一个圆，那这两个值到底有什么区别呢：border-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。如一个50px 150px的方形，如果border-radius设置为100%，则等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>/<span class="hljs-number">150px</span>; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>而border-radius又是由border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius组成，所有上面border-radius：100%又等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">100%</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">100%</span>;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-left-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br><span class="hljs-attribute">border-bottom-right-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">150px</span>; <br></code></pre></td></tr></table></figure><p>为什么border-radius设置成100%和50%都能画成圆呢？因为，在W3C中对重合曲线做了规定：如果两个相邻的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算以保证它们不重合。也就是说，如果相邻圆角的半径都设置成大于50%，那么浏览器会根据图形的实际情况做一些计算。因此，为了避免不必要的计算，建议使用border-radius: 50%。</p><p><strong>（2）实现半圆：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用元素的margin/padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;trapezoid&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>（1）实现一个直角梯形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">40px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773730069-a1bf7073-14ba-4665-9e5e-cf0aa0722235.png" alt="img"></p><p>（2）实现一个等腰梯形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trapezoid</span> &#123;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-width</span>:<span class="hljs-number">0</span> <span class="hljs-number">40px</span> <span class="hljs-number">100px</span> <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">border-style</span>:none solid solid;<br>  <span class="hljs-attribute">border-color</span>:transparent transparent red;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1630773825580-c1821c13-4513-4462-9a13-73ad4a3ef6e6.png" alt="img"></p><h3 id="5-画一条0-5px的线"><a href="#5-画一条0-5px的线" class="headerlink" title="5. 画一条0.5px的线"></a>5. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, minimum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>, maximum-<span class="hljs-attribute">scale</span>=<span class="hljs-number">0.5</span>&quot;/&gt;<br></code></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="6-设置小于12px的字体"><a href="#6-设置小于12px的字体" class="headerlink" title="6. 设置小于12px的字体"></a>6. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="7-如何解决-1px-问题？"><a href="#7-如何解决-1px-问题？" class="headerlink" title="7. 如何解决 1px 问题？"></a>7. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">window.devicePixelRatio = 设备的物理像素 / CSS像素。<br></code></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/CSS.assets/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.png" alt="img"></p><p>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。</p><p><strong>解决**</strong>1px 问题的三种思路：**</p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span><br></code></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>&#125;&#125;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：**</strong>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的<strong><strong>宽和高都设置为目标元素的两倍，border值设为 1px。</strong></strong>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一<strong>**，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scale = <span class="hljs-number">1</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;<br><span class="hljs-comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br>metaEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">`width=device-width,user-scalable=no,initial-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,maximum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>,minimum-scale=<span class="hljs-subst">$&#123;scale&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2025/07/12/HTML/"/>
    <url>/2025/07/12/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p><p>（1）src</p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src =”js.<span class="hljs-property">js</span>”&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p><p>（2）href</p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;link href=”common.<span class="hljs-property">css</span>” rel=”stylesheet”/&gt;<br></code></pre></td></tr></table></figure><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h2 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h2><p><strong>语义化是指**</strong>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  头部<br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>  导航栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  区块（有语义化的div）<br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  主要区域<br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  主要内容<br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  侧边栏<br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>  底部<br></code></pre></td></tr></table></figure><h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义**</strong>来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h2 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:</p><p><img src="https://zhengcookie.github.io/file/前端面试题/HTML.assets/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="img"></p><p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h2 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><p>（2） <code>keywords</code>，页面关键词：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;关键词&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（3）<code>description</code>，页面描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;页面描述内容&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（4）<code>refresh</code>，页面重定向和刷新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0;url=&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值/device-width)</li><li><code>height viewport</code> ：高度(数值/device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li></ul><p>（6）搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&#x27;true&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop=‘true’ 循环播放</li></ul><p>（2）video视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&#x27;imgs/aa.jpg&#x27;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签</p><p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.flv&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/flv&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;aa.mp4&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li>placeholder ：提示信息</li><li>autofocus ：自动获取焦点</li><li><p>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li>pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li><li>multiple：可以选择多个文件或者多个邮箱</li><li>form=” form表单的ID”</li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong></p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h2 id="9-对-web-worker-的理解"><a href="#9-对-web-worker-的理解" class="headerlink" title="9. 对 web worker 的理解"></a>9. 对 web worker 的理解</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong></p><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong></p><p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 </p><p>其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript</title>
    <link href="/2025/07/12/javascript/"/>
    <url>/2025/07/12/javascript/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是**</strong>判断在其原型链中能否找到该类型的原型**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br> <br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br> <br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>([]));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">000</span>: object   - 当前存储的数据指向一个对象。<br>  <span class="hljs-number">1</span>: int      - 当前存储的数据是一个 <span class="hljs-number">31</span> 位的有符号整数。<br><span class="hljs-number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<br><span class="hljs-number">100</span>: string   - 当前存储的数据指向一个字符串。<br><span class="hljs-number">110</span>: boolean  - 当前存储的数据是布尔值。<br></code></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011.</span>..<br></code></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> <span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(arg1 - arg2) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;        <br>&#125;        <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numberepsilon</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-其他值到字符串的转换规则？"><a href="#11-其他值到字符串的转换规则？" class="headerlink" title="11. 其他值到字符串的转换规则？"></a>11. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="12-其他值到数字值的转换规则？"><a href="#12-其他值到数字值的转换规则？" class="headerlink" title="12. 其他值到数字值的转换规则？"></a>12. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="13-其他值到布尔类型的值的转换规则？"><a href="#13-其他值到布尔类型的值的转换规则？" class="headerlink" title="13. 其他值到布尔类型的值的转换规则？"></a>13. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p><p>• undefined</p><p>• null</p><p>• false</p><p>• +0、-0 和 NaN</p><p>• “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#15-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="15. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>15. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-JavaScript-中如何进行隐式类型转换？"><a href="#17-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="17. JavaScript 中如何进行隐式类型转换？"></a>17. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@obj</span> 需要转换的对象</span><br><span class="hljs-comment">* <span class="hljs-doctag">@type</span> 期望的结果类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">ToPrimitive</span>(obj,type)<br></code></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>**type**</code><strong>为</strong><code>**number**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>**type**</code><strong>为</strong><code>**string**</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">objToNumber</span> = value =&gt; <span class="hljs-title class_">Number</span>(value.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>())<br><span class="hljs-title function_">objToNumber</span>([]) === <span class="hljs-number">0</span><br><span class="hljs-title function_">objToNumber</span>(&#123;&#125;) === <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>**+**</code><strong>操作符</strong><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// &#x27;123&#x27;</span><br> <span class="hljs-number">1</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// 1 </span><br> <span class="hljs-number">1</span> + <span class="hljs-title class_">Symbol</span>() <span class="hljs-comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span><br> <span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &#x27;1false&#x27;</span><br> <span class="hljs-literal">false</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li><code>**-**</code><strong>、</strong><code>*****</code><strong>、</strong><code>**\**</code><strong>操作符</strong><code>NaN</code>也是一个数字</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// 23</span><br> <span class="hljs-number">1</span> * <span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br> <span class="hljs-number">1</span> / <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**==**</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false, 3 转为number为3，true转为number为1</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// &#x27;0&#x27;转为number为0</span><br></code></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>**&lt;**</code><strong>和</strong><code>**&gt;**</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;ca&#x27;</span> &lt; <span class="hljs-string">&#x27;bd&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;a&#x27;</span> &lt; <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;12&#x27;</span> &lt; <span class="hljs-number">13</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> &gt; -<span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;<br>a &gt; <span class="hljs-number">2</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="hljs-title class_">Number</span>(a.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br><span class="hljs-title class_">NaN</span> &gt; <span class="hljs-number">2</span> <span class="hljs-comment">//false，得出比较结果</span><br></code></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;<br><span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br>a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>b.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// 同理</span><br>b.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>a + b <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong>块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><div class="table-container"><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table></div><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的<strong>proto</strong>属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doesNotReturn</span>();<br></code></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;GLOBAL&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">a</span>();    <span class="hljs-comment">// &#x27;OBJ&#x27;</span><br>obj.<span class="hljs-title function_">b</span>();    <span class="hljs-comment">// &#x27;GLOBAL&#x27;</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">a</span>()  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">b</span>()  <span class="hljs-comment">// Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>)<br>&#125;;<br><span class="hljs-title function_">fun1</span>();                     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">apply</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);    <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;)();   <span class="hljs-comment">// &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 </span><br><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === obj); <br>    &#125;; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5，由 Babel 转译</span><br><span class="hljs-keyword">var</span> obj = &#123; <br>   <span class="hljs-attr">getArrow</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>; <br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_this === obj); <br>     &#125;; <br>   &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = &#123; ...bar &#125;; <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, bar); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> baz = &#123;...bar, ...&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>&#125;&#125;;  <span class="hljs-comment">// &#123;a: 2, b: 4&#125;</span><br></code></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对**</strong>对象实例的拷贝属于浅拷贝**。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>])<br><span class="hljs-comment">// 1 [2, 3, 4] 5</span><br></code></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1];<br></code></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;one&#x27;</span>, ...arr1, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>];<br><span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></code></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>first <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];         <span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">const</span> [first, ...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[...<span class="hljs-string">&#x27;hello&#x27;</span>]    <span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>**Math**</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...numbers); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...numbers); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h3 id="7-对对象与数组的解构的理解"><a href="#7-对对象与数组的解构的理解" class="headerlink" title="7. 对对象与数组的解构的理解"></a>7. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p><p><strong>1）数组的解构</strong></p><p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913177-30749c84-8254-4543-a3e7-c2fb488a4228.png" alt="img"></p><p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [a,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913186-eb8be693-9b19-48e5-bda5-9dbd7cc77ea6.png" alt="img"></p><p><strong>2）对象的解构</strong></p><p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> stu = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name, age &#125; = stu<br></code></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1616076913314-53687a23-07ef-4a01-a78a-a0304f2b2826.png" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; age, name &#125; = stu<br></code></pre></td></tr></table></figure><h3 id="8-如何提取高度嵌套的对象里的指定属性？"><a href="#8-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="8. 如何提取高度嵌套的对象里的指定属性？"></a>8. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> school = &#123;<br>   <span class="hljs-attr">classes</span>: &#123;<br>      <span class="hljs-attr">stu</span>: &#123;<br>         <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>         <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; name &#125; = school<br></code></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; classes &#125; = school<br><span class="hljs-keyword">const</span> &#123; stu &#125; = classes<br><span class="hljs-keyword">const</span> &#123; name &#125; = stu<br>name <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">classes</span>: &#123; <span class="hljs-attr">stu</span>: &#123; name &#125; &#125;&#125; = school<br>       <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)  <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="9-对-rest-参数的理解"><a href="#9-对-rest-参数的理解" class="headerlink" title="9. 对 rest 参数的理解"></a>9. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> args) &#123;<br>    result *= val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="10-ES6中模板语法与字符串处理"><a href="#10-ES6中模板语法与字符串处理" class="headerlink" title="10. ES6中模板语法与字符串处理"></a>10. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">&#x27;my name is &#x27;</span> + name + <span class="hljs-string">&#x27;, I work as a &#x27;</span> + career + <span class="hljs-string">&#x27;, I love &#x27;</span> + hobby[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27; and &#x27;</span> + hobby[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>, I work as a <span class="hljs-subst">$&#123;career&#125;</span> I love <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">0</span>]&#125;</span> and <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">1</span>]&#125;</span>`</span><br></code></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="hljs-string">&lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 正确输出，不存在报错</span><br></code></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">const</span> finalString = <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> + <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a+b&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalString)<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 &#x27;1 + 2 = 3&#x27;</span><br></code></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><ul><li><p><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p></li><li><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> son = <span class="hljs-string">&#x27;haha&#x27;</span> <br><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">includes</span>(son) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;haha&#x27;</span>) <span class="hljs-comment">// false</span><br>father.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;xixi&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>  father.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;hehe&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">&#x27;repeat for 3 times;&#x27;</span><br><span class="hljs-keyword">const</span> repeated = sourceCode.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(repeated) <span class="hljs-comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span><br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><div class="table-container"><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table></div><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在</p><p>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p><p>例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 </p><p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong>给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong>动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong>设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>`</td><td>`</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table></div><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。</p><p>例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span> <br>   <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br> = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，3|5的值为7。</p><p>注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p><p>例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>  <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> <br>= <span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><p>因此，3^5的值为6。</p><p>异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p>运算规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p><p>例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br>= <span class="hljs-number">1111</span> <span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p><p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0000</span> <span class="hljs-number">0110</span><br>   = <span class="hljs-number">1111</span> <span class="hljs-number">1001</span><br>反码：<span class="hljs-number">1000</span> <span class="hljs-number">0110</span><br>补码：<span class="hljs-number">1000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p><p>设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</p><p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。</p><p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。</p><p>例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br></code></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原码：<span class="hljs-number">1000</span> <span class="hljs-number">1010</span><br>反码：<span class="hljs-number">1111</span> <span class="hljs-number">0101</span><br>补码：<span class="hljs-number">1111</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-keyword">const</span> arrArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>) <br>  arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">const</span> arrArgs = [...<span class="hljs-variable language_">arguments</span>] <br>    arrArgs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)) <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p></li><li><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong></p><p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp);<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp[i]);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别： </p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。 </li></ul><p>ES6 Module和CommonJS模块的共同点： </p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。 </li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong>for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table></div><p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Person.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> <span class="hljs-comment">// Person</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1605247722640-5bcb9156-a8b4-4d7c-83d7-9ff80930e1de.jpeg" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-params">obj</span>)&#123;<br>   <span class="hljs-keyword">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))<br>           res.<span class="hljs-title function_">push</span>(key+<span class="hljs-string">&#x27;: &#x27;</span>+obj[key]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">B</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-title function_">A</span>()<br><span class="hljs-title function_">B</span>() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  ;(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;, j * <span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong></p><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>**eval**</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong></p><p>此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1691053717225-17afa0a8-d891-4458-86d6-0218d38704b5.png" alt="img"></p><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<span class="hljs-comment">//1. 打印 script start</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)<span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async/await"></a>（3）async/await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func1</span>())<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1604021075237-8249a8df-3a28-4bca-9f22-02923aba8618.png" alt="img"></p><p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">func1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  <span class="hljs-comment">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong></p><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>**new Promise()**</code><strong>来创建promise对象，但是也可以使用</strong><code>**promise.resolve**</code><strong>和</strong> <code>**promise.reject**</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">11</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(“我错了，请原谅俺！！”));<br></code></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>   <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;我错了，请原谅俺！！&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br><span class="hljs-title function_">testPromise</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">promise.then(function(value) &#123;<br>  // success<br>&#125;, function(error) &#123;<br>  // failure<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p><p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>); <br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-comment">//结果为：[1,2,3] </span><br>&#125;)<br></code></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">//结果：2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">rej</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server.<span class="hljs-title function_">listen</span>(port)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(server.<span class="hljs-property">stop</span>);<br></code></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise<br>.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>  fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; <span class="hljs-title function_">reject</span>(error)<br>      <span class="hljs-title function_">resolve</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">read</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data) <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）**</strong>Promise.all**</p><p><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async/await 的理解"></a>7.  对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><p><img src="https://zhengcookie.github.io/file/前端面试题/javascript.assets/1605099411873-d2eac25a-5d8c-4586-bc36-769bce79010e.png" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>() <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2);<br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">resolve</span>(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  <span class="hljs-keyword">let</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 3秒钟之后出现cug</span><br>&#125;<br><span class="hljs-title function_">testAwt</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async/await的优势"></a>9.  async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="hljs-comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">takeLongTime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">takeLongTime</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-title function_">step1</span>(time1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> <span class="hljs-title function_">step2</span>(time2))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> <span class="hljs-title function_">step3</span>(time3))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br><span class="hljs-comment">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="hljs-comment">// step1 with 300</span><br><span class="hljs-comment">// step2 with 500</span><br><span class="hljs-comment">// step3 with 700</span><br><span class="hljs-comment">// result is 900</span><br><span class="hljs-comment">// doIt: 1507.251ms</span><br></code></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 </li><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 </li><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 </li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 </li></ul><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p><p><strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code>obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj1 = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> obj2 = &#123;&#125;;<br>    obj1.<span class="hljs-property">a</span> = obj2; <span class="hljs-comment">// obj1 引用 obj2</span><br>    obj2.<span class="hljs-property">a</span> = obj1; <span class="hljs-comment">// obj2 引用 obj1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj1.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br> obj2.<span class="hljs-property">a</span> =  <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>**object**</code><strong>进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合约</title>
    <link href="/2025/07/09/%E5%90%88%E7%BA%A6/"/>
    <url>/2025/07/09/%E5%90%88%E7%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts"></a></h1><p>Solidity中的合约类似于面向对象语言中的类。 它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。 在不同的合约（实例）上调用一个函数将执行一个EVM函数调用， 从而切换上下文，使调用合约中的状态变量无法访问。 任何事情的发生都需要调用合约及其函数。 在以太坊中没有 “定时（cron）” 的概念来在特定事件中自动调用函数。</p><h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-1"></a></h2><p>可以通过以太坊交易 “从外部” 或从 Solidity 合约内部创建合约。</p><p>集成开发环境，如 <a href="https://remix.ethereum.org/">Remix</a>，使用UI元素使创建过程无缝化。</p><p>在以太坊上以编程方式创建合约的一种方法是通过JavaScript API <a href="https://github.com/web3/web3.js">web3.js</a>。 它有一个名为 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的函数， 以方便创建合约。</p><p>当一个合约被创建时，它的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor">构造函数（constructor）</a> （一个用 <code>constructor</code> 关键字声明的函数）被执行一次。</p><p>构造函数是可选的。但是只允许有一个构造函数，这意味着不支持重写。</p><p>构造函数执行完毕后，合约的最终代码被存储在区块链上。 这段代码包括所有公开和外部函数，以及所有通过函数调用可从那里到达的函数。 部署的代码不包括构造函数代码或只从构造函数调用的内部函数。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 传递， 但是如果您使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想创建另一个合约，创建者必须知道所创建合约的源代码（和二进制）。 这意味着，循环的创建依赖是不可能的。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIOaYr+WmguS4i+WumuS5ieeahOWQiOe6puexu+Wei+OAggogICAgLy8g5LiN5Yib5bu65paw5ZCI57qm55qE6K+d77yM5Lmf5Y+v5Lul5byV55So5a6D44CCCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8g6L+Z5piv5rOo5YaMIGNyZWF0b3Ig5ZKM6K6+572u5ZCN56ew55qE5p6E6YCg5Ye95pWw44CCCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8g54q25oCB5Y+Y6YeP6YCa6L+H5YW25ZCN56ew6K6/6Zeu77yMCiAgICAgICAgLy8g6ICM5LiN5piv6YCa6L+H5L6L5aaCIGB0aGlzLm93bmVyYCDnmoTmlrnlvI/orr/pl67jgIIKICAgICAgICAvLyDlh73mlbDlj6/ku6Xnm7TmjqXmiJbpgJrov4cgYHRoaXMuZmAg6K6/6Zeu44CCCiAgICAgICAgLy8g5L2G5ZCO6ICF5o+Q5L6b5LqG5LiA5Liq5a+55Ye95pWw55qE5aSW6YOo5Y+v6KeG5pa55rOV44CCCiAgICAgICAgLy8g54m55Yir5piv5Zyo5p6E6YCg5Ye95pWw5Lit77yM5oKo5LiN5bqU6K+l5LuO5aSW6YOo6K6/6Zeu5Ye95pWw77yMCiAgICAgICAgLy8g5Zug5Li66K+l5Ye95pWw6L+Y5LiN5a2Y5Zyo44CCCiAgICAgICAgLy8g6K+m6KeB5LiL5LiA6IqC44CCCiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgICAgICAvLyDmiJHku6zov5vooYzkuobku44gYGFkZHJlc3NgIOWIsCBgVG9rZW5DcmVhdG9yYCDnmoTmmL7lvI/nsbvlnovovazmjaLvvIwKICAgICAgICAvLyDlubblgYflrprosIPnlKjlkIjnuqbnmoTnsbvlnovmmK8gYFRva2VuQ3JlYXRvcmDvvIwKICAgICAgICAvLyDmsqHmnInnnJ/mraPnmoTmlrnms5XmnaXpqozor4HvvIwKICAgICAgICAvLyDov5nlubbmsqHmnInliJvlu7rkuIDkuKrmlrDnmoTlkIjnuqbjgIIKICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyDlj6rmnInliJvlu7rogIXlj6/ku6XmlLnlj5jlkI3np7DjgIIKICAgICAgICAvLyDmiJHku6zmoLnmja7lkIjnuqbnmoTlnLDlnYDov5vooYzmr5TovoPvvIwKICAgICAgICAvLyDlroPlj6/ku6XpgJrov4fmmL7lvI/ovazmjaLkuLrlnLDlnYDmnaXmo4DntKLjgIIKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBhZGRyZXNzKGNyZWF0b3IpKQogICAgICAgICAgICBuYW1lID0gbmV3TmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgewogICAgICAgIC8vIOWPquacieW9k+WJjeaJgOacieiAheaJjeiDveWPkemAgSB0b2tlbuOAggogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIOaIkeS7rOmAmui/h+S9v+eUqOS4i+mdouWumuS5ieeahCBgVG9rZW5DcmVhdG9yYCDlkIjnuqbnmoTkuIDkuKrlh73mlbAKICAgICAgICAvLyDmnaXor6Lpl67liJvlu7rogIXlkIjnuqbmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICAvLyDlpoLmnpzosIPnlKjlpLHotKXvvIjkvovlpoLnlLHkuo7nh4PmlpnlgLzogJflsL3vvInvvIwKICAgICAgICAvLyDov5nph4znmoTmiafooYzkuZ/kvJrlpLHotKXjgIIKICAgICAgICBpZiAoY3JlYXRvci5pc1Rva2VuVHJhbnNmZXJPSyhvd25lciwgbmV3T3duZXIpKQogICAgICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9CgoKY29udHJhY3QgVG9rZW5DcmVhdG9yIHsKICAgIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGJ5dGVzMzIgbmFtZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChPd25lZFRva2VuIHRva2VuQWRkcmVzcykKICAgIHsKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgYFRva2VuYCDlkIjnuqblubbov5Tlm57lhbblnLDlnYDjgIIKICAgICAgICAvLyDku45KYXZhU2NyaXB05pa56Z2i5p2l55yL77yMCiAgICAgICAgLy8g6L+Z5Liq5Ye95pWw55qE6L+U5Zue57G75Z6L5pivIGBhZGRyZXNzYO+8jAogICAgICAgIC8vIOWboOS4uui/meaYr0FCSeS4reacgOaOpei/keeahOexu+Wei+OAggogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8g5ZCM5qC377yMYHRva2VuQWRkcmVzc2Ag55qE5aSW6YOo57G75Z6L5piv566A5Y2V55qEIGBhZGRyZXNzYOOAggogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIOaJp+ihjOajgOafpe+8jOS7peehruWumuaYr+WQpuW6lOivpeWwhuS7o+W4gei9rOenu+WIsCBgT3duZWRUb2tlbmAg5ZCI57qm5LiK44CCCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyDmo4Dmn6XkuIDkuKrku7vmhI/nmoTmnaHku7bvvIznnIvmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoY3VycmVudE93bmVyLCBuZXdPd25lcikpWzBdID09IDB4N2Y7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br>contract OwnedToken &#123;<br>    <span class="hljs-comment">// `TokenCreator` 是如下定义的合约类型。</span><br>    <span class="hljs-comment">// 不创建新合约的话，也可以引用它。</span><br>    TokenCreator creator;<br>    address owner;<br>    bytes32 name;<br><br>    <span class="hljs-comment">// 这是注册 creator 和设置名称的构造函数。</span><br>    constructor(bytes32 name_) &#123;<br>        <span class="hljs-comment">// 状态变量通过其名称访问，</span><br>        <span class="hljs-comment">// 而不是通过例如 `this.owner` 的方式访问。</span><br>        <span class="hljs-comment">// 函数可以直接或通过 `this.f` 访问。</span><br>        <span class="hljs-comment">// 但后者提供了一个对函数的外部可视方法。</span><br>        <span class="hljs-comment">// 特别是在构造函数中，您不应该从外部访问函数，</span><br>        <span class="hljs-comment">// 因为该函数还不存在。</span><br>        <span class="hljs-comment">// 详见下一节。</span><br>        owner = msg.sender;<br><br>        <span class="hljs-comment">// 我们进行了从 `address` 到 `TokenCreator` 的显式类型转换，</span><br>        <span class="hljs-comment">// 并假定调用合约的类型是 `TokenCreator`，</span><br>        <span class="hljs-comment">// 没有真正的方法来验证，</span><br>        <span class="hljs-comment">// 这并没有创建一个新的合约。</span><br>        creator = TokenCreator(msg.sender);<br>        name = name_;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(bytes32 newName) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有创建者可以改变名称。</span><br>        <span class="hljs-comment">// 我们根据合约的地址进行比较，</span><br>        <span class="hljs-comment">// 它可以通过显式转换为地址来检索。</span><br>        <span class="hljs-keyword">if</span> (msg.sender == address(creator))<br>            name = newName;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> transfer(address newOwner) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 只有当前所有者才能发送 token。</span><br>        <span class="hljs-keyword">if</span> (msg.sender != owner) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 我们通过使用下面定义的 `TokenCreator` 合约的一个函数</span><br>        <span class="hljs-comment">// 来询问创建者合约是否应该进行转移。</span><br>        <span class="hljs-comment">// 如果调用失败（例如由于燃料值耗尽），</span><br>        <span class="hljs-comment">// 这里的执行也会失败。</span><br>        <span class="hljs-keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))<br>            owner = newOwner;<br>    &#125;<br>&#125;<br><br><br>contract TokenCreator &#123;<br>    <span class="hljs-built_in">function</span> createToken(bytes32 name)<br>        <span class="hljs-keyword">public</span><br>        returns (OwnedToken tokenAddress)<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的 `Token` 合约并返回其地址。</span><br>        <span class="hljs-comment">// 从JavaScript方面来看，</span><br>        <span class="hljs-comment">// 这个函数的返回类型是 `address`，</span><br>        <span class="hljs-comment">// 因为这是ABI中最接近的类型。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OwnedToken(name);<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeName(OwnedToken tokenAddress, bytes32 name) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 同样，`tokenAddress` 的外部类型是简单的 `address`。</span><br>        tokenAddress.changeName(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行检查，以确定是否应该将代币转移到 `OwnedToken` 合约上。</span><br>    <span class="hljs-built_in">function</span> isTokenTransferOK(address currentOwner, address newOwner)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">bool</span> ok)<br>    &#123;<br>        <span class="hljs-comment">// 检查一个任意的条件，看是否应该进行转移。</span><br>        <span class="hljs-keyword">return</span> keccak256(abi.encodePacked(currentOwner, newOwner))[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>x7f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可见性和-getter-函数"><a href="#可见性和-getter-函数" class="headerlink" title="可见性和 getter 函数"></a>可见性和 getter 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter"></a></h2><h3 id="状态变量的可见性"><a href="#状态变量的可见性" class="headerlink" title="状态变量的可见性"></a>状态变量的可见性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id3"></a></h3><ul><li><p><code>public</code></p><p>公开状态变量与内部变量的不同之处在于，编译器会自动为它们生成 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions">getter函数</a>， 从而允许其他合约读取它们的值。当在同一个合约中使用时，外部访问（例如 <code>this.x</code>）会调用getter， 而内部访问（例如 <code>x</code>）会直接从存储中获取变量值。 Setter函数没有被生成，所以其他合约不能直接修改其值。</p></li><li><p><code>internal</code></p><p>内部状态变量只能从它们所定义的合约和派生合约中访问。 它们不能被外部访问。 这是状态变量的默认可见性。</p></li><li><p><code>private</code></p><p>私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p></li></ul><p>警告</p><p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p><h3 id="函数的可见性"><a href="#函数的可见性" class="headerlink" title="函数的可见性"></a>函数的可见性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id4"></a></h3><p>Solidity 有两种函数调用：确实创建了实际 EVM 消息调用的外部函数和不创建 EVM 消息调用的内部函数。 此外，派生合约可能无法访问内部函数。 这就产生了四种类型的函数的可见性。</p><ul><li><p><code>external</code></p><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用 （即 <code>f()</code> 不起作用，但 <code>this.f()</code> 可以）。</p></li><li><p><code>public</code></p><p>公开函数是合约接口的一部分，可以在内部或通过消息调用。</p></li><li><p><code>internal</code></p><p>内部函数只能从当前的合约或从它派生出来的合约中访问。 它们不能被外部访问。 由于它们没有通过合约的ABI暴露在外部，它们可以接受内部类型的参数，如映射或存储引用。</p></li><li><p><code>private</code></p><p>私有函数和内部函数一样，但它们在派生合约中是不可见的。</p></li></ul><p>警告</p><p>标记一些变量为 <code>private</code> 或 <code>internal</code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p><p>在状态变量的类型之后，以及在函数的参数列表和返回参数列表之间，都会给出可见性指定符。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a) <span class="hljs-keyword">private</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> b) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-built_in">function</span> setData(<span class="hljs-built_in">uint</span> a) internal &#123; data = a; &#125;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面的例子中，合约 <code>D</code>, 可以调用 <code>c.getData()</code> 来检索状态存储中 <code>data</code> 的值， 但不能调用 <code>f</code>。 合约 <code>E</code> 是从合约 <code>C</code> 派生出来的，因此可以调用 <code>compute</code>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyDov5nlsIbkuI3kvJrnvJbor5EKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyDplJnor6/vvJrmiJDlkZggYGZgIOS4jeWPr+ingQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyDplJnor6/vvJrmiJDlkZggYGNvbXB1dGVgIOS4jeWPr+ingQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIOiuv+mXruWGhemDqOaIkOWRmO+8iOS7jue7p+aJv+WQiOe6puiuv+mXrueItuWQiOe6puaIkOWRmO+8iQogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">private</span> data;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">private</span> pure <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> b</span>)</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">setData</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">public</span></span> &#123; data = a; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">getData</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">compute</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b</span>) <span class="hljs-keyword">internal</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;<br><br><span class="hljs-comment">// 这将不会编译</span><br>contract D &#123;<br>    <span class="hljs-function">function <span class="hljs-title">readData</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> local = c.f(<span class="hljs-number">7</span>); <span class="hljs-comment">// 错误：成员 `f` 不可见</span><br>        c.setData(<span class="hljs-number">3</span>);<br>        local = c.getData();<br>        local = c.compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 错误：成员 `compute` 不可见</span><br>    &#125;<br>&#125;<br><br>contract E <span class="hljs-keyword">is</span> C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> val = compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 访问内部成员（从继承合约访问父合约成员）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Getter-函数"><a href="#Getter-函数" class="headerlink" title="Getter 函数"></a>Getter 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions"></a></h3><p>编译器会自动为所有 <strong>公开</strong> 状态变量创建getter函数。 对于下面给出的合约，编译器将生成一个名为 <code>data</code> 的函数， 它没有任何输入参数，并返回一个 <code>uint</code>， 即状态变量 <code>data</code> 的值。状态变量在声明时可以被初始化。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data = <span class="hljs-number">42</span>;<br>&#125;<br><br>contract Caller &#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> c.data();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getter函数具有外部可见性。 如果该符号被内部访问（即没有 <code>this.</code>），它被评估为一个状态变量。 如果它被外部访问（即有 <code>this.</code>），它将被评价为一个函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIOWGhemDqOiuv+mXrgogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8g5aSW6YOo6K6/6ZeuCiAgICB9Cn0=">open in Remix</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint <span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span>;<br>    function x() <span class="hljs-keyword">public</span> returns (uint) &#123;<br>        <span class="hljs-keyword">data</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 内部访问</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>(); <span class="hljs-comment">// 外部访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您有一个数组类型的 <code>public</code> 状态变量， 那么您只能通过生成的getter函数检索数组的单个元素。 这种机制的存在是为了避免在返回整个数组时产生高额的燃料成本。 您可以使用参数来指定要返回的单个元素，例如 <code>myArray(0)</code>。 如果您想在一次调用中返回整个数组，那么您需要写一个函数，例如：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyDlhazlvIDnirbmgIHlj5jph48KICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyDnvJbor5HlmajnlJ/miJDnmoRnZXR0ZXLlh73mlbAKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyDov5Tlm57mlbTkuKrmlbDnu4TnmoTlh73mlbAKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract arrayExample &#123;<br>    <span class="hljs-comment">// 公开状态变量</span><br>    <span class="hljs-built_in">uint</span>[] <span class="hljs-keyword">public</span> myArray;<br><br>    <span class="hljs-comment">// 编译器生成的getter函数</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    function myArray(uint i) public view returns (uint) &#123;</span><br><span class="hljs-comment">        return myArray[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 返回整个数组的函数</span><br>    <span class="hljs-function">function <span class="hljs-title">getArray</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> myArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在您可以使用 <code>getArray()</code> 来检索整个数组， 而不是使用 <code>myArray(i)</code>，它每次调用只返回一个元素。</p><p>下一个例子稍微复杂一些：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcodWludCA9PiB1aW50KSBtYXA7CiAgICAgICAgdWludFszXSBjOwogICAgICAgIHVpbnRbXSBkOwogICAgICAgIGJ5dGVzIGU7CiAgICB9CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhib29sID0+IERhdGFbXSkpIHB1YmxpYyBkYXRhOwp9">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Complex &#123;<br>    struct Data &#123;<br>        <span class="hljs-keyword">uint</span> a;<br>        bytes3 b;<br>        mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">uint</span>) map;<br>        <span class="hljs-keyword">uint</span>[<span class="hljs-number">3</span>] c;<br>        <span class="hljs-keyword">uint</span>[] d;<br>        bytes e;<br>    &#125;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; mapping(<span class="hljs-keyword">bool</span> =&gt; Data[])) <span class="hljs-keyword">public</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>它生成了一个如下形式的函数。结构中的映射和数组（字节数组除外）被省略了， 因为没有好的方法来选择单个结构成员或为映射提供一个键：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9">open in Remix</a></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">function</span> <span class="hljs-class"><span class="hljs-keyword">data</span>(<span class="hljs-title">uint</span> <span class="hljs-title">arg1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">arg2</span>, <span class="hljs-title">uint</span> <span class="hljs-title">arg3</span>)</span><br>    public<br>    returns (uint a, bytes3 b, bytes memory e)<br>&#123;<br>    a = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].a;</span><br>    b = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].b;</span><br>    e = <span class="hljs-class"><span class="hljs-keyword">data</span>[arg1][arg2][arg3].e;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifiers"></a></h2><p>函数修饰器可以用来以声明的方式改变函数的行为。 例如，您可以使用修饰器在执行函数之前自动检查一个条件。</p><p>修饰器是合约的可继承属性，可以被派生合约重写， 但只有当它们被标记为 <code>virtual</code> 时，才能被重写。 详情请见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding">修饰器重写</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIOi/meS4quWQiOe6puWPquWumuS5ieS6huS4gOS4quS/rumlsOWZqO+8jOS9huayoeacieS9v+eUqOWug++8mgogICAgLy8g5a6D5bCG5Zyo5rS+55Sf5ZCI57qm5Lit5L2/55So44CCCiAgICAvLyDkv67ppbDlmajmiYDkv67ppbDnmoTlh73mlbDkvZPkvJrooqvmj5LlhaXliLDnibnmrornrKblj7cgYF87YCDnmoTkvY3nva7jgIIKICAgIC8vIOi/meaEj+WRs+edgO+8jOWmguaenOaJgOacieiAheiwg+eUqOi/meS4quWHveaVsO+8jOi/meS4quWHveaVsOWwseS8muiiq+aJp+ihjO+8jAogICAgLy8g5ZCm5YiZ5bCx5Lya5oqb5Ye65LiA5Liq5byC5bi444CCCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgZGVzdHJ1Y3RpYmxlIGlzIG93bmVkIHsKICAgIC8vIOi/meS4quWQiOe6puS7jiBgb3duZWRgIOWQiOe6pue7p+aJv+S6hiBgb25seU93bmVyYCDkv67ppbDlmajvvIwKICAgIC8vIOW5tuWwhuWFtuW6lOeUqOS6jiBgZGVzdHJveWAg5Ye95pWw77yMCiAgICAvLyDlj6rmnInlnKjlkIjnuqbph4zkv53lrZjnmoQgb3duZXIg6LCD55SoIGBkZXN0cm95YCDlh73mlbDvvIzmiY3kvJrnlJ/mlYjjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBzZWxmZGVzdHJ1Y3Qob3duZXIpOwogICAgfQp9Cgpjb250cmFjdCBwcmljZWQgewogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul5o6l5Y+X5Y+C5pWw77yaCiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHJlZ2lzdGVyZWRBZGRyZXNzZXM7CiAgICB1aW50IHByaWNlOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgaW5pdGlhbFByaWNlKSB7IHByaWNlID0gaW5pdGlhbFByaWNlOyB9CgogICAgLy8g5Zyo6L+Z6YeM5Lmf5L2/55So5YWz6ZSu5a2XIGBwYXlhYmxlYCDpnZ7luLjph43opoHvvIwKICAgIC8vIOWQpuWImeWHveaVsOS8muiHquWKqOaLkue7neaJgOacieWPkemAgee7meWug+eahOS7peWkquW4geOAggogICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSBwdWJsaWMgcGF5YWJsZSBjb3N0cyhwcmljZSkgewogICAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzZXNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZVByaWNlKHVpbnQgcHJpY2VfKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBwcmljZSA9IHByaWNlXzsKICAgIH0KfQoKY29udHJhY3QgTXV0ZXggewogICAgYm9vbCBsb2NrZWQ7CiAgICBtb2RpZmllciBub1JlZW50cmFuY3koKSB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIWxvY2tlZCwKICAgICAgICAgICAgIlJlZW50cmFudCBjYWxsLiIKICAgICAgICApOwogICAgICAgIGxvY2tlZCA9IHRydWU7CiAgICAgICAgXzsKICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICAvLy8g6L+Z5Liq5Ye95pWw5Y+X5LqS5pal6YeP5L+d5oqk77yM6L+Z5oSP5ZGz552AIGBtc2cuc2VuZGVyLmNhbGxgIOS4reeahOmHjeWFpeiwg+eUqOS4jeiDveWGjeasoeiwg+eUqCAgYGZg44CCCiAgICAvLy8gYHJldHVybiA3YCDor63lj6XmjIflrprov5Tlm57lgLzkuLogN++8jOS9huS/rumlsOWZqOS4reeahOivreWPpSBgbG9ja2VkID0gZmFsc2VgIOS7jeS8muaJp+ihjOOAggogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br><br>    <span class="hljs-comment">// 这个合约只定义了一个修饰器，但没有使用它：</span><br>    <span class="hljs-comment">// 它将在派生合约中使用。</span><br>    <span class="hljs-comment">// 修饰器所修饰的函数体会被插入到特殊符号 `_;` 的位置。</span><br>    <span class="hljs-comment">// 这意味着，如果所有者调用这个函数，这个函数就会被执行，</span><br>    <span class="hljs-comment">// 否则就会抛出一个异常。</span><br>    modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            <span class="hljs-string">&quot;Only owner can call this function.&quot;</span><br>        );<br>        _;<br>    &#125;<br>&#125;<br><br>contract destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-comment">// 这个合约从 `owned` 合约继承了 `onlyOwner` 修饰器，</span><br>    <span class="hljs-comment">// 并将其应用于 `destroy` 函数，</span><br>    <span class="hljs-comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract priced &#123;<br>    <span class="hljs-comment">// 修饰器可以接受参数：</span><br>    <span class="hljs-function">modifier <span class="hljs-title">costs</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-keyword">value</span> &gt;= price) &#123;<br>            _;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Register <span class="hljs-keyword">is</span> priced, destructible &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">bool</span>) registeredAddresses;<br>    <span class="hljs-built_in">uint</span> price;<br><br>    constructor(<span class="hljs-built_in">uint</span> initialPrice) &#123; price = initialPrice; &#125;<br><br>    <span class="hljs-comment">// 在这里也使用关键字 `payable` 非常重要，</span><br>    <span class="hljs-comment">// 否则函数会自动拒绝所有发送给它的以太币。</span><br>    <span class="hljs-function">function <span class="hljs-title">register</span>() <span class="hljs-keyword">public</span> payable <span class="hljs-title">costs</span>(<span class="hljs-params">price</span>)</span> &#123;<br>        registeredAddresses[msg.sender] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">changePrice</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price_</span>) <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        price = price_;<br>    &#125;<br>&#125;<br><br>contract Mutex &#123;<br>    <span class="hljs-built_in">bool</span> locked;<br>    <span class="hljs-function">modifier <span class="hljs-title">noReentrancy</span>()</span> &#123;<br>        require(<br>            !locked,<br>            <span class="hljs-string">&quot;Reentrant call.&quot;</span><br>        );<br>        locked = <span class="hljs-literal">true</span>;<br>        _;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> `return 7` 语句指定返回值为 7，但修饰器中的语句 `locked = false` 仍会执行。</span><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> noReentrancy <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        (<span class="hljs-built_in">bool</span> success,) = msg.sender.call(<span class="hljs-string">&quot;&quot;</span>);<br>        require(success);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您想访问定义在合约 <code>C</code> 中的修饰器 <code>m</code>， 您可以使用 <code>C.m</code> 来引用它而不需要虚拟查询。 只能使用定义在当前合约或其基础合约中的修饰器。 修饰器也可以定义在库合约中，但其使用仅限于同一库合约的函数。</p><p>如果同一个函数有多个修饰器，它们之间以空格隔开，并按照所呈现的顺序进行评估运算。</p><p>修饰器不能隐式地访问或改变它们所修改的函数的参数和返回值。 它们的值只能在调用的时候明确地传递给它们。</p><p>在函数修改器中，有必要指定何时运行应用修改器的函数。 占位符语句（用单个下划线字符 <code>_</code> 表示）用于表示被修改的函数主体应该插入的位置。 请注意，占位符操作符与在变量名中使用下划线作为前导或尾随字符不同， 后者是一种风格上的选择。</p><p>修饰器或函数体的显式返回只离开当前修饰器或函数体。 返回变量会被赋值，但整个执行逻辑会从前一个修饰器中定义的 <code>_</code> 之后继续执行。</p><p>警告</p><p>在Solidity的早期版本中，具有修饰器的函数中的 <code>return</code> 语句会表现的不同。</p><p>用 <code>return;</code> 从修饰器显式返回并不影响函数返回的值。 然而，修饰器可以选择完全不执行函数主体，在这种情况下， 返回变量被设置为 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>，就像函数有一个空主体一样。</p><p><code>_</code> 符号可以在修饰器中多次出现。每次出现都会被替换成函数体。 该函数返回最后一次调用的返回值。</p><p>允许修饰器参数使用任意表达式，在这种情况下，所有从函数中可见的符号在修饰器中都是可见的。 修饰器中引入的符号在函数中是不可见的（因为它们可能因重写而改变）。</p><h2 id="常量和不可变状态变量"><a href="#常量和不可变状态变量" class="headerlink" title="常量和不可变状态变量"></a>常量和不可变状态变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constants"></a></h2><p>状态变量可以被声明为 <code>constant</code> 或 <code>immutable</code>。 在这两种情况下，变量在合约构建完成后不能被修改。 对于 <code>constant</code> 变量，其值必须在编译时固定， 而对于 <code>immutable</code> 变量，仍然可以在构造时分配。</p><p>也可以在文件级别定义 <code>constant</code> 变量。</p><p>编译器并没有为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式。</p><p>与普通的状态变量相比，常量变量（constant）和不可改变的变量（immutable）的燃料成本要低得多。 对于常量变量，分配给它的表达式被复制到所有访问它的地方，并且每次都要重新评估， 这使得局部优化成为可能。不可变的变量在构造时被评估一次，其值被复制到代码中所有被访问的地方。 对于这些值，要保留32个字节，即使它们可以装入更少的字节。由于这个原因，常量值有时会比不可变的值更便宜。</p><p>目前，并非所有的常量和不可变量的类型都已实现。 唯一支持的类型是 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#strings">字符串类型</a> （仅用于常量）和 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#value-types">值类型</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjE7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzID0gMTg7CiAgICB1aW50IGltbXV0YWJsZSBtYXhCYWxhbmNlOwogICAgYWRkcmVzcyBpbW11dGFibGUgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgZGVjaW1hbHNfLCBhZGRyZXNzIHJlZikgewogICAgICAgIGlmIChkZWNpbWFsc18gIT0gMCkKICAgICAgICAgICAgLy8gaW1tdXRhYmxl5Y+Y6YeP5Y+q5pyJ5Zyo6YOo572y5pe25omN5piv5LiN5Y+v5Y+Y55qE44CCCiAgICAgICAgICAgIC8vIOWcqOaehOW7uuaXtu+8jOWug+S7rOWPr+S7peiiq+WIhumFjeS7u+aEj+asoeaVsOOAggogICAgICAgICAgICBkZWNpbWFscyA9IGRlY2ltYWxzXzsKCiAgICAgICAgLy8g5a+5aW1tdXRhYmxl5Y+Y6YeP55qE6LWL5YC855Sa6Iez5Y+v5Lul6K6/6Zeu546v5aKD5Y+Y6YeP44CCCiAgICAgICAgbWF4QmFsYW5jZSA9IHJlZi5iYWxhbmNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGlzQmFsYW5jZVRvb0hpZ2goYWRkcmVzcyBvdGhlcikgcHVibGljIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBvdGhlci5iYWxhbmNlID4gbWF4QmFsYW5jZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.21</span>;<br><br><span class="hljs-built_in">uint</span> constant X = <span class="hljs-number">32</span>**<span class="hljs-number">22</span> + <span class="hljs-number">8</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">string</span> constant TEXT = <span class="hljs-string">&quot;abc&quot;</span>;<br>    bytes32 constant MY_HASH = keccak256(<span class="hljs-string">&quot;abc&quot;</span>);<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> decimals = <span class="hljs-number">18</span>;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">immutable</span> maxBalance;<br>    address <span class="hljs-keyword">immutable</span> owner = msg.sender;<br><br>    constructor(<span class="hljs-built_in">uint</span> decimals_, address <span class="hljs-keyword">ref</span>) &#123;<br>        <span class="hljs-keyword">if</span> (decimals_ != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// immutable变量只有在部署时才是不可变的。</span><br>            <span class="hljs-comment">// 在构建时，它们可以被分配任意次数。</span><br>            decimals = decimals_;<br><br>        <span class="hljs-comment">// 对immutable变量的赋值甚至可以访问环境变量。</span><br>        maxBalance = <span class="hljs-keyword">ref</span>.balance;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> isBalanceTooHigh(address other) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">bool</span>) &#123;<br>        <span class="hljs-keyword">return</span> other.balance &gt; maxBalance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constant"></a></h3><p>对于 <code>constant</code> 变量，其值在编译时必须是一个常量，并且必须在变量声明的地方分配。 任何访问存储、区块链数据（例如： <code>block.timestamp</code>, <code>address(this).balance</code> 或 <code>block.number</code>） 或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code>）或者调用外部合约的表达式都是不允许的。 但可能对内存分配产生副作用的表达式是允许的，但那些可能对其他内存对象产生副作用的表达式是不允许的。 内置函数 <code>keccak256</code>， <code>sha256</code>， <code>ripemd160</code>， <code>ecrecover</code>， <code>addmod</code> 和 <code>mulmod</code> 是允许的（尽管除了 <code>keccak256</code>，它们确实调用了外部合约）。</p><p>允许在内存分配器上产生副作用的原因是， 它应该可以构建复杂的对象，比如说查找表。 这个功能现在还不能完全使用。</p><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#immutable"></a></h3><p>声明为 <code>immutable</code> 的变量比声明为 <code>constant</code> 的变量受到的限制要少一些： 不可变（immutable）变量可以在构造时赋值。 该值在部署前的任何时候都可以更改，然后成为永久值。</p><p>另外一个限制是，不可变变量只能分配给创建后不可能被执行的表达式内部。 这就排除了所有修改器定义和构造函数以外的函数。</p><p>读取不可变变量没有任何限制。 读取甚至可以在变量第一次被写入之前进行， 因为Solidity中的变量总是有一个定义明确的初始值。 因此，也允许永远不对不可变变量显式赋值。</p><p>警告</p><p>在构造时访问不可变变量时，请牢记 <a href="https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#state-variable-initialization-order">初始化顺序</a>。 即使您提供了显式初始化器，某些表达式可能最终会在初始化器之前被求值， 尤其是当它们处于继承层次结构的不同层级时。</p><p>备注</p><p>在 Solidity 0.8.21 之前，不可变变量的初始化限制较多。 这些变量必须在构造时被初始化一次，而且在此之前不能被读取。</p><p>编译器生成的合约创建代码会在返回合约之前修改合约的运行时代码， 并用分配给它们的值替换所有对不可变变量的引用。 如果您要比较编译器生成的运行时代码和实际存储在区块链中的运行时代码，这一点非常重要。 编译器会在 <a href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api">编译器JSON标准输出</a> 的 <code>immutableReferences</code> 字段中 输出这些不可变变量在部署字节码中的位置。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#functions"></a></h2><p>可以在合约内部和外部定义函数。</p><p>合约之外的函数，也称为 “自由函数”，总是隐含着 <code>internal</code> 的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">可见性</a>。 它们的代码包含在所有调用它们的合约中，类似于内部库函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Zyo5YaF6YOo6LCD55So6Ieq55Sx5Ye95pWw44CCCiAgICAgICAgLy8g57yW6K+R5Zmo5Lya5bCG5YW25Luj56CB5re75Yqg5Yiw5ZCI57qm5Lit44CCCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)<br>        s += arr[i];<br>&#125;<br><br>contract ArrayExample &#123;<br>    <span class="hljs-keyword">bool</span> found;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory arr)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这在内部调用自由函数。</span><br>        <span class="hljs-comment">// 编译器会将其代码添加到合约中。</span><br>        <span class="hljs-keyword">uint</span> s = sum(arr);<br>        <span class="hljs-keyword">require</span>(s &gt;= <span class="hljs-number">10</span>);<br>        found = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>在合约之外定义的函数仍然总是在合约的范围内执行。 它们仍然可以调用其他合约，向它们发送以太，并销毁调用它们的合约，以及其他一些事情。 与合约内定义的函数的主要区别是，自由函数不能直接访问变量 <code>this</code>，存储变量和不在其范围内的函数。</p><h3 id="函数参数和返回变量"><a href="#函数参数和返回变量" class="headerlink" title="函数参数和返回变量"></a>函数参数和返回变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-parameters-return-variables"></a></h3><p>与许多其他语言不同, 函数接受类型化的参数作为输入， 也可以返回任意数量的值作为输出。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id10"></a></h4><p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。</p><p>例如，如果您想让您的合约接受一种带有两个整数的外部调用，您可以使用类似以下的方式：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">uint</span> sum;<br>    <span class="hljs-built_in">function</span> taker(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> &#123;<br>        sum = a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数参数可以像任何其他局部变量一样使用，它们也可以被赋值。</p><h4 id="返回的变量"><a href="#返回的变量" class="headerlink" title="返回的变量"></a>返回的变量<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8"></a></h4><p>函数的返回变量在 <code>returns</code> 关键字之后用同样的语法声明。</p><p>例如，假设您想返回两个结果：作为函数参数传递的两个整数的总和和乘积，那么您就使用类似的方法：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        sum = a + b;<br>        product = a * b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回变量的名字可以被省略。返回变量可以像其他本地变量一样使用， 它们被初始化为相应的 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>， 并且在它们被（重新）赋值之前拥有这个值。</p><p>您可以明确地赋值给返回变量，然后像上面那样结束函数， 或者您可以用 <code>return</code> 语句直接提供返回值（单个或 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return">多个返回值</a>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetic(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> sum, <span class="hljs-built_in">uint</span> product)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (a + b, a * b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您过早使用 <code>return</code> 来结束一个有返回变量的函数，您必须在返回语句中同时提供返回值。</p><p>备注</p><p>您不能从非内部函数返回某些类型。 这包括下面列出的类型和任何递归地包含它们的复合类型：</p><ul><li>映射，</li><li>内部函数类型，</li><li>参考类型，位置设置为 <code>storage</code>，</li><li>多维数组（仅适用于 <a href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>），</li><li>结构体（仅适用于 <a href="https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#abi-coder">ABI coder v1</a>）。</li></ul><p>这个限制不适用于库函数，因为它们有不同的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#library-selectors">内部 ABI</a>。</p><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-return"></a></h4><p>当一个函数有多个返回类型时，语句 <code>return (v0, v1, ..., vn)</code> 可以用来返回多个值。 声明的数量必须与返回变量的数量相同，并且它们的类型必须匹配， 有可能是经过 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types-conversion-elementary-types">隐式转换</a>。</p><h3 id="状态可变性"><a href="#状态可变性" class="headerlink" title="状态可变性"></a>状态可变性<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#state-mutability"></a></h3><h4 id="View-函数"><a href="#View-函数" class="headerlink" title="View 函数"></a>View 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#view"></a></h4><p>函数可以被声明为 <code>view</code>，在这种情况下，它们承诺不修改状态。</p><p>备注</p><p>如果编译器的EVM版本是Byzantium或更新的（默认）， 当调用 <code>view</code> 函数时，会使用操作码 <code>STATICCALL</code>，这使得状态作为EVM执行的一部分保持不被修改。 对于库合约的 <code>view</code> 函数，会使用 <code>DELEGATECALL</code>， 因为没有组合的 <code>DELEGATECALL</code> 和 <code>STATICCALL</code>。 这意味着库合约中的 <code>view</code> 函数没有防止状态修改的运行时的检查。 这应该不会对安全产生负面影响，因为库合约的代码通常在编译时就知道了， 而且静态检查器也会进行编译时检查。</p><p>以下声明被认为是修改状态：</p><ol><li>修改状态变量。</li><li><a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events">产生事件</a>。</li><li><a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts">创建其它合约</a>。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送以太币。</li><li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含特定操作码的内联汇编。</li></ol><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>) + block.timestamp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>函数上的 <code>constant</code> 曾经是 <code>view</code> 的别名，但在0.5.0版本中被取消。</p><p>备注</p><p>Getter方法被自动标记为 <code>view</code>。</p><p>备注</p><p>在0.5.0版本之前，编译器没有为 <code>view</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得 <code>view</code> 函数通过使用无效的显式类型转换进行状态修改。 通过对 <code>view</code> 函数使用 <code>STATICCALL</code>，在EVM层面上防止了对状态的修改。</p><h4 id="Pure-函数"><a href="#Pure-函数" class="headerlink" title="Pure 函数"></a>Pure 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#pure"></a></h4><p>函数可以被声明为 <code>pure</code>，在这种情况下，它们承诺不读取或修改状态。 特别是，应该可以在编译时评估一个 <code>pure</code> 函数，只给它的输入和 <code>msg.data</code>， 但不知道当前区块链状态。这意味着读取 <code>immutable</code> 的变量可以是一个非标准pure的操作。</p><p>备注</p><p>如果编译器的EVM版本是Byzantium或更新的（默认），则使用操作码 <code>STATICCALL</code>， 这并不能保证不读取状态，但至少不能修改。</p><p>除了上面解释的状态修改语句列表外，以下内容被认为是从状态中读取的：</p><ol><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或者 <code>&lt;address&gt;.balance</code>。</li><li>访问 <code>block</code>， <code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">错误发生</a> 时， Pure 函数能够使用 <code>revert()</code> 和 <code>require()</code> 函数来恢复潜在的状态变化。</p><p>恢复一个状态变化不被认为是 “状态修改”， 因为只有之前在没有 <code>view</code> 或 <code>pure</code> 限制的代码中对状态的改变才会被恢复， 并且该代码可以选择捕捉 <code>revert</code> 而不传递给它。</p><p>这种行为也与 <code>STATICCALL</code> 操作码一致。</p><p>警告</p><p>在EVM层面不可能阻止函数读取状态，只可能阻止它们写入状态 （即只有 <code>view</code> 可以在EVM层面执行， <code>pure</code> 不可以）。</p><p>备注</p><p>在0.5.0版本之前，编译器没有为 <code>pure</code> 函数使用 <code>STATICCALL</code> 操作码。 这使得在 <code>pure</code> 函数中通过使用无效的显式类型转换进行状态修改。 通过对 <code>pure</code> 函数使用 <code>STATICCALL</code>，在EVM层面防止了对状态的修改。</p><p>备注</p><p>在0.4.17版本之前，编译器并没有强制要求 <code>pure</code> 不读取状态。 这是一个编译时的类型检查，可以规避在合约类型之间做无效的显式转换， 因为编译器可以验证合约的类型不做改变状态的操作， 但它不能检查将在运行时被调用的合约是否真的属于该类型。</p><h3 id="特殊的函数"><a href="#特殊的函数" class="headerlink" title="特殊的函数"></a>特殊的函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#special-functions"></a></h3><h4 id="接收以太的函数"><a href="#接收以太的函数" class="headerlink" title="接收以太的函数"></a>接收以太的函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function"></a></h4><p>一个合约最多可以有一个 <code>receive</code> 函数， 使用 <code>receive() external payable &#123; ... &#125;</code> 来声明。（没有 <code>function</code> 关键字）。 这个函数不能有参数，不能返回任何东西，必须具有 <code>external</code> 的可见性和 <code>payable</code> 的状态可变性。 它可以是虚拟的，可以重写，也可以有修饰器。</p><p>receive 函数是在调用合约时执行的，并带有空的 calldata。 这是在纯以太传输（例如通过 <code>.send()</code> 或 <code>.transfer()</code> ）时执行的函数。 如果不存在这样的函数，但存在一个 payable 类型的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function">fallback函数</a>， 这个 fallback 函数将在纯以太传输时被调用。 如果既没有直接接收以太（receive函数），也没有 payable 类型的 fallback 函数， 那么合约就不能通过不代表支付函数调用的交易接收以太币，还会抛出一个异常。</p><p>在最坏的情况下， <code>receive</code> 函数只有2300个燃料可用（例如当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基本的记录外，几乎没有空间来执行其他操作。以下操作的消耗燃料将超过2300燃料的规定：</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量燃料的外部函数</li><li>发送以太币</li></ul><p>警告</p><p>当以太被直接发送到一个合约（没有使用函数调用，即发送者使用 <code>send</code> 或 <code>transfer</code>）， 但接收合约没有定义一个接收以太的函数或一个 payable 类型的 fallback 函数，会抛出一个异常， 将以太送回（这在Solidity v0.4.0之前是不同的）。因此，如果您想让您的合约接收以太， 您必须实现一个 receive 函数（不建议使用 payable 类型的 fallback 函数来接收以太， 因为它不会因为接口混乱而失败）。</p><p>警告</p><p>没有接收以太币功能的合约可以作为 <em>coinbase交易</em> （又称 <em>矿工区块奖励</em>）的接收者 或作为 <code>selfdestruct</code> 的目的地接收以太币。</p><p>合约不能对这样的以太币转移做出反应，因此也不能拒绝它们。 这是EVM的一个设计选择，Solidity无法绕过它。</p><p>这也意味着 <code>address(this).balance</code> 可以高于合约中 实现的一些手工记帐的总和（即在接收以太函数中更新的累加器）。</p><p>下面您可以看到一个使用 <code>receive</code> 函数的Sink合约的例子。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g6L+Z5Liq5ZCI57qm5Lya5L+d55WZ5omA5pyJ5Y+R6YCB57uZ5a6D55qE5Lul5aSq5biB77yM5rKh5pyJ5Yqe5rOV6L+U6L+Y44CCCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span><br>contract Sink &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Received</span>(<span class="hljs-params">address, <span class="hljs-built_in">uint</span></span>)</span>;<br>    receive() external payable &#123;<br>        <span class="hljs-function">emit <span class="hljs-title">Received</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Fallback-函数"><a href="#Fallback-函数" class="headerlink" title="Fallback 函数"></a>Fallback 函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback"></a></h4><p>一个合约最多可以有一个 <code>fallback</code> 函数，使用 <code>fallback () external [payable]</code> 或 <code>fallback (bytes calldata input) external [payable] returns (bytes memory output)</code> 来声明（都没有 <code>function</code> 关键字）。 这个函数必须具有 <code>external</code> 的函数可见性。 一个 fallback 函数可以被标记为 virtual，可以标记为 override，也可以有修饰器。</p><p>如果其他函数都不符合给定的函数签名，或者根本没有提供数据， 也没有 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太的函数</a>，那么fallback函数将在调用合约时执行。 fallback函数总是接收数据，但为了同时接收以太，它必须被标记为 <code>payable</code>。</p><p>如果使用带参数的版本， <code>input</code> 将包含发送给合约的全部数据（等于 <code>msg.data</code>）， 并可以在 <code>output</code> 中返回数据。返回的数据将不会被ABI编码。 相反，它将在没有修改的情况下返回（甚至没有填充）。</p><p>在最坏的情况下，如果一个可接收以太的fallback函数也被用来代替接收功能， 那么它只有2300燃料是可用的 （参见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太函数</a> 对这一含义的简要描述）。</p><p>像任何函数一样，只要有足够的燃料传递给它，fallback函数就可以执行复杂的操作。</p><p>警告</p><p>如果没有 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">receive 函数</a> 的存在， 一个标记为 <code>payable</code> 的 fallback 函数也会在普通的以太传输时执行。 如果您已经定义了一个 payable 类型的 fallback 函数， 我们仍建议您也定义一个 receive 函数接收以太，以区分以太传输和接口混淆的情况。</p><p>备注</p><p>如果您想对输入数据进行解码，您可以检查前四个字节的函数选择器， 然后您可以使用 <code>abi.decode</code> 与数组切片语法一起对ABI编码的数据进行解码： <code>(c, d) = abi.decode(input[4:], (uint256, uint256));</code> 注意，这只能作为最后的手段，应该使用适当的函数来代替。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyDmiYDmnInlj5HpgIHliLDmraTlkIjnuqbnmoTmtojmga/pg73kvJrosIPnlKjmraTlh73mlbDvvIjmsqHmnInlhbbku5blh73mlbDvvInjgIIKICAgIC8vIOWQkeivpeWQiOe6puWPkemAgeS7peWkquW4geWwhuW8lei1t+W8guW4uO+8jAogICAgLy8g5Zug5Li6ZmFsbGJhY2vlh73mlbDmsqHmnIkgYHBheWFibGVgIOS/rumlsOWZqOOAggogICAgZmFsbGJhY2soKSBleHRlcm5hbCB7IHggPSAxOyB9Cn0KCmNvbnRyYWN0IFRlc3RQYXlhYmxlIHsKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIC8vIOaJgOacieWPkemAgeWIsOatpOWQiOe6pueahOa2iOaBr+mDveS8muiwg+eUqOi/meS4quWHveaVsO+8jAogICAgLy8g6Zmk5LqG5pmu6YCa55qE5Lul5aSq5Lyg6L6T77yI6Zmk5LqGcmVjZWl2ZeWHveaVsO+8jOayoeacieWFtuS7luWHveaVsO+8ieOAggogICAgLy8g5Lu75L2V5a+56K+l5ZCI57qm55qE6Z2e56m655qE6LCD55So6YO95bCG5omn6KGMZmFsbGJhY2vlh73mlbDvvIjljbPkvb/ku6XlpKrkuI7osIPnlKjkuIDotbfooqvlj5HpgIHvvInjgIIKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8g6L+Z5Liq5Ye95pWw5piv5Li657qv5Lul5aSq5Lyg6L6T6ICM6LCD55So55qE77yMCiAgICAvLyDljbPkuLrmr4/kuIDkuKrluKbmnInnqbpjYWxsZGF0YeeahOiwg+eUqOOAggogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgeyB4ID0gMjsgeSA9IG1zZy52YWx1ZTsgfQp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgZnVuY3Rpb24gY2FsbFRlc3QoVGVzdCB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMeOAggoKICAgICAgICAvLyBhZGRyZXNzKHRlc3Qp5bCG5LiN5YWB6K6455u05o6l6LCD55SoIGBgc2VuZGBg77yMCiAgICAgICAgLy8g5Zug5Li6IGBgdGVzdGBgIOayoeacieWPr+aOpeaUtuS7peWkqueahGZhbGxiYWNr5Ye95pWw44CCCiAgICAgICAgLy8g5a6D5b+F6aG76KKr6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5omN5YWB6K646LCD55SoIGBgc2VuZGBg44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIHRlc3RQYXlhYmxlID0gcGF5YWJsZShhZGRyZXNzKHRlc3QpKTsKCiAgICAgICAgLy8g5aaC5p6c5pyJ5Lq65ZCR6K+l5ZCI57qm5Y+R6YCB5Lul5aSq5biB77yM6L2s6LSm5bCG5aSx6LSl77yM5Y2z6L+Z6YeM6L+U5ZueZmFsc2XjgIIKICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIOe7k+aenOaYryB0ZXN0Lngg562J5LqOIDHvvIx0ZXN0Lnkg562J5LqOIDDjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMe+8jHRlc3QueSDnrYnkuo4gMeOAggoKICAgICAgICAvLyDlpoLmnpzmnInkurrlkJHor6XlkIjnuqblj5HpgIHku6XlpKrluIHvvIxUZXN0UGF5YWJsZeeahHJlY2VpdmXlh73mlbDlsIbooqvosIPnlKjjgIIKICAgICAgICAvLyDnlLHkuo7or6Xlh73mlbDkvJrlhpnlhaXlrZjlgqjnqbrpl7TvvIzlroPpnIDopoHnmoTnh4Pmlpnmr5TnroDljZXnmoQgYGBzZW5kYGAg5oiWIGBgdHJhbnNmZXJgYCDopoHlpJrjgIIKICAgICAgICAvLyDnlLHkuo7ov5nkuKrljp/lm6DvvIzmiJHku6zlv4XpobvopoHkvb/nlKjkuIDkuKrkvY7nuqfliKvnmoTosIPnlKjjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyDnu5PmnpzmmK8gdGVzdC54IOetieS6jiAx77yMdGVzdC55IOetieS6jiAyIOS4quS7peWkquOAggoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Test &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用此函数（没有其他函数）。</span><br>    <span class="hljs-comment">// 向该合约发送以太币将引起异常，</span><br>    <span class="hljs-comment">// 因为fallback函数没有 `payable` 修饰器。</span><br>    fallback() external &#123; x = <span class="hljs-number">1</span>; &#125;<br>&#125;<br><br>contract TestPayable &#123;<br>    <span class="hljs-keyword">uint</span> x;<br>    <span class="hljs-keyword">uint</span> y;<br>    <span class="hljs-comment">// 所有发送到此合约的消息都会调用这个函数，</span><br>    <span class="hljs-comment">// 除了普通的以太传输（除了receive函数，没有其他函数）。</span><br>    <span class="hljs-comment">// 任何对该合约的非空的调用都将执行fallback函数（即使以太与调用一起被发送）。</span><br>    fallback() external payable &#123; x = <span class="hljs-number">1</span>; y = msg.value; &#125;<br><br>    <span class="hljs-comment">// 这个函数是为纯以太传输而调用的，</span><br>    <span class="hljs-comment">// 即为每一个带有空calldata的调用。</span><br>    receive() external payable &#123; x = <span class="hljs-number">2</span>; y = msg.value; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTest</span><span class="hljs-params">(Test test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1。</span><br><br>        <span class="hljs-comment">// address(test)将不允许直接调用 ``send``，</span><br>        <span class="hljs-comment">// 因为 ``test`` 没有可接收以太的fallback函数。</span><br>        <span class="hljs-comment">// 它必须被转换为 ``address payable`` 类型，才允许调用 ``send``。</span><br>        address payable testPayable = payable(address(test));<br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，转账将失败，即这里返回false。</span><br>        <span class="hljs-keyword">return</span> testPayable.send(<span class="hljs-number">2</span> ether);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTestPayable</span><span class="hljs-params">(TestPayable test)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        (<span class="hljs-keyword">bool</span> success,) = address(test).call(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 0。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">1</span>&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;nonExistingFunction()&quot;</span>));<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 1。</span><br><br>        <span class="hljs-comment">// 如果有人向该合约发送以太币，TestPayable的receive函数将被调用。</span><br>        <span class="hljs-comment">// 由于该函数会写入存储空间，它需要的燃料比简单的 ``send`` 或 ``transfer`` 要多。</span><br>        <span class="hljs-comment">// 由于这个原因，我们必须要使用一个低级别的调用。</span><br>        (success,) = address(test).call&#123;value: <span class="hljs-number">2</span> ether&#125;(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">require</span>(success);<br>        <span class="hljs-comment">// 结果是 test.x 等于 1，test.y 等于 2 个以太。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#overload-function"></a></h3><p>一个合约可以有多个同名的，但参数类型不同的函数。 这个过程被称为 “重写”，也适用于继承的函数。 下面的例子显示了在合约 <code>A</code> 范围内对函数 <code>f</code> 的重写。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> value, <span class="hljs-built_in">bool</span> really) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">if</span> (really)<br>            <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIOi/meauteS7o+eggeS4jeS8mue8luivkQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这段代码不会编译</span><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(B value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (B <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(address value) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (address <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = value;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两个 <code>f</code> 函数重写最终都接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p><h4 id="重写解析和参数匹配"><a href="#重写解析和参数匹配" class="headerlink" title="重写解析和参数匹配"></a>重写解析和参数匹配<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id17"></a></h4><p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重写函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重写候选项。 如果一个候选都没有，解析失败。</p><p>备注</p><p>返回参数不作为重写解析的依据。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(uint8 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint8 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(uint256 val) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (uint256 <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>f(50)</code> 会导致类型错误，因为 <code>50</code> 既可以被隐式转换为 <code>uint8</code> 也可以被隐式转换为 <code>uint256</code>。 另一方面，调用 <code>f(256)</code> 则会解析为 <code>f(uint256)</code> 重写， 因为 <code>256</code> 不能隐式转换为 <code>uint8</code>。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events"></a></h2><p>Solidity事件在EVM的日志功能之上给出了一个抽象。 应用程序可以通过Ethereum客户端的RPC接口订阅和监听这些事件。</p><p>事件是合约的可继承成员。当您调用它们时， 它们会导致参数被存储在交易的日志中–区块链中的一个特殊数据结构。 这些日志与合约的地址相关联，被纳入区块链， 只要有区块可以访问，就会留在那里（目前是永远，但 将来可能会改变）。 日志及其事件数据不能从合约内部访问（甚至不能从创建它们的合约访问）。</p><p>有可能要求为日志提供Merkle证明， 所以如果外部实体向合约提供这样的证明，它可以检查日志是否真的存在于区块链中。 由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p><p>您可以最多给三个参数添加 <code>indexed</code> 属性，将它们添加到一个特殊的数据结构中， 称为 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-events">“topics”</a>，而不是日志的数据部分。 一个topic只能容纳一个字（32字节），所以如果您为一个索引参数使用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#reference-types">引用类型</a>， 该值的Keccak-256哈希值将被存储为一个topic中。</p><p>所有没有 <code>indexed</code> 属性的参数都会被 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI 编码</a> 到日志的数据部分。</p><p>Topics允许您用来搜索事件，例如为特定的事件来过滤一系列的区块。 您用来也可以通过发出事件的合约的地址来过滤事件。</p><p>例如，下面的代码使用web3.js <code>subscribe(&quot;logs&quot;)</code> <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">方法</a> 来过滤与某一地址值相匹配的日志：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">fromBlock</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">address</span>: web3.eth.defaultAccount,<br>    <span class="hljs-attr">topics</span>: [<span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>&#125;;<br>web3.eth.subscribe(<span class="hljs-string">&#x27;logs&#x27;</span>, options, <span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;)<br>    .on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">log</span>);<br>    &#125;)<br>    .on(<span class="hljs-string">&quot;changed&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>除非您用 <code>anonymous</code> 指定符声明事件，否则事件的签名的哈希值是topic之一。 这意味着不可能通过名字来过滤特定的匿名事件， 您只能通过合约地址来过滤。匿名事件的优点是，它们的部署和调用都比较便宜。 它还允许您声明四个索引参数，而不是三个。</p><p>备注</p><p>由于交易日志只存储事件数据而不存储类型，因此您必须知道事件的类型， 包括哪个参数被索引以及事件是否是匿名的，以便正确解析数据。 特别的是，有可能用一个匿名事件 “伪造“ 另一个事件的签名。</p><h3 id="事件类型的成员方法"><a href="#事件类型的成员方法" class="headerlink" title="事件类型的成员方法"></a>事件类型的成员方法<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-15"></a></h3><ul><li><code>event.selector</code>： 对于非匿名事件，这是一个 <code>bytes32</code> 值， 包含事件签名的 <code>keccak256</code> 哈希值，在默认topic中使用。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id21"></a></h3><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyDkuovku7bmmK/nlKggYGVtaXRgIOWPkeWHuueahO+8jOWQjumdouaYr+S6i+S7tueahOWQjeensOWSjOaLrOWPt+mHjOeahOWPguaVsO+8iOWmguaenOacie+8ieOAggogICAgICAgIC8vIOS7u+S9lei/meagt+eahOiwg+eUqO+8iOeUmuiHs+aYr+a3seW6puW1jOWll++8iemDveWPr+S7pemAmui/h+i/h+a7pCBgRGVwb3NpdGAKICAgICAgICAvLyDku45KYXZhU2NyaXB0IEFQSeS4reajgOa1i+WHuuadpeOAggogICAgICAgIGVtaXQgRGVwb3NpdChtc2cuc2VuZGVyLCBpZCwgbXNnLnZhbHVlKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.21</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract ClientReceipt &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        address indexed <span class="hljs-keyword">from</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        bytes32 indexed id,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">uint</span> <span class="hljs-keyword">value</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>)</span>;<br><br>    <span class="hljs-function">function <span class="hljs-title">deposit</span>(<span class="hljs-params">bytes32 id</span>) <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// 事件是用 `emit` 发出的，后面是事件的名称和括号里的参数（如果有）。</span><br>        <span class="hljs-comment">// 任何这样的调用（甚至是深度嵌套）都可以通过过滤 `Deposit`</span><br>        <span class="hljs-comment">// 从JavaScript API中检测出来。</span><br>        <span class="hljs-function">emit <span class="hljs-title">Deposit</span>(<span class="hljs-params">msg.sender, id, msg.<span class="hljs-keyword">value</span></span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在JavaScript API中的使用方式如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> abi = <span class="hljs-comment">/* 由编译器产生的abi */</span>;<br><span class="hljs-keyword">var</span> ClientReceipt = web3.eth.contract(abi);<br><span class="hljs-keyword">var</span> clientReceipt = ClientReceipt.at(<span class="hljs-string">&quot;0x1234...ab67&quot;</span> <span class="hljs-comment">/* 地址 */</span>);<br><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit();<br><br><span class="hljs-comment">// 监视变化</span><br>depositEvent.watch(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>)&#123;<br>    <span class="hljs-comment">// 结果包含非索引的参数和给 `Deposit` 调用的 topics。</span><br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br><br><br><span class="hljs-comment">// 或者通过回调立即开始监视</span><br><span class="hljs-keyword">var</span> depositEvent = clientReceipt.Deposit(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的输出看起来像下面这样（经过修剪）:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   &quot;returnValues&quot;: &#123;<br>       &quot;<span class="hljs-selector-tag">from</span>&quot;: <span class="hljs-string">&quot;0x1111…FFFFCCCC&quot;</span>,<br>       <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;0x50…sd5adb20&quot;</span>,<br>       <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;0x420042&quot;</span><br>   &#125;,<br>   &quot;raw&quot;: &#123;<br>       &quot;data&quot;: <span class="hljs-string">&quot;0x7f…91385&quot;</span>,<br>       <span class="hljs-string">&quot;topics&quot;</span>: [<span class="hljs-string">&quot;0xfd4…b4ead7&quot;</span>, <span class="hljs-string">&quot;0x7f…1a91385&quot;</span>]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="了解事件类型的其他资料"><a href="#了解事件类型的其他资料" class="headerlink" title="了解事件类型的其他资料"></a>了解事件类型的其他资料<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id22"></a></h3><ul><li><a href="https://github.com/web3/web3.js/blob/1.x/docs/web3-eth-contract.rst#events">JavaScript 文档</a></li><li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的使用实例</a></li><li><a href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们</a></li></ul><h2 id="错误和恢复语句"><a href="#错误和恢复语句" class="headerlink" title="错误和恢复语句"></a>错误和恢复语句<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors"></a></h2><p>Solidity 中的错误提供了一种方便且省燃料的方式来向用户解释为什么一个操作会失败。 它们可以被定义在合约内部和外部（包括接口合约和库合约）。</p><p>它们必须与 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert-statement">恢复语句</a> 一起使用， 它导致当前调用中的所有变化被恢复，并将错误数据传回给调用者。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDovazotKbnmoTkvZnpop3kuI3otrPjgILpnIDopoEgYHJlcXVpcmVkYCDmlbDph4/kvYblj6rmnIkgYGF2YWlsYWJsZWAg5pWw6YeP5Y+v55So44CCCi8vLyBAcGFyYW0g5Y+v55So55qE5L2Z6aKd44CCCi8vLyBAcGFyYW0g6ZyA6KaB6KaB5rGC55qE6L2s5biQ6YeR6aKd44CCCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.4</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 转账的余额不足。需要 `required` 数量但只有 `available` 数量可用。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 可用的余额。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> @param 需要要求的转帐金额。</span><br><span class="hljs-function">error <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">uint256 available, uint256 <span class="hljs-keyword">required</span></span>)</span>;<br><br>contract TestToken &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) balance;<br>    <span class="hljs-function">function <span class="hljs-title">transfer</span>(<span class="hljs-params">address to, uint256 amount</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; balance[msg.sender])<br>            <span class="hljs-function">revert <span class="hljs-title">InsufficientBalance</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                available: balance[msg.sender],</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">required</span>: amount</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span>)</span>;<br>        balance[msg.sender] -= amount;<br>        balance[to] += amount;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>错误不能被重写或覆盖，但是可以被继承。 只要作用域不同，同一个错误可以在多个地方定义。 错误的实例只能使用 <code>revert</code> 语句创建。</p><p>错误会创建数据，然后通过还原操作传递给调用者， 使其返回到链下组件或在 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#try-catch">try/catch 语句</a> 中捕获它。 需要注意的是，一个错误只能在来自外部调用时被捕获， 发生在内部调用或同一函数内的还原不能被捕获。</p><p>如果您不提供任何参数，错误只需要四个字节的数据， 您可以像上面一样使用 <a href="https://docs.soliditylang.org/zh-cn/latest/natspec-format.html#natspec">NatSpec 语法</a> 来进一步解释错误背后的原因， 这并不存储在链上。这使得这同时也是一个非常便宜和方便的错误报告功能。</p><p>更具体地说，一个错误实例在被ABI编码时， 其方式与对相同名称和类型的函数的调用相同， 然后作为 <code>revert</code> 操作码的返回数据。 这意味着数据由一个4字节的选择器和 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 数据组成。 选择器由错误类型的签名的keccak256-hash的前四个字节组成。</p><p>备注</p><p>一个合约有可能因为同名的不同错误而恢复， 甚至因为在不同地方定义的错误而使调用者无法区分。 对于外部来说，即ABI，只有错误的名称是相关的，而不是定义它的合约或文件。</p><p>如果您能定义 <code>error Error(string)</code>， 那么语句 <code>require(condition, &quot;description&quot;);</code> 将等同于 <code>if (!condition) revert Error(&quot;description&quot;)</code>。 但是请注意， <code>Error</code> 是一个内置类型，不能在用户提供的代码中定义。</p><p>同样，一个失败的 <code>assert</code> 或类似的条件将以一个内置的 <code>Panic(uint256)</code> 类型的错误来恢复。</p><p>备注</p><p>错误数据应该只被用来指示失败，而不是作为控制流的手段。 原因是内部调用的恢复数据默认是通过外部调用链传播回来的。 这意味着内部调用可以 ”伪造” 恢复数据，使它看起来像是来自调用它的合约。</p><h3 id="错误类型的成员"><a href="#错误类型的成员" class="headerlink" title="错误类型的成员"></a>错误类型的成员<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id25"></a></h3><ul><li><code>error.selector</code>： 一个包含错误类型的选择器的 <code>bytes4</code> 值。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17"></a></h2><p>Solidity支持多重继承，包括多态性。</p><p>多态性意味着函数调用（内部和外部）总是执行继承层次结构中最新继承的合约中的同名函数（和参数类型）。 但必须使用 <code>virtual</code> 和 <code>override</code> 关键字在层次结构中的每个函数上明确启用。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 以了解更多细节。</p><p>通过使用 <code>ContractName.functionName()</code> 明确指定合约， 可以在内部调用继承层次结构中更高的函数。 或者如果您想在扁平化的继承层次中调用高一级的函数（见下文）， 可以使用 <code>super.functionName()</code>。</p><p>当一个合约继承自其他合约时，在区块链上只创建一个单一的合约， 所有基础合约的代码被编译到创建的合约中。 这意味着对基础合约的所有内部函数的调用也只是使用内部函数调用 （ <code>super.f(..)</code> 将使用 JUMP 而不是消息调用）。</p><p>状态变量的阴影被认为是一个错误。 一个派生合约只能声明一个状态变量 <code>x</code>， 如果在它的任何基类中没有相同名称的可见状态变量。</p><p>总的来说，Solidity 的继承系统与 <a href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a> 非常相似，特别是关于多重继承方面，但也有一些 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance">不同之处</a>。</p><p>详细情况见下面的例子。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIOS9v+eUqCBgaXNgIOS7juWPpuS4gOS4quWQiOe6pua0vueUn+OAgua0vueUn+WQiOe6puWPr+S7peiuv+mXruaJgOaciemdnuengeacieaIkOWRmO+8jAovLyDljIXmi6zlhoXpg6jlh73mlbDlkoznirbmgIHlj5jph4/vvIzkvYbml6Dms5XpgJrov4cgYHRoaXNgIOadpeWklumDqOiuv+mXruOAggpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8g5YWz6ZSu5a2XIGB2aXJ0dWFsYCDmhI/lkbPnnYDor6Xlh73mlbDlj6/ku6XlnKjmtL7nlJ/nsbvkuK3mlLnlj5jlhbbooYzkuLrvvIjigJzph43lhpnigJ3vvInjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB2aXJ0dWFsIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIHNlbGZkZXN0cnVjdChvd25lcik7CiAgICB9Cn0KCgovLyDov5nkupvmir3osaHlkIjnuqbku4XnlKjkuo7nu5nnvJbor5Hlmajmj5DkvpvmjqXlj6PjgIIKLy8g5rOo5oSP5Ye95pWw5rKh5pyJ5Ye95pWw5L2T44CCCi8vIOWmguaenOS4gOS4quWQiOe6puayoeacieWunueOsOaJgOacieWHveaVsO+8jOWImeWPquiDveeUqOS9nOaOpeWPo+OAggphYnN0cmFjdCBjb250cmFjdCBDb25maWcgewogICAgZnVuY3Rpb24gbG9va3VwKHVpbnQgaWQpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGFkZHJlc3MgYWRyKTsKfQoKCmFic3RyYWN0IGNvbnRyYWN0IE5hbWVSZWcgewogICAgZnVuY3Rpb24gcmVnaXN0ZXIoYnl0ZXMzMiBuYW1lKSBwdWJsaWMgdmlydHVhbDsKICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSBwdWJsaWMgdmlydHVhbDsKfQoKCi8vIOWkmumHjee7p+aJv+aYr+WPr+iDveeahOOAguivt+azqOaEj++8jCBgT3duZWRgIOS5n+aYryBgRGVzdHJ1Y3RpYmxlYCDnmoTln7rnsbvvvIwKLy8g5L2G5Y+q5pyJ5LiA5LiqIGBPd25lZGAg5a6e5L6L77yI5bCx5YOPIEMrKyDkuK3nmoTomZrmi5/nu6fmib/vvInjgIIKY29udHJhY3QgTmFtZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSB7CiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWUpIHsKICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS5yZWdpc3RlcihuYW1lKTsKICAgIH0KCiAgICAvLyDlh73mlbDlj6/ku6Xooqvlj6bkuIDkuKrlhbfmnInnm7jlkIzlkI3np7Dlkoznm7jlkIzmlbDph48v57G75Z6L6L6T5YWl55qE5Ye95pWw6YeN5YaZ44CCCiAgICAvLyDlpoLmnpzph43lhpnlh73mlbDmnInkuI3lkIznsbvlnovnmoTovpPlh7rlj4LmlbDvvIzkvJrlr7zoh7TplJnor6/jgIIKICAgIC8vIOacrOWcsOWSjOWfuuS6jua2iOaBr+eahOWHveaVsOiwg+eUqOmDveS8muiAg+iZkei/meS6m+mHjeWGmeOAggogICAgLy8g5aaC5p6c5oKo5oOz6YeN5YaZ6L+Z5Liq5Ye95pWw77yM5oKo6ZyA6KaB5L2/55SoIGBvdmVycmlkZWAg5YWz6ZSu5a2X44CCCiAgICAvLyDlpoLmnpzmgqjmg7Porqnov5nkuKrlh73mlbDlho3mrKHooqvph43lhpnvvIzmgqjpnIDopoHlho3mjIflrpogYHZpcnR1YWxgIOWFs+mUruWtl+OAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgICAgIE5hbWVSZWcoY29uZmlnLmxvb2t1cCgxKSkudW5yZWdpc3RlcigpOwogICAgICAgICAgICAvLyDku43nhLblj6/ku6XosIPnlKjnibnlrprnmoTph43lhpnlh73mlbDjgIIKICAgICAgICAgICAgRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsKICAgICAgICB9CiAgICB9Cn0KCgovLyDlpoLmnpzmnoTpgKDlh73mlbDmjqXlj5flj4LmlbDvvIwKLy8g5YiZ6ZyA6KaB5Zyo5aOw5piO77yI5ZCI57qm55qE5p6E6YCg5Ye95pWw77yJ5pe25o+Q5L6b77yMCi8vIOaIluWcqOa0vueUn+WQiOe6pueahOaehOmAoOWHveaVsOS9jee9ruS7peS/rumlsOWZqOiwg+eUqOmjjuagvOaPkOS+m++8iOingeS4i+aWh++8ieOAggpjb250cmFjdCBQcmljZUZlZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSwgTmFtZWQoIkdvbGRGZWVkIikgewogICAgZnVuY3Rpb24gdXBkYXRlSW5mbyh1aW50IG5ld0luZm8pIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIGluZm8gPSBuZXdJbmZvOwogICAgfQoKICAgIC8vIOWcqOi/memHjO+8jOaIkeS7rOWPquaMh+WumuS6hiBgb3ZlcnJpZGVgIOiAjOayoeaciSBgdmlydHVhbGDjgIIKICAgIC8vIOi/meaEj+WRs+edgOS7jiBgUHJpY2VGZWVkYCDmtL7nlJ/lh7rmnaXnmoTlkIjnuqbkuI3og73lho3mlLnlj5ggYGRlc3Ryb3lgIOeahOihjOS4uuOAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShEZXN0cnVjdGlibGUsIE5hbWVkKSB7IE5hbWVkLmRlc3Ryb3koKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KCiAgICB1aW50IGluZm87Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br><br>contract Owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br><br><span class="hljs-comment">// 使用 `is` 从另一个合约派生。派生合约可以访问所有非私有成员，</span><br><span class="hljs-comment">// 包括内部函数和状态变量，但无法通过 `this` 来外部访问。</span><br>contract Destructible <span class="hljs-keyword">is</span> Owned &#123;<br>    <span class="hljs-comment">// 关键字 `virtual` 意味着该函数可以在派生类中改变其行为（“重写”）。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 这些抽象合约仅用于给编译器提供接口。</span><br><span class="hljs-comment">// 注意函数没有函数体。</span><br><span class="hljs-comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span><br><span class="hljs-keyword">abstract</span> contract Config &#123;<br>    <span class="hljs-function">function <span class="hljs-title">lookup</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> id</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">address adr</span>)</span>;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> contract NameReg &#123;<br>    <span class="hljs-function">function <span class="hljs-title">register</span>(<span class="hljs-params">bytes32 name</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>    <span class="hljs-function">function <span class="hljs-title">unregister</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">// 多重继承是可能的。请注意， `Owned` 也是 `Destructible` 的基类，</span><br><span class="hljs-comment">// 但只有一个 `Owned` 实例（就像 C++ 中的虚拟继承）。</span><br>contract Named <span class="hljs-keyword">is</span> Owned, Destructible &#123;<br>    constructor(bytes32 name) &#123;<br>        Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>        NameReg(config.lookup(<span class="hljs-number">1</span>)).register(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重写。</span><br>    <span class="hljs-comment">// 如果重写函数有不同类型的输出参数，会导致错误。</span><br>    <span class="hljs-comment">// 本地和基于消息的函数调用都会考虑这些重写。</span><br>    <span class="hljs-comment">// 如果您想重写这个函数，您需要使用 `override` 关键字。</span><br>    <span class="hljs-comment">// 如果您想让这个函数再次被重写，您需要再指定 `virtual` 关键字。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) &#123;<br>            Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>            NameReg(config.lookup(<span class="hljs-number">1</span>)).unregister();<br>            <span class="hljs-comment">// 仍然可以调用特定的重写函数。</span><br>            Destructible.destroy();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 如果构造函数接受参数，</span><br><span class="hljs-comment">// 则需要在声明（合约的构造函数）时提供，</span><br><span class="hljs-comment">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span><br>contract PriceFeed <span class="hljs-keyword">is</span> Owned, Destructible, Named(<span class="hljs-string">&quot;GoldFeed&quot;</span>) &#123;<br>    <span class="hljs-function">function <span class="hljs-title">updateInfo</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newInfo</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) info = newInfo;<br>    &#125;<br><br>    <span class="hljs-comment">// 在这里，我们只指定了 `override` 而没有 `virtual`。</span><br>    <span class="hljs-comment">// 这意味着从 `PriceFeed` 派生出来的合约不能再改变 `destroy` 的行为。</span><br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Destructible, Named</span>)</span> &#123; Named.destroy(); &#125;<br>    <span class="hljs-function">function <span class="hljs-title">get</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> r</span>)</span> &#123; <span class="hljs-keyword">return</span> info; &#125;<br><br>    <span class="hljs-built_in">uint</span> info;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在上面，我们调用 <code>Destructible.destroy()</code> 来 “转发” 销毁请求。 这样做的方式是有问题的，从下面的例子中可以看出：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgRmluYWwgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7IEJhc2UyLmRlc3Ryb3koKTsgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> Destructible.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; Base2.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>Final.destroy()</code> 时会调用最后的派生重写函数 <code>Base2.destroy</code>， 但是会绕过 <code>Base1.destroy</code>， 解决这个问题的方法是使用 <code>super</code>：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgc3VwZXIuZGVzdHJveSgpOyB9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个由于废弃的 selfdestruct 而产生的警告</span><br><br>contract owned &#123;<br>    constructor() &#123; owner = payable(msg.sender); &#125;<br>    address payable owner;<br>&#125;<br><br>contract Destructible <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 1 */</span> super.destroy(); &#125;<br>&#125;<br><br><br>contract Base2 <span class="hljs-keyword">is</span> Destructible &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">/* 清除操作 2 */</span> super.destroy(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>    <span class="hljs-function">function <span class="hljs-title">destroy</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123; super.destroy(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>Base2</code> 调用 <code>super</code> 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的上一个基类合约中调用这个函数， 所以它会调用 <code>Base1.destroy()</code> （注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, Destructible, ownerd）。 在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。</p><h3 id="函数重写-1"><a href="#函数重写-1" class="headerlink" title="函数重写"></a>函数重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding"></a></h3><p>如果基函数被标记为 <code>virtual</code>，则可以通过继承合约来改变其行为。 被重写的函数必须在函数头中使用 <code>override</code> 关键字。 重写函数只能将被重写函数的可见性从 <code>external</code> 改为 <code>public</code>。 可变性可以按照以下顺序改变为更严格的可变性。 <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 重写。 <code>view</code> 可以被 <code>pure</code> 重写。 <code>payable</code> 是一个例外，不能被改变为任何其他可变性。</p><p>下面的例子演示了改变函数可变性和可见性：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> external view</span> &#123;&#125;<br>&#125;<br><br>contract Middle <span class="hljs-keyword">is</span> Base &#123;&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Middle<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> pure</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于多重继承，必须在 <code>override</code> 关键字后明确指定定义同一函数的最多派生基类合约。 换句话说，您必须指定所有定义同一函数的基类合约， 并且还没有被另一个基类合约重写（在继承图的某个路径上）。 此外，如果一个合约从多个（不相关的）基类合约上继承了同一个函数，必须明确地重写它。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyDmtL7nlJ/oh6rlpJrkuKrlrprkuYkgZm9vKCkg5Ye95pWw55qE5Z+657G75ZCI57qm77yMCiAgICAvLyDmiYDku6XmiJHku6zlv4XpobvmmI7noa7lnLDph43lhpnlroMKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-comment">// 派生自多个定义 foo() 函数的基类合约，</span><br>    <span class="hljs-comment">// 所以我们必须明确地重写它</span><br>    <span class="hljs-function">function <span class="hljs-title">foo</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果函数被定义在一个共同的基类合约中， 或者在一个共同的基类合约中有一个独特的函数已经重写了所有其他的函数， 则不需要明确的函数重写指定符。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyDml6DpnIDmmI7noa7nmoTph43lhpkKY29udHJhY3QgRCBpcyBCLCBDIHt9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A &#123; <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span>&#123;&#125; &#125;<br>contract B <span class="hljs-keyword">is</span> A &#123;&#125;<br>contract C <span class="hljs-keyword">is</span> A &#123;&#125;<br><span class="hljs-comment">// 无需明确的重写</span><br>contract D <span class="hljs-keyword">is</span> B, C &#123;&#125;<br></code></pre></td></tr></table></figure><p>更准确地说，如果有一个基类合约是该签名的所有重写路径的一部分， 并且（1）该基类合约实现了该函数，并且从当前合约到该基类合约的任何路径都没有提到具有该签名的函数， 或者（2）该基类合约没有实现该函数，并且从当前合约到该基类合约的所有路径中最多只有一个提到该函数， 那么就不需要重写从多个基类合约继承的函数（直接或间接）。</p><p>在这个意义上，一个签名的重写路径是一条继承图的路径， 它从所考虑的合约开始，到提到具有该签名的函数的合约结束， 而该签名没有重写。</p><p>如果您不把一个重写的函数标记为 <code>virtual</code>，派生合约就不能再改变该函数的行为。</p><p>备注</p><p>具有 <code>private</code> 可见性的函数不能是 <code>virtual</code>。</p><p>备注</p><p>在接口合约之外，没有实现的函数必须被标记为 <code>virtual</code>。 在接口合约中，所有的函数都被自动视为 <code>virtual</code>。</p><p>备注</p><p>从Solidity 0.8.8开始，当重写一个接口函数时， 不需要 <code>override</code> 关键字，除非该函数被定义在多个基础上。</p><p>如果函数的参数和返回类型与变量的getter函数匹配，公共状态变量可以重写为外部函数。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract A<br>&#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() external view <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br><br>contract B <span class="hljs-keyword">is</span> A<br>&#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> f;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>虽然公共状态变量可以重写外部函数，但它们本身不能被重写。</p><h3 id="修饰器重写"><a href="#修饰器重写" class="headerlink" title="修饰器重写"></a>修饰器重写<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding"></a></h3><p>函数修改器可以相互重写。 这与 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#function-overriding">函数重写</a> 的工作方式相同（除了对修改器没有重写）。 <code>virtual</code> 关键字必须用在被重写的修改器上， <code>override</code> 关键字必须用在重写的修改器上：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span></span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在多重继承的情况下，必须明确指定所有的直接基类合约。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base1<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">virtual</span></span> &#123;_;&#125;<br>&#125;<br><br>contract Inherited <span class="hljs-keyword">is</span> Base1, Base2<br>&#123;<br>    <span class="hljs-function">modifier <span class="hljs-title">foo</span>() <span class="hljs-keyword">override</span>(<span class="hljs-params">Base1, Base2</span>)</span> &#123;_;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#constructor"></a></h3><p>构造函数是一个用 <code>constructor</code> 关键字声明的可选函数， 它在合约创建时被执行，您可以在这里运行合约初始化代码。</p><p>在构造函数代码执行之前，如果您用内联编程的方式初始化状态变量，则将其初始化为指定的值； 如果您不用内联编程的方式来初始化，则将其初始化为 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>。</p><p>构造函数运行后，合约的最终代码被部署到区块链上。 部署代码的燃料花费与代码长度成线性关系。 这段代码包括属于公共接口的所有函数，以及所有通过函数调用可以到达的函数。 但不包括构造函数代码或只从构造函数中调用的内部函数。</p><p>如果没有构造函数，合约将假定默认的构造函数， 相当于 <code>constructor() &#123;&#125;</code>。比如说：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=">open in Remix</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract A &#123;<br>    uint <span class="hljs-keyword">public</span> a;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">uint a_</span>) &#123;<br>        a = a_;<br>    &#125;<br>&#125;<br><br>contract B is <span class="hljs-title function_">A</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以在构造函数中使用内部参数（例如，存储指针）。 在这种情况下，合约必须被标记为 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract">abstract</a>， 因为这些参数不能从外部分配有效的值，只能通过派生合约的构造函数来赋值。</p><p>警告</p><p>在0.4.22版本之前，构造函数被定义为与合约同名的函数。 这种语法已被废弃，在0.5.0版本中不再允许。</p><p>警告</p><p>在0.7.0版本之前，您必须指定构造函数的可见性为 <code>internal</code> 或 <code>public</code>。</p><h3 id="基本构造函数的参数"><a href="#基本构造函数的参数" class="headerlink" title="基本构造函数的参数"></a>基本构造函数的参数<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21"></a></h3><p>所有基类合约的构造函数将按照下面解释的线性化规则被调用。 如果基类合约构造函数有参数，派生合约需要指定所有的参数。 这可以通过两种方式实现：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyDopoHkuYjnm7TmjqXlnKjnu6fmib/liJfooajkuK3mjIflrpouLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaIluiAhemAmui/h+a0vueUn+aehOmAoOWHveaVsOeahOS4gOS4qiAi5L+u5pS55ZmoIuKApuKApgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgeSkgQmFzZSh5ICogeSkge30KfQoKLy8g5oiW6ICF5bCG5ZCI57qm5aOw5piO5Li6YWJzdHJhY3TnsbvlnovigKbigKYKYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIOW5tuiuqeS4i+S4gOS4quWFt+S9k+eahOa0vueUn+WQiOe6puWvueWFtui/m+ihjOWIneWni+WMluOAggpjb250cmFjdCBEZXJpdmVkRnJvbURlcml2ZWQgaXMgRGVyaXZlZDMgewogICAgY29uc3RydWN0b3IoKSBCYXNlKDEwICsgMTApIHt9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Base &#123;<br>    <span class="hljs-built_in">uint</span> x;<br>    constructor(<span class="hljs-built_in">uint</span> x_) &#123; x = x_; &#125;<br>&#125;<br><br><span class="hljs-comment">// 要么直接在继承列表中指定...</span><br><span class="hljs-function">contract Derived1 <span class="hljs-keyword">is</span> <span class="hljs-title">Base</span>(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span> &#123;<br>    constructor() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者通过派生构造函数的一个 &quot;修改器&quot;……</span><br>contract Derived2 <span class="hljs-keyword">is</span> Base &#123;<br>    constructor(<span class="hljs-built_in">uint</span> y) Base(y * y) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 或者将合约声明为abstract类型……</span><br><span class="hljs-keyword">abstract</span> contract Derived3 <span class="hljs-keyword">is</span> Base &#123;<br>&#125;<br><br><span class="hljs-comment">// 并让下一个具体的派生合约对其进行初始化。</span><br>contract DerivedFromDerived <span class="hljs-keyword">is</span> Derived3 &#123;<br>    constructor() Base(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一种方式是直接在继承列表中给出（ <code>is Base(7)</code> ）。 另一种是通过修改器作为派生构造函数的一部分被调用的方式（ <code>Base(y * y)</code> ）。 如果构造函数参数是一个常量，并且定义了合约的行为或描述了它，那么第一种方式更方便。 如果基类合约的构造函数参数依赖于派生合约的参数，则必须使用第二种方式。 参数必须在继承列表中或在派生构造函数中以修饰器的形式给出。 在两个地方都指定参数是一个错误。</p><p>如果一个派生合约没有指定其所有基类合约的构造函数的参数，那么它必须被声明为 abstract 类型。在这种情况下， 当另一个合约从它派生时，其他合约的继承列表或构造函数必须为所有没有指定参数的基类合约提供必要的参数 （否则，其他合约也必须被声明为 abstract 类型）。例如，在上面的代码片段中， 可以查看合约 <code>Derived3</code> 和 <code>DerivedFromDerived</code>。</p><h3 id="多重继承与线性化"><a href="#多重继承与线性化" class="headerlink" title="多重继承与线性化"></a>多重继承与线性化<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#multi-inheritance"></a></h3><p>编程语言实现多重继承需要解决几个问题。 一个问题是 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a> 。 Solidity 借鉴了 Python 的方式并且使用 “<a href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>” 强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终实现我们所希望的唯一化的结果，但也使某些继承方式变为无效。 尤其是，基类在 <code>is</code> 后面的顺序很重要。 在下面的代码中， 您必须按照从 “最接近的基类”（most base-like）到 “最远的继承”（most derived）的顺序来指定所有的基类。 注意，这个顺序与Python中使用的顺序相反。</p><p>另一种简化的解释方式是，当一个函数被调用时， 它在不同的合约中被多次定义，给定的基类以深度优先的方式从右到左（Python中从左到右）进行搜索， 在第一个匹配处停止。如果一个基类合约已经被搜索过了，它就被跳过。</p><p>在下面的代码中，Solidity 会给出 “Linearization of inheritance graph impossible” 这样的错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8g6L+Z5q615Luj56CB5LiN5Lya57yW6K+RCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==">open in Remix</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>contract <span class="hljs-attribute">X</span> &#123;&#125;<br>contract <span class="hljs-selector-tag">A</span> is <span class="hljs-attribute">X</span> &#123;&#125;<br>// 这段代码不会编译<br>contract C is <span class="hljs-selector-tag">A</span>, <span class="hljs-attribute">X</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>代码编译出错的原因是 <code>C</code> 要求 <code>X</code> 重写 <code>A</code> （因为定义的顺序是 <code>A, X</code> ）， 但是 <code>A</code> 本身要求重写 <code>X</code>， 这是一种无法解决的冲突。</p><p>由于您必须明确地重写一个从多个基类合约继承的函数， 而没有唯一的重写，C3线性化在实践中不是太重要。</p><p>继承的线性化特别重要的一个领域是，当继承层次中存在多个构造函数时，也许不那么清楚。 构造函数将总是按照线性化的顺序执行，而不管它们的参数在继承合约的构造函数中是以何种顺序提供的。 比如说：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaehOmAoOWHveaVsOaMieS7peS4i+mhuuW6j+aJp+ihjO+8mgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8g5p6E6YCg5Ye95pWw5oyJ5Lul5LiL6aG65bqP5omn6KGM77yaCi8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyDmnoTpgKDlh73mlbDku43mjInku6XkuIvpobrluo/miafooYzvvJoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=">open in Remix</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br>contract <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base1</span><br><span class="hljs-comment">//  2 - Base2</span><br><span class="hljs-comment">//  3 - Derived1</span><br>contract <span class="hljs-title class_">Derived1</span> is <span class="hljs-title class_">Base1</span>, <span class="hljs-title class_">Base2</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived2</span><br>contract <span class="hljs-title class_">Derived2</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base2</span>() <span class="hljs-title class_">Base1</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造函数仍按以下顺序执行：</span><br><span class="hljs-comment">//  1 - Base2</span><br><span class="hljs-comment">//  2 - Base1</span><br><span class="hljs-comment">//  3 - Derived3</span><br>contract <span class="hljs-title class_">Derived3</span> is <span class="hljs-title class_">Base2</span>, <span class="hljs-title class_">Base1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-title class_">Base1</span>() <span class="hljs-title class_">Base2</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承有相同名字的不同类型成员"><a href="#继承有相同名字的不同类型成员" class="headerlink" title="继承有相同名字的不同类型成员"></a>继承有相同名字的不同类型成员<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#id33"></a></h3><p>由于继承的关系，一个合约可能包含多个共享相同名称的定义，这种情况只有一种：</p><ul><li>函数重写。</li><li>重写virtual函数</li><li>通过状态变量获取器重写外部virtual函数。</li><li>重写virtual修饰符。</li><li>事件重写。</li></ul><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#abstract-contract"></a></h2><p>当合约中至少有一个函数没有被实现，或者合约没有为其所有的基本合约构造函数提供参数时， 合约必须被标记为 abstract。 即使不是这种情况，合约仍然可以被标记为 abstract， 例如，当您不打算直接创建合约时。 抽象（abstract）合约类似于 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interfaces">接口（interface）合约</a>， 但是接口（interface）合约可以声明的内容更加有限。</p><p>如下例所示，使用 <code>abstract</code> 关键字来声明一个抽象合约。 注意，这个合约需要被定义为 abstract，因为函数 <code>utterance()</code> 被声明了， 但没有提供实现（没有给出实现体 <code>&#123; &#125;</code>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的抽象合约不能被直接实例化。如果一个抽象合约本身实现了所有定义的功能，这也是可以的。 抽象合约作为基类的用法在下面的例子中显示：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">abstract</span> contract Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">virtual</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span>;<br>&#125;<br><br>contract Cat <span class="hljs-keyword">is</span> Feline &#123;<br>    <span class="hljs-function">function <span class="hljs-title">utterance</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-keyword">override</span> <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;miaow&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个合约继承自一个抽象合约，并且没有通过重写实现所有未实现的函数，那么它也需要被标记为抽象的。</p><p>注意，没有实现的函数与 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#function-types">函数类型</a> 不同，尽管它们的语法看起来非常相似。</p><p>没有实现内容的函数的例子（一个函数声明）：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span>;<br></code></pre></td></tr></table></figure><p>类型为函数类型的变量的声明实例：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span> <span class="hljs-title function_">foo</span>;<br></code></pre></td></tr></table></figure><p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自我记录， 促进了像 <a href="https://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a> 这样的模式， 并消除了代码的重复。抽象合约的作用与在接口中定义方法的作用相同。 它是抽象合约的设计者说 “我的任何孩子都必须实现这个方法” 的一种方式。</p><p>备注</p><p>抽象合约不能用一个未实现的virtual函数来重写一个已实现的virtual函数。</p><h2 id="接口（interface）合约"><a href="#接口（interface）合约" class="headerlink" title="接口（interface）合约"></a>接口（interface）合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interface"></a></h2><p>接口（interface）合约类似于抽象（abstract）合约，但是它们不能实现任何函数。并且还有进一步的限制：</p><ul><li>它们不能继承其他合约，但是它们可以继承其他接口合约。</li><li>在接口合约中所有声明的函数必须是 external 类型的，即使它们在合约中是 public 类型的。</li><li>它们不能声明构造函数。</li><li>它们不能声明状态变量。</li><li>它们不能声明修饰器。</li></ul><p>将来可能会解除这些里的某些限制。</p><p>接口合约基本上仅限于合约 ABI 可以表示的内容， 并且 ABI 和接口合约之间的转换应该不会丢失任何信息。</p><p>接口合约由它们自己的关键字表示：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> Token &#123;<br>    <span class="hljs-keyword">enum</span> TokenType &#123; Fungible, NonFungible &#125;<br>    <span class="hljs-keyword">struct</span> Coin &#123; <span class="hljs-built_in">string</span> obverse; <span class="hljs-built_in">string</span> reverse; &#125;<br>    <span class="hljs-built_in">function</span> transfer(address recipient, <span class="hljs-built_in">uint</span> amount) external;<br>&#125;<br></code></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口合约。</p><p>所有在接口合约中声明的函数都是隐式的 <code>virtual</code> 的类型， 任何重写它们的函数都不需要 <code>override</code> 关键字。 这并不自动意味着一个重写的函数可以被再次重写–这只有在重写的函数被标记为 <code>virtual</code> 时才可能。</p><p>接口合约可以从其他接口合约继承。这与普通的继承有着相同的规则。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyDlv4Xpobvph43mlrDlrprkuYl0ZXN077yM5Lul5L6/5pat6KiA54i257G755qE5ZCr5LmJ5piv5YW85a6555qE44CCCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.2</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentA</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParentB</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SubInterface</span> <span class="hljs-keyword">is</span> ParentA, ParentB &#123;<br>    <span class="hljs-comment">// 必须重新定义test，以便断言父类的含义是兼容的。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">override</span><span class="hljs-params">(ParentA, ParentB)</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口合约和其他类似合约的结构中定义的类型可以从其他合约中访问： <code>Token.TokenType</code> 或 <code>Token.Coin</code>。</p><p>警告</p><p>接口合约从 <a href="https://docs.soliditylang.org/zh-cn/latest/050-breaking-changes.html">Solidity 0.5.0</a> 开始支持 <code>enum</code> 类型， 请确保pragma版本至少指定这个版本。</p><h2 id="库合约"><a href="#库合约" class="headerlink" title="库合约"></a>库合约<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries"></a></h2><p>库合约与普通合约类似，但是它们只需要在特定的地址部署一次， 并且它们的代码可以通过 EVM 的 <code>DELEGATECALL</code> (Homestead 之前使用 <code>CALLCODE</code> 关键字)特性进行重用。 这意味着如果库函数被调用，它的代码在调用合约的上下文中执行， 即 <code>this</code> 指向调用合约，特别是可以访问调用合约的存储。 因为每个库合约都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。 如果库函数不修改状态（也就是说，如果它们是 <code>view</code> 或者 <code>pure</code> 函数）， 它们可以通过直接调用来使用（即不使用 <code>DELEGATECALL</code> 关键字）， 这是因为我们假定库合约是无状态的。 特别的是，销毁一个库合约是不可能的。</p><p>备注</p><p>在0.4.20版本之前，有可能通过规避Solidity的类型系统来破坏库合约。 从该版本开始，库合约包含一个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection">保护机制</a>， 不允许直接调用修改状态的函数（即没有 <code>DELEGATECALL</code> ）。</p><p>库合约可以看作是使用他们的合约的隐式的基类合约。 虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似 （如果 <code>L</code> 是库合约的话，可以使用 <code>L.f()</code> 调用库函数）。 当然，需要使用内部调用约定来调用内部函数，这意味着所有的内部类型都可以被传递， 类型 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存</a> 将被引用传递而不是复制。 为了在EVM中实现这一点，从合约中调用的内部库函数的代码和其中调用的所有函数将在编译时包含在调用合约中， 并使用常规的 <code>JUMP</code> 调用，而不是 <code>DELEGATECALL</code>。</p><p>备注</p><p>当涉及到公共函数时，继承的类比就失效了。 用 <code>L.f()</code> 调用公共库函数的结果是一个外部调用（准确地说，是 <code>DELEGATECALL</code> ）。 相反，当 <code>A.f()</code> 是当前合约的基类合约时， <code>A.f()</code> 是一个内部调用。</p><p>下面的示例说明如何使用库（但也请务必看看 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for">using for</a> 有一个实现 set 更好的例子）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOaIkeS7rOWumuS5ieS6huS4gOS4quaWsOeahOe7k+aehOS9k+aVsOaNruexu+Wei++8jOeUqOS6juWcqOiwg+eUqOWQiOe6puS4reS/neWtmOaVsOaNruOAggpzdHJ1Y3QgRGF0YSB7CiAgICBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7Cn0KCmxpYnJhcnkgU2V0IHsKICAgIC8vIOazqOaEj+esrOS4gOS4quWPguaVsOaYryDigJxzdG9yYWdlIHJlZmVyZW5jZeKAneexu+Wei++8jAogICAgLy8g5Zug5q2k5Zyo6LCD55So5Lit5Y+C5pWw5Lyg6YCS55qE5Y+q5piv5a6D55qE5a2Y5YKo5Zyw5Z2A6ICM5LiN5piv5YaF5a6544CCCiAgICAvLyDov5nmmK/lupPlh73mlbDnmoTkuIDkuKrnibnmgKfjgILlpoLmnpzor6Xlh73mlbDlj6/ku6Xooqvop4bkuLrlr7nosaHnmoTmlrnms5XvvIwKICAgIC8vIOWImeS5oOaDr+ensOesrOS4gOS4quWPguaVsOS4uiBgc2VsZmAg44CCCiAgICBmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5LiN5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDkuI3pnIDopoHlupPnmoTnibnlrprlrp7kvovlsLHlj6/ku6XosIPnlKjlupPlh73mlbDvvIwKICAgICAgICAvLyDlm6DkuLrlvZPliY3lkIjnuqblsLHmmK8g4oCcaW5zdGFuY2XigJ3jgIIKICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyDlpoLmnpzmiJHku6zmhL/mhI/vvIzmiJHku6zkuZ/lj6/ku6XlnKjov5nkuKrlkIjnuqbkuK3nm7TmjqXorr/pl64ga25vd25WYWx1ZXMuZmxhZ3PjgIIKfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br><span class="hljs-comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span><br>struct Data &#123;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags;<br>&#125;<br><br>library Set &#123;<br>    <span class="hljs-comment">// 注意第一个参数是 “storage reference”类型，</span><br>    <span class="hljs-comment">// 因此在调用中参数传递的只是它的存储地址而不是内容。</span><br>    <span class="hljs-comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，</span><br>    <span class="hljs-comment">// 则习惯称第一个参数为 `self` 。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>        <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">view</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>    &#125;<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 不需要库的特定实例就可以调用库函数，</span><br>        <span class="hljs-comment">// 因为当前合约就是 “instance”。</span><br>        <span class="hljs-keyword">require</span>(Set.insert(knownValues, value));<br>    &#125;<br>    <span class="hljs-comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，您不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。 函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p><p>调用 <code>Set.contains</code>， <code>Set.insert</code> 和 <code>Set.remove</code> 都被编译为对外部合约/库的调用（ <code>DELEGATECALL</code> ）。 如果使用库，请注意实际执行的是外部函数调用。 <code>msg.sender</code>， <code>msg.value</code> 和 <code>this</code> 在调用中将保留它们的值， （在 Homestead 之前，因为使用了 <code>CALLCODE</code> ，改变了 <code>msg.sender</code> 和 <code>msg.value</code>)。</p><p>下面的例子显示了如何使用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location">存储在内存中的类型</a> 和库合约中的内部函数， 以实现自定义类型，而没有外部函数调用的开销：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDns5/ns5XvvIzmiJHku6zlv4Xpobvlop7liqDkuIDkuKogbGltYgogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBhLCB1aW50IGluZGV4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gaW5kZXggPCBhLmxpbWJzLmxlbmd0aCA/IGEubGltYnNbaW5kZXhdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<br><br>struct <span class="hljs-type">bigint</span> &#123;<br>    uint[] limbs;<br>&#125;<br><br>library <span class="hljs-type">BigInt</span> &#123;<br>    <span class="hljs-keyword">function</span> fromUint(uint x) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](<span class="hljs-number">1</span>);<br>        r.limbs[<span class="hljs-number">0</span>] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">bigint</span> memory a, <span class="hljs-type">bigint</span> memory b) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> memory r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](max(a.limbs.length, b.limbs.length));<br>        uint carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i) &#123;<br>            uint limbA = limb(a, i);<br>            uint limbB = limb(b, i);<br>            unchecked &#123;<br>                r.limbs[i] = limbA + limbB + carry;<br><br>                <span class="hljs-keyword">if</span> (limbA + limbB &lt; limbA || (limbA + limbB == <span class="hljs-keyword">type</span>(uint).max &amp;&amp; carry &gt; <span class="hljs-number">0</span>))<br>                    carry = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    carry = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            // 糟糕，我们必须增加一个 limb<br>            uint[] memory newLimbs = <span class="hljs-built_in">new</span> uint[](r.limbs.length + <span class="hljs-number">1</span>);<br>            uint i;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i)<br>                newLimbs[i] = r.limbs[i];<br>            newLimbs[i] = carry;<br>            r.limbs = newLimbs;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> limb(<span class="hljs-type">bigint</span> memory a, uint <span class="hljs-keyword">index</span>) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> &lt; a.limbs.length ? a.limbs[<span class="hljs-keyword">index</span>] : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> max(uint a, uint b) private pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">BigInt</span> <span class="hljs-keyword">for</span> <span class="hljs-type">bigint</span>;<br><br>    <span class="hljs-keyword">function</span> f() <span class="hljs-built_in">public</span> pure &#123;<br>        <span class="hljs-type">bigint</span> memory x = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-number">7</span>);<br>        <span class="hljs-type">bigint</span> memory y = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-keyword">type</span>(uint).max);<br>        <span class="hljs-type">bigint</span> memory z = x.<span class="hljs-keyword">add</span>(y);<br>        <span class="hljs-keyword">assert</span>(z.limb(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过将库合约的类型转换为 <code>address</code> 类型，即使用 <code>address(LibraryName)</code>，可以获得一个库的地址。</p><p>由于编译器不知道库合约的部署地址， 编译后的十六进制代码将包含 <code>__$30bbc0abd4d6364515865950d3e0d10953$__</code> 形式的占位符。 占位符是完全等同于库合约名的keccak256哈希值的34个字符的前缀，例如 <code>libraries/bigint.sol:BigInt</code>， 如果该库存储在 <code>libraries/</code> 目录下一个名为 <code>bigint.sol</code> 的文件中。 这样的字节码是不完整的，不应该被部署。占位符需要被替换成实际地址。 您可以在编译库的时候把它们传递给编译器，或者用链接器来更新已经编译好的二进制文件。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#library-linking">库链接</a>，了解如何使用命令行编译器进行链接。</p><p>与合约相比，库在以下方面受到限制：</p><ul><li>它们不能有状态变量</li><li>它们不能继承，也不能被继承</li><li>它们不能接收以太</li><li>它们不能被销毁</li></ul><p>(这些可能会在以后的时间里被解除)。</p><h3 id="库合约中的函数签名和选择器"><a href="#库合约中的函数签名和选择器" class="headerlink" title="库合约中的函数签名和选择器"></a>库合约中的函数签名和选择器<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-27"></a></h3><p>虽然对公共或外部库函数的外部调用是可能的，但这种调用的调用惯例被认为是 Solidity 内部的， 与常规 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">合约 ABI</a> 所指定的不一样。 外部库函数比外部合约函数支持更多的参数类型，例如递归结构和存储指针。 由于这个原因，用于计算4字节选择器的函数签名是按照内部命名模式计算的， 合约ABI中不支持的类型的参数使用内部编码。</p><p>签名中的类型使用了以下标识符：</p><ul><li>值类型、非存储的 <code>string</code> 和非存储的 <code>bytes</code> 使用与合约ABI中相同的标识符。</li><li>非存储数组类型遵循与合约ABI中相同的惯例，即 <code>&lt;type&gt;[]</code> 用于动态数组， <code>&lt;type&gt;[M]</code> 用于 <code>M</code> 元素的固定大小数组。</li><li>非存储结构体用其完全等同于的名称来指代，即 <code>C.S</code> 代表 <code>contract C &#123; struct S &#123; ... &#125; &#125;</code>。</li><li>存储指针映射使用 <code>mapping(&lt;keyType&gt; =&gt; &lt;valueType&gt;) storage</code>， 其中 <code>&lt;keyType&gt;</code> 和 <code>&lt;valueType&gt;</code> 分别是映射的键和值类型的标识。</li><li>其他存储指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格，即 <code>storage</code>。</li></ul><p>参数的编码与普通合约ABI相同，除了存储指针， 它被编码为一个 <code>uint256</code> 值，指的是它们所指向的存储槽。</p><p>与合约ABI类似，选择器由签名的Keccak256-hash的前四个字节组成。 它的值可以通过使用 <code>.selector</code> 成员从 Solidity 获得，如下：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ada">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span>.<span class="hljs-number">14</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>library L &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(uint256) external &#123;&#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">g</span>() public pure returns (bytes4) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">L.f.selector</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#call-protection"></a></h3><p>正如介绍中提到的那样，如果库的代码是通过 <code>CALL</code> 来执行， 而不是 <code>DELEGATECALL</code> 或者 <code>CALLCODE</code>， 那么执行的结果会被恢复， 除非是对 <code>view</code> 或者 <code>pure</code> 函数的调用。</p><p>EVM没有提供一个直接的方法让合约检测它是否被使用 <code>CALL</code> 调用， 但是合约可以使用 <code>ADDRESS</code> 操作码来找出它当前运行的 “位置”。 生成的代码将这个地址与构造时使用的地址进行比较，以确定调用的模式。</p><p>更具体地说，一个库合约的运行时代码总是以 push 指令开始， 在编译时它是一个20字节的零。 当部署代码运行时，这个常数在内存中被当前地址所取代，这个修改后的代码被存储在合约中。 在运行时，这导致部署时的地址成为第一个被推入堆栈的常数， 对于任何非view和非pure函数，调度器代码会将当前地址与这个常数进行比较。</p><p>这意味着一个存储在链上的库合约的实际代码，与编译器报告的 <code>deployedBytecode</code> 的代码不同。</p><h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For<a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for"></a></h2><p>指令 <code>using A for B</code> 可以用来将函数（ <code>A</code>）作为操作符附加到用户定义的值类型， 或者作为任何类型（ <code>B</code>）的成员函数。 成员函数将它们被调用的对象作为第一个参数接收（像 Python 中的 <code>self</code> 变量）。 操作符函数将操作数作为参数接收。</p><p>它可以在文件级别或者在合约级别的合约内部有效。</p><p>第一部分， <code>A</code>，可以是以下之一：</p><ul><li>一个函数列表，可以选择性地分配操作符名称（例如 <code>using &#123;f, g as +, h, L.t&#125; for uint</code>）。 如果没有指定操作符，函数可以是库函数或自由函数，并作为成员函数附加到类型上。 否则，它必须是一个自由函数，并成为该类型上该操作符的定义。</li><li>一个库合约的名称（例如 <code>using L for uint</code> ）- 该库合约的所有非私有函数都作为成员函数附加在该类型上。</li></ul><p>在文件级别中，第二部分， <code>B</code>，必须是一个明确的类型（没有数据位置指定）。 在合约内部，您也可以用 <code>*</code> 代替类型（例如 <code>using L for *;</code> ）， 这样做的效果是，库合约 <code>L</code> 中所有的函数都会被附加到 <em>所有</em> 类型上。</p><p>如果您指定了一个库合约，那么该库合约中的 <em>所有</em> 非私有函数都会被附加到该类型上， 即使是那些第一个参数的类型与对象的类型不匹配的函数。 类型会在函数被调用的时候检查， 并执行函数重写解析。</p><p>如果您使用一个函数列表（例如 <code>using &#123;f, g, h, L.t&#125; for uint</code> ）， 那么类型（ <code>uint</code> ）必须可以隐式地转换为这些函数的第一个参数。 即使这些函数都没有被调用，也要进行这种检查。 请注意，只有当 <code>using for</code> 位于库合约内时，才能指定私有库函数。</p><p>如果您定义了一个操作符（例如 <code>using &#123;f as +&#125; for T</code>），那么类型（ <code>T</code>）必须是一个 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#user-defined-value-types">用户定义的值类型</a>，并且定义必须是一个 <code>pure</code> 函数。 操作符定义必须是全局的。 以下操作符可以用这种方式定义：</p><div class="table-container"><table><thead><tr><th>Category</th><th>Operator</th><th>Possible signatures</th></tr></thead><tbody><tr><td>Bitwise</td><td><code>&amp;</code></td><td><code>function (T, T) pure returns (T)</code></td></tr><tr><td>`</td><td>`</td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>^</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>~</code></td><td><code>function (T) pure returns (T)</code></td><td></td></tr><tr><td>Arithmetic</td><td><code>+</code></td><td><code>function (T, T) pure returns (T)</code></td></tr><tr><td><code>-</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>function (T) pure returns (T)</code></td><td></td><td></td></tr><tr><td><code>*</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>/</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td><code>%</code></td><td><code>function (T, T) pure returns (T)</code></td><td></td></tr><tr><td>Comparison</td><td><code>==</code></td><td><code>function (T, T) pure returns (bool)</code></td></tr><tr><td><code>!=</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&lt;</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&lt;=</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&gt;</code></td><td><code>function (T, T) pure returns (bool)</code></td><td></td></tr><tr><td><code>&gt;=</code></td><td><code>function (T, T) pure returns (bool)</code></td></tr></tbody></table></div><p>注意，一元和二元的 <code>-</code> 需要单独定义。 编译器会根据操作符的调用方式选择正确的定义。</p><p><code>using A for B;</code> 指令只在当前作用域（合约或当前模块/源单元）内有效， 包括其中所有的函数，在使用它的合约或模块之外没有任何效果。</p><p>当在文件级别使用该指令并应用于在同一文件中用户定义类型时， 可以在末尾添加 <code>global</code> 关键字。 这将使函数和操作符附加到该类型的任何可用位置（包括其他文件）， 而不仅仅是在 using 语句的范围内。</p><p>下面我们将使用文件级函数来重写 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries">库合约</a> 部分中的 set 示例。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyDnjrDlnKjmiJHku6znu5nov5nkuKrnsbvlnovpmYTliqDkuIrlh73mlbDjgIIKLy8g6ZmE5Yqg55qE5Ye95pWw5Y+v5Lul5Zyo5qih5Z2X55qE5YW25LuW6YOo5YiG5L2/55So44CCCi8vIOWmguaenOaCqOWvvOWFpeS6huivpeaooeWdl++8jAovLyDmgqjlv4XpobvlnKjpgqPph4zph43lpI11c2luZ+aMh+S7pO+8jOS+i+WmggovLyAgIGltcG9ydCAiZmxhZ3Muc29sIiBhcyBGbGFnczsKLy8gICB1c2luZyB7RmxhZ3MuaW5zZXJ0LCBGbGFncy5yZW1vdmUsIEZsYWdzLmNvbnRhaW5zfQovLyAgICAgZm9yIEZsYWdzLkRhdGE7CnVzaW5nIHtpbnNlcnQsIHJlbW92ZSwgY29udGFpbnN9IGZvciBEYXRhOwoKZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOS4jeWtmOWcqAogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHZpZXcKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIHJldHVybiBzZWxmLmZsYWdzW3ZhbHVlXTsKfQoKCmNvbnRyYWN0IEMgewogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIOi/memHjO+8jCBEYXRhIOexu+Wei+eahOaJgOacieWPmOmHj+mDveacieS4juS5i+ebuOWvueW6lOeahOaIkOWRmOWHveaVsOOAggogICAgICAgIC8vIOS4i+mdoueahOWHveaVsOiwg+eUqOWSjCBgU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpYCDnmoTmlYjmnpzlrozlhajnm7jlkIzjgIIKICAgICAgICByZXF1aXJlKGtub3duVmFsdWVzLmluc2VydCh2YWx1ZSkpOwogICAgfQp9">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>struct Data &#123; mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags; &#125;<br><span class="hljs-comment">// 现在我们给这个类型附加上函数。</span><br><span class="hljs-comment">// 附加的函数可以在模块的其他部分使用。</span><br><span class="hljs-comment">// 如果您导入了该模块，</span><br><span class="hljs-comment">// 您必须在那里重复using指令，例如</span><br><span class="hljs-comment">//   import &quot;flags.sol&quot; as Flags;</span><br><span class="hljs-comment">//   using &#123;Flags.insert, Flags.remove, Flags.contains&#125;</span><br><span class="hljs-comment">//     for Flags.Data;</span><br>using &#123;insert, remove, contains&#125; <span class="hljs-keyword">for</span> Data;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 已经存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在</span><br>    <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">    <span class="hljs-title">view</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>&#125;<br><br><br>contract C &#123;<br>    Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// 这里， Data 类型的所有变量都有与之相对应的成员函数。</span><br>        <span class="hljs-comment">// 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span><br>        <span class="hljs-keyword">require</span>(knownValues.insert(value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过这种方式来扩展内置类型。 在这个例子中，我们将使用一个库合约。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyDov5nlsIbmiafooYzlupPlkIjnuqbkuK3nmoTlh73mlbDosIPnlKgKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.13</span>;<br><br>library <span class="hljs-keyword">Search</span> &#123;<br>    <span class="hljs-keyword">function</span> indexOf(uint[] <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>        <span class="hljs-built_in">public</span><br>        <span class="hljs-keyword">view</span><br>        <span class="hljs-keyword">returns</span> (uint)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; self.length; i++)<br>            <span class="hljs-keyword">if</span> (self[i] == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>(uint).max;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">Search</span> <span class="hljs-keyword">for</span> uint[];<br><br>contract C &#123;<br>    uint[] data;<br><br>    <span class="hljs-keyword">function</span> append(uint <span class="hljs-keyword">value</span>) <span class="hljs-built_in">public</span> &#123;<br>        data.push(<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> replace(uint <span class="hljs-keyword">from</span>, uint <span class="hljs-keyword">to</span>) <span class="hljs-built_in">public</span> &#123;<br>        // 这将执行库合约中的函数调用<br>        uint <span class="hljs-keyword">index</span> = data.indexOf(<span class="hljs-keyword">from</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == <span class="hljs-keyword">type</span>(uint).max)<br>            data.push(<span class="hljs-keyword">to</span>);<br>        <span class="hljs-keyword">else</span><br>            data[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">to</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，所有的外部库调用实际都是EVM函数调用。 这意味着，如果传递内存或值类型，即使是 <code>self</code> 变量，也会执行复制。 只有在使用存储引用变量或调用内部库函数时，才不会执行复制。</p><p>另一个展示了如何为用户定义的类型定义一个自定义操作符的例子：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTk7Cgp0eXBlIFVGaXhlZDE2eDIgaXMgdWludDE2OwoKdXNpbmcgewogICAgYWRkIGFzICssCiAgICBkaXYgYXMgLwp9IGZvciBVRml4ZWQxNngyIGdsb2JhbDsKCnVpbnQzMiBjb25zdGFudCBTQ0FMRSA9IDEwMDsKCmZ1bmN0aW9uIGFkZChVRml4ZWQxNngyIGEsIFVGaXhlZDE2eDIgYikgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICByZXR1cm4gVUZpeGVkMTZ4Mi53cmFwKFVGaXhlZDE2eDIudW53cmFwKGEpICsgVUZpeGVkMTZ4Mi51bndyYXAoYikpOwp9CgpmdW5jdGlvbiBkaXYoVUZpeGVkMTZ4MiBhLCBVRml4ZWQxNngyIGIpIHB1cmUgcmV0dXJucyAoVUZpeGVkMTZ4MikgewogICAgdWludDMyIGEzMiA9IFVGaXhlZDE2eDIudW53cmFwKGEpOwogICAgdWludDMyIGIzMiA9IFVGaXhlZDE2eDIudW53cmFwKGIpOwogICAgdWludDMyIHJlc3VsdDMyID0gYTMyICogU0NBTEUgLyBiMzI7CiAgICByZXF1aXJlKHJlc3VsdDMyIDw9IHR5cGUodWludDE2KS5tYXgsICJEaXZpZGUgb3ZlcmZsb3ciKTsKICAgIHJldHVybiBVRml4ZWQxNngyLndyYXAodWludDE2KGEzMiAqIFNDQUxFIC8gYjMyKSk7Cn0KCmNvbnRyYWN0IE1hdGggewogICAgZnVuY3Rpb24gYXZnKFVGaXhlZDE2eDIgYSwgVUZpeGVkMTZ4MiBiKSBwdWJsaWMgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICAgICAgcmV0dXJuIChhICsgYikgLyBVRml4ZWQxNngyLndyYXAoMjAwKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// SPDX-License-Identifier: GPL<span class="hljs-number">-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.19</span>;<br><br><span class="hljs-keyword">type</span> UFixed16x2 <span class="hljs-keyword">is</span> uint16;<br><br><span class="hljs-keyword">using</span> &#123;<br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">as</span> +,<br>    div <span class="hljs-keyword">as</span> /<br>&#125; <span class="hljs-keyword">for</span> UFixed16x2 <span class="hljs-keyword">global</span>;<br><br>uint32 <span class="hljs-keyword">constant</span> SCALE = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));<br>&#125;<br><br><span class="hljs-keyword">function</span> div(UFixed16x2 a, UFixed16x2 b) pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>    uint32 a32 = UFixed16x2.unwrap(a);<br>    uint32 b32 = UFixed16x2.unwrap(b);<br>    uint32 result32 = a32 * SCALE / b32;<br>    require(result32 &lt;= <span class="hljs-keyword">type</span>(uint16).max, &quot;Divide overflow&quot;);<br>    <span class="hljs-keyword">return</span> UFixed16x2.wrap(uint16(a32 * SCALE / b32));<br>&#125;<br><br>contract Math &#123;<br>    <span class="hljs-keyword">function</span> avg(UFixed16x2 a, UFixed16x2 b) <span class="hljs-built_in">public</span> pure <span class="hljs-keyword">returns</span> (UFixed16x2) &#123;<br>        <span class="hljs-keyword">return</span> (a + b) / UFixed16x2.wrap(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue</title>
    <link href="/2025/07/08/vue/"/>
    <url>/2025/07/08/vue/</url>
    
    <content type="html"><![CDATA[<p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1621612367141-93b24efc-8b06-4c10-8259-586cd8c6c5d5.webp" alt="img"></p><h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1620128979608-f7465ffc-9411-43e3-a6bc-96ab44dd77df.png" alt="img"></p><h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1618656573096-ebdc520c-5d60-4d12-ad04-5df4ebbb5fe7.png" alt="img"></p><h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1603814137582-5a9aa62f-0045-4272-bef0-447dedb25596.png" alt="img"></p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1603814104939-8c8ac923-735d-4476-937a-cb1f795ffe84.png" alt="img"></p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><p><strong>对于Watch：</strong></p><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li><p>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</p></li><li><ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><strong>总结：</strong></p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 </li></ul><p><strong>运用场景：</strong> </p><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 </li></ul><h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 </p><p><strong>不同点：</strong> </p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p><p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行</p><p>被包裹在keep-alive中的组件的状态将会被保留：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;keep-alive&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>&lt;/kepp-alive&gt;<br></code></pre></td></tr></table></figure><p><strong>router.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../src/views/xxx.vue&#x27;</span>),<br>  <span class="hljs-attr">meta</span>:&#123;<br>    <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 需要被缓存</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code> ：只会触发一次。</li></ul><h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul><h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul><h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong></p><p>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input v-model=<span class="hljs-string">&quot;sth&quot;</span> /&gt;<br><span class="hljs-comment">//  等同于</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;message&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">&gt;</span></span><br><span class="language-xml">//$event 指代当前触发的事件对象;</span><br><span class="language-xml">//$event.target 指代当前触发的事件对象的dom;</span><br><span class="language-xml">//$event.target.value 就是当前dom的value值;</span><br><span class="language-xml">//在@input方法中，value =&gt; sth;</span><br><span class="language-xml">//在:value中,sth =&gt; value;</span><br></code></pre></td></tr></table></figure><p><strong>（2）作用在组件上</strong></p><p>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p><p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong>因此父组件 v-model 语法糖本质上可以修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;child :value=<span class="hljs-string">&quot;message&quot;</span>  @input=<span class="hljs-string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;<br></code></pre></td></tr></table></figure><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;aa-input v-model=<span class="hljs-string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;<br><span class="hljs-comment">// 等价于</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">aa-input</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;aa&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aa-input</span>&gt;</span></span><br><br><span class="hljs-comment">// 子组件：</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;aa&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;onmessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aa-input</span>&gt;</span></span><br><br><span class="hljs-attr">props</span>:&#123;<span class="hljs-attr">value</span>:aa,&#125;<br><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">onmessage</span>(<span class="hljs-params">e</span>)&#123;<br>        $emit(<span class="hljs-string">&#x27;input&#x27;</span>,e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。</p><h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p><h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p><strong>（1）**</strong>keep-alive**</p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><p><strong>（2）keep-alive 的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">patternTypes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt; = [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>] <span class="hljs-comment">// 接收：字符串，正则，数组</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span><br><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 匹配的组件，缓存</span><br>    <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 不去匹配的组件，不缓存</span><br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>], <span class="hljs-comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span><br>  &#125;,<br><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []<br>  &#125;,<br><br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 销毁缓存cache的组件实例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<br>      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// prune 削减精简[v.]</span><br>    <span class="hljs-comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span><br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>render函数：</strong></p><ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li><li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li><li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">render</span> () &#123;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFirstComponentChild</span> (<span class="hljs-params">children: ?<span class="hljs-built_in">Array</span>&lt;VNode&gt;</span>): ?<span class="hljs-title class_">VNode</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children)) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> c = children[i]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(c) &amp;&amp; (<span class="hljs-title function_">isDef</span>(c.<span class="hljs-property">componentOptions</span>) || <span class="hljs-title function_">isAsyncPlaceholder</span>(c))) &#123;<br>      <span class="hljs-keyword">return</span> c<br>    &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <span class="hljs-comment">// 获取默认插槽</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-title function_">getFirstComponentChild</span>(slot)<span class="hljs-comment">// 获取第一个子组件</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">componentOptions</span>: ?<span class="hljs-title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span> <span class="hljs-comment">// 组件参数</span><br>  <span class="hljs-keyword">if</span> (componentOptions) &#123; <span class="hljs-comment">// 是否有组件参数</span><br>    <span class="hljs-comment">// check pattern</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: ?string = <span class="hljs-title function_">getComponentName</span>(componentOptions) <span class="hljs-comment">// 获取组件名</span><br>    <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">if</span> (<br>      <span class="hljs-comment">// not included</span><br>      (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) ||<br>      <span class="hljs-comment">// excluded</span><br>      (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>    ) &#123;<br>      <span class="hljs-comment">// 如果不匹配当前组件的名字和include以及exclude</span><br>      <span class="hljs-comment">// 那么直接返回组件的实例</span><br>      <span class="hljs-keyword">return</span> vnode<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span><br><br>    <span class="hljs-comment">// 获取这个组件的key</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: ?string = vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span><br>      <span class="hljs-comment">// same constructor may get registered as different local components</span><br>      <span class="hljs-comment">// so cid alone is not enough (#3269)</span><br>      ? componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ? <span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>)<br>      : vnode.<span class="hljs-property">key</span><br><br>    <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>      <span class="hljs-comment">// LRU缓存策略执行</span><br>      vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span> <span class="hljs-comment">// 组件初次渲染的时候componentInstance为undefined</span><br><br>      <span class="hljs-comment">// make current key freshest</span><br>      <span class="hljs-title function_">remove</span>(keys, key)<br>      keys.<span class="hljs-title function_">push</span>(key)<br>      <span class="hljs-comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span><br>      <span class="hljs-comment">// 使用时间间隔最长的一个</span><br>      cache[key] = vnode<br>      keys.<span class="hljs-title function_">push</span>(key)<br>      <span class="hljs-comment">// prune oldest entry</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>        <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将组件的keepAlive属性设置为true</span><br>    vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p><p><strong>实现步骤：</strong></p><ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li></ol><ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key </li></ul><ol><li>最后将这个组件的 keepAlive 设置为 true</li></ol><p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p><p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p><p><strong>首次渲染</strong></p><ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// core/instance/lifecycle</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLifecycle</span> (<span class="hljs-params">vm: Component</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = vm.<span class="hljs-property">$options</span><br><br>  <span class="hljs-comment">// locate first non-abstract parent</span><br>  <span class="hljs-keyword">let</span> parent = options.<span class="hljs-property">parent</span><br>  <span class="hljs-keyword">if</span> (parent &amp;&amp; !options.<span class="hljs-property">abstract</span>) &#123; <span class="hljs-comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span><br>    <span class="hljs-keyword">while</span> (parent.<span class="hljs-property">$options</span>.<span class="hljs-property">abstract</span> &amp;&amp; parent.<span class="hljs-property">$parent</span>) &#123;<br>      parent = parent.<span class="hljs-property">$parent</span><br>    &#125;<br>    parent.<span class="hljs-property">$children</span>.<span class="hljs-title function_">push</span>(vm)<br>  &#125;<br><br>  vm.<span class="hljs-property">$parent</span> = parent<br>  vm.<span class="hljs-property">$root</span> = parent ? parent.<span class="hljs-property">$root</span> : vm<br><br>  vm.<span class="hljs-property">$children</span> = []<br>  vm.<span class="hljs-property">$refs</span> = &#123;&#125;<br><br>  vm.<span class="hljs-property">_watcher</span> = <span class="hljs-literal">null</span><br>  vm.<span class="hljs-property">_inactive</span> = <span class="hljs-literal">null</span><br>  vm.<span class="hljs-property">_directInactive</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isDestroyed</span> = <span class="hljs-literal">false</span><br>  vm.<span class="hljs-property">_isBeingDestroyed</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// core/vdom/create-component</span><br><span class="hljs-title function_">init</span> (<span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNodeWithData</span>, <span class="hljs-attr">hydrating</span>: boolean): ?boolean &#123;<br>    <span class="hljs-keyword">if</span> (<br>      vnode.<span class="hljs-property">componentInstance</span> &amp;&amp;<br>      !vnode.<span class="hljs-property">componentInstance</span>.<span class="hljs-property">_isDestroyed</span> &amp;&amp;<br>      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span><br>    ) &#123; <span class="hljs-comment">// componentInstance在初次是undefined!!!</span><br>      <span class="hljs-comment">// kept-alive components, treat as a patch</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">mountedNode</span>: any = vnode <span class="hljs-comment">// work around flow</span><br>      componentVNodeHooks.<span class="hljs-title function_">prepatch</span>(mountedNode, mountedNode) <span class="hljs-comment">// prepatch函数执行的是组件更新的过程</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> child = vnode.<span class="hljs-property">componentInstance</span> = <span class="hljs-title function_">createComponentInstanceForVnode</span>(<br>        vnode,<br>        activeInstance<br>      )<br>      child.$mount(hydrating ? vnode.<span class="hljs-property">elm</span> : <span class="hljs-literal">undefined</span>, hydrating)<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p><p><strong>（4）LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。</p><p>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是<strong>“如果数据最近被访问过，那么将来被访问的几率也更高”</strong>。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ </p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p><p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取数据的操作...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p><h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt; <br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-title function_">data</span> () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">return</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">obj</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">                  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;obj.a&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              &#125; </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">       &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-attr">methods</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">addObjB</span> () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;obj.b&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>) </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">addObjB</span> () (<br>   <span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;obj.b&#x27;</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。</p><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1604019269329-d88e91cf-b33d-4b2d-b014-e5739e9b7dbc.png" alt="img"></p><p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 缓存数组原型</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 实现 arrayMethods.__proto__ === Array.prototype</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-comment">// 需要进行功能拓展的方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span><br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) &#123;<br>  <span class="hljs-comment">// 缓存原生数组方法</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method];<br>  <span class="hljs-title function_">def</span>(arrayMethods, method, <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutator</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 执行并缓存原生数组功能</span><br>    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-comment">// 响应式处理</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>    <span class="hljs-comment">// push、unshift会新增索引，所以要手动observer</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<span class="hljs-comment">// 获取插入的值，并设置响应式监听</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();<span class="hljs-comment">// 通知依赖更新</span><br>    <span class="hljs-comment">// 返回原生数组方法的执行结果</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的<strong>ob</strong>，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><strong>区别：</strong></p><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1609521413572-54d0bd0f-8ed6-4438-997a-c890e4cd9c5e.jpeg" alt="img"></p><h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p><p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将模板编译为render函数</span><br><span class="hljs-keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="hljs-title function_">compileToFunctions</span>(template,options<span class="hljs-comment">//省略&#125;, this)</span><br></code></pre></td></tr></table></figure><p>CompileToFunctions中的主要逻辑如下∶</p><p><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">constast = <span class="hljs-title function_">parse</span>(template.<span class="hljs-title function_">trim</span>(), options)<br></code></pre></td></tr></table></figure><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul><p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p><p><strong>（2）对静态节点做优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">optimize</span>(ast,options)<br></code></pre></td></tr></table></figure><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p><p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p><p><strong>（3）生成代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> code = <span class="hljs-title function_">generate</span>(ast, options)<br></code></pre></td></tr></table></figure><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p><h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong></p><p>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1609518480272-8cb1af01-a4a8-4d54-91bb-5546aafac510.jpeg" alt="img"></p><p><strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!child.<span class="hljs-property">_base</span>) &#123;<br>    <span class="hljs-keyword">if</span>(child.<span class="hljs-property">extends</span>) &#123;<br>        parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">extends</span>, vm)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(child.<span class="hljs-property">mixins</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = child.<span class="hljs-property">mixins</span>.<span class="hljs-property">length</span>; i &lt; l; i++)&#123;<br>            parent = <span class="hljs-title function_">mergeOptions</span>(parent, child.<span class="hljs-property">mixins</span>[i], vm)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p><strong>只能通过</strong> <code>**$emit**</code> <strong>派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p><h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defieneReactive</span> (<span class="hljs-params">obj, key, val</span>)&#123;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br>  ...<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    ...<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)&#123;<br>        dep.<span class="hljs-title function_">depend</span>();<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">return</span> val<br>    &#125;<br>    ...<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。</p><p><strong>（1）Dep</strong></p><p>Dep是整个依赖收集的核心，其关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-keyword">static</span> target;<br>  subs;<br><br>  <span class="hljs-title function_">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">addSub</span> (sub) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub)<br>  &#125;<br>  <span class="hljs-title function_">removeSub</span> (sub) &#123;<br>    <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sub</span>, sub)<br>  &#125;<br>  <span class="hljs-title function_">depend</span> () &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)&#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span> () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subds</span>.<span class="hljs-title function_">slice</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; subs.<span class="hljs-property">length</span>; i++)&#123;<br>      subs[i].<span class="hljs-title function_">update</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p><p><strong>（2）Watcher</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  getter;<br>  ...<br>  <span class="hljs-title function_">constructor</span> (<span class="hljs-params">vm, expression</span>)&#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expression;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span> () &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>);<br>    value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>    ...<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  <span class="hljs-title function_">addDep</span> (dep)&#123;<br>        ...<br>    dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  ...<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span> (<span class="hljs-params">_target</span>) &#123;<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = _target<br>&#125;<br></code></pre></td></tr></table></figure><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p><p><strong>（3）过程</strong></p><p>在实例化 Vue 时，依赖收集的相关过程如下∶</p><p>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。</p><p>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">updateComponent = <span class="hljs-function">() =&gt;</span> &#123;<br>  vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>())<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent)<br></code></pre></td></tr></table></figure><p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p><p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p><h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p><p><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React ==&gt; Create React APP</li><li>Vue ==&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React ==&gt; React Native</li><li>Vue ==&gt; Weex</li></ul><h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li></ul><h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;OBKoro1&quot;</span>); <span class="hljs-comment">// 改变数组</span><br><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;OBKoro1&quot;</span>); <span class="hljs-comment">// 改变对象</span><br></code></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">splice</span>()、 <span class="hljs-title function_">push</span>()、<span class="hljs-title function_">pop</span>()、<span class="hljs-title function_">shift</span>()、<span class="hljs-title function_">unshift</span>()、<span class="hljs-title function_">sort</span>()、<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul><h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p><p>SSR的优势：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>SSR的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[v-cloak] &#123;<br>    <span class="hljs-attr">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建组件构造器</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span><br>&#125;)<br><span class="hljs-comment">// 挂载到 #app 上</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>().$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-comment">// 除了上面的方式，还可以用来扩展已有的组件</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">SuperComponent</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(<span class="hljs-title class_">Component</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperComponent</span>(&#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperComponent</span>().$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. <strong>MVVM</strong>的优缺点<strong>?</strong></h3><p>优点: </p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 </li><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 </li><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放 </li></ul><p>缺点: </p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 </li><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 </li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li></ul><h3 id="43-v-if-和-v-for哪个优先级更高？如果同时出现，应如何优化？"><a href="#43-v-if-和-v-for哪个优先级更高？如果同时出现，应如何优化？" class="headerlink" title="43. v-if**和**v-for哪个优先级更高？如果同时出现，应如何优化？"></a>43. <strong>v-if**</strong>和<strong>**v-for哪个优先级更高？如果同时出现，应如何优化？</strong></h3><p>v-for优先于v-if被解析，如果同时出现，每次渲染都会<strong>先执行循环再判断条件</strong>，无论如何循环都不可避免，浪费了性能。</p><p>要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。</p><h3 id="44-对Vue组件化的理解"><a href="#44-对Vue组件化的理解" class="headerlink" title="44. 对Vue组件化的理解"></a>44. 对Vue组件化的理解</h3><ol><li>组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；</li><li>组件化开发能大幅提高应用开发效率、测试性、复用性等；</li><li>组件使用按分类有：页面组件、业务组件、通用组件；</li><li>vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue；</li><li>vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能；</li><li>组件应该是高内聚、低耦合的；</li><li>遵循单向数据流的原则。</li></ol><h3 id="45-对vue设计原则的理解"><a href="#45-对vue设计原则的理解" class="headerlink" title="45. 对vue设计原则的理解"></a>45. 对vue设计原则的理解</h3><ol><li><strong>渐进式JavaScript框架</strong>：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。</li><li><strong>易用性</strong>：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。</li><li><strong>灵活性</strong>：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。</li><li><strong>高效性：</strong>超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。</li></ol><h3 id="46-常见的Vue性能优化方法"><a href="#46-常见的Vue性能优化方法" class="headerlink" title="46. 常见的Vue性能优化方法"></a>46. 常见的Vue性能优化方法</h3><ol><li>路由懒加载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">const router = new VueRouter(&#123; routes: [<br>  &#123; path: &#x27;/foo&#x27;, component: () =&gt; import(&#x27;./Foo.vue&#x27;) &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li>keep-alive缓存页面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;keep-alive&gt;<br>      &lt;router-view/&gt;<br>    &lt;/keep-alive&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ol><li>使用v-show复用DOM</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;cell&quot;&gt;<br>     &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt;<br>     &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt;<br>        &lt;Heavy :n=&quot;10000&quot;/&gt;<br>     &lt;/div&gt;<br>     &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt;<br>        &lt;Heavy :n=&quot;10000&quot;/&gt;<br>     &lt;/section&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ol><li>v-for 遍历避免同时使用 v-if</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ul&gt;<br>&lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt;<br>&#123;&#123; user.name &#125;&#125;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123; <br>  computed: &#123;<br>activeUsers: function () &#123;<br>return this.users.filter(function (user) &#123; <br>        return user.isActive<br>      &#125;)<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li>长列表性能优化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化<br>export default &#123; <br>data: () =&gt; (&#123;<br>users: []<br>&#125;),<br>async created() &#123;<br>const users = await axios.get(&quot;/api/users&quot;); <br>this.users = Object.freeze(users);<br>&#125;<br>&#125;;<br><br>// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容<br>&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt;<br>&lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;<br> &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot;/&gt;<br>  &lt;/template&gt;<br>&lt;/recycle-scroller&gt;<br></code></pre></td></tr></table></figure><ol><li>事件的销毁</li></ol><p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">created() &#123;<br>this.timer = setInterval(this.refresh, 2000)<br>&#125;,<br>beforeDestroy() &#123; <br>clearInterval(this.timer)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>图片懒加载</li></ol><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;<br></code></pre></td></tr></table></figure><ol><li>第三方插件按需引入</li></ol><p>像element-ui这样的第三方组件库可以按需引入避免体积太大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Vue from &#x27;vue&#x27;;<br>import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;<br><br><br>Vue.use(Button) Vue.use(Select)<br></code></pre></td></tr></table></figure><ol><li>无状态的组件标记为函数式组件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template functional&gt;<br>&lt;div class=&quot;cell&quot;&gt;<br>&lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;<br>&lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script&gt;<br>export default &#123; props: [&#x27;value&#x27;] &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li>子组件分隔</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;ChildComp/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123; <br>    components: &#123;<br>ChildComp: &#123; <br>        methods: &#123;<br>heavy () &#123; /* 耗时任务 */ &#125;<br>&#125;,<br>render (h) &#123;<br>return h(&#x27;div&#x27;, this.heavy())<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li>变量本地化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt;<br>&#123;&#123; result &#125;&#125;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; heavy &#125; from &#x27;@/utils&#x27;<br><br>export default &#123; <br>  props: [&#x27;start&#x27;], <br>  computed: &#123;<br>base () &#123; <br>      return 42 <br>    &#125;, <br>    result () &#123;<br>const base = this.base // 不要频繁引用this.base<br>let result = this.start<br>for (let i = 0; i &lt; 1000; i++) &#123; <br>        result += heavy(base)<br>&#125;<br>return result<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="47-v-model的实现原理"><a href="#47-v-model的实现原理" class="headerlink" title="47. v-model的实现原理"></a>47. v-model的实现原理</h3><p>vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。</p><p>实现原理：</p><ul><li>v-bind绑定响应数据</li><li>触发input事件并传递数据</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>// 等价于：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;text = $event.target.value&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>// 组件中使用：<br><span class="hljs-tag">&lt;<span class="hljs-name">custom-input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$event&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-input</span>&gt;</span><br>// 根据v-model原理模拟：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ipt1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ipt2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> ipt1=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ipt1&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> ipt2=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ipt2&#x27;</span>);</span><br><span class="language-javascript">    ipt1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;input&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        ipt2.<span class="hljs-property">value</span>=ipt1.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </p><ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li><strong>created**</strong>（创建后）** ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li><li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p><h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><p>1.父组件 beforeCreate</p><p>2.父组件 created</p><p>3.父组件 beforeMount</p><p>4.子组件 beforeCreate</p><p>5.子组件 created</p><p>6.子组件 beforeMount</p><p>7.子组件 mounted</p><p>8.父组件 mounted</p><p><strong>更新过程：</strong></p><ol><li>父组件 beforeUpdate</li></ol><p>2.子组件 beforeUpdate</p><p>3.子组件 updated</p><p>4.父组件 updated</p><p><strong>销毁过程：</strong></p><ol><li>父组件 beforeDestroy</li></ol><p>2.子组件 beforeDestroy</p><p>3.子组件 destroyed</p><p>4.父组件 destoryed</p><h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p><h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  /  $emit"></a>（1） props  /  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">son</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msgData&quot;</span> <span class="hljs-attr">:fn</span>=<span class="hljs-string">&quot;myFunction&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> son <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./son.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: father,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">msgData</span>: <span class="hljs-string">&quot;父组件数据&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;vue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        son</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;son&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;fn&quot;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">com-article</span> <span class="hljs-attr">:articles</span>=<span class="hljs-string">&quot;articleList&quot;</span> @<span class="hljs-attr">onEmitIndex</span>=<span class="hljs-string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-article</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> comArticle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;comArticle&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; comArticle &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">currentIndex</span>: -<span class="hljs-number">1</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">articleList</span>: [<span class="hljs-string">&#x27;红楼梦&#x27;</span>, <span class="hljs-string">&#x27;西游记&#x27;</span>, <span class="hljs-string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onEmitIndex</span>(<span class="hljs-params">idx</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentIndex</span> = idx</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in articles&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;articles&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">emitIndex</span>(<span class="hljs-params">index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;onEmitIndex&#x27;</span>, index) <span class="hljs-comment">// 触发父组件的方法，并传递参数index</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（$emit / $on）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p><p><strong>（1）创建事件中心管理组件之间的通信</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// event-bus.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure><p><strong>（2）发送事件</strong></p><p>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">first-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">first-com</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">second-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">second-com</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> firstCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./firstCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> secondCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./secondCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; firstCom, secondCom &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在<code>firstCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>加法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">EventBus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span> <span class="hljs-comment">// 引入事件中心</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">num</span>:<span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;addition&#x27;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">num</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>（3）接收事件</strong></p><p>在<code>secondCom</code>组件中发送事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;addition&#x27;</span>, <span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> + param.<span class="hljs-property">num</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide/ inject）"></a>（3）依赖注入（provide/ inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;num&#x27;</span>]<br></code></pre></td></tr></table></figure><p>还可以这样写，这样写就可以访问父组件中的所有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-variable language_">this</span><br>  &#125;;<br>&#125;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;app&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">num</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（3）ref-refs"><a href="#（3）ref-refs" class="headerlink" title="（3）ref / $refs"></a>（3）ref / $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JavaScript&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">sayHello</span> () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span> () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// JavaScript</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// hello</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent / $children"></a>（4）$parent / $children</h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">parentVal</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">msg</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在父组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件中</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello_world&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Welcome&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 获取到子组件</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。</p><p><strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs / $listeners"></a>（5）$attrs / $listeners</h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><p>A组件（<code>APP.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">        //此处监听了两个事件，可以在B组件或者C组件中直接触发 </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child1</span> <span class="hljs-attr">:p-child1</span>=<span class="hljs-string">&quot;child1&quot;</span> <span class="hljs-attr">:p-child2</span>=<span class="hljs-string">&quot;child2&quot;</span> @<span class="hljs-attr">test1</span>=<span class="hljs-string">&quot;onTest1&quot;</span> @<span class="hljs-attr">test2</span>=<span class="hljs-string">&quot;onTest2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child1.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child1</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">onTest1</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1 running&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">onTest2</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test2 running&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>B组件（<code>Child1.vue</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child2.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild1&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child2</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test1&#x27;</span>); <span class="hljs-comment">// 触发APP.vue中的test1方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>C 组件 (<code>Child2.vue</code>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-2&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild2&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test2&#x27;</span>);<span class="hljs-comment">// 触发APP.vue中的test2方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在上述代码中：</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul><h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li><li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><p>非懒加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/list.vue&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（1）方案一(常用)：使用箭头函数+import动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/list.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（2）方案二：使用箭头函数+require动态加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>   &#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>     <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;@/components/list&#x27;</span>], resolve)<br>   &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// r就是resolve</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = r =&gt; <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;list&#x27;</span><br>  &#125;<br> ]<br>&#125;))<br></code></pre></td></tr></table></figure><h3 id="2-路由的hash和history模式的区别"><a href="#2-路由的hash和history模式的区别" class="headerlink" title="2. 路由的hash和history模式的区别"></a>2. 路由的hash和history模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p><h4 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h4><p><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="http://www.abc.com/#/vue，它的hash值就是`#/vue`。">http://www.abc.com/#/vue，它的hash值就是`#/vue`。</a></p><p><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">oldURL</span>, event.<span class="hljs-property">newURL</span>);<br><span class="hljs-keyword">let</span> hash = location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p><h4 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h4><p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</p><p><strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。">http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</a></p><p><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p><p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: [...]<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h4><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用。</li><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul><p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p><h3 id="3-如何获取页面的hash变化"><a href="#3-如何获取页面的hash变化" class="headerlink" title="3. 如何获取页面的hash变化"></a>3. 如何获取页面的hash变化</h3><p><strong>（1）监听$route的变化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听,当路由发生变化的时候执行</span><br><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-attr">$route</span>: &#123;<br>    <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val, oldVal</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>    &#125;,<br>    <span class="hljs-comment">// 深度观察监听</span><br>    <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>（2）window.location.hash读取#值</strong></p><p>window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p><h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. $route 和$router 的区别"></a>4. $route 和$router 的区别</h3><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul><h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><p><strong>（1）param方式</strong></p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递的方式：在path后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在APP.vue中</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    <br><br><span class="hljs-comment">//在index.js</span><br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:userid&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>2）路由跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法1：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link<br><br><span class="hljs-comment">// 方法2：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;users&#x27;</span>,<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">uname</span>:wade&#125;&#125;)<br><br><span class="hljs-comment">// 方法3：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user/&#x27;</span> + wade)<br></code></pre></td></tr></table></figure><p>3）参数获取</p><p>通过 <code>$route.params.userid</code> 获取传递的值</p><p><strong>（2）query方式</strong></p><ul><li>配置路由格式：<code>/router</code>，也就是普通配置</li><li>传递的方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：<code>/route?id=123</code></li></ul><p>1）路由定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式1：直接在router-link 标签上以对象的形式</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方式2：写成按钮以点击事件形式</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>    <br><br><span class="hljs-title function_">profileClick</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/profile&quot;</span>,<br>    <span class="hljs-attr">query</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobi&quot;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;28&quot;</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">198</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>2）跳转方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法1：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法2：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法3：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法4：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法5：</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user?uname=&#x27;</span> + jsmes)<br></code></pre></td></tr></table></figure><p>3）获取参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">通过$route.<span class="hljs-property">query</span> 获取传递的值<br></code></pre></td></tr></table></figure><h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p><p>为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><ol><li>全局路由钩子</li></ol><p>全局有三个路由钩子;</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ul><p>具体使用∶</p><ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">let</span> ifInfo = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$common</span>.<span class="hljs-title function_">getSession</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);  <span class="hljs-comment">// 判断是否登录的存储信息</span><br>    <span class="hljs-keyword">if</span> (!ifInfo) &#123; <br>        <span class="hljs-comment">// sessionStorage里没有储存user信息    </span><br>        <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <br>            <span class="hljs-comment">//如果是登录页面路径，就直接next()      </span><br>            <span class="hljs-title function_">next</span>();    <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">//不然就跳转到登录      </span><br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">warning</span>(<span class="hljs-string">&quot;请重新登录！&quot;</span>);     <br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$loginUrl</span>;    <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();  <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <br>    <span class="hljs-comment">// 跳转之后滚动条回到顶部  </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>单个路由独享钩子</li></ol><p><strong>beforeEnter</strong></p><p>如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    <br>    &#123;        <br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,        <br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,        <br>        <span class="hljs-attr">component</span>: login,        <br>        <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;          <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;即将进入登录页面&#x27;</span>)          <br>            <span class="hljs-title function_">next</span>()        <br>        &#125;    <br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ol><li>组件内钩子</li></ol><p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p><p>这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;      <br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> &#123;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/classProcess&#x27;</span>) &#123;          <br>            target.<span class="hljs-property">isFromProcess</span> = <span class="hljs-literal">true</span>        <br>        &#125;      <br>    &#125;)    <br>&#125;<br></code></pre></td></tr></table></figure><p>二、Vue路由钩子在生命周期函数的体现</p><ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫beforeRouteLeave</li><li>调用局前置守卫∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发DOM更新（mounted）。</li><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><ol><li>触发钩子的完整顺序</li></ol><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问/操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。 </li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h3 id="7-Vue-router跳转和location-href有什么区别"><a href="#7-Vue-router跳转和location-href有什么区别" class="headerlink" title="7. Vue-router跳转和location.href有什么区别"></a>7. Vue-router跳转和location.href有什么区别</h3><ul><li>使用 <code>location.href= /url</code>来跳转，简单方便，但是刷新了页面；</li><li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li><li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul><h3 id="8-params和query的区别"><a href="#8-params和query的区别" class="headerlink" title="8. params和query的区别"></a>8. params和query的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p><p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p><h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p><p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p><p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p><ul><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li><li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li></ul><p>为了解决这个问题，前端路由出现了。</p><p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p><p>那么如何实现这个目的呢？首先要解决两个问题：</p><ul><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li><li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ul><p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p><ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul><h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li></ul><p><img src="https://zhengcookie.github.io/file/前端面试题/vue/1609522434579-ff590978-32e1-4cf5-bbbd-d8caf932f8d6.png" alt="img"></p><p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 </p><p><strong>（1）核心流程中的主要功能：</strong></p><ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><p><strong>（2）各模块在核心流程中的主要功能：</strong></p><ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><p><strong>总结：</strong></p><p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。</p><h3 id="2-Vuex中action和mutation的区别"><a href="#2-Vuex中action和mutation的区别" class="headerlink" title="2. Vuex中action和mutation的区别"></a>2. Vuex中action和mutation的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span> (state) &#123;<br>      state.<span class="hljs-property">count</span>++      <span class="hljs-comment">// 变更状态</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><p>而Action类似于mutation，不同点在于：</p><ul><li>Action 可以包含任意异步操作。</li><li>Action 提交的是 mutation，而不是直接变更状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span> (state) &#123;<br>      state.<span class="hljs-property">count</span>++<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">increment</span> (context) &#123;<br>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><p>所以，两者的不同点如下：</p><ul><li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li><li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li><li>在视图更新时，先触发actions，actions再触发mutation</li><li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li></ul><h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><p><strong>（1）最重要的区别</strong></p><ul><li>vuex存储在内存中</li><li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li></ul><p><strong>（2）应用场景</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li><li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li><li>Vuex能做到数据的响应式，localstorage不能</li></ul><p><strong>（3）永久性</strong></p><p>刷新页面时vuex存储的值会丢失，localstorage不会。</p><p><strong>注意：</strong>对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p><h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li><li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li></ul><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p><p><strong>（2）共同思想</strong></p><ul><li>单—的数据源 </li><li>变化可以预测</li></ul><p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;</p><p>形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p><h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p><p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p><p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p><h3 id="6-Vuex有哪几种属性？"><a href="#6-Vuex有哪几种属性？" class="headerlink" title="6. Vuex有哪几种属性？"></a>6. Vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><ul><li>state =&gt; 基本数据(数据源存放地)</li><li>getters =&gt; 从基本数据派生出来的数据</li><li>mutations =&gt; 提交更改数据的方法，同步</li><li>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li><li>modules =&gt; 模块化Vuex</li></ul><h3 id="7-Vuex和单纯的全局对象有什么区别？"><a href="#7-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex和单纯的全局对象有什么区别？"></a>7. Vuex和单纯的全局对象有什么区别？</h3><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li></ul><h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h3 id="9-Vuex的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const store = new Vuex.Store(&#123;<br>    strict:true,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="10-如何在组件中批量使用Vuex的getter属性"><a href="#10-如何在组件中批量使用Vuex的getter属性" class="headerlink" title="10. 如何在组件中批量使用Vuex的getter属性"></a>10. 如何在组件中批量使用Vuex的getter属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapGetters&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">computed</span>:&#123;<br>        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-如何在组件中重复使用Vuex的mutation"><a href="#11-如何在组件中重复使用Vuex的mutation" class="headerlink" title="11. 如何在组件中重复使用Vuex的mutation"></a>11. 如何在组件中重复使用Vuex的mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<br>        <span class="hljs-attr">setNumber</span>:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p><h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0有什么更新"><a href="#1-Vue3-0有什么更新" class="headerlink" title="1. Vue3.0有什么更新"></a>1. Vue3.0有什么更新</h3><p><strong>（1）监测机制的改变</strong></p><ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul><p><strong>（2）只能监测属性，不能监测对象</strong></p><ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p><strong>（3）模板</strong></p><ul><li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul><p><strong>（4）对象式的组件声明方式</strong></p><ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul><p><strong>（5）其它方面的更改</strong></p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h3 id="2-defineProperty和proxy的区别"><a href="#2-defineProperty和proxy的区别" class="headerlink" title="2. defineProperty和proxy的区别"></a>2. defineProperty和proxy的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。</p><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>但是这样做有以下问题：</p><ol><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li><li>无法监控到数组下标和长度的变化。</li></ol><p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p><ol><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li></ol><h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p> Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ </p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li></ul><h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4.  Vue 3.0 中的 Vue Composition API？"></a>4.  Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p><ol><li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li><li>Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li></ol><p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p><p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span></span><br><span class="language-xml">    Count: &#123;&#123; count &#125;&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br> <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// 对应于Vue2中的mounted声明周期</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;component mounted!&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count,</span></span><br><span class="language-javascript"><span class="language-xml">      increment</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p><h3 id="5-Composition-API与React-Hook很像，区别是什么"><a href="#5-Composition-API与React-Hook很像，区别是什么" class="headerlink" title="5. Composition API与React Hook很像，区别是什么"></a>5. Composition API与React Hook很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p><h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p><ul><li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li><li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li><li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li></ul><h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong></p><p>看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM</strong> <strong>-&gt;</strong> <strong>生成 CSSOM</strong> <strong>-&gt;</strong> <strong>Layout</strong> <strong>-&gt;</strong> <strong>Paint</strong> <strong>-&gt;</strong> <strong>Compiler</strong></p><p>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p><ul><li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li><li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li></ul><p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。</p><p><strong>（2）跨平台</strong></p><p>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p><h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul><li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li><li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li></ul><h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li>匹配时，找到相同的子节点，递归比较子节点</li></ul><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="6-Vue中key的作用"><a href="#6-Vue中key的作用" class="headerlink" title="6. Vue中key的作用"></a>6. Vue中key的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p><ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><h3 id="7-为什么不建议用index作为key"><a href="#7-为什么不建议用index作为key" class="headerlink" title="7. 为什么不建议用index作为key?"></a>7. 为什么不建议用index作为key?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表达式和控制结构</title>
    <link href="/2025/07/08/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2025/07/08/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式和控制结构"><a href="#表达式和控制结构" class="headerlink" title="表达式和控制结构"></a>表达式和控制结构<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#id1"></a></h1><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1"></a></h2><p>大多数从大括号语言中知道的控制结构都可以在Solidity中使用：</p><p>有： <code>if</code>， <code>else</code>， <code>while</code>， <code>do</code>， <code>for</code>， <code>break</code>， <code>continue</code>， <code>return</code>， 这些在 C 或者 JavaScript 中表达相同语义的关键词。</p><p>Solidity也支持 <code>try</code> / <code>catch</code> 形式的语句的异常处理， 但只适用于 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#external-function-calls">外部函数调用</a> 和合约创建调用。 可以使用 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert-statement">恢复状态</a> 来创建错误。</p><p>条件句 <em>不能</em> 省略括号，但单句体周围可以省略大括号。</p><p>请注意，没有像C和JavaScript那样从非布尔类型到布尔类型的类型转换， 所以 <code>if (1) &#123; ... &#125;</code> 在Solidity <em>不是</em> 有效的。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#function-calls"></a></h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#internal-function-calls"></a></h3><p>当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCi8vIOi/meS8muacieS4gOS4quitpuWRigpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGcodWludCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHJldCkgeyByZXR1cm4gYSArIGYoKTsgfQogICAgZnVuY3Rpb24gZigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCByZXQpIHsgcmV0dXJuIGcoNykgKyBmKCk7IH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这会有一个警告</span><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> g(<span class="hljs-built_in">uint</span> a) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> ret) &#123; <span class="hljs-keyword">return</span> a + f(); &#125;<br>    <span class="hljs-built_in">function</span> f() internal <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span> ret) &#123; <span class="hljs-keyword">return</span> g(<span class="hljs-number">7</span>) + f(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些函数调用在EVM内部被转化为简单的跳转。 这样做的效果是，当前的内存不会被清空，也就是说， 将内存引用传递给内部调用的函数是非常有效的。 但只有同一合约实例的函数可以被内部调用。</p><p>您还是应该避免过度的递归调用，因为每个内部函数的调用都会占用至少一个堆栈槽，而可用的堆栈槽只有1024个。</p><h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#external-function-calls"></a></h3><p>函数也可以使用 <code>this.g(8);</code> 和 <code>c.g(2);</code> 符号来调用， 其中 <code>c</code> 是一个合约实例， <code>g</code> 是属于 <code>c</code> 的函数。 通过这两种方式调用函数 <code>g</code> 会导致它被 “外部” 调用， 使用消息调用而不是直接通过跳转。 请注意，对 <code>this</code> 的函数调用不能在构造函数中使用，因为实际的合约还没有被创建。</p><p>其他合约的函数必须被外部调用。对于一个外部调用， 所有的函数参数都必须被拷贝到内存中。</p><p>备注</p><p>从一个合约到另一个合约的函数调用并不创建自己的交易，它是作为整个交易的一部分的消息调用。</p><p>当调用其他合约的函数时，您可以用特殊的选项 <code>&#123;value: 10, gas: 10000&#125;</code> 指定随调用发送的wei或燃料（gas）数量。 请注意，不鼓励明确指定燃料值，因为操作码的燃料成本可能在未来发生变化。 您发送给合约的任何Wei都会被添加到该合约的总余额中：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgSW5mb0ZlZWQgewogICAgZnVuY3Rpb24gaW5mbygpIHB1YmxpYyBwYXlhYmxlIHJldHVybnMgKHVpbnQgcmV0KSB7IHJldHVybiA0MjsgfQp9Cgpjb250cmFjdCBDb25zdW1lciB7CiAgICBJbmZvRmVlZCBmZWVkOwogICAgZnVuY3Rpb24gc2V0RmVlZChJbmZvRmVlZCBhZGRyKSBwdWJsaWMgeyBmZWVkID0gYWRkcjsgfQogICAgZnVuY3Rpb24gY2FsbEZlZWQoKSBwdWJsaWMgeyBmZWVkLmluZm97dmFsdWU6IDEwLCBnYXM6IDgwMH0oKTsgfQp9">open in Remix</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ada">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span>.<span class="hljs-number">2</span> &lt;<span class="hljs-number">0.9</span>.<span class="hljs-number">0</span>;<br><br>contract InfoFeed &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">info</span>() public payable returns (uint ret) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">42</span>; &#125;<br>&#125;<br><br>contract Consumer &#123;<br>    InfoFeed feed;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">setFeed</span>(InfoFeed addr) public &#123; feed = addr; &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">callFeed</span>() public &#123; feed.info&#123;value: 10, gas: 800&#125;(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您需要对 <code>info</code> 函数使用修饰符 <code>payable</code>， 因为不这样的话， <code>value</code> 选项则不可用。</p><p>警告</p><p>注意 <code>feed.info&#123;value: 10, gas: 800&#125;</code> 只在本地设置 <code>value</code> 和随函数调用发送的 <code>gas</code> 数量， 最后的括号执行实际调用。所以 <code>feed.info&#123;value: 10, gas: 800&#125;</code> 不会调用函数， <code>value</code> 和 <code>gas</code> 的设置也会丢失， 只有 <code>feed.info&#123;value: 10, gas: 800&#125;()</code> 执行了函数调用。</p><p>由于EVM认为对一个不存在的合约的调用总是成功的， Solidity使用 <code>extcodesize</code> 操作码来检查即将被调用的合约是否真的存在（它包含代码）， 如果不存在就会引起异常。如果返回数据将在调用后被解码， 则跳过该检查，因此ABI解码器将捕获不存在的合约的情况。</p><p>请注意，这个检查在 <a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#address-related">低级调用</a> 的情况下不执行， 这些调用是对地址而不是合约实例进行操作。</p><p>备注</p><p>在对 <a href="https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#precompiledcontracts">预编译合约</a> 使用高级调用时要小心， 因为根据上述逻辑，编译器认为它们不存在，即使它们执行代码并可以返回数据。</p><p>如果被调用的合约本身抛出异常或超出了燃料值，函数调用也会引起异常。</p><p>警告</p><p>与另一个合约的任何互动都会带来潜在的危险， 特别是当合约的源代码事先不知道的时候。 当前的合约将控制权交给了被调用的合约，而这有可能做任何事情。 即使被调用的合约继承自一个已知的父合约， 继承的合约也只需要有一个正确的接口。 然而，合约的实现完全可以是任意的，因此这会带来危险。 此外，要做好准备，以防它调用到您系统中的其他合约， 甚至在第一次调用返回之前就回到调用合约中。 这意味着被调用的合约可以通过这个函数改变调用合约的状态变量。 编写您的函数时，例如，对外部函数的调用发生在对您的合约中的状态变量的任何改变之后， 这样您的合约就不会受到重入性漏洞的攻击。</p><p>备注</p><p>在 Solidity 0.6.2 之前，指定以太值和燃料值的推荐方法是 使用 <code>f.value(x).gas(g)()</code>。这在Solidity 0.6.2中被废弃， 并且从Solidity 0.7.0开始不再支持。</p><h3 id="带命名参数的函数调用"><a href="#带命名参数的函数调用" class="headerlink" title="带命名参数的函数调用"></a>带命名参数的函数调用<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#id6"></a></h3><p>函数调用参数可以用名字来表示，如果用 <code>&#123; &#125;</code> 括起来的话， 可以用任何顺序，如下面的例子所示。 参数列表在名称上必须与函数声明中的参数列表相一致，但可以有任意的顺序。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBtYXBwaW5nKHVpbnQgPT4gdWludCkgZGF0YTsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBzZXQoe3ZhbHVlOiAyLCBrZXk6IDN9KTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCBrZXksIHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    mapping(<span class="hljs-built_in">uint</span> =&gt; <span class="hljs-built_in">uint</span>) data;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">set</span>(&#123;<span class="hljs-keyword">value</span>: <span class="hljs-number">2</span>, key: <span class="hljs-number">3</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">set</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> key, <span class="hljs-built_in">uint</span> <span class="hljs-keyword">value</span></span>) <span class="hljs-keyword">public</span></span> &#123;<br>        data[key] = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数定义中省略的名称"><a href="#函数定义中省略的名称" class="headerlink" title="函数定义中省略的名称"></a>函数定义中省略的名称<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#id7"></a></h3><p>函数声明中的参数和返回值的名称可以省略。 那些名字被省略的参数仍然会出现在堆栈中，但是无法通过名字访问。 省略的返回值名称仍然可以通过使用 <code>return</code> 语句向调用者返回一个值。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8g55yB55Wl5Y+C5pWw5ZCN56ewCiAgICBmdW5jdGlvbiBmdW5jKHVpbnQgaywgdWludCkgcHVibGljIHB1cmUgcmV0dXJucyh1aW50KSB7CiAgICAgICAgcmV0dXJuIGs7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-comment">// 省略参数名称</span><br>    <span class="hljs-built_in">function</span> func(<span class="hljs-built_in">uint</span> k, <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns(<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过-new-创建合约"><a href="#通过-new-创建合约" class="headerlink" title="通过 new 创建合约"></a>通过 <code>new</code> 创建合约<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#new"></a></h2><p>一个合约可以使用 <code>new</code> 关键字创建其他合约。 待创建合约的完整代码必须在创建的合约被编译时知道， 所以递归的创建依赖是不可能的。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHBheWFibGUgewogICAgICAgIHggPSBhOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIEQgZCA9IG5ldyBEKDQpOyAvLyDlsIbkvZzkuLrlkIjnuqYgQyDmnoTpgKDlh73mlbDnmoTkuIDpg6jliIbmiafooYwKCiAgICBmdW5jdGlvbiBjcmVhdGVEKHVpbnQgYXJnKSBwdWJsaWMgewogICAgICAgIEQgbmV3RCA9IG5ldyBEKGFyZyk7CiAgICAgICAgbmV3RC54KCk7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlQW5kRW5kb3dEKHVpbnQgYXJnLCB1aW50IGFtb3VudCkgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIOmaj+WQiOe6pueahOWIm+W7uuWPkemAgSBldGhlcgogICAgICAgIEQgbmV3RCA9IG5ldyBEe3ZhbHVlOiBhbW91bnR9KGFyZyk7CiAgICAgICAgbmV3RC54KCk7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br>contract D &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> x;<br>    constructor(<span class="hljs-built_in">uint</span> a) payable &#123;<br>        x = a;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    D d = <span class="hljs-keyword">new</span> D(<span class="hljs-number">4</span>); <span class="hljs-comment">// 将作为合约 C 构造函数的一部分执行</span><br><br>    <span class="hljs-built_in">function</span> createD(<span class="hljs-built_in">uint</span> arg) <span class="hljs-keyword">public</span> &#123;<br>        D newD = <span class="hljs-keyword">new</span> D(arg);<br>        newD.x();<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> createAndEndowD(<span class="hljs-built_in">uint</span> arg, <span class="hljs-built_in">uint</span> amount) <span class="hljs-keyword">public</span> payable &#123;<br>        <span class="hljs-comment">// 随合约的创建发送 ether</span><br>        D newD = <span class="hljs-keyword">new</span> D&#123;value: amount&#125;(arg);<br>        newD.x();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如在例子中所看到的，在使用 <code>value</code> 选项创建 <code>D</code> 的实例时， 可以发送以太，但不可能限制燃料的数量。 如果创建失败（由于堆栈耗尽，没有足够的余额或其他问题），会抛出一个异常。</p><h3 id="加盐合约创建-create2"><a href="#加盐合约创建-create2" class="headerlink" title="加盐合约创建 / create2"></a>加盐合约创建 / create2<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#create2"></a></h3><p>当创建一个合约时，合约的地址是由创建合约的地址和一个计数器计算出来的， 这个计数器在每次创建合约时都会增加。</p><p>如果您指定了选项 <code>salt</code> （一个32字节的值）， 那么合约的创建将使用一种不同的机制来得出新合约的地址。</p><p>它将从创建合约的地址、给定的盐值、创建合约的（创建）字节码和构造函数参数中计算出地址。</p><p>特别的是，计数器（“nonce”）没有被使用。这使得创建合约时有更多的灵活性。 您能够在新合约创建之前得出它的地址。此外，在创建合约的同时创建其他合约的情况下， 您也可以依赖这个地址。</p><p>这里的主要用例是做为链外互动的评判的合约， 只有在有争议的时候才需要创建。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHsKICAgICAgICB4ID0gYTsKICAgIH0KfQoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBjcmVhdGVEU2FsdGVkKGJ5dGVzMzIgc2FsdCwgdWludCBhcmcpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z5Liq5aSN5p2C55qE6KGo6L6+5byP5Y+q5piv5ZGK6K+J5oKo5aaC5L2V6aKE5YWI6K6h566X5Ye65Zyw5Z2A44CCCiAgICAgICAgLy8g5a6D5Y+q5piv55So5LqO6K+05piO6Zeu6aKY44CCCiAgICAgICAgLy8g5a6e6ZmF5LiK5oKo5Y+q6ZyA6KaBIGBgbmV3IER7c2FsdDogc2FsdH0oYXJnKWBg44CCCiAgICAgICAgYWRkcmVzcyBwcmVkaWN0ZWRBZGRyZXNzID0gYWRkcmVzcyh1aW50MTYwKHVpbnQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoCiAgICAgICAgICAgIGJ5dGVzMSgweGZmKSwKICAgICAgICAgICAgYWRkcmVzcyh0aGlzKSwKICAgICAgICAgICAgc2FsdCwKICAgICAgICAgICAga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoCiAgICAgICAgICAgICAgICB0eXBlKEQpLmNyZWF0aW9uQ29kZSwKICAgICAgICAgICAgICAgIGFiaS5lbmNvZGUoYXJnKQogICAgICAgICAgICApKQogICAgICAgICkpKSkpOwoKICAgICAgICBEIGQgPSBuZXcgRHtzYWx0OiBzYWx0fShhcmcpOwogICAgICAgIHJlcXVpcmUoYWRkcmVzcyhkKSA9PSBwcmVkaWN0ZWRBZGRyZXNzKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br>contract D &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> x;<br>    constructor(<span class="hljs-built_in">uint</span> a) &#123;<br>        x = a;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> createDSalted(bytes32 salt, <span class="hljs-built_in">uint</span> arg) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 这个复杂的表达式只是告诉您如何预先计算出地址。</span><br>        <span class="hljs-comment">// 它只是用于说明问题。</span><br>        <span class="hljs-comment">// 实际上您只需要 ``new D&#123;salt: salt&#125;(arg)``。</span><br>        address predictedAddress = address(uint160(<span class="hljs-built_in">uint</span>(keccak256(abi.encodePacked(<br>            bytes1(<span class="hljs-number">0</span>xff),<br>            address(<span class="hljs-keyword">this</span>),<br>            salt,<br>            keccak256(abi.encodePacked(<br>                type(D).creationCode,<br>                abi.encode(arg)<br>            ))<br>        )))));<br><br>        D d = <span class="hljs-keyword">new</span> D&#123;salt: salt&#125;(arg);<br>        require(address(d) == predictedAddress);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>警告</p><p>在用加盐方式创建合约时，有一些特殊性。一个合约可以在被销毁后在同一地址重新创建。 然而，新创建的合约有可能具有不同的部署字节码， 即使创建字节码是相同的（这是一个要求，否则地址会改变）。 这是由于构造函数可以查询在两次创建之间可能发生变化的外部状态， 并在存储之前将其纳入部署字节码。</p><h2 id="表达式计算顺序"><a href="#表达式计算顺序" class="headerlink" title="表达式计算顺序"></a>表达式计算顺序<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#id8"></a></h2><p>表达式的计算顺序不是特定的（更准确地说， 表达式树中某节点的子节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。 该规则只能保证语句按顺序执行，并对布尔表达式进行短路处理。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-4"></a></h2><h3 id="解构赋值和返回多个值"><a href="#解构赋值和返回多个值" class="headerlink" title="解构赋值和返回多个值"></a>解构赋值和返回多个值<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-5"></a></h3><p>Solidity 内部允许元组 (tuple) 类型，也就是一个在编译时元素数量固定的对象列表， 列表中的元素可以是不同类型的对象。这些元组可以用来同时返回多个数值， 也可以用它们来同时赋值给多个新声明的变量或者既存的变量（或通常的 LValues）：</p><p>在Solidity中，元组不是适当的类型，它们只能被用来构建表达式的语法分组。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGluZGV4OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50LCBib29sLCB1aW50KSB7CiAgICAgICAgcmV0dXJuICg3LCB0cnVlLCAyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyDnlKjnsbvlnovlo7DmmI7nmoTlj5jph4/vvIzlubbku47ov5Tlm57nmoTlhYPnu4TkuK3liIbphY3vvIwKICAgICAgICAvLyDkuI3mmK/miYDmnInnmoTlhYPntKDpg73lv4XpobvooqvmjIflrprvvIjkvYbmlbDph4/lv4XpobvljLnphY3vvInjgIIKICAgICAgICAodWludCB4LCAsIHVpbnQgeSkgPSBmKCk7CiAgICAgICAgLy8g5Lqk5o2i5pWw5YC855qE5bi46KeB5oqA5benIC0tIOWvuemdnuaVsOWAvOWtmOWCqOexu+Wei+S4jei1t+S9nOeUqOOAggogICAgICAgICh4LCB5KSA9ICh5LCB4KTsKICAgICAgICAvLyDlhYPntKDlj6/ku6XkuI3kvb/nlKjvvIjkuZ/pgILnlKjkuo7lj5jph4/lo7DmmI7vvInjgIIKICAgICAgICAoaW5kZXgsICwgKSA9IGYoKTsgLy8g5bCGaW5kZXjorr7nva7kuLogNwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> index;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>, <span class="hljs-built_in">bool</span>, <span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">7</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// 用类型声明的变量，并从返回的元组中分配，</span><br>        <span class="hljs-comment">// 不是所有的元素都必须被指定（但数量必须匹配）。</span><br>        (<span class="hljs-built_in">uint</span> x, , <span class="hljs-built_in">uint</span> y) = f();<br>        <span class="hljs-comment">// 交换数值的常见技巧 -- 对非数值存储类型不起作用。</span><br>        (x, y) = (y, x);<br>        <span class="hljs-comment">// 元素可以不使用（也适用于变量声明）。</span><br>        (index, , ) = f(); <span class="hljs-comment">// 将index设置为 7</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不可能混合使用声明和非声明变量赋值。 例如，下面的方法是无效的。 <code>(x, uint y) = (1, 2);</code>。</p><p>备注</p><p>在0.5.0版本之前，给具有更少元素数的元组赋值都是可能的， 要么在左边填充，要么在右边填充（无论哪个是空的）。 现在这是不允许的，所以两边必须有相同数量的元素。</p><p>警告</p><p>当涉及到引用类型时，在同时向多个变量赋值时要小心，因为这可能导致意外的复制行为。</p><h3 id="数组和结构体的复杂情况"><a href="#数组和结构体的复杂情况" class="headerlink" title="数组和结构体的复杂情况"></a>数组和结构体的复杂情况<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#id11"></a></h3><p>对于像数组和结构体这样的非值类型，包括 <code>bytes</code> 和 <code>string</code>，赋值的语义更为复杂， 详见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location-assignment">数据位置和赋值行为</a>。</p><p>在下面的例子中，调用 <code>g(x)</code> 对 <code>x</code> 没有影响， 因为它在内存中创建了一个独立的存储值的副本。然而， <code>h(x)</code> 成功地修改了 <code>x</code>， 因为传递了一个引用而不是一个拷贝。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludFsyMF0geDsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBnKHgpOwogICAgICAgIGgoeCk7CiAgICB9CgogICAgZnVuY3Rpb24gZyh1aW50WzIwXSBtZW1vcnkgeSkgaW50ZXJuYWwgcHVyZSB7CiAgICAgICAgeVsyXSA9IDM7CiAgICB9CgogICAgZnVuY3Rpb24gaCh1aW50WzIwXSBzdG9yYWdlIHkpIGludGVybmFsIHsKICAgICAgICB5WzNdID0gNDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span>[<span class="hljs-number">20</span>] x;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        g(x);<br>        h(x);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">g</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span>[<span class="hljs-number">20</span>] memory y</span>) <span class="hljs-keyword">internal</span> pure</span> &#123;<br>        y[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">h</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span>[<span class="hljs-number">20</span>] storage y</span>) <span class="hljs-keyword">internal</span></span> &#123;<br>        y[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value"></a></h2><p>一个被声明的变量将有一个初始默认值，其字节表示为所有的零。 变量的 “默认值” 是任何类型的典型 “零状态”。 例如， <code>bool</code> 的默认值是 <code>false</code>。 <code>uint</code> 或 <code>int</code> 类型的默认值是 <code>0</code>。 对于静态大小的数组和 <code>bytes1</code> 到 <code>bytes32</code>， 每个单独的元素将被初始化为与其类型相应的默认值。 对于动态大小的数组， <code>bytes</code> 和 <code>string</code>，默认值是一个空数组或字符串。 对于 <code>enum</code> 类型，默认值是其第一个成员。</p><p>Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）： 变量将会从它们被声明之后可见，直到一对 <code>&#123; &#125;</code> 块的结束。 这一规则有个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。</p><p>类似于参数的变量（函数参数、修改器参数、捕获（catch）参数……） 在后面的代码块中是可见的–对于函数和修改器参数，在函数/修改器的主体中， 对于捕获参数，在捕获块中。</p><p>在代码块之外声明的变量，例如函数、合约、用户定义的类型等， 甚至在声明之前就已经可见。 这意味着您可以在声明之前使用状态变量，并递归地调用函数。</p><p>因此，下面的例子在编译时不会出现警告，因为这两个变量的名字虽然相同，但作用域不同。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG1pbmltYWxTY29waW5nKCkgcHVyZSBwdWJsaWMgewogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMTsKICAgICAgICB9CgogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMzsKICAgICAgICB9CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br>contract C &#123;<br>    <span class="hljs-built_in">function</span> minimalScoping() <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> &#123;<br>        &#123;<br>            <span class="hljs-built_in">uint</span> same;<br>            same = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        &#123;<br>            <span class="hljs-built_in">uint</span> same;<br>            same = <span class="hljs-number">3</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作为 C99 作用域规则的特例，请注意在下边的例子里， 第一次对 <code>x</code> 的赋值实际上将赋给外层变量而不是内层变量。 在任何情况下，您都会得到一个关于外部变量被影射（译者注：就是说被在内部作用域中由一个同名变量所替代）的警告。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrorablkYrkv6Hmga8KY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgeCA9IDE7CiAgICAgICAgewogICAgICAgICAgICB4ID0gMjsgLy8gdGhpcyB3aWxsIGFzc2lnbiB0byB0aGUgb3V0ZXIgdmFyaWFibGUKICAgICAgICAgICAgdWludCB4OwogICAgICAgIH0KICAgICAgICByZXR1cm4geDsgLy8geCBoYXMgdmFsdWUgMgogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将报告一个警告信息</span><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-built_in">uint</span> x = <span class="hljs-number">1</span>;<br>        &#123;<br>            x = <span class="hljs-number">2</span>; <span class="hljs-comment">// this will assign to the outer variable</span><br>            <span class="hljs-built_in">uint</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// x has value 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>警告</p><p>在0.5.0版本之前，Solidity遵循与JavaScript相同的作用域规则， 也就是说，在一个函数中的任何地方声明的变量都会在整个函数的作用域中，不管它是在哪里声明。 下面的例子显示了一个曾经可以编译的代码片段，但从0.5.0版本开始导致了一个错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyDov5nlsIbml6Dms5XnvJbor5EKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHggPSAyOwogICAgICAgIHVpbnQgeDsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><span class="hljs-comment">// 这将无法编译</span><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        x = <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">uint</span> x;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="检查或不检查的算术"><a href="#检查或不检查的算术" class="headerlink" title="检查或不检查的算术"></a>检查或不检查的算术<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#unchecked"></a></h2><p>上溢或下溢是指算术运算的结果值，当对一个不受限制的整数执行时，超出了结果类型的范围。</p><p>在Solidity 0.8.0之前，算术运算总是在下溢或上溢的情况下被包起来， 这导致广泛使用引入额外检查的库。</p><p>从Solidity 0.8.0开始，在默认情况下所有的算术运算都会在上溢和下溢时还原， 从而使这些库的使用变得没有必要。</p><p>为了获得以前的行为，可以使用一个 <code>unchecked</code> 区块：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgLy8g6L+Z5Liq5YeP5rOV5bCG5Zyo5LiL5rqi5pe26KKr5YyF6LW35p2l44CCCiAgICAgICAgdW5jaGVja2VkIHsgcmV0dXJuIGEgLSBiOyB9CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnQgYSwgdWludCBiKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgLy8g6L+Z5Liq5YeP5rOV5Zyo5LiL5rqi5pe25bCG6KKr6L+Y5Y6f44CCCiAgICAgICAgcmV0dXJuIGEgLSBiOwogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-comment">// 这个减法将在下溢时被包起来。</span><br>        unchecked &#123; <span class="hljs-keyword">return</span> a - b; &#125;<br>    &#125;<br>    <span class="hljs-built_in">function</span> g(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-comment">// 这个减法在下溢时将被还原。</span><br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>f(2, 3)</code> 将返回 <code>2**256-1</code>，而 <code>g(2, 3)</code> 将导致一个失败的断言。</p><p><code>unchecked</code> 代码块可以在代码块内的任何地方使用，但不能替代代码块。 它也不能被嵌套。</p><p>该设置只影响到在语法上位于代码块内的语句。 从 <code>unchecked</code> 代码块内调用的函数不继承该属性。</p><p>备注</p><p>为了避免歧义，您不能在一个 <code>unchecked</code> 代码块内使用 <code>_;</code>。</p><p>以下运算符在上溢或下溢时将导致一个失败的断言， 如果在一个未检查的代码块内使用，将被包裹而不会出现错误。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">++`， `--`， `+`， 二进制 `-`， 单进制 `-`， `*`， `/`， `%`， `**<br>+=`， `-=`， `*=`， `/=`， `%=<br></code></pre></td></tr></table></figure><p>警告</p><p>不能使用 <code>unchecked</code> 代码块来禁止检查除以0或对0取余数。</p><p>备注</p><p>位操作符不执行上溢或下溢检查。 这在使用位操作符移位（ <code>&lt;&lt;</code> ， <code>&gt;&gt;</code>， <code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>）来代替整数除法和2的幂次方时尤其明显。 例如 <code>type(uint256).max &lt;&lt; 3</code> 不会恢复操作，尽管 <code>type(uint256).max * 8</code> 会恢复操作。</p><p>备注</p><p><code>int x = type(int).min; -x;</code> 中的第二条语句将导致溢出， 因为负数范围可以比正数范围多容纳一个值。</p><p>明确的类型转换将总是截断，并且永远不会导致失败的断言，但从整数到枚举类型的转换除外。</p><h2 id="错误处理：Assert-Require-Revert-和其余异常"><a href="#错误处理：Assert-Require-Revert-和其余异常" class="headerlink" title="错误处理：Assert, Require, Revert 和其余异常"></a>错误处理：Assert, Require, Revert 和其余异常<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-require-revert"></a></h2><p>Solidity 使用状态恢复异常来处理错误。 这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改， 并且还向调用者标记错误。</p><p>当异常发生在子调用中时，它们会自动 “冒泡”（也就是说，异常被重新抛出）， 除非它们被 <code>try/catch</code> 语句捕获。这个规则的例外是 <code>send</code> 和低级函数 <code>call</code>， <code>delegatecall</code> 和 <code>staticcall</code>： 它们在发生异常时返回 <code>false</code> 作为第一个返回值而不是 “冒泡”。</p><p>警告</p><p>如果被调用的账户不存在，低级函数 <code>call</code>， <code>delegatecall</code> 和 <code>staticcall</code> 的第一个返回值为 <code>true</code>，这是EVM设计的一部分。 如果需要的话，必须在调用之前检查账户是否存在。</p><p>异常可以包含错误数据，以 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors">错误实例</a> 的形式传回给调用者。 内置的错误 <code>Error(string)</code> 和 <code>Panic(uint256)</code> 被特殊函数使用， 解释如下。 <code>Error</code> 用于 “常规” 错误条件，而 <code>Panic</code> 用于在无错误代码中不应该出现的错误。</p><h3 id="通过-assert-引起Panic异常和通过-require-引起Error异常"><a href="#通过-assert-引起Panic异常和通过-require-引起Error异常" class="headerlink" title="通过 assert 引起Panic异常和通过 require 引起Error异常"></a>通过 <code>assert</code> 引起Panic异常和通过 <code>require</code> 引起Error异常<a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-panic-require-error"></a></h3><p>快捷函数 <code>assert</code> 和 <code>require</code> 可以用来检查条件，如果不符合条件就抛出一个异常。</p><p><code>assert</code> 函数创建了一个 <code>Panic(uint256)</code> 类型的错误。 在某些情况下，编译器也会产生同样的错误，如下所述。</p><p>Assert应该只用于测试内部错误，以及检查不变量。 正确运行的代码不应该创建一个Panic异常，甚至在无效的外部输入时也不应该。 如果发生这种情况，那么您的合约中就有一个错误，您应该修复它。 语言分析工具可以评估您的合约，以确定会导致Panic异常的条件和函数调用。</p><p>在下列情况下会产生一个Panic异常。 与错误数据一起提供的错误代码表明Panic异常的种类。</p><ol><li>0x00： 用于一般的编译器插入Panic异常的情况。</li><li>0x01： 如果您带参数调用 <code>assert</code> 时结果是false。</li><li>0x11： 如果一个算术运算在一个 <code>unchecked &#123; ... &#125;</code> 代码块之外导致下溢或上溢。</li><li>0x12： 如果您对0做除法或者取余（例如 <code>5 / 0</code> 或者 <code>23 % 0</code> ）。</li><li>0x21： 如果您把一个太大的或负数的值转换成一个枚举类型。</li><li>0x22： 如果您访问一个编码不正确的存储字节数组。</li><li>0x31： 如果您在一个空数组上调用 <code>.pop()</code>。</li><li>0x32： 如果您访问一个数组， <code>bytesN</code> 或一个数组切片索引超出数组长度或负索引（即 <code>x[i]</code>，其中 <code>i &gt;= x.length</code> 或 <code>i &lt; 0</code> ）。</li><li>0x41： 如果您分配了太多的内存空间或创建了一个太大的数组。</li><li>0x51： 如果您调用一个零初始化的内部函数类型的变量。</li></ol><p><code>require</code> 函数要么创造一个没有任何数据的错误， 要么创造一个 <code>Error(string)</code> 类型的错误。 它应该被用来确保在执行之前无法检测到的有效条件。 这包括对输入的条件或调用外部合约的返回值。</p><p>备注</p><p>目前不能将自定义错误与 <code>require</code> 结合使用。 请使用 <code>if (!condition) revert CustomError();</code> 代替。</p><p>在下列情况下，编译器会产生一个 <code>Error(string)</code> 异常（或者没有数据的异常）。</p><ol><li>调用 <code>require(x)</code>，其中 <code>x</code> 的值为 <code>false</code>。</li><li>如果您使用 <code>revert()</code> 或 <code>revert(&quot;错误描述&quot;)</code>。</li><li>如果您执行一个外部函数调用，目标是一个不包含代码的合约。</li><li>如果您的合约通过一个没有 <code>payable</code> 修饰符的公开函数（包括构造函数和备用函数）接收以太。</li><li>如果您的合约通过一个公共的getter函数接收以太。</li></ol><p>对于以下情况，来自外部调用的错误数据（如果提供的话）会被转发。 这意味着它既可以引起 <code>Error</code> 异常，也可以引起 <code>Panic</code> 异常（或提供的其他什么错误）。</p><ol><li>如果 <code>.transfer()</code> 失败。</li><li>如果您通过消息调用一个函数，但它不能正常完成 （即，耗尽了燃料，没有匹配的函数，或自己抛出一个异常）， 除非使用低级操作 <code>call</code>， <code>send</code>， <code>delegatecall</code>， <code>callcode</code> 或 <code>staticcall</code>。低级操作从不抛出异常，但通过返回 <code>false</code> 表示失败。</li><li>如果您使用 <code>new</code> 关键字创建一个合约， 但合约创建 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts">没有正常完成</a>。</li></ol><p>您可以选择为 <code>require</code> 提供一个信息字符串，但不能为 <code>assert</code> 提供。</p><p>备注</p><p>如果您没有给 <code>require</code> 提供一个字符串参数，它将以空的错误数据进行还原， 甚至不包括错误选择器。</p><p>下面的例子显示了如何使用 <code>require</code> 来检查输入的条件 和 <code>assert</code> 进行内部错误检查。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgU2hhcmVyIHsKICAgIGZ1bmN0aW9uIHNlbmRIYWxmKGFkZHJlc3MgcGF5YWJsZSBhZGRyKSBwdWJsaWMgcGF5YWJsZSByZXR1cm5zICh1aW50IGJhbGFuY2UpIHsKICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSAlIDIgPT0gMCwgIkV2ZW4gdmFsdWUgcmVxdWlyZWQuIik7CiAgICAgICAgdWludCBiYWxhbmNlQmVmb3JlVHJhbnNmZXIgPSBhZGRyZXNzKHRoaXMpLmJhbGFuY2U7CiAgICAgICAgYWRkci50cmFuc2Zlcihtc2cudmFsdWUgLyAyKTsKICAgICAgICAvLyDnlLHkuo7ovazotKblpLHotKXlkI7mipvlh7rlvILluLjlubbkuJTkuI3og73lnKjov5nph4zlm57osIPvvIwKICAgICAgICAvLyDlm6DmraTmiJHku6zlupTor6XmsqHmnInlip7ms5Xku43nhLbmnInkuIDljYrnmoTku6XlpKrlnYrjgIIKICAgICAgICBhc3NlcnQoYWRkcmVzcyh0aGlzKS5iYWxhbmNlID09IGJhbGFuY2VCZWZvcmVUcmFuc2ZlciAtIG1zZy52YWx1ZSAvIDIpOwogICAgICAgIHJldHVybiBhZGRyZXNzKHRoaXMpLmJhbGFuY2U7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Sharer &#123;<br>    <span class="hljs-built_in">function</span> sendHalf(address payable addr) <span class="hljs-keyword">public</span> payable returns (<span class="hljs-built_in">uint</span> balance) &#123;<br>        require(msg.value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Even value required.&quot;</span>);<br>        <span class="hljs-built_in">uint</span> balanceBeforeTransfer = address(<span class="hljs-keyword">this</span>).balance;<br>        addr.transfer(msg.value / <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 由于转账失败后抛出异常并且不能在这里回调，</span><br>        <span class="hljs-comment">// 因此我们应该没有办法仍然有一半的以太坊。</span><br>        <span class="hljs-keyword">assert</span>(address(<span class="hljs-keyword">this</span>).balance == balanceBeforeTransfer - msg.value / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> address(<span class="hljs-keyword">this</span>).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在内部， Solidity 会执行恢复操作（指令 <code>0xfd</code> ）。 这会导致 EVM 恢复对状态所做的所有更改。恢复的原因是不能继续安全地执行， 因为没有实现预期的效果，还因为我们想保留交易的原子性， 所以最安全的做法是恢复所有更改并使整个交易（或至少是调用）不产生效果。</p><p>在这两种情况下，调用者可以使用 <code>try</code>/ <code>catch</code> 对这种失败做出处理， 但被调用者的变化将总是被恢复。</p><p>备注</p><p>在Solidity 0.8.0之前，Panic异常曾使用 <code>invalid</code> 操作码， 它消耗了所有可用于调用的燃料。在Metropolis发布之前， 使用 <code>require</code> 的异常会消耗所有燃料。</p><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a><code>revert</code><a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert"></a></h3><p>可以使用 <code>revert</code> 语句和 <code>revert</code> 函数来触发直接恢复。</p><p><code>revert</code> 语句将一个自定义的错误作为直接参数，没有括号：</p><blockquote><p>revert CustomError(arg1, arg2);</p></blockquote><p>出于向后兼容的原因，还有一个 <code>revert()</code> 函数， 它使用圆括号并接受一个字符串：</p><blockquote><p>revert(); revert(“description”);</p></blockquote><p>错误数据将被传回给调用者，可以在那里捕获。 使用 <code>revert()</code> 会导致没有任何错误数据的还原， 而 <code>revert(&quot;description&quot;)</code> 将创建一个 <code>Error(string)</code> 错误。</p><p>使用一个自定义的错误实例通常会比字符串描述便宜得多， 因为您可以使用错误的名称来描述它，它的编码只有四个字节。 可以通过NatSpec提供更长的描述，这不会产生任何费用。</p><p>下面的例子显示了如何将一个错误字符串和一个自定义的错误实例 与 <code>revert</code> 和相应的 <code>require</code> 一起使用。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFZlbmRpbmdNYWNoaW5lIHsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBlcnJvciBVbmF1dGhvcml6ZWQoKTsKICAgIGZ1bmN0aW9uIGJ1eSh1aW50IGFtb3VudCkgcHVibGljIHBheWFibGUgewogICAgICAgIGlmIChhbW91bnQgPiBtc2cudmFsdWUgLyAyIGV0aGVyKQogICAgICAgICAgICByZXZlcnQoIk5vdCBlbm91Z2ggRXRoZXIgcHJvdmlkZWQuIik7CiAgICAgICAgLy8g5Y+m5LiA56eN5pa55rOV77yaCiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgYW1vdW50IDw9IG1zZy52YWx1ZSAvIDIgZXRoZXIsCiAgICAgICAgICAgICJOb3QgZW5vdWdoIEV0aGVyIHByb3ZpZGVkLiIKICAgICAgICApOwogICAgICAgIC8vIOaJp+ihjOi0reS5sOOAggogICAgfQogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBwdWJsaWMgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKQogICAgICAgICAgICByZXZlcnQgVW5hdXRob3JpemVkKCk7CgogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-selector-class">.4</span>;<br><br>contract VendingMachine &#123;<br>    <span class="hljs-selector-tag">address</span> owner;<br>    error <span class="hljs-built_in">Unauthorized</span>();<br>    function <span class="hljs-built_in">buy</span>(uint amount) public payable &#123;<br>        if (amount &gt; msg.value / <span class="hljs-number">2</span> ether)<br>            <span class="hljs-built_in">revert</span>(&quot;Not enough Ether provided.&quot;);<br>        <span class="hljs-comment">// 另一种方法：</span><br>        <span class="hljs-built_in">require</span>(<br>            amount &lt;= msg.value / <span class="hljs-number">2</span> ether,<br>            &quot;Not enough Ether provided.&quot;<br>        );<br>        <span class="hljs-comment">// 执行购买。</span><br>    &#125;<br>    function <span class="hljs-built_in">withdraw</span>() public &#123;<br>        if (msg.sender != owner)<br>            revert <span class="hljs-built_in">Unauthorized</span>();<br><br>        <span class="hljs-built_in">payable</span>(msg.sender)<span class="hljs-selector-class">.transfer</span>(address(this)<span class="hljs-selector-class">.balance</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>if (!condition) revert(...);</code> 和 <code>require(condition, ...);</code> 这两种方式是等价的， 只要 <code>revert</code> 和 <code>require</code> 的参数没有副作用，比如说它们只是字符串。</p><p>备注</p><p><code>require</code> 函数和其他函数一样。这意味着在执行函数本身之前，所有参数都会被评估。 特别是，在 <code>require(condition, f())</code> 中，即使 <code>condition</code> 为真， 函数 <code>f</code> 也被执行。</p><p>提供的字符串是 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI编码</a> 之后的，就像调用一个函数 <code>Error(string)</code> 一样。 在上面的例子中， <code>revert(&quot;Not enough Ether provided.&quot;);</code> 返回以下十六进制作为错误返回数据：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=MHgwOGMzNzlhMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZykg55qE5Ye95pWw6YCJ5oup5ZmoCjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMCAvLyDmlbDmja7nmoTlgY/np7vph4/vvIgzMu+8iQoweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWEgLy8g5a2X56ym5Liy6ZW/5bqm77yIMjbvvIkKMHg0ZTZmNzQyMDY1NmU2Zjc1Njc2ODIwNDU3NDY4NjU3MjIwNzA3MjZmNzY2OTY0NjU2NDJlMDAwMDAwMDAwMDAwIC8vIOWtl+espuS4suaVsOaNru+8iCJOb3QgZW5vdWdoIEV0aGVyIHByb3ZpZGVkLiIg55qEIEFTQ0lJIOe8luegge+8jDI25a2X6IqC77yJ">open in Remix</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">0</span>x08c379a0                                                         <span class="hljs-regexp">//</span> Error(string) 的函数选择器<br><span class="hljs-number">0</span>x0000000000000000000000000000000000000000000000000000000000000020 <span class="hljs-regexp">//</span> 数据的偏移量（<span class="hljs-number">32</span>）<br><span class="hljs-number">0</span>x000000000000000000000000000000000000000000000000000000000000001a <span class="hljs-regexp">//</span> 字符串长度（<span class="hljs-number">26</span>）<br><span class="hljs-number">0</span>x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 <span class="hljs-regexp">//</span> 字符串数据（<span class="hljs-string">&quot;Not enough Ether provided.&quot;</span> 的 ASCII 编码，<span class="hljs-number">26</span>字节）<br></code></pre></td></tr></table></figure><p>调用者可以使用 <code>try</code> / <code>catch</code> 检索所提供的消息，如下所示。</p><p>备注</p><p>以前有一个叫 <code>throw</code> 的关键字，其语义与 <code>revert()</code> 相同， 在0.4.13版本中被弃用，在0.5.0版本中被删除。</p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try / catch"></a><code>try</code> / <code>catch</code><a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#try-catch"></a></h3><p>外部调用的失败可以用 try/catch 语句来捕获，如下所示：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CgppbnRlcmZhY2UgRGF0YUZlZWQgeyBmdW5jdGlvbiBnZXREYXRhKGFkZHJlc3MgdG9rZW4pIGV4dGVybmFsIHJldHVybnMgKHVpbnQgdmFsdWUpOyB9Cgpjb250cmFjdCBGZWVkQ29uc3VtZXIgewogICAgRGF0YUZlZWQgZmVlZDsKICAgIHVpbnQgZXJyb3JDb3VudDsKICAgIGZ1bmN0aW9uIHJhdGUoYWRkcmVzcyB0b2tlbikgcHVibGljIHJldHVybnMgKHVpbnQgdmFsdWUsIGJvb2wgc3VjY2VzcykgewogICAgICAgIC8vIOWmguaenOaciTEw5Liq5Lul5LiK55qE6ZSZ6K+v77yM5bCx5rC45LmF5YGc55So6K+l5py65Yi244CCCiAgICAgICAgcmVxdWlyZShlcnJvckNvdW50IDwgMTApOwogICAgICAgIHRyeSBmZWVkLmdldERhdGEodG9rZW4pIHJldHVybnMgKHVpbnQgdikgewogICAgICAgICAgICByZXR1cm4gKHYsIHRydWUpOwogICAgICAgIH0gY2F0Y2ggRXJyb3Ioc3RyaW5nIG1lbW9yeSAvKnJlYXNvbiovKSB7CiAgICAgICAgICAgIC8vIOWmguaenOWcqGdldERhdGHkuK3osIPnlKhyZXZlcnTvvIwKICAgICAgICAgICAgLy8g5bm25LiU5o+Q5L6b5LqG5LiA5Liq5Y6f5Zug5a2X56ym5Liy77yMCiAgICAgICAgICAgIC8vIOWImeaJp+ihjOivpeWRveS7pOOAggogICAgICAgICAgICBlcnJvckNvdW50Kys7CiAgICAgICAgICAgIHJldHVybiAoMCwgZmFsc2UpOwogICAgICAgIH0gY2F0Y2ggUGFuaWModWludCAvKmVycm9yQ29kZSovKSB7CiAgICAgICAgICAgIC8vIOWcqOWPkeeUn1Bhbmlj5byC5bi455qE5oOF5Ya15LiL5omn6KGM77yMCiAgICAgICAgICAgIC8vIOWNs+WHuueOsOS4pemHjeeahOmUmeivr++8jOWmgumZpOS7pembtuaIlua6ouWHuuOAggogICAgICAgICAgICAvLyDplJnor6/ku6PnoIHlj6/ku6XnlKjmnaXnoa7lrprplJnor6/nmoTnp43nsbvjgIIKICAgICAgICAgICAgZXJyb3JDb3VudCsrOwogICAgICAgICAgICByZXR1cm4gKDAsIGZhbHNlKTsKICAgICAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgLypsb3dMZXZlbERhdGEqLykgewogICAgICAgICAgICAvLyDlnKjkvb/nlKhyZXZlcnQoKeeahOaDheWGteS4i++8jOS8muaJp+ihjOi/meS4quWRveS7pOOAggogICAgICAgICAgICBlcnJvckNvdW50Kys7CiAgICAgICAgICAgIHJldHVybiAoMCwgZmFsc2UpOwogICAgICAgIH0KICAgIH0KfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataFeed</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span><span class="hljs-params">(address token)</span> <span class="hljs-title">external</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span></span>; &#125;<br><br>contract FeedConsumer &#123;<br>    DataFeed feed;<br>    <span class="hljs-keyword">uint</span> errorCount;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rate</span><span class="hljs-params">(address token)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> value, <span class="hljs-keyword">bool</span> success)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果有10个以上的错误，就永久停用该机制。</span><br>        <span class="hljs-keyword">require</span>(errorCount &lt; <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">try</span> feed.getData(token) returns (<span class="hljs-keyword">uint</span> v) &#123;<br>            <span class="hljs-keyword">return</span> (v, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> Error(<span class="hljs-keyword">string</span> memory <span class="hljs-comment">/*reason*/</span>) &#123;<br>            <span class="hljs-comment">// 如果在getData中调用revert，</span><br>            <span class="hljs-comment">// 并且提供了一个原因字符串，</span><br>            <span class="hljs-comment">// 则执行该命令。</span><br>            errorCount++;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> Panic(<span class="hljs-keyword">uint</span> <span class="hljs-comment">/*errorCode*/</span>) &#123;<br>            <span class="hljs-comment">// 在发生Panic异常的情况下执行，</span><br>            <span class="hljs-comment">// 即出现严重的错误，如除以零或溢出。</span><br>            <span class="hljs-comment">// 错误代码可以用来确定错误的种类。</span><br>            errorCount++;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (bytes memory <span class="hljs-comment">/*lowLevelData*/</span>) &#123;<br>            <span class="hljs-comment">// 在使用revert()的情况下，会执行这个命令。</span><br>            errorCount++;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>try</code> 关键字后面必须有一个表达式，代表外部函数调用或合约建（ <code>new ContractName()</code> ）。 表达式中的错误不会被捕获（例如，如果它是一个复杂的表达式，也涉及到内部函数调用）， 只有外部调用本身发生恢复。 接下来的 <code>returns</code> 部分（是可选的）声明了与外部调用返回的类型相匹配的返回变量。 如果没有错误，这些变量将被分配，合约执行将在第一个成功代码块内继续。 如果到达成功代码块的末端，则在 <code>catch</code> 块之后继续执行。</p><p>Solidity 根据错误的类型，支持不同种类的捕获块：</p><ul><li><code>catch Error(string memory reason) &#123; ... &#125;</code>： 这个catch子句会被执行， 如果错误是由 <code>revert(&quot;reasonString&quot;)</code> 或 <code>require(false, &quot;reasonString&quot;)</code> 造成的 （或内部错误造成的）。</li><li><code>catch Panic(uint errorCode) &#123; ... &#125;</code>： 如果错误是由Panic异常引起的， 例如由失败的 <code>assert</code>、除以0、无效的数组访问、算术溢出和其他原因引起的，这个catch子句将被运行。</li><li><code>catch (bytes memory lowLevelData) &#123; ... &#125;</code>： 如果错误签名与其他子句不匹配， 或者在解码错误信息时出现了错误，或者没有与异常一起提供错误数据， 那么这个子句就会被执行。在这种情况下，声明的变量提供了对低级错误数据的访问。</li><li><code>catch &#123; ... &#125;</code>： 如果您对错误数据不感兴趣，您可以直接使用 <code>catch &#123; ... &#125;</code> （甚至作为唯一的catch子句）来代替前面的子句。</li></ul><p>计划在未来支持其他类型的错误数据。字符串 <code>Error</code> 和 <code>Panic</code> 目前是按原样解析的，不作为标识符处理。</p><p>为了捕捉所有的错误情况，您至少要有 <code>catch &#123; ...&#125;</code> 或 <code>catch (bytes memory lowLevelData) &#123; ... &#125;</code> 子句。</p><p>在 <code>returns</code> 和 <code>catch</code> 子句中声明的变量只在后面的代码块中有作用域。</p><p>备注</p><p>如果在 try/catch 语句内部的返回数据解码过程中发生错误， 这将导致当前执行的合约出现异常，正因为如此，它不会在catch子句中被捕获。 如果在 <code>catch Error(string memory reason)</code> 的解码过程中出现错误， 并且有一个低级的catch子句，那么这个错误就会在那里被捕获。</p><p>备注</p><p>如果执行到一个catch代码块，那么外部调用的状态改变效果已经被恢复。 如果执行到了成功代码块，那么这些影响就没有被还原。 如果影响已经被还原，那么执行要么在catch代码块中继续， 要么try/catch语句的执行本身被还原（例如由于上面提到的解码失败或者由于没有提供低级别的catch子句）。</p><p>备注</p><p>调用失败背后的原因可能是多方面的。不要认为错误信息是直接来自被调用的合约： 错误可能发生在调用链的更深处，被调用的合约只是转发了它。 另外，这可能是由于消耗完燃料值的情况，而不是故意的错误状况。 调用方总是保留调用中至少1/64的燃料值， 因此，即使被调用合约没有燃料了，调用方仍然有一些燃料。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单位与全局变量</title>
    <link href="/2025/07/06/%E5%8D%95%E4%BD%8D%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <url>/2025/07/06/%E5%8D%95%E4%BD%8D%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单位和全局可用变量"><a href="#单位和全局可用变量" class="headerlink" title="单位和全局可用变量"></a>单位和全局可用变量<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-0"></a></h1><h2 id="以太坊（Ether）-单位"><a href="#以太坊（Ether）-单位" class="headerlink" title="以太坊（Ether） 单位"></a>以太坊（Ether） 单位<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#ether"></a></h2><p>一个字面常量可以带一个后缀 <code>wei</code>， <code>gwei</code> 或 <code>ether</code> 来指定一个以太币的数量， 其中没有后缀的以太数字被认为单位是wei。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw==">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">assert(<span class="hljs-number">1</span> wei <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>assert(<span class="hljs-number">1</span> gwei <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>e9)<span class="hljs-comment">;</span><br>assert(<span class="hljs-number">1</span> ether <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>e18)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>单位后缀的唯一作用是乘以10的幂次方。</p><p>备注</p><p>0.7.0 版本中删除了 <code>finney</code> 和 <code>szabo</code> 这两个单位。</p><h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2"></a></h2><p>诸如 <code>seconds</code>， <code>minutes</code>， <code>hours</code>， <code>days</code> 和 <code>weeks</code> 等 后缀在字面常量后面，可以用来指定时间单位，其中秒是基本单位，单位的考虑方式很直白：</p><ul><li><code>1 == 1 seconds</code></li><li><code>1 minutes == 60 seconds</code></li><li><code>1 hours == 60 minutes</code></li><li><code>1 days == 24 hours</code></li><li><code>1 weeks == 7 days</code></li></ul><p>如果您使用这些单位进行日历计算，请注意，由于 <a href="https://en.wikipedia.org/wiki/Leap_second">闰秒</a> 会造成不是每一年都等于365天，甚至不是每一天都有24小时，而且因为闰秒是无法预测的， 所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。</p><p>备注</p><p>由于上述原因，在 0.5.0 版本中删除了后缀 <code>years</code>。</p><p>这些后缀单位不能应用于变量。例如， 如果您想用时间单位（例如 days）来将输入变量换算为时间，您可以用以下方式：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgICAvLyAuLi4KICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> start, <span class="hljs-built_in">uint</span> daysAfter</span>) <span class="hljs-keyword">public</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (block.timestamp &gt;= start + daysAfter * <span class="hljs-number">1</span> days) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特殊变量和函数"><a href="#特殊变量和函数" class="headerlink" title="特殊变量和函数"></a>特殊变量和函数<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#special-variables-functions"></a></h2><p>有一些特殊的变量和函数总是存在于全局命名空间，主要用于提供区块链的信息，或者是通用的工具函数。</p><h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3"></a></h3><ul><li><code>blockhash(uint blockNumber) returns (bytes32)</code>： 给定区块的哈希值 - 只对最近的256个区块有效</li><li><code>blobhash(uint index) returns (bytes32)</code>： 与当前交易相关联的第 <code>index</code> 个blob。 此带版本的哈希值是由一个表示版本的单字节（当前为 <code>0x01</code> ）和紧随其后的KZG证明的SHA256哈希的最后31个字节组成。 （ <a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a> ）。</li><li><code>block.basefee</code> (<code>uint</code>)： 当前区块的基本费用 （ <a href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a> ）</li><li><code>block.blobbasefee</code> (<code>uint</code>): 当前区块的blob基础费用（ <a href="https://eips.ethereum.org/EIPS/eip-7516">EIP-7516</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a>）</li><li><code>block.chainid</code> (<code>uint</code>)： 当前链的ID</li><li><code>block.coinbase</code> (<code>address payable</code>)： 当前区块矿工的地址</li><li><code>block.difficulty</code> (<code>uint</code>)： 当前区块的难度值（ <code>EVM &lt; Paris</code> ）。对于其他EVM版本，它是 <code>block.prevrandao</code> 的一个废弃的别名，将在下一个重大改变版本中被删除。</li><li><code>block.gaslimit</code> (<code>uint</code>)： 当前区块的燃料上限</li><li><code>block.number</code> (<code>uint</code>)： 当前区块的区块号</li><li><code>block.prevrandao</code> (<code>uint</code>)： 由信标链提供的随机数（ <code>EVM &gt;= Paris</code> ）（见 <a href="https://eips.ethereum.org/EIPS/eip-4399">EIP-4399</a> ）。</li><li><code>block.timestamp</code> (<code>uint</code>)： 当前区块的时间戳，自Unix epoch以来的秒数</li><li><code>gasleft() returns (uint256)</code>： 剩余燃料</li><li><code>msg.data</code> (<code>bytes</code>)： 完整的调用数据</li><li><code>msg.sender</code> (<code>address</code>)： 消息发送方（当前调用）</li><li><code>msg.sig</code> (<code>bytes4</code>)： 调用数据的前四个字节（即函数标识符）。</li><li><code>msg.value</code> (<code>uint</code>)： 随消息发送的 wei 的数量</li><li><code>tx.gasprice</code> (<code>uint</code>)： 交易的燃料价格</li><li><code>tx.origin</code> (<code>address</code>)： 交易发送方（完整调用链上的原始发送方）</li></ul><p>备注</p><p>对于每一个 <strong>外部（external）</strong> 函数调用， 包括 <code>msg.sender</code> 和 <code>msg.value</code> 在内所有 <code>msg</code> 成员的值都会变化。 这里包括对库函数的调用。</p><p>备注</p><p>当合约在链下而不是在区块中包含的交易的背景下计算时， 您不应该认为 <code>block.*</code> 和 <code>tx.*</code> 是指任何特定区块或交易的值。 这些值是由执行合约的EVM实现提供的，可以是任意的。</p><p>备注</p><p>不要依赖 <code>block.timestamp</code> 和 <code>blockhash</code> 产生随机数，除非您知道自己在做什么。</p><p>时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。 例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的支付函数， 而如果他们没收到任何奖励，例如以太币，还可以用一个不同的哈希重新尝试。</p><p>当前区块的时间戳必须严格大于最后一个区块的时间戳， 但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。</p><p>备注</p><p>基于可扩展因素，区块哈希不是对所有区块都有效。 您仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。</p><p>备注</p><p>函数 <code>blockhash</code> 以前被称为 <code>block.blockhash</code>， 在 0.4.22 版本中被废弃，在 0.5.0 版本中被删除。</p><p>备注</p><p>函数 <code>gasleft</code> 的前身是 <code>msg.gas</code>， 在 0.4.21 版本中被弃用，在 0.5.0 版本中被删除。</p><p>备注</p><p>在 0.7.0 版本中，删除了别名 <code>now</code> （用于 <code>block.timestamp</code>）。</p><h3 id="ABI编码和解码函数"><a href="#ABI编码和解码函数" class="headerlink" title="ABI编码和解码函数"></a>ABI编码和解码函数<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#abi"></a></h3><ul><li><code>abi.decode(bytes memory encodedData, (...)) returns (...)</code>: ABI-解码给定的数据，而类型在括号中作为第二个参数给出。例如： <code>(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))</code></li><li><code>abi.encode(...) returns (bytes memory)</code>： 对给定的参数进行ABI编码</li><li><code>abi.encodePacked(...) returns (bytes memory)</code>： 对给定参数执行 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-packed-mode">紧打包编码</a>。 请注意，打包编码可能会有歧义!</li><li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)</code>： ABI-对给定参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</li><li><code>abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)</code>： 相当于 <code>abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)</code></li><li><code>abi.encodeCall(function functionPointer, (...)) returns (bytes memory)</code>： 对 <code>函数指针</code> 的调用进行ABI编码，参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果相当于 <code>abi.encodeWithSelector(functionPointer.selector, (...))</code>。</li></ul><p>备注</p><p>这些编码函数可用于制作外部函数调用的数据，而无需实际调用外部函数。 此外， <code>keccak256(abi.encodePacked(a, b))</code> 是一种计算结构化数据的哈希值的方法 （但是要注意有可能使用不同的函数参数类型会制作出一个 “哈希碰撞”）。</p><p>更多详情请参考 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI</a> 和 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-packed-mode">紧打包编码</a>。</p><h3 id="字节类型的成员"><a href="#字节类型的成员" class="headerlink" title="字节类型的成员"></a>字节类型的成员<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-5"></a></h3><ul><li><code>bytes.concat(...) returns (bytes memory)</code>: <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#bytes-concat">将可变数量的字节和byte1, …, byte32参数串联成一个字节数组</a></li></ul><h3 id="字符串的成员"><a href="#字符串的成员" class="headerlink" title="字符串的成员"></a>字符串的成员<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-6"></a></h3><ul><li><code>string.concat(...) returns (string memory)</code>: <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#string-concat">将可变数量的字符串参数串联成一个字符串数组</a></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-7"></a></h3><p>关于错误处理和何时使用哪个函数的更多细节， 请参见 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">assert 和 require</a> 的专门章节。</p><ul><li><p><code>assert(bool condition)</code></p><p>如果条件不满足，会导致异常，因此，状态变化会被恢复 - 用于内部错误。</p></li><li><p><code>require(bool condition)</code></p><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误。</p></li><li><p><code>require(bool condition, string memory message)</code></p><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误，可以同时提供一个错误消息。</p></li><li><p><code>revert()</code></p><p>终止运行并恢复状态更改。</p></li><li><p><code>revert(string memory reason)</code></p><p>终止运行并恢复状态更改，可以同时提供一个解释性的字符串。</p></li></ul><h3 id="数学和密码学函数"><a href="#数学和密码学函数" class="headerlink" title="数学和密码学函数"></a>数学和密码学函数<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions"></a></h3><ul><li><p><code>addmod(uint x, uint y, uint k) returns (uint)</code></p><p>计算 <code>(x + y) % k</code>，加法会在任意精度下执行，并且加法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code>k != 0</code> 的校验（assert）。</p></li><li><p><code>mulmod(uint x, uint y, uint k) returns (uint)</code></p><p>计算 <code>(x * y) % k</code>，乘法会在任意精度下执行，并且乘法的结果即使超过 <code>2**256</code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code>k != 0</code> 的校验（assert）。</p></li><li><p><code>keccak256(bytes memory) returns (bytes32)</code></p><p>计算输入的 Keccak-256 哈希值。</p></li></ul><p>备注</p><p>以前 <code>keccak256</code> 的别名叫 <code>sha3</code> ，在 0.5.0 版本中被删除。</p><ul><li><p><code>sha256(bytes memory) returns (bytes32)</code></p><p>计算输入的 SHA-256 哈希值。</p></li><li><p><code>ripemd160(bytes memory) returns (bytes20)</code></p><p>计算输入的 RIPEMD-160 哈希值。</p></li><li><p><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code></p><p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。 函数参数对应于签名的 ECDSA 值：<code>r</code> = 签名的前32字节<code>s</code> = 签名的第二个32字节<code>v</code> = 签名的最后1个字节<code>ecrecover</code> 返回一个 <code>address</code>，而不是 <code>address payable</code>。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 进行转换，以备您需要向恢复的地址转移资金。更多细节，请阅读 <a href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">使用示例</a>.</p></li></ul><p>警告</p><p>如果您使用 <code>ecrecover</code>，请注意，一个有效的签名可以变成另一个有效的签名，而不需要知道相应的私钥。 在 Homestead 硬分叉中，这个问题对 <em>transaction</em> 签名进行了修复 （见 <a href="https://eips.ethereum.org/EIPS/eip-2#specification">EIP-2</a>）， 但 ecrecover 函数仍然没有改变。</p><p>这通常不是一个问题，除非您要求签名是唯一的，或者用它们来识别个体。 OpenZeppelin 有一个 <a href="https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA">ECDSA 辅助库</a>， 您可以用它作为 <code>ecrecover</code> 的包装，那样就没有这个问题。</p><p>备注</p><p>当在 <em>私有区块链</em> 上运行 <code>sha256</code>， <code>ripemd160</code> 或 <code>ecrecover</code> 时，您可能会遇到燃料耗尽（Out-of-Gas）的错误。这是因为这些功能是作为 “预编译合约” 实现的，只有在它们收到第一个消息后才真正存在（尽管它们的合约代码是硬编码的）。向不存在的合约发送消息的成本较高，因此执行时可能会遇到 Out-of-Gas 错误。这个问题的一个变通方法是，在您的实际合约中使用它们之前，先向每个合约发送 Wei（例如1）。这在主网和测试网上都没有问题。</p><h3 id="地址类型的成员"><a href="#地址类型的成员" class="headerlink" title="地址类型的成员"></a>地址类型的成员<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#address-related"></a></h3><ul><li><p><code>&lt;address&gt;.balance</code> （ <code>uint256</code> ）</p><p>以 Wei 为单位的 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 的余额。</p></li><li><p><code>&lt;address&gt;.code</code> （ <code>bytes memory</code> ）</p><p>在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 的代码（可以是空的）。</p></li><li><p><code>&lt;address&gt;.codehash</code> （ <code>bytes32</code> ）</p><p><a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 的代码哈希值</p></li><li><p><code>&lt;address payable&gt;.transfer(uint256 amount)</code></p><p>向 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 发送数量为 amount 的 Wei，失败时抛出异常，发送2300燃料的矿工费，不可调节。</p></li><li><p><code>&lt;address payable&gt;.send(uint256 amount) returns (bool)</code></p><p>向 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 发送数量为 amount 的 Wei，失败时返回 <code>false</code> 2300燃料的矿工费用，不可调节。</p></li><li><p><code>&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的数据发出低级别的 <code>CALL</code>，返回是否成功的结果和数据，发送所有可用燃料，可调节。</p></li><li><p><code>&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的数据发出低级别的 <code>DELEGATECALL</code>，返回是否成功的结果和数据，发送所有可用燃料，可调节。</p></li><li><p><code>&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)</code></p><p>用给定的数据发出低级别的 <code>STATICCALL</code>，返回是否成功的结果和数据，发送所有可用燃料，可调节。</p></li></ul><p>更多信息，请参见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 一节。</p><p>警告</p><p>您应该尽可能避免在执行另一个合约函数时使用 <code>.call()</code>，因为它绕过了类型检查、函数存在性检查和参数打包。</p><p>警告</p><p>使用 <code>send</code> 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定）， 转账会失败；并且如果接收者用光了以太燃料，转账同样会失败。为了保证以太币转账安全， 总是检查 <code>send</code> 的返回值，使用 <code>transfer</code> 或者下面更好的方式： 使用接收者可以提取以太的模式。</p><p>警告</p><p>由于 EVM 认为对一个不存在的合约的调用总是成功的， Solidity 在执行外部调用时使用 <code>extcodesize</code> 操作码进行额外的检查。 这确保了即将被调用的合约要么实际存在（它包含代码），要么就会产生一个异常。</p><p>对地址而不是合约实例进行低级调用 （即 <code>.call()</code>, <code>.delegatecall()</code>, <code>.staticcall()</code>, <code>.send()</code> 和 <code>.transfer()</code>） <strong>不包括</strong> 这种检查，这使得它们在燃料方面更便宜，但也更不安全。</p><p>备注</p><p>在 0.5.0 版本之前，Solidity 允许地址成员被合约实例访问，例如 <code>this.balance</code>。 现在这被禁止了，必须做一个明确的地址转换。 <code>address(this).balance</code>。</p><p>备注</p><p>如果状态变量是通过低级别的委托调用来访问的，那么两个合约的存储布局必须一致， 以便被调用的合约能够正确地通过名称来访问调用合约的存储变量。 当然，如果存储指针作为函数参数被传递的话，情况就不是这样了，就像高层库的情况一样。</p><p>备注</p><p>在 0.5.0 版本之前， <code>.call</code>, <code>.delegatecall</code> 和 <code>.staticcall</code> 只返回成功状况， 不返回数据。</p><p>备注</p><p>在 0.5.0 版本之前，有一个名为 <code>callcode</code> 的成员，其语义与 <code>delegatecall</code> 相似但略有不同。</p><h3 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-10"></a></h3><ul><li><p><code>this</code> （当前合约类型）</p><p>当前合约，可以显式转换为 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a></p></li><li><p><code>super</code></p><p>继承层次结构中上一级的合约</p></li><li><p><code>selfdestruct(address payable recipient)</code></p><p>销毁当前合约，将其资金发送到给定的 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 并结束执行。 注意， <code>selfdestruct</code> 有一些从EVM继承的特殊性：接收合约的接收函数不会被执行。合约只有在交易结束时才真正被销毁， 任何一个 <code>revert</code> 可能会 “恢复” 销毁。</p></li></ul><p>此外，当前合约的所有函数都可以直接调用，包括当前函数。</p><p>警告</p><p>从 0.8.18 及以上版本开始，在 Solidity 和 Yul 中使用 <code>selfdestruct</code> 将触发一个已废弃警告， 因为 <code>SELFDESTRUCT</code> 操作码最终会发生如 <a href="https://eips.ethereum.org/EIPS/eip-6049">EIP-6049</a> 中所述的行为上的重大变化。</p><p>备注</p><p>在 0.5.0 版本之前，有一个叫做 <code>suicide</code> 的函数，其语义与 <code>selfdestruct</code> 相同。</p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type"></a></h3><p>表达式 <code>type(X)</code> 可以用来检索关于 <code>X</code> 类型的信息。 目前，对这一功能的支持是有限的（ <code>X</code> 可以是合约类型或整数型），但在未来可能会扩展。</p><p>以下是合约类型 <code>C</code> 的可用属性：</p><ul><li><p><code>type(C).name</code></p><p>合约的名称。</p></li><li><p><code>type(C).creationCode</code></p><p>内存字节数组，包含合约的创建字节码。 可以在内联程序中用来建立自定义的创建程序， 特别是通过使用 <code>create2</code> 操作码。 这个属性 <strong>不能</strong> 在合约本身或任何派生合约中被访问。 它会导致字节码被包含在调用站点的字节码中，因此像这样的循环引用是不可能的。</p></li><li><p><code>type(C).runtimeCode</code></p><p>内存字节数组，包含合约运行时的字节码。 通常是由 <code>C</code> 的构造函数部署的代码。 如果 <code>C</code> 有一个使用内联汇编的构造函数，这可能与实际部署的字节码不同。 还要注意的是，库合约在部署时修改其运行时字节码，以防止常规调用。 与 <code>.creationCode</code> 相同的限制也适用于这个属性。</p></li></ul><p>除了上述属性外，以下属性对接口类型 <code>I</code> 可用：</p><ul><li><p><code>type(I).interfaceId</code></p><p>一个 <code>bytes4</code> 值，是包含给定接口 <code>I</code> 的 <a href="https://eips.ethereum.org/EIPS/eip-165">EIP-165</a> 接口标识符。 这个标识符被定义为接口本身定义的所有函数选择器的 <code>XOR</code>，不包括所有继承的函数。</p></li></ul><p>以下属性可用于整数类型 <code>T</code>：</p><ul><li><p><code>type(T).min</code></p><p>类型 <code>T</code> 所能代表的最小值。</p></li><li><p><code>type(T).max</code></p><p>类型 <code>T</code> 所能代表的最大值。</p></li></ul><h2 id="保留关键词"><a href="#保留关键词" class="headerlink" title="保留关键词"></a>保留关键词<a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#id15"></a></h2><p>这些关键字在 Solidity 中是保留的。它们在将来可能成为语法的一部分：</p><p><code>after</code>， <code>alias</code>， <code>apply</code>， <code>auto</code>， <code>byte</code>， <code>case</code>， <code>copyof</code>， <code>default</code>， <code>define</code>， <code>final</code>， <code>implements</code>， <code>in</code>， <code>inline</code>， <code>let</code>， <code>macro</code>， <code>match</code>， <code>mutable</code>， <code>null</code>， <code>of</code>， <code>partial</code>， <code>promise</code>， <code>reference</code>， <code>relocatable</code>， <code>sealed</code>， <code>sizeof</code>， <code>static</code>， <code>supports</code>， <code>switch</code>， <code>typedef</code>， <code>typeof</code>， <code>var</code>。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型</title>
    <link href="/2025/07/06/%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/07/06/%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types"></a></h1><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p><p>除此之外，各个类型之间可以在包含运算符号的表达式中进行交互。 关于各种运算符的快速参考，可以参考 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#order">运算符的优先顺序</a>。</p><p>Solidity中不存在“未定义”或“空”值的概念， 但新声明的变量总是有一个取决于其类型的 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>。 为了处理任何意外的值，您应该使用 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">revert 函数</a> 来恢复整个事务， 或者返回一个带有第二个 <code>bool</code> 值的元组来表示成功。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#value-types"></a></h2><p>以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-2"></a></h3><p><code>bool</code> ：可能的取值为常数值 <code>true</code> 和 <code>false</code>。</p><p>运算符：</p><ul><li><code>!</code> (逻辑非)</li><li><code>&amp;&amp;</code> (逻辑与, “and”)</li><li><code>||</code> (逻辑或, “or”)</li><li><code>==</code> (等于)</li><li><code>!=</code> (不等于)</li></ul><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。 就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> ， 那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#integers"></a></h3><p><code>int</code> / <code>uint</code>: 分别表示有符号和无符号的不同位数的整型变量。 关键字 <code>uint8</code> 到 <code>uint256</code> （无符号整型，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>， 以 8 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> (异或)， <code>~</code> (位取反)</li><li>移位运算符： <code>&lt;&lt;</code> （左移）， <code>&gt;&gt;</code> （右移）</li><li>算数运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code> （只适用于有符号的整数）， <code>*</code>， <code>/</code>， <code>%</code> (取余)， <code>**</code> (幂)</li></ul><p>对于一个整数类型 <code>X</code>，您可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 来访问该类型代表的最小值和最大值。</p><p>警告</p><p>Solidity 中的整数被限制在一个特定的范围内。例如，对于 <code>uint32</code>，这是 <code>0</code> 到 <code>2**32 - 1</code>。 有两种模式在这些类型上进行算术。“包装” 或 “不检查” 模式和 “检查” 模式。 默认情况下，算术总是 “检查” 模式的，这意味着如果一个操作的结果超出了该类型的值范围， 调用将通过一个 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">失败的断言</a> 而被恢复。 您可以用 <code>unchecked &#123; ... &#125;</code> 来转换到“未检查”模式。 更多的细节可以在关于 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#unchecked">未检查</a> 的章节中找到。</p><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id5"></a></h4><p>比较的值是通过比较整数值得到的值。</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id6"></a></h4><p>位操作是在数字的二进制补码表示上进行的。 这意味着，例如 <code>~int256(0) == int256(-1)</code>。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id7"></a></h4><p>移位操作的结果具有左操作数的类型，将结果截断以符合类型。 右操作数必须是无符号类型，试图对有符号类型进行移位会产生一个编译错误。</p><p>移位可以通过以下方式用2的幂的乘法来 “模拟”。 请注意，对左边操作数类型的截断总是在最后进行，但没有明确提及。</p><ul><li><code>x &lt;&lt; y</code> 等同于数学表达式 <code>x * 2**y</code>。</li><li><code>x &gt;&gt; y</code> 等同于数学表达式 <code>x / 2**y</code>，向负无穷远的方向取整。</li></ul><p>警告</p><p>在 <code>0.5.0</code> 版本之前，负数 <code>x</code> 的右移 <code>x &gt;&gt; y</code> 相当于数学表达式 <code>x / 2**y</code> 向零舍入， 即右移使用向上舍入（向零舍入）而不是向下舍入（向负无穷大）。</p><p>备注</p><p>就像对算术操作那样，对移位操作从不进行溢出检查。相反，结果总是被截断的。</p><h4 id="加法、减法和乘法"><a href="#加法、减法和乘法" class="headerlink" title="加法、减法和乘法"></a>加法、减法和乘法<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id8"></a></h4><p>加法、减法和乘法具有通常的语义，在上溢和下溢方面有两种不同的模式：</p><p>默认情况下，所有的算术都会被检查是否有下溢或上溢，但这可以用 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#unchecked">不检查限制</a> 来禁用。 这会导致包装的算术。更多细节可以在那一节中找到。</p><p>表达式 <code>-x</code> 等同于 <code>(T(0) - x)</code>，其中 <code>T</code> 是 <code>x</code> 的类型。它只能用于有符号的类型。 如果 <code>x</code> 是负的， <code>-x</code> 的值就是正的。 还有一个注意事项也是由二进制补码表示产生的：</p><p>如果您有（这样的表达式） <code>int x = type(int).min;</code>，那么 <code>-x</code> 就不符合正数范围。 这意味着 <code>unchecked &#123; assert(-x == x); &#125;</code> 可以工作， 而表达式 <code>-x</code> 在检查模式下使用时将导致断言失败。</p><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id9"></a></h4><p>由于运算结果的类型总是操作数之一的类型，整数除法的结果总是一个整数。 在 Solidity 中，除法是向零进位的。这意味着 <code>int256(-5) / int256(2) == int256(-2)</code>。</p><p>请注意，与此相反，在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#rational-literals">字面上</a> 的除法会产生任意精度的分数值。</p><p>备注</p><p>除以0会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。这个检查 <strong>不能</strong> 通过 <code>unchecked &#123; ... &#125;</code> 禁用。</p><p>备注</p><p>表达式 <code>type(int).min / (-1)</code> 是除法导致溢出的唯一情况。 在检查算术模式下，这将导致一个失败的断言， 而在包装模式下，值将是 <code>type(int).min</code>。</p><h4 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id10"></a></h4><p>模数运算 <code>a % n</code> 是操作数 <code>a</code> 除以操作数 <code>n</code> 后产生余数 <code>r</code>， 其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code>。 这意味着模数运算结果与它的左边操作数（或零）拥有相同的符号， <code>a % n == -(-a % n)</code> 对负的 <code>a</code> 来说成立。</p><ul><li><code>int256(5) % int256(2) == int256(1)</code></li><li><code>int256(5) % int256(-2) == int256(1)</code></li><li><code>int256(-5) % int256(2) == int256(-1)</code></li><li><code>int256(-5) % int256(-2) == int256(-1)</code></li></ul><p>备注</p><p>对0取余会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。这个检查 <strong>不能</strong> 通过 <code>unchecked &#123; ... &#125;</code> 禁用。</p><h4 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id11"></a></h4><p>幂运算只适用于指数中的无符号类型。幂运算的结果类型总是等于基数的类型。 请注意，它足够大以容纳结果，并为潜在的断言失败或包装行为做好准备。</p><p>备注</p><p>在检查模式下，幂运算只对小基数使用相对便宜的 <code>exp</code> 操作码。 对于 <code>x**3</code> 的情况，表达式 <code>x*x*x</code> 可能更便宜。 在任何情况下，燃料成本测试和使用优化器都是可取的。</p><p>备注</p><p>请注意， <code>0**0</code> 被EVM定义为 <code>1</code>。</p><h3 id="定长浮点型"><a href="#定长浮点型" class="headerlink" title="定长浮点型"></a>定长浮点型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-4"></a></h3><p>警告</p><p>Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。</p><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中， <code>M</code> 表示该类型占用的位数， <code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x18</code> 和 <code>fixed128x18</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> （返回值是布尔型）</li><li>算术运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code> (取余数)</li></ul><p>备注</p><p>浮点型（在许多语言中的 <code>float</code> 和 <code>double</code> ，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是， 在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。 一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address"></a></h3><p>地址类型有两种大致相同的类型：</p><ul><li><code>address</code>: 保存一个20字节的值（一个以太坊地址的大小）。</li><li><code>address payable</code>: 与 <code>address</code> 类型相同，但有额外的方法 <code>transfer</code> 和 <code>send</code>。</li></ul><p>这种区别背后的想法是， <code>address payable</code> 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 <code>address</code>，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。</p><p>类型转换：</p><p>允许从 <code>address payable</code> 到 <code>address</code> 的隐式转换， 而从 <code>address</code> 到 <code>address payable</code> 的转换必须通过 <code>payable(&lt;address&gt;)</code> 来明确。</p><p>对于 <code>uint160</code>、整数、 <code>bytes20</code> 和合约类型，允许对 <code>address</code> 进行明确的转换和输出。</p><p>只有 <code>address</code> 类型和合约类型的表达式可以通过 <code>payable(...)</code> 显式转换为 <code>address payable</code> 类型。 对于合约类型，只有在合约可以接收以太的情况下才允许这种转换，也就是说， 合约要么有一个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">receive</a> 函数，要么有一个 payable 类型的 fallback 的函数。 请注意， <code>payable(0)</code> 是有效的，是这个规则的例外。</p><p>备注</p><p>如果您需要一个 <code>address</code> 类型的变量，并计划向其发送以太，那么就将其类型声明为 <code>address payable</code>， 以使这一要求可行。另外，尽量尽早地进行这种区分或转换。</p><p><code>address</code> 和 <code>address payable</code> 之间的区别是从 0.5.0 版本开始的。 同样从该版本开始，合约不能隐式地转换为 <code>address</code> 类型，但仍然可以显式地转换为 <code>address</code> 或 <code>address payable</code>，如果它们有一个 receive 或 payable 类型的 fallback 函数的话。</p><p>运算符：</p><ul><li><code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> 和 <code>&gt;</code></li></ul><p>警告</p><p>如果您使用较大字节的类型转换为 <code>address</code>，例如 <code>bytes32</code>，那么 <code>address</code> 就被截断了。 为了减少转换的模糊性，从 0.4.24 版本开始，编译器将强迫您在转换中明确地进行截断处理。以32字节的值 <code>0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC</code> 为例。</p><p>您可以使用 <code>address(uint160(bytes20(b)))</code>，结果是 <code>0x111122223333444455556666777788889999aAaa</code>， 或者您可以使用 <code>address(uint160(uint256(b)))</code>，结果是 <code>0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</code>。</p><p>备注</p><p>符合 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a> 的混合大小写十六进制数字会自动被视为 <code>address</code> 类型的字面数字。参见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals">地址字面类型</a>。</p><h4 id="地址类型成员变量"><a href="#地址类型成员变量" class="headerlink" title="地址类型成员变量"></a>地址类型成员变量<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#members-of-addresses"></a></h4><p>快速参考，请见 <a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#address-related">地址类型的成员</a>。</p><ul><li><code>balance</code> 和 <code>transfer</code></li></ul><p>可以使用 <code>balance</code> 属性来查询一个地址的以太币余额， 也可以使用 <code>transfer</code> 函数向一个地址发送以太币（以 wei 为单位）：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw==">open in Remix</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">address </span>payable x = payable(<span class="hljs-number">0x123</span>);<br><span class="hljs-keyword">address </span>myAddress = <span class="hljs-keyword">address(this);</span><br><span class="hljs-keyword"></span>if (x.<span class="hljs-keyword">balance </span>&lt; <span class="hljs-number">10</span> &amp;&amp; myAddress.<span class="hljs-keyword">balance </span>&gt;= <span class="hljs-number">10</span>) x.transfer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>如果当前合约的余额不足，或者以太币转账被接收账户拒收，那么 <code>transfer</code> 功能就会失败。 <code>transfer</code> 功能在失败后会被还原。</p><p>备注</p><p>如果 <code>x</code> 是一个合约地址，它的代码（更具体地说：它的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function">接收以太的函数</a>，如果有的话， 或者它的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function">Fallback 函数</a>，如果有的话）将与 <code>transfer</code> 调用一起执行（这是EVM的一个特性，无法阻止）。 如果执行过程中耗尽了燃料或出现了任何故障，以太币的转移将被还原，当前的合约将以异常的方式停止。</p><ul><li><code>send</code></li></ul><p><code>send</code> 是 <code>transfer</code> 的低级对应部分。如果执行失败，当前的合约不会因异常而停止，但 <code>send</code> 会返回 <code>false</code>。</p><p>警告</p><p>使用 <code>send</code> 有一些危险：如果调用堆栈深度为1024，传输就会失败（这可以由调用者强制执行）， 如果接收者的燃料耗尽，也会失败。因此，为了安全地进行以太币转账， 一定要检查 <code>send</code> 的返回值，或者使用 <code>transfer</code>，甚至使用更好的方式： 使用收款人提取以太币的模式。</p><ul><li><code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code></li></ul><p>为了与不遵守ABI的合约对接，或者为了更直接地控制编码， 我们提供了 <code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code> 函数。 它们都接受一个 <code>bytes memory</code> 参数，并返回成功条件（作为一个 <code>bool</code>） 和返回的数据（ <code>bytes memory</code>）。 函数 <code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSelector</code> 和 <code>abi.encodeWithSignature</code> 可以用来编码结构化的数据。</p><p>示例：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw==">open in Remix</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bytes </span>memory payload = abi.encodeWithSignature(<span class="hljs-string">&quot;register(string)&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);<br>(<span class="hljs-keyword">bool </span>success, <span class="hljs-keyword">bytes </span>memory returnData) = <span class="hljs-keyword">address(nameReg).call(payload);</span><br><span class="hljs-keyword"></span>require(success);<br></code></pre></td></tr></table></figure><p>警告</p><p>所有这些函数都是低级别的函数，应该谨慎使用。 具体来说，任何未知的合约都可能是恶意的，如果您调用它， 您就把控制权交给了该合约，而该合约又可能回调到您的合约中， 所以要准备好在调用返回时改变您合约的状态变量。 与其他合约互动的常规方法是在合约对象上调用一个函数（ <code>x.f()</code>）。</p><p>备注</p><p>以前的 Solidity 版本允许这些函数接收任意的参数， 并且也会以不同的方式处理 <code>bytes4</code> 类型的第一个参数。 这些边缘情况在0.5.0版本中被移除。</p><p>可以用 <code>gas</code> 修饰器来调整所提供的燃料：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw==">open in Remix</a></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">address</span>(nameReg).<span class="hljs-built_in">call</span>&#123;g<span class="hljs-symbol">as:</span> <span class="hljs-number">1000000</span>&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;register(string)&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>));<br></code></pre></td></tr></table></figure><p>同样，所提供的以太值也可以被控制：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7">open in Remix</a></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">address</span>(nameReg).<span class="hljs-built_in">call</span>&#123;val<span class="hljs-symbol">ue:</span> <span class="hljs-number">1</span> ether&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;register(string)&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>));<br></code></pre></td></tr></table></figure><p>最后，这些修饰器可以合并。它们的顺序并不重要：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs=">open in Remix</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">address</span>(nameReg).call&#123;gas: <span class="hljs-number">1000000</span>, value: <span class="hljs-number">1</span> ether&#125;(abi.encodeWithSignature(<span class="hljs-string">&quot;register(string)&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>));<br></code></pre></td></tr></table></figure><p>以类似的方式，可以使用函数 <code>delegatecall</code>：不同的是，它只使用给定地址的代码， 所有其他方面（存储，余额，…）都取自当前的合约。 <code>delegatecall</code> 的目的是为了使用存储在另一个合约中的库代码。 用户必须确保两个合约中的存储结构都适合使用delegatecall。</p><p>备注</p><p>在 homestead 版本之前，只有一个功能类似但作用有限的 <code>callcode</code> 的函数可用， 但它不能获取委托方的 <code>msg.sender</code> 和 <code>msg.value</code>。这个功能在 0.5.0 版本中被移除。</p><p>从 byzantium 开始，也可以使用 <code>staticcall</code>。这基本上与 <code>call</code> 相同， 但如果被调用的函数以任何方式修改了状态，则会恢复。</p><p>这三个函数 <code>call</code>， <code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数， 只应该作为 <em>最后的手段</em> 来使用，因为它们破坏了Solidity的类型安全。</p><p><code>gas</code> 选项在所有三种方法中都可用，而 <code>value</code> 选项只在 <code>call</code> 中可用。</p><p>备注</p><p>最好避免在您的智能合约代码中依赖硬编码的燃料值，无论状态是读出还是写入， 因为这可能有很多隐患。另外，对燃料的访问在未来可能会改变。</p><ul><li><code>code</code> 和 <code>codehash</code></li></ul><p>您可以查询任何智能合约的部署代码。使用 <code>.code</code> 获得作为 <code>bytes memory</code> 的EVM字节码， 这可能是空的。使用 <code>.codehash</code> 获得该代码的Keccak-256哈希值（作为 <code>bytes32</code>）。 注意，使用 <code>addr.codehash</code> 比 <code>keccak256(addr.code)</code> 更便宜。</p><p>备注</p><p>所有的合约都可以转换为 <code>address</code> 类型，所以可以用 <code>address(this).balance</code> 查询当前合约的余额。</p><h3 id="合约类型"><a href="#合约类型" class="headerlink" title="合约类型"></a>合约类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#contract-types"></a></h3><p>每个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts">合约</a> 都定义了自己的类型。 您可以隐式地将一个合约转换为它们所继承的另一个合约。 合约可以显式地转换为 <code>address</code> 类型，也可以从 <code>address</code> 类型中转换。</p><p>只有在合约类型具有 receive 或 payable 类型的 fallback 函数的情况下， 才有可能明确转换为 <code>address payable</code> 类型和从该类型转换。 这种转换仍然使用 <code>address(x)</code> 进行转换。如果合约类型没有一个 receive 或 payable 类型的 fallback 函数， 可以使用 <code>payable(address(x))</code> 来转换为 <code>address payable</code> 。 您可以在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address">地址类型</a> 一节中找到更多信息。</p><p>备注</p><p>在 0.5.0 版本之前，合约直接从地址类型派生出来， 并且在 <code>address</code> 和 <code>address payable</code> 之间没有区别。</p><p>如果您声明了一个本地类型的变量（ <code>MyContract c</code> ），您可以调用该合约上的函数。 注意要从相同合约类型的地方将其赋值。</p><p>您也可以实例化合约（这意味着它们是新创建的）。 您可以在 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts">‘通过关键字new创建合约’</a> 部分找到更多细节。</p><p>合约的数据表示与 <code>address</code> 类型相同，该类型也用于 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI</a>。</p><p>合约不支持任何运算符。</p><p>合约类型的成员是合约的外部函数，包括任何标记为 <code>public</code> 的状态变量。</p><p>对于一个合约 <code>C</code>，您可以使用 <code>type(C)</code> 来访问 关于该合约的 <a href="https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type">类型信息</a> 。</p><h3 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-7"></a></h3><p>值类型 <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code> 代表从1到32的字节序列。</p><p>运算符：</p><p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p><ul><li>比较运算符： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code> (返回 <code>bool</code>)</li><li>位运算符： <code>&amp;</code>， <code>|</code>， <code>^</code> （按位异或）， <code>~</code> （按位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位）， <code>&gt;&gt;</code> （右移位）</li><li>索引访问： 如果 <code>x</code> 是 <code>bytesI</code> 类型，那么当 <code>0 &lt;= k &lt; I</code> 时， <code>x[k]</code> 返回第 <code>k</code> 个字节（只读）。</li></ul><p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型）， 它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p><p>成员变量：</p><ul><li><code>.length</code> 表示这个字节数组的长度（只读）.</li></ul><p>备注</p><p>类型 <code>bytes1[]</code> 是一个字节数组，但是由于填充规则，它为每个元素浪费了31个字节的空间（在存储中除外）。 因此最好使用 <code>bytes</code> 类型来代替。</p><p>备注</p><p>在 0.8.0 版本之前， <code>byte</code> 曾经是 <code>bytes1</code> 的别名。</p><h3 id="变长字节数组"><a href="#变长字节数组" class="headerlink" title="变长字节数组"></a>变长字节数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id17"></a></h3><ul><li><p><code>bytes</code>:</p><p>变长字节数组，参见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#arrays">数组</a>。它并不是值类型！</p></li><li><p><code>string</code>:</p><p>变长 UTF-8 编码字符串类型，参见 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#arrays">数组</a>。并不是值类型！</p></li></ul><h3 id="地址字面量（Address-Literals）"><a href="#地址字面量（Address-Literals）" class="headerlink" title="地址字面量（Address Literals）"></a>地址字面量（Address Literals）<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals"></a></h3><p>比如像 <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> 这样的 通过了地址校验测试的十六进制字属于 <code>address</code> 类型。 十六进制字数在39到41位之间，并且没有通过校验测试，会产生一个错误。 您可以预加（对于整数类型）或附加（对于bytesNN类型）零来消除该错误。</p><p>备注</p><p>混合大小写的地址校验和格式定义在 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>。</p><h3 id="有理数和整数字面量"><a href="#有理数和整数字面量" class="headerlink" title="有理数和整数字面量"></a>有理数和整数字面量<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#rational-literals"></a></h3><p>整数字面量由范围在 0-9 的一串数字组成，表现成十进制。 例如， <code>69</code> 表示十进制数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。</p><p>小数字面常数由 <code>.</code> 和小数点后的至少一个数字组成。例如， <code>.1</code> 和 <code>1.3</code> （但不是 <code>1.</code>）。</p><p>也支持 <code>2e10</code> 形式的科学符号，其中尾数可以是小数，但指数必须是一个整数。 字面的 <code>MeE</code> 相当于 <code>M * 10**E</code>。 例子包括 <code>2e10</code>, <code>-2e10</code>, <code>2e-10</code>, <code>2.5e1</code>。</p><p>下划线可以用来分隔数字字面的数字，以帮助阅读。 例如，十进制 <code>123_000</code>，十六进制 <code>0x2eff_abde</code>，科学十进制 <code>1_2e345_678</code> 都是有效的。 下划线只允许在两个数字之间，并且只允许一个连续的下划线。 含有下划线的数字字面没有额外的语义，下划线被忽略。</p><p>数值字面量表达式保留任意精度，直到它们被转换为非字面量类型 （即通过与数字字面量表达式以外的任何东西一起使用（如布尔字面量）或通过显式转换）。 这意味着在数值常量表达式中，计算不会溢出，除法不会截断。</p><p>例如， <code>(2**800 + 1) - 2**800</code> 的结果是常数 <code>1</code> （类型 <code>uint8</code>）， 尽管中间的结果甚至不符合机器字的大小。此外， <code>.5 * 8</code> 的结果是整数 <code>4</code> （尽管中间使用了非整数）。</p><p>警告</p><p>虽然大多数运算符在应用于字面量时都会产生一个字面量表达式，但有一些运算符并不遵循这种模式：</p><ul><li>三元运算符（ <code>...？ ...：...</code>）。</li><li>数组下标（ <code>&lt;array&gt;[&lt;index&gt;]</code>）。</li></ul><p>您可能期望像 <code>255 + (true ? 1 : 0)</code> 或 <code>255 + [1, 2, 3][0]</code> 这样的表达式等同于直接使用字面量256， 但实际上它们是在 <code>uint8</code> 类型中计算的，可能会溢出。</p><p>只要操作数是整数，任何可以应用于整数的操作数也可以应用于数值字面量表达式。 如果两者中的任何一个是小数，则不允许进行位操作， 如果指数是小数，则不允许进行幂运算（因为这可能导致无理数）。</p><p>以数值字面量表达式为左（或基数）操作数，以整数类型为右（指数）操作数的移位和幂运算， 总是在 <code>uint256</code> （非负数数值字面量）或 <code>int256</code> （负数数值字面量）类型中进行。 无论右（指数）操作数的类型如何。</p><p>警告</p><p>在 0.4.0 版本之前，Solidity 中整数字的除法会被截断，但现在它转换为一个有理数，即 <code>5 / 2</code> 不等于 <code>2</code>，而是 <code>2.5</code>。</p><p>备注</p><p>Solidity 对每个有理数都有对应的数值字面量类型。 整数字面量和有理数字面量都属于数值字面量类型。 除此之外，所有的数值字面量表达式（即只包含数值字面量和运算符的表达式）都属于数值字面量类型。 因此数值字面量表达式 <code>1 + 2</code> 和 <code>2 + 1</code> 的结果跟有理数3的数值字面量类型相同。</p><p>备注</p><p>数字字面表达式一旦与非字面表达式一起使用，就会被转换为非字面类型。 不考虑类型，下面分配给 <code>b</code> 的表达式的值被评估为一个整数。 因为 <code>a</code> 的类型是 <code>uint128</code>，所以表达式 <code>2.5 + a</code> 必须有一个合适的类型。 由于 <code>2.5</code> 和 <code>uint128</code> 的类型没有共同的类型，Solidity编译器不接受这段代码。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs=">open in Remix</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">uint128</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">uint128</span> b = <span class="hljs-number">2</span>.<span class="hljs-number">5</span> + a + <span class="hljs-number">0</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="字符串字面量和类型"><a href="#字符串字面量和类型" class="headerlink" title="字符串字面量和类型"></a>字符串字面量和类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#string-literals"></a></h3><p>字符串字面量是指由双引号或单引号引起来的字符串（ <code>&quot;foo&quot;</code> 或者 <code>&#39;bar&#39;</code>）。 它们也可以分成多个连续部分（ <code>&quot;foo&quot; &quot;bar&quot;</code> 相当于 <code>&quot;foobar&quot;</code> ），这在处理长字符串时很有帮助。 它们不像在 C 语言中那样带有结束符； <code>&quot;foo&quot;</code> 相当于3个字节而不是4个。 和整数字面量一样，字符串字面量的类型也可以发生改变， 但它们可以隐式地转换成 <code>bytes1</code>，……， <code>bytes32</code>，如果合适的话，还可以转换成 <code>bytes</code> 以及 <code>string</code>。</p><p>例如，使用 <code>bytes32 samevar = &quot;stringliteral&quot;</code>， 当分配给 <code>bytes32</code> 类型时，字符串字面量被解释成原始字节形式。</p><p>字符串字面量只能包含可打印的ASCII字符，也就是0x20 … 0x7E之间的字符。</p><p>此外，字符串字元还支持以下转义字符：</p><ul><li><code>\&lt;newline&gt;</code> （转义一个实际的换行）</li><li><code>\\</code> （反斜杠）</li><li><code>\&#39;</code> （单引号）</li><li><code>\&quot;</code> （双引号）</li><li><code>\n</code> （换行）</li><li><code>\r</code> （回车键）</li><li><code>\t</code> （制表）</li><li><code>\xNN</code> （十六进制转义，见下文）</li><li><code>\uNNNN</code> （unicode转义，见下文）</li></ul><p><code>\xNN</code> 接收一个十六进制值并插入相应的字节，而 <code>\uNNNN</code> 接收一个Unicode编码点并插入一个UTF-8序列。</p><p>备注</p><p>在 0.8.0 版本之前，有三个额外的转义序列。 <code>\b</code>， <code>\f</code> 和 <code>v</code>。 它们在其他语言中通常是可用的，但在实践中很少需要。 如果您确实需要它们，仍然可以通过十六进制转义插入， 即分别为 <code>\x08</code>， <code>x0c</code> 和 <code>\x0b</code>，就像其他ASCII字符一样。</p><p>下面例子中的字符串的长度为10个字节。 它以一个换行字节开始，接着是一个双引号，一个单引号，一个反斜杠字符， 然后（没有分隔符）是字符序列 <code>abcdef</code>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=IlxuXCJcJ1xcYWJjXApkZWYi">open in Remix</a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\&quot;</span><span class="hljs-char escape_">\&#x27;</span><span class="hljs-char escape_">\\</span>abc\</span><br><span class="hljs-string">def&quot;</span><br></code></pre></td></tr></table></figure><p>任何非换行的 Unicode 行结束符（即LF, VF, FF, CR, NEL, LS, PS）都被认为是字符串字面的结束。 换行只在字符串字面内容前面没有 <code>\</code> 的情况下终止。</p><h3 id="Unicode-字面量"><a href="#Unicode-字面量" class="headerlink" title="Unicode 字面量"></a>Unicode 字面量<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#unicode"></a></h3><p>普通字符串字面量只能包含ASCII码，而 Unicode 字面量 - 以关键字 <code>unicode</code> 为前缀 - 可以包含任何有效的UTF-8序列。 它们也支持与普通字符串字面意义相同的转义序列。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs=">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string memory a <span class="hljs-operator">=</span> unicode<span class="hljs-string">&quot;Hello 😃&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="十六进制字面量"><a href="#十六进制字面量" class="headerlink" title="十六进制字面量"></a>十六进制字面量<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-12"></a></h3><p>十六进制字面量以关键字 <code>hex</code> 打头， 后面紧跟着用单引号或双引号引起来的字符串（ <code>hex&quot;001122FF&quot;</code>, <code>hex&#39;0011_22_FF&#39;</code>）。 它们的内容必须是十六进制的数字，可以选择使用一个下划线作为字节边界之间的分隔符。 字面的值将是十六进制序列的二进制表示。</p><p>由空格分隔的多个十六进制字面量被串联成一个字面量： <code>hex&quot;00112233&quot; hex&quot;44556677&quot;</code> 相当于 <code>hex&quot;0011223344556677&quot;</code>。</p><p>十六进制字面量在某些方面的行为类似 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#string-literals">字符串字面量</a> ，但不能隐式转换为 <code>string</code> 类型。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#enums"></a></h3><p>枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。</p><p>数据表示与 C 语言中的枚举相同。选项由后续的从 <code>0</code> 开始无符号整数值表示。</p><p>使用 <code>type(NameOfEnum).min</code> 和 <code>type(NameOfEnum).max</code> 您可以得到给定枚举的最小值和最大值。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8g55Sx5LqO5p6a5Li+57G75Z6L5LiN5bGe5LqOQUJJ55qE5LiA6YOo5YiG77yM5Zug5q2k5a+55LqO5omA5pyJ5p2l6IeqIFNvbGlkaXR5IOWklumDqOeahOiwg+eUqO+8jAogICAgLy8gImdldENob2ljZSIg55qE562+5ZCN5Lya6Ieq5Yqo6KKr5pS55oiQICJnZXRDaG9pY2UoKSByZXR1cm5zICh1aW50OCki44CCCiAgICBmdW5jdGlvbiBnZXRDaG9pY2UoKSBwdWJsaWMgdmlldyByZXR1cm5zIChBY3Rpb25DaG9pY2VzKSB7CiAgICAgICAgcmV0dXJuIGNob2ljZTsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXREZWZhdWx0Q2hvaWNlKCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB1aW50KGRlZmF1bHRDaG9pY2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldExhcmdlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5tYXg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0U21hbGxlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5taW47CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br>contract test &#123;<br>    <span class="hljs-built_in">enum</span> ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;<br>    ActionChoices choice;<br>    ActionChoices constant defaultChoice = ActionChoices.GoStraight;<br><br>    <span class="hljs-function">function <span class="hljs-title">setGoStraight</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        choice = ActionChoices.GoStraight;<br>    &#125;<br><br>    <span class="hljs-comment">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span><br>    <span class="hljs-comment">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span><br>    <span class="hljs-function">function <span class="hljs-title">getChoice</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> choice;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getDefaultChoice</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">uint</span>(defaultChoice);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getLargestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).max;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">getSmallestValue</span>() <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">ActionChoices</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> type(ActionChoices).min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>枚举也可以在文件级别上声明，在合约或库定义之外。</p><h3 id="用户定义的值类型"><a href="#用户定义的值类型" class="headerlink" title="用户定义的值类型"></a>用户定义的值类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#user-defined-value-types"></a></h3><p>一个用户定义的值类型允许在一个基本的值类型上创建一个零成本的抽象。 这类似于一个别名，但有更严格的类型要求。</p><p>一个用户定义的值类型是用 <code>type C is V</code> 定义的，其中 <code>C</code> 是新引入的类型的名称， <code>V</code> 必须是一个内置的值类型（“底层类型”）。 函数 <code>C.wrap</code> 被用来从底层类型转换到自定义类型。同样地， 函数 <code>C.unwrap</code> 用于从自定义类型转换到底层类型。</p><p>类型 <code>C</code> 没有任何运算符或附加成员函数。特别是，甚至运算符 <code>==</code> 也没有定义。 不允许对其他类型进行显式和隐式转换。</p><p>这种类型的值的数据表示是从底层类型中继承的，底层类型也被用于ABI中。</p><p>下面的例子说明了一个自定义类型 <code>UFixed256x18</code>， 代表一个有18位小数的十进制定点类型和一个最小的库来对该类型做算术运算。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIOS9v+eUqOeUqOaIt+WumuS5ieeahOWAvOexu+Wei+ihqOekuuWNgei/m+WItjE45L2N77yMMjU25L2N5a6955qE5a6a54K557G75Z6L44CCCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8g5LiA5Liq5ZyoVUZpeGVkMjU2eDE45LiK6L+b6KGM5a6a54K55pON5L2c55qE5pyA5bCP5bqT44CCCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8g5bCG5Lik5LiqVUZpeGVkMjU2eDE455qE5pWw5a2X55u45Yqg44CC5rqi5Ye65pe25bCG6L+U5Zue77yM5L6d6Z2gdWludDI1NueahOeul+acr+ajgOafpeOAggogICAgZnVuY3Rpb24gYWRkKFVGaXhlZDI1NngxOCBhLCBVRml4ZWQyNTZ4MTggYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSArIFVGaXhlZDI1NngxOC51bndyYXAoYikpOwogICAgfQogICAgLy8vIOWwhlVGaXhlZDI1NngxOOWSjHVpbnQyNTbnm7jkuZjjgILmuqLlh7rml7blsIbov5Tlm57vvIzkvp3pnaB1aW50MjU255qE566X5pyv5qOA5p+l44CCCiAgICBmdW5jdGlvbiBtdWwoVUZpeGVkMjU2eDE4IGEsIHVpbnQyNTYgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSAqIGIpOwogICAgfQogICAgLy8vIOWvueS4gOS4qlVGaXhlZDI1NngxOOexu+Wei+eahOaVsOWtl+ebuOS4i+WPluaVtOOAggogICAgLy8vIEByZXR1cm4g5LiN6LaF6L+HIGBhYCDnmoTmnIDlpKfmlbTmlbDjgIIKICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8g5bCG5LiA5LiqdWludDI1Nui9rOWMluS4uuebuOWQjOWAvOeahFVGaXhlZDI1NngxOOOAggogICAgLy8vIOWmguaenOaVtOaVsOWkquWkp++8jOWImeaBouWkjeiuoeeul+OAggogICAgZnVuY3Rpb24gdG9VRml4ZWQyNTZ4MTgodWludDI1NiBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKFVGaXhlZDI1NngxOCkgewogICAgICAgIHJldHVybiBVRml4ZWQyNTZ4MTgud3JhcChhICogbXVsdGlwbGllcik7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br><span class="hljs-comment">// 使用用户定义的值类型表示十进制18位，256位宽的定点类型。</span><br>type UFixed256x18 <span class="hljs-keyword">is</span> uint256;<br><br><span class="hljs-comment">/// 一个在UFixed256x18上进行定点操作的最小库。</span><br>library FixedMath &#123;<br>    uint constant multiplier = <span class="hljs-number">10</span>**<span class="hljs-number">18</span>;<br><br>    <span class="hljs-comment">/// 将两个UFixed256x18的数字相加。溢出时将返回，依靠uint256的算术检查。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UFixed256x18 a, UFixed256x18 b)</span> <span class="hljs-title function_">internal</span> <span class="hljs-title function_">pure</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(UFixed256x18)</span> &#123;<br>        <span class="hljs-keyword">return</span> UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));<br>    &#125;<br>    <span class="hljs-comment">/// 将UFixed256x18和uint256相乘。溢出时将返回，依靠uint256的算术检查。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(UFixed256x18 a, uint256 b)</span> <span class="hljs-title function_">internal</span> <span class="hljs-title function_">pure</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(UFixed256x18)</span> &#123;<br>        <span class="hljs-keyword">return</span> UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);<br>    &#125;<br>    <span class="hljs-comment">/// 对一个UFixed256x18类型的数字相下取整。</span><br>    <span class="hljs-comment">/// @return 不超过 `a` 的最大整数。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(UFixed256x18 a)</span> <span class="hljs-title function_">internal</span> <span class="hljs-title function_">pure</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint256)</span> &#123;<br>        <span class="hljs-keyword">return</span> UFixed256x18.unwrap(a) / multiplier;<br>    &#125;<br>    <span class="hljs-comment">/// 将一个uint256转化为相同值的UFixed256x18。</span><br>    <span class="hljs-comment">/// 如果整数太大，则恢复计算。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">toUFixed256x18</span><span class="hljs-params">(uint256 a)</span> <span class="hljs-title function_">internal</span> <span class="hljs-title function_">pure</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(UFixed256x18)</span> &#123;<br>        <span class="hljs-keyword">return</span> UFixed256x18.wrap(a * multiplier);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>UFixed256x18.wrap</code> 和 <code>FixedMath.toUFixed256x18</code> 有相同的签名， 但执行两个非常不同的操作。 <code>UFixed256x18.wrap</code> 函数返回一个与输入的数据表示相同的 <code>UFixed256x18</code>， 而 <code>toUFixed256x18</code> 则返回一个具有相同数值的 <code>UFixed256x18</code>。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#function-types"></a></h3><p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- <em>内部（internal）</em> 函数和 <em>外部（external）</em> 函数：</p><p>内部函数只能在当前合约内被调用（更具体来说， 在当前代码块内，包括内部库函数和继承的函数中）， 因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的， 就像在当前合约的内部调用一个函数。</p><p>外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。</p><p>函数类型表示成如下的形式：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0=">open in Remix</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> (&lt;parameter <span class="hljs-keyword">types</span>&gt;) &#123;<span class="hljs-type">internal</span>|<span class="hljs-keyword">external</span>&#125; [pure|<span class="hljs-keyword">view</span>|payable] [<span class="hljs-keyword">returns</span> (&lt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">types</span>&gt;)]<br></code></pre></td></tr></table></figure><p>与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回， 则需要删除整个 <code>returns (&lt;return types&gt;)</code> 部分。</p><p>默认情况下，函数类型是内部函数，所以可以省略 <code>internal</code> 关键字。 注意，这只适用于函数类型。对于合约中定义的函数， 必须明确指定其可见性，它们没有默认类型。</p><p>转换：</p><p>当且仅当它们的参数类型相同，它们的返回类型相同，它们的内部/外部属性相同， 并且 <code>A</code> 的状态可变性比 <code>B</code> 的状态可变性更具限制性时， 一个函数类型 <code>A</code> 就可以隐式转换为一个函数类型 <code>B</code>。特别是：</p><ul><li><code>pure</code> 函数可以转换为 <code>view</code> 和 <code>非 payable</code> 函数</li><li><code>view</code> 函数可以转换为 <code>非 payable</code> 函数</li><li><code>payable</code> 函数可以转换为 <code>非 payable</code> 函数</li></ul><p>其他函数类型之间的转换是不可能的。</p><p>关于 <code>payable</code> 和 <code>非 payable</code> 的规则可能有点混乱， 但实质上，如果一个函数是 <code>payable</code>，这意味着 它也接受零以太的支付，所以它也是 <code>非 payable</code>。 另一方面，一个 <code>非 payable</code> 的函数将拒收发送给它的以太， 所以 <code>非 payable</code> 的函数不能被转换为 <code>payable</code> 的函数。 声明一下，拒收以太比不拒收以太更有限制性。 这意味着您可以用一个不可支付的函数覆写一个可支付的函数，但不能反过来。</p><p>此外，当您定义一个 <code>非 payable</code> 的函数指针时， 编译器并不强制要求被指向的函数实际拒收以太。 相反，它强制要求该函数指针永远不会被用来发送以太。 这使得我们有可能将一个 <code>payable</code> 的函数指针分配给一个 <code>非 payable</code> 的函数指针， 以确保这两种类型的函数表现相同，即都不能用来发送以太。</p><p>如果一个函数类型的变量没有被初始化，调用它将导致 会出现 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require">异常</a>。如果您在一个函数上使用了 <code>delete</code> 之后再调用它， 也会发生同样的情况。</p><p>如果外部函数类型在 Solidity 的上下文中被使用， 它们将被视为 <code>function</code> 类型，它将地址和函数标识符一起编码为一个 <code>bytes24</code> 类型。</p><p>请注意，当前合约的公共函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 <code>f</code> 调用， 如果想将其当作外部函数，使用 <code>this.f</code> 。</p><p>一个内部类型的函数可以被分配给一个内部函数类型的变量，无论它在哪里被定义。 这包括合约和库的私有，内部和公共函数，以及自由函数。 另一方面，外部函数类型只与公共和外部合约函数兼容。</p><p>备注</p><p>带有 <code>calldata</code> 参数的外部函数与带有 <code>calldata</code> 参数的外部函数类型不兼容。 它们与相应的带有 <code>memory</code> 参数的类型兼容。 例如，没有一个函数可以被 <code>function (string calldata) external</code> 类型的值所指向， 而 <code>function (string memory) external</code> 可以同时指向 <code>function f(string memory) external &#123;&#125;</code> 和 <code>function g(string calldata) external &#123;&#125;</code>。 这是因为对于这两个位置，参数是以同样的方式传递给函数的。 调用者不能直接将其calldata传递给外部函数，总是ABI将参数编码到内存中。 将参数标记为 <code>calldata</code> 只影响到外部函数的实现，在调用者一方的函数指针中是没有意义的。</p><p>警告</p><p>在启用了优化器的旧版优化流程中，内部函数指针的比较可能会产生意想不到的结果， 因为优化器可能会将相同的函数合并为一个，这将导致这些函数指针在比较时显示为相等， 而不是不相等。不建议进行此类比较，这会导致编译器发出警告，直到下一个重大更新版本（0.9.0）时， 该警告将升级为错误，从而禁止此类比较。</p><p>库合约被排除在外，因为它们需要用到 <code>delegatecall</code>， 并且 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#library-selectors">对库合约的函数选择器使用不同的ABI约定</a>。 接口中声明的函数没有定义，所以指向它们也没有意义。</p><p>成员： 外部（或公共）函数有以下成员：</p><ul><li><code>.address</code> 返回该函数的合约地址。</li><li><code>.selector</code> 返回 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-function-selector">ABI 函数选择器</a></li></ul><p>备注</p><p>外部（或公共）函数曾经有额外的成员 <code>.gas(uint)</code> 和 <code>.value(uint)</code>。 这些在 Solidity 0.6.2 中被废弃，并在 Solidity 0.7.0 中被移除。取而代之的是 使用 <code>&#123;gas: ...&#125;</code> 和 <code>&#123;value: ...&#125;</code> 来分别指定发送到函数的燃料量或以太（wei为单位）量。 参见 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#external-function-calls">外部函数调用</a> 以获得更多信息。</p><p>以下例子展示如何使用这些成员：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.4</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Example &#123;<br>    function f() <span class="hljs-keyword">public</span> payable returns (bytes4) &#123;<br>        assert(<span class="hljs-keyword">this</span>.f.address == address(<span class="hljs-keyword">this</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.f.selector;<br>    &#125;<br><br>    function g() <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-keyword">this</span>.f&#123;gas: <span class="hljs-number">10</span>, value: <span class="hljs-number">800</span>&#125;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下例子展示如何使用内部函数类型：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyDlhoXpg6jlh73mlbDlj6/ku6XlnKjlhoXpg6jlupPlh73mlbDkuK3kvb/nlKjvvIzlm6DkuLrlroPku6zlsIbmmK/lkIzkuIDku6PnoIHkuIrkuIvmlofnmoTkuIDpg6jliIYKICAgIGZ1bmN0aW9uIG1hcCh1aW50W10gbWVtb3J5IHNlbGYsIGZ1bmN0aW9uICh1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludFtdIG1lbW9yeSByKQogICAgewogICAgICAgIHIgPSBuZXcgdWludFtdKHNlbGYubGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBmKHNlbGZbaV0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZWR1Y2UoCiAgICAgICAgdWludFtdIG1lbW9yeSBzZWxmLAogICAgICAgIGZ1bmN0aW9uICh1aW50LCB1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYKICAgICkKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHIpCiAgICB7CiAgICAgICAgciA9IHNlbGZbMF07CiAgICAgICAgZm9yICh1aW50IGkgPSAxOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByID0gZihyLCBzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmFuZ2UodWludCBsZW5ndGgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludFtdIG1lbW9yeSByKSB7CiAgICAgICAgciA9IG5ldyB1aW50W10obGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBpOwogICAgICAgIH0KICAgIH0KfQoKCmNvbnRyYWN0IFB5cmFtaWQgewogICAgdXNpbmcgQXJyYXlVdGlscyBmb3IgKjsKCiAgICBmdW5jdGlvbiBweXJhbWlkKHVpbnQgbCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBBcnJheVV0aWxzLnJhbmdlKGwpLm1hcChzcXVhcmUpLnJlZHVjZShzdW0pOwogICAgfQoKICAgIGZ1bmN0aW9uIHNxdWFyZSh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICogeDsKICAgIH0KCiAgICBmdW5jdGlvbiBzdW0odWludCB4LCB1aW50IHkpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICsgeTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>library ArrayUtils &#123;<br>    <span class="hljs-comment">// 内部函数可以在内部库函数中使用，因为它们将是同一代码上下文的一部分</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory <span class="hljs-keyword">self</span>, <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> pure returns <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> f)</span></span><br><span class="hljs-function">        <span class="hljs-title">internal</span></span><br><span class="hljs-function">        <span class="hljs-title">pure</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint</span>[](<span class="hljs-keyword">self</span>.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">self</span>.length; i++) &#123;<br>            r[i] = f(<span class="hljs-keyword">self</span>[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">uint</span>[] memory <span class="hljs-keyword">self</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">uint</span>)</span> pure returns <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> f</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span><br><span class="hljs-function">        <span class="hljs-title">internal</span></span><br><span class="hljs-function">        <span class="hljs-title">pure</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        r = <span class="hljs-keyword">self</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">self</span>.length; i++) &#123;<br>            r = f(r, <span class="hljs-keyword">self</span>[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> length)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory r)</span> </span>&#123;<br>        r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint</span>[](length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; r.length; i++) &#123;<br>            r[i] = i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>contract Pyramid &#123;<br>    using ArrayUtils <span class="hljs-keyword">for</span> *;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pyramid</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> l)</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> x)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> x, <span class="hljs-keyword">uint</span> y)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个使用外部函数类型的例子：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z6YeM6KaB5qOA5p+l55qE5piv6LCD55So6L+U5Zue5piv5ZCm5p2l6Ieq5Y+v5L+h55qE5p2l5rqQCiAgICAgICAgcmVxdWVzdHNbcmVxdWVzdElEXS5jYWxsYmFjayhyZXNwb25zZSk7CiAgICB9Cn0KCgpjb250cmFjdCBPcmFjbGVVc2VyIHsKICAgIE9yYWNsZSBjb25zdGFudCBwcml2YXRlIE9SQUNMRV9DT05TVCA9IE9yYWNsZShhZGRyZXNzKDB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYSkpOyAvLyDlt7Lnn6XnmoTlkIjnuqYKICAgIHVpbnQgcHJpdmF0ZSBleGNoYW5nZVJhdGU7CgogICAgZnVuY3Rpb24gYnV5U29tZXRoaW5nKCkgcHVibGljIHsKICAgICAgICBPUkFDTEVfQ09OU1QucXVlcnkoIlVTRCIsIHRoaXMub3JhY2xlUmVzcG9uc2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9yYWNsZVJlc3BvbnNlKHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBhZGRyZXNzKE9SQUNMRV9DT05TVCksCiAgICAgICAgICAgICJPbmx5IG9yYWNsZSBjYW4gY2FsbCB0aGlzLiIKICAgICAgICApOwogICAgICAgIGV4Y2hhbmdlUmF0ZSA9IHJlc3BvbnNlOwogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><br>contract Oracle &#123;<br>    <span class="hljs-keyword">struct</span> Request &#123;<br>        bytes data;<br>        function(<span class="hljs-built_in">uint</span>) external callback;<br>    &#125;<br><br>    Request[] <span class="hljs-keyword">private</span> requests;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">NewRequest</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span>;<br><br>    <span class="hljs-function">function <span class="hljs-title">query</span>(<span class="hljs-params">bytes memory data, function(<span class="hljs-built_in">uint</span></span>) external callback) <span class="hljs-keyword">public</span></span> &#123;<br>        requests.push(Request(data, callback));<br>        <span class="hljs-function">emit <span class="hljs-title">NewRequest</span>(<span class="hljs-params">requests.length - <span class="hljs-number">1</span></span>)</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">reply</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> requestID, <span class="hljs-built_in">uint</span> response</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// 这里要检查的是调用返回是否来自可信的来源</span><br>        requests[requestID].callback(response);<br>    &#125;<br>&#125;<br><br><br>contract OracleUser &#123;<br>    Oracle constant <span class="hljs-keyword">private</span> ORACLE_CONST = Oracle(address(<span class="hljs-number">0x00000000219ab540356cBB839Cbe05303d7705Fa</span>)); <span class="hljs-comment">// 已知的合约</span><br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">private</span> exchangeRate;<br><br>    <span class="hljs-function">function <span class="hljs-title">buySomething</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        ORACLE_CONST.query(<span class="hljs-string">&quot;USD&quot;</span>, <span class="hljs-keyword">this</span>.oracleResponse);<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">oracleResponse</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> response</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        require(<br>            msg.sender == address(ORACLE_CONST),<br>            <span class="hljs-string">&quot;Only oracle can call this.&quot;</span><br>        );<br>        exchangeRate = response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备注</p><p>Lambda 或内联函数是计划中的，但还不支持。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#reference-types"></a></h2><p>引用类型的值可以通过多个不同的名称进行修改。 这与值类型形成鲜明对比，在值类型的变量被使用时，您会得到一个独立的副本。 正因为如此，对引用类型的处理要比对值类型的处理更加谨慎。目前， 引用类型包括结构、数组和映射。如果您使用一个引用类型， 您必须明确地提供存储该类型的数据区域。 <code>memory</code> （其寿命限于外部函数调用）， <code>storage</code> （存储状态变量的位置，其寿命限于合约的寿命） 或 <code>calldata</code> （包含函数参数的特殊数据位置）。</p><p>改变数据位置的赋值或类型转换将总是导致自动复制操作， 而同一数据位置内的赋值只在某些情况下对存储类型进行复制。</p><h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location"></a></h3><p>每个引用类型都有一个额外的属性，即 “数据位置”， 关于它的存储位置。有三个数据位置。 <code>memory</code>, <code>storage</code> 和 <code>calldata</code>。 Calldata是一个不可修改的、非持久性的区域，用于存储函数参数，其行为主要类似于memory。</p><p>备注</p><p>如果可以的话，尽量使用 <code>calldata</code> 作为数据位置，因为这样可以避免复制， 也可以确保数据不能被修改。使用 <code>calldata</code> 数据位置的数组和结构也可以从函数中返回， 但不可能分配这种类型。</p><p>备注</p><p>在0.6.9版本之前，引用型参数的数据位置被限制在外部函数中的 <code>calldata</code>， 公开函数中的 <code>memory</code>，以及内部和私有函数中的 <code>memory</code> 或 <code>storage</code>。 现在 <code>memory</code> 和 <code>calldata</code> 在所有函数中都被允许使用，无论其可见性如何。</p><p>备注</p><p>在0.5.0版本之前，数据位置可以省略，并且会根据变量的种类、函数类型等默认为不同的位置， 但现在所有的复杂类型都必须给出一个明确的数据位置。</p><h4 id="数据位置和分配行为"><a href="#数据位置和分配行为" class="headerlink" title="数据位置和分配行为"></a>数据位置和分配行为<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#data-location-assignment"></a></h4><p>数据位置不仅与数据的持久性有关，而且也与分配的语义有关：</p><ul><li>在 <code>storage</code> 和 <code>memory</code> 之间的分配（或从 <code>calldata</code> 中分配） 总是创建一个独立的拷贝。</li><li>从 <code>memory</code> 到 <code>memory</code> 的赋值只创建引用。 这意味着对一个内存变量的改变在所有其他引用相同数据的内存变量中也是可见的。</li><li>从 <code>storage</code> 到 <strong>local</strong> 存储变量的赋值也只赋值一个引用。</li><li>所有其他对 <code>storage</code> 的赋值总是拷贝的。 这种情况的例子是对状态变量或存储结构类型的局部变量成员的赋值， 即使局部变量本身只是一个引用。</li></ul><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyB4IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBzdG9yYWdl44CCCiAgICAvLyDov5nmmK/llK/kuIDlj6/ku6XnnIHnlaXmlbDmja7kvY3nva7nmoTlnLDmlrnjgIIKICAgIHVpbnRbXSB4OwoKICAgIC8vIG1lbW9yeUFycmF5IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBtZW1vcnnjgIIKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIOWwhuaVtOS4quaVsOe7hOaLt+i0neWIsCBzdG9yYWdlIOS4re+8jOWPr+ihjAogICAgICAgIHVpbnRbXSBzdG9yYWdlIHkgPSB4OyAvLyDliIbphY3kuIDkuKrmjIfpkojvvIzlhbbkuK0geSDnmoTmlbDmja7lrZjlgqjkvY3nva7mmK8gc3RvcmFnZe+8jOWPr+ihjAogICAgICAgIHlbN107IC8vIOi/lOWbnuesrCA4IOS4quWFg+e0oO+8jOWPr+ihjAogICAgICAgIHkucG9wKCk7IC8vIOmAmui/h3nkv67mlLl477yM5Y+v6KGMCiAgICAgICAgZGVsZXRlIHg7IC8vIOa4hemZpOaVsOe7hO+8jOWQjOaXtuS/ruaUuSB577yM5Y+v6KGMCiAgICAgICAgLy8g5LiL6Z2i55qE5bCx5LiN5Y+v6KGM5LqG77yb6ZyA6KaB5ZyoIHN0b3JhZ2Ug5Lit5Yib5bu65paw55qE5pyq5ZG95ZCN55qE5Li05pe25pWw57uE77yMLwogICAgICAgIC8vIOS9hiBzdG9yYWdlIOaYr+KAnOmdmeaAgeKAneWIhumFjeeahO+8mgogICAgICAgIC8vIHkgPSBtZW1vcnlBcnJheTsKICAgICAgICAvLyDlkIzmoLfvvIwgImRlbGV0ZSB5IiDkuZ/mmK/ml6DmlYjnmoTvvIwKICAgICAgICAvLyDlm6DkuLrlr7nlvJXnlKjlrZjlgqjlr7nosaHnmoTlsYDpg6jlj5jph4/nmoTotYvlgLzlj6rog73ku47njrDmnInnmoTlrZjlgqjlr7nosaHkuK3ov5vooYzjgIIKICAgICAgICAvLyDlroPlsIYg4oCc6YeN572u4oCdIOaMh+mSiO+8jOS9huayoeacieS7u+S9leWQiOeQhueahOS9jee9ruWPr+S7peaMh+WQkeWug+OAggogICAgICAgIC8vIOabtOWkmue7huiKguingSAiZGVsZXRlIiDmk43kvZznrKbnmoTmlofmoaPjgIIKICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyDosIPnlKggZyDlh73mlbDvvIzlkIzml7bnp7vkuqTlr7kgeCDnmoTlvJXnlKgKICAgICAgICBoKHgpOyAvLyDosIPnlKggaCDlh73mlbDvvIzlkIzml7blnKggbWVtb3J5IOS4reWIm+W7uuS4gOS4queLrOeri+eahOS4tOaXtuaLt+i0nQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.5</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-comment">// x 的数据存储位置是 storage。</span><br>    <span class="hljs-comment">// 这是唯一可以省略数据位置的地方。</span><br>    <span class="hljs-built_in">uint</span>[] x;<br><br>    <span class="hljs-comment">// memoryArray 的数据存储位置是 memory。</span><br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span>[] memory memoryArray) <span class="hljs-keyword">public</span> &#123;<br>        x = memoryArray; <span class="hljs-comment">// 将整个数组拷贝到 storage 中，可行</span><br>        <span class="hljs-built_in">uint</span>[] storage y = x; <span class="hljs-comment">// 分配一个指针，其中 y 的数据存储位置是 storage，可行</span><br>        y[<span class="hljs-number">7</span>]; <span class="hljs-comment">// 返回第 8 个元素，可行</span><br>        y.pop(); <span class="hljs-comment">// 通过y修改x，可行</span><br>        <span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 清除数组，同时修改 y，可行</span><br>        <span class="hljs-comment">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，/</span><br>        <span class="hljs-comment">// 但 storage 是“静态”分配的：</span><br>        <span class="hljs-comment">// y = memoryArray;</span><br>        <span class="hljs-comment">// 同样， &quot;delete y&quot; 也是无效的，</span><br>        <span class="hljs-comment">// 因为对引用存储对象的局部变量的赋值只能从现有的存储对象中进行。</span><br>        <span class="hljs-comment">// 它将 “重置” 指针，但没有任何合理的位置可以指向它。</span><br>        <span class="hljs-comment">// 更多细节见 &quot;delete&quot; 操作符的文档。</span><br>        <span class="hljs-comment">// delete y;</span><br>        g(x); <span class="hljs-comment">// 调用 g 函数，同时移交对 x 的引用</span><br>        h(x); <span class="hljs-comment">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span><br>    &#125;<br><br>    <span class="hljs-built_in">function</span> g(<span class="hljs-built_in">uint</span>[] storage) internal <span class="hljs-keyword">pure</span> &#123;&#125;<br>    <span class="hljs-built_in">function</span> h(<span class="hljs-built_in">uint</span>[] memory) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#arrays"></a></h3><p>数组可以在声明时指定长度，也可以动态调整大小。</p><p>一个元素类型为 <code>T</code>，固定长度为 <code>k</code> 的数组可以声明为 <code>T[k]</code>， 而动态数组声明为 <code>T[]</code>。</p><p>例如，一个由5个 <code>uint</code> 的动态数组组成的数组被写成 <code>uint[][5]</code>。 与其他一些语言相比, 这种记法是相反的。 在Solidity中, <code>X[3]</code> 总是一个包含三个 <code>X</code> 类型元素的数组， 即使 <code>X</code> 本身是一个数组。 这在其他语言中是不存在的，如C语言。</p><p>索引是基于零的，访问方向与声明相反。</p><p>例如，如果您有一个变量 <code>uint[][5] memory x</code>，您用 <code>x[2][6]</code> 访问第三个动态数组中的第七个 <code>uint</code>， 要访问第三个动态数组，用 <code>x[2]</code>。同样，如果您有一个数组 <code>T[5] a</code> 的类型 <code>T</code>， 也可以是一个数组，那么 <code>a[2]</code> 总是有类型 <code>T</code>。</p><p>数组元素可以是任何类型，包括映射或结构体。 并适用于类型的一般限制，映射只能存储在 <code>storage</code> 数据位置， 公开可见的函数需要参数是 <a href="https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi">ABI类型</a>。</p><p>可以将状态变量数组标记为 <code>public</code>， 并让Solidity创建一个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">getter</a> 函数。数字索引成为该函数的一个必要参数。</p><p>访问一个超过它的末端的数组会导致一个失败的断言。 方法 <code>.push()</code> 和 <code>.push(value)</code> 可以用来在动态大小的数组末端追加一个新的元素， 其中 <code>.push()</code> 追加一个零初始化的元素并返回它的引用。</p><p>备注</p><p>动态大小的数组只能在存储中调整大小。 在内存中，这样的数组可以是任意大小的，但是一旦分配了数组，就不能改变数组的大小。</p><h4 id="bytes-和-string-类型的数组"><a href="#bytes-和-string-类型的数组" class="headerlink" title="bytes 和 string 类型的数组"></a><code>bytes</code> 和 <code>string</code> 类型的数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#bytes-string"></a></h4><p><code>bytes</code> 和 <code>string</code> 类型的变量是特殊的数组。 <code>bytes</code> 类似于 <code>bytes1[]</code>， 但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 <code>string</code> 与 <code>bytes</code> 相同，但不允许用长度或索引来访问。</p><p>Solidity没有字符串操作函数，但有第三方的字符串库。 您也可以用 <code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code> 来比较两个字符串的keccak256-hash，用 <code>string.concat(s1, s2)</code> 来连接两个字符串。</p><p>您应该使用 <code>bytes</code> 而不是 <code>bytes1[]</code>，因为它更便宜， 因为在 <code>memory</code> 中使用 <code>bytes1[]</code> 会在元素之间增加31个填充字节。 请注意，在 <code>storage</code> 中，由于紧打包，没有填充，参见 <a href="https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#bytes-and-string">字节和字符串</a>。 一般来说，对于任意长度的原始字节数据使用 <code>bytes</code>，对于任意长度的字符串（UTF-8）数据使用 <code>string</code>。 如果您能将长度限制在一定的字节数，总是使用 <code>bytes1</code> 到 <code>bytes32</code> 中的一种值类型，因为它们更便宜。</p><p>备注</p><p>如果想要访问以字节表示的字符串 <code>s</code>， 请使用 <code>bytes(s).length</code> / <code>bytes(s)[7] = &#39;x&#39;;</code>。 注意这时您访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。</p><h4 id="函数-bytes-concat-和-string-concat"><a href="#函数-bytes-concat-和-string-concat" class="headerlink" title="函数 bytes.concat 和 string.concat"></a>函数 <code>bytes.concat</code> 和 <code>string.concat</code><a href="https://docs.soliditylang.org/zh-cn/latest/types.html#bytes-concat-string-concat"></a></h4><p>您可以使用 <code>string.concat</code> 连接任意数量的 <code>string</code> 值。 该函数返回一个单一的 <code>string memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用不能隐式转换为 <code>string</code> 的其他类型的参数，您需要先将它们转换为 <code>string</code>。</p><p>同样， <code>bytes.concat</code> 函数可以连接任意数量的 <code>bytes</code> 或 <code>bytes1 ... bytes32</code> 值。 该函数返回一个单一的 <code>bytes memory</code> 数组，其中包含没有填充的参数内容。 如果您想使用字符串参数或其他不能隐式转换为 <code>bytes</code> 的类型， 您需要先将它们转换为 <code>bytes</code> 或 <code>bytes1</code> /…/ <code>bytes32</code>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// SPDX-License-Identifier: GPL-<span class="hljs-number">3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.12</span>;<br><br><span class="hljs-built_in">contract</span> C &#123;<br>    <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Storage&quot;</span>;<br>    function f(bytes calldata bc, <span class="hljs-built_in">string</span> memory sm, bytes16 b) public <span class="hljs-built_in">view</span> &#123;<br>        <span class="hljs-built_in">string</span> memory concatString = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">concat</span>(s, <span class="hljs-built_in">string</span>(bc), <span class="hljs-string">&quot;Literal&quot;</span>, sm);<br>        assert((bytes(s).<span class="hljs-built_in">length</span> + bc.<span class="hljs-built_in">length</span> + <span class="hljs-number">7</span> + bytes(sm).<span class="hljs-built_in">length</span>) == bytes(concatString).<span class="hljs-built_in">length</span>);<br><br>        bytes memory concatBytes = bytes.<span class="hljs-built_in">concat</span>(bytes(s), bc, bc[:<span class="hljs-number">2</span>], <span class="hljs-string">&quot;Literal&quot;</span>, bytes(sm), b);<br>        assert((bytes(s).<span class="hljs-built_in">length</span> + bc.<span class="hljs-built_in">length</span> + <span class="hljs-number">2</span> + <span class="hljs-number">7</span> + bytes(sm).<span class="hljs-built_in">length</span> + b.<span class="hljs-built_in">length</span>) == concatBytes.<span class="hljs-built_in">length</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您不带参数调用 <code>string.concat</code> 或 <code>bytes.concat</code>，它们会返回一个空数组。</p><h4 id="创建内存数组"><a href="#创建内存数组" class="headerlink" title="创建内存数组"></a>创建内存数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-20"></a></h4><p>具有动态长度的内存数组可以使用 <code>new</code> 操作符创建。 与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code>.push</code> 成员函数不可用）。 您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p><p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a> 进行初始化。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> len) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        <span class="hljs-built_in">uint</span>[] memory a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[](<span class="hljs-number">7</span>);<br>        bytes memory b = <span class="hljs-keyword">new</span> bytes(len);<br>        <span class="hljs-keyword">assert</span>(a.length == <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">assert</span>(b.length == len);<br>        a[<span class="hljs-number">6</span>] = <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组字面常数"><a href="#数组字面常数" class="headerlink" title="数组字面常数"></a>数组字面常数<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-21"></a></h4><p>数组字面常数表达式是一个逗号分隔的一个或多个表达式的列表，用方括号（ <code>[...]</code> ）括起来。 例如， <code>[1, a, f(3)]</code>。数组字面常数的类型确定如下：</p><p>它总是一个静态大小的内存数组，其长度是表达式的数量。</p><p>数组的基本类型是列表上第一个表达式的类型，这样所有其他表达式都可以隐含地转换为它。 如果不能做到这一点，则会有一个类型错误。</p><p>仅仅存在一个所有元素都可以转换的类型是不够的。其中一个元素必须是该类型的。</p><p>在下面的例子中， <code>[1, 2, 3]</code> 的类型是 <code>uint8[3] memory</code>， 因为这些常量的类型都是 <code>uint8</code>。如果您想让结果是 <code>uint[3] memory</code> 类型， 您需要把第一个元素转换为 <code>uint</code>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        g([<span class="hljs-built_in">uint</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-built_in">function</span> g(<span class="hljs-built_in">uint</span>[<span class="hljs-number">3</span>] memory) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>数组表达式 <code>[1, -1]</code> 是无效的，因为第一个表达式的类型是 <code>uint8</code>， 而第二个表达式的类型是 <code>int8</code>，它们不能相互隐式转换。为了使其有效， 例如，您可以使用 <code>[int8(1), -1]</code>。</p><p>由于不同类型的固定大小的内存数组不能相互转换（即使基类可以）， 如果您想使用二维数组字面常数，您必须总是明确指定一个共同的基类：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIOS4i+mdoueahOaWueazleS4jeS8mui1t+S9nOeUqO+8jOWboOS4uuS4gOS6m+WGhemDqOaVsOe7hOeahOexu+Wei+S4jeWvueOAggogICAgICAgIC8vIHVpbnRbMl1bNF0gbWVtb3J5IHggPSBbWzB4MSwgMV0sIFsweGZmZmZmZiwgMl0sIFsweGZmLCAzXSwgWzB4ZmZmZiwgNF1dOwogICAgICAgIHJldHVybiB4OwogICAgfQp9">open in Remix</a></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.16 &lt;0.9.0;<br><br>contract C &#123;<br>    function f() public pure returns (uint24<span class="hljs-comment">[2]</span><span class="hljs-comment">[4]</span> memory) &#123;<br>        uint24<span class="hljs-comment">[2]</span><span class="hljs-comment">[4]</span> memory x = <span class="hljs-comment">[<span class="hljs-comment">[uint24(0x1), 1]</span>, <span class="hljs-comment">[0xffffff, 2]</span>, <span class="hljs-comment">[uint24(0xff), 3]</span>, <span class="hljs-comment">[uint24(0xffff), 4]</span>]</span>;<br>        // 下面的方法不会起作用，因为一些内部数组的类型不对。<br>        // uint<span class="hljs-comment">[2]</span><span class="hljs-comment">[4]</span> memory x = <span class="hljs-comment">[<span class="hljs-comment">[0x1, 1]</span>, <span class="hljs-comment">[0xffffff, 2]</span>, <span class="hljs-comment">[0xff, 3]</span>, <span class="hljs-comment">[0xffff, 4]</span>]</span>;<br>        return x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>固定大小的内存数组不能分配给动态大小的内存数组，也就是说，以下情况是不可能的：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8g6L+Z5LiN5Lya6KKr57yW6K+R44CCCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyB7CiAgICAgICAgLy8g5LiL5LiA6KGM5Lya5Lqn55Sf5LiA5Liq57G75Z6L6ZSZ6K+v77yM5Zug5Li6dWludFszXeWGheWtmOS4jeiDveiiq+i9rOaNouS4unVpbnRbXeWGheWtmOOAggogICAgICAgIHVpbnRbXSBtZW1vcnkgeCA9IFt1aW50KDEpLCAzLCA0XTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这不会被编译。</span><br>contract C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// 下一行会产生一个类型错误，因为uint[3]内存不能被转换为uint[]内存。</span><br>        <span class="hljs-built_in">uint</span>[] memory x = [<span class="hljs-built_in">uint</span>(<span class="hljs-number">1</span>), <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计划在将来取消这一限制，但由于ABI中数组的传递方式，它产生了一些复杂的问题。</p><p>如果您想初始化动态大小的数组，您必须分配各个元素：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.16</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        <span class="hljs-built_in">uint</span>[] memory x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[](<span class="hljs-number">3</span>);<br>        x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        x[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>        x[<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#array-members"></a></h4><ul><li><p><strong>length</strong>:</p><p>数组有 <code>length</code> 成员变量表示当前数组的长度。一经创建， 内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。</p></li><li><p><strong>push()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push()</code> 的成员函数， 您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用， 因此可以像 <code>x.push().t = 2</code> 或 <code>x.push() = b</code> 那样使用。</p></li><li><p><strong>push(x)</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>push(x)</code> 的成员函数， 您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p></li><li><p><strong>pop()</strong>:</p><p>动态存储数组和 <code>bytes</code> （不是 <code>string</code> ）有一个叫 <code>pop()</code> 的成员函数， 您可以用它来从数组的末端移除一个元素。 这也隐含地在被删除的元素上调用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete">delete</a>。该函数不返回任何东西。</p></li></ul><p>备注</p><p>通过调用 <code>push()</code> 增加存储数组的长度有恒定的燃料成本，因为存储是零初始化的， 而通过调用 <code>pop()</code> 减少长度的成本取决于被移除元素的 “大小”。 如果该元素是一个数组，它的成本可能非常高， 因为它包括明确地清除被移除的元素，类似于对它们调用 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete">delete</a>。</p><p>备注</p><p>要在外部（而不是公开）函数中使用数组的数组， 您需要激活ABI coder v2。</p><p>备注</p><p>在Byzantium之前的EVM版本中，不能访问从函数调用返回的动态数组。 如果您调用返回动态数组的函数，请确保使用设置为Byzantium模式的EVM。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIOivt+azqOaEj++8jOS4i+mdouS4jeaYr+S4gOWvueWKqOaAgeaVsOe7hO+8jAogICAgLy8g6ICM5piv5LiA5Liq5Yqo5oCB5pWw57uE5a+577yI5Y2z6ZW/5bqm5Li6MueahOWbuuWumuWkp+Wwj+aVsOe7hO+8ieOAggogICAgLy8g5ZyoIFNvbGlkaXR5IOS4re+8jFRba13lkoxUW13mgLvmmK/lhbfmnIlU57G75Z6L5YWD57Sg55qE5pWw57uE77yMCiAgICAvLyDljbPkvb9U5pys6Lqr5piv5LiA5Liq5pWw57uE44CCCiAgICAvLyDmraPlm6DkuLrlpoLmraTvvIxib29sWzJdW13mmK/kuIDkuKrliqjmgIHmlbDnu4Tlr7nvvIzlhbblhYPntKDmmK9ib29sWzJd44CCCiAgICAvLyDov5nkuI7lhbbku5bor63oqIDkuI3lkIzvvIzmr5TlpoJD77yMCiAgICAvLyDmiYDmnInnirbmgIHlj5jph4/nmoTmlbDmja7kvY3nva7pg73mmK/lrZjlgqjjgIIKICAgIGJvb2xbMl1bXSBwYWlyc09mRmxhZ3M7CgogICAgLy8gbmV3UGFpcnPooqvlrZjlgqjlnKhtZW1vcnnkuK0tLei/meaYr+WFrOW8gOWQiOe6puWHveaVsOWPguaVsOeahOWUr+S4gOWPr+iDveaAp+OAggogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8g6LWL5YC85Yiw5LiA5Liq5a2Y5YKo5pWw57uE5Lya5omn6KGMIGBgbmV3UGFpcnNgYCDnmoTmi7fotJ3vvIwKICAgICAgICAvLyDlubbmm7/mjaLlrozmlbTnmoTmlbDnu4QgYGBwYWlyc09mRmxhZ3NgYOOAggogICAgICAgIHBhaXJzT2ZGbGFncyA9IG5ld1BhaXJzOwogICAgfQoKICAgIHN0cnVjdCBTdHJ1Y3RUeXBlIHsKICAgICAgICB1aW50W10gY29udGVudHM7CiAgICAgICAgdWludCBtb3JlSW5mbzsKICAgIH0KICAgIFN0cnVjdFR5cGUgczsKCiAgICBmdW5jdGlvbiBmKHVpbnRbXSBtZW1vcnkgYykgcHVibGljIHsKICAgICAgICAvLyDlnKggYGBnYGAg5Lit5a2Y5YKo5LiA5Liq5a+5IGBgc2BgIOeahOW8leeUqOOAggogICAgICAgIFN0cnVjdFR5cGUgc3RvcmFnZSBnID0gczsKICAgICAgICAvLyDkuZ/mlLnlj5jkuoYgYGBzLm1vcmVJbmZvYGAuCiAgICAgICAgZy5tb3JlSW5mbyA9IDI7CiAgICAgICAgLy8g5oyH5a6a5LiA5Liq5ou36LSd77yM5Zug5Li6IGBgZy5jb250ZW50c2BgIOS4jeaYr+S4gOS4quWxgOmDqOWPmOmHj++8jAogICAgICAgIC8vIOiAjOaYr+S4gOS4quWxgOmDqOWPmOmHj+eahOaIkOWRmOOAggogICAgICAgIGcuY29udGVudHMgPSBjOwogICAgfQoKICAgIGZ1bmN0aW9uIHNldEZsYWdQYWlyKHVpbnQgaW5kZXgsIGJvb2wgZmxhZ0EsIGJvb2wgZmxhZ0IpIHB1YmxpYyB7CiAgICAgICAgLy8g6K6/6Zeu5LiA5Liq5LiN5a2Y5Zyo55qE5pWw57uE57Si5byV5Lya5byV5Y+R5LiA5Liq5byC5bi4CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVswXSA9IGZsYWdBOwogICAgICAgIHBhaXJzT2ZGbGFnc1tpbmRleF1bMV0gPSBmbGFnQjsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VGbGFnQXJyYXlTaXplKHVpbnQgbmV3U2l6ZSkgcHVibGljIHsKICAgICAgICAvLyDkvb/nlKhwdXNo5ZKMcG9w5piv5pS55Y+Y5pWw57uE6ZW/5bqm55qE5ZSv5LiA5pa55rOV44CCCiAgICAgICAgaWYgKG5ld1NpemUgPCBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoID4gbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wb3AoKTsKICAgICAgICB9IGVsc2UgaWYgKG5ld1NpemUgPiBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoIDwgbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wdXNoKCk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGNsZWFyKCkgcHVibGljIHsKICAgICAgICAvLyDov5nkupvlrozlhajmuIXpmaTkuobmlbDnu4QKICAgICAgICBkZWxldGUgcGFpcnNPZkZsYWdzOwogICAgICAgIGRlbGV0ZSBhTG90T2ZJbnRlZ2VyczsKICAgICAgICAvLyDov5nph4zmnInnm7jlkIznmoTmlYjmnpwKICAgICAgICBwYWlyc09mRmxhZ3MgPSBuZXcgYm9vbFsyXVtdKDApOwogICAgfQoKICAgIGJ5dGVzIGJ5dGVEYXRhOwoKICAgIGZ1bmN0aW9uIGJ5dGVBcnJheXMoYnl0ZXMgbWVtb3J5IGRhdGEpIHB1YmxpYyB7CiAgICAgICAgLy8g5a2X6IqC5pWw57uE77yIImJ5dGUi77yJ5piv5LiN5ZCM55qE77yM5Zug5Li65a6D5Lus55qE5a2Y5YKo5rKh5pyJ5aGr5YWF77yMCiAgICAgICAgLy8g5L2G5Y+v5Lul5LiOICJ1aW50OFtdIuebuOWQjOOAggogICAgICAgIGJ5dGVEYXRhID0gZGF0YTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCA3OyBpKyspCiAgICAgICAgICAgIGJ5dGVEYXRhLnB1c2goKTsKICAgICAgICBieXRlRGF0YVszXSA9IDB4MDg7CiAgICAgICAgZGVsZXRlIGJ5dGVEYXRhWzJdOwogICAgfQoKICAgIGZ1bmN0aW9uIGFkZEZsYWcoYm9vbFsyXSBtZW1vcnkgZmxhZykgcHVibGljIHJldHVybnMgKHVpbnQpIHsKICAgICAgICBwYWlyc09mRmxhZ3MucHVzaChmbGFnKTsKICAgICAgICByZXR1cm4gcGFpcnNPZkZsYWdzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlBcnJheSh1aW50IHNpemUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIOS9v+eUqCBgbmV3YCDliJvlu7rliqjmgIEgbWVtb3J5IOaVsOe7hO+8mgogICAgICAgIHVpbnRbMl1bXSBtZW1vcnkgYXJyYXlPZlBhaXJzID0gbmV3IHVpbnRbMl1bXShzaXplKTsKCiAgICAgICAgLy8g5YaF6IGU5pWw57uE5oC75piv6Z2Z5oCB5aSn5bCP55qE77yM5aaC5p6c5oKo5Y+q5L2/55So5a2X6Z2i5bi45pWw6KGo6L6+5byP77yM5oKo5b+F6aG76Iez5bCR5o+Q5L6b5LiA56eN57G75Z6L44CCCiAgICAgICAgYXJyYXlPZlBhaXJzWzBdID0gW3VpbnQoMSksIDJdOwoKICAgICAgICAvLyDliJvlu7rkuIDkuKrliqjmgIHlrZfoioLmlbDnu4TvvJoKICAgICAgICBieXRlcyBtZW1vcnkgYiA9IG5ldyBieXRlcygyMDApOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGJbaV0gPSBieXRlczEodWludDgoaSkpOwogICAgICAgIHJldHVybiBiOwogICAgfQp9">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract ArrayContract &#123;<br>    <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>**<span class="hljs-number">20</span>] aLotOfIntegers;<br>    <span class="hljs-comment">// 请注意，下面不是一对动态数组，</span><br>    <span class="hljs-comment">// 而是一个动态数组对（即长度为2的固定大小数组）。</span><br>    <span class="hljs-comment">// 在 Solidity 中，T[k]和T[]总是具有T类型元素的数组，</span><br>    <span class="hljs-comment">// 即使T本身是一个数组。</span><br>    <span class="hljs-comment">// 正因为如此，bool[2][]是一个动态数组对，其元素是bool[2]。</span><br>    <span class="hljs-comment">// 这与其他语言不同，比如C，</span><br>    <span class="hljs-comment">// 所有状态变量的数据位置都是存储。</span><br>    <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>][] pairsOfFlags;<br><br>    <span class="hljs-comment">// newPairs被存储在memory中--这是公开合约函数参数的唯一可能性。</span><br>    <span class="hljs-built_in">function</span> setAllFlagPairs(<span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>][] memory newPairs) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 赋值到一个存储数组会执行 ``newPairs`` 的拷贝，</span><br>        <span class="hljs-comment">// 并替换完整的数组 ``pairsOfFlags``。</span><br>        pairsOfFlags = newPairs;<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> StructType &#123;<br>        <span class="hljs-built_in">uint</span>[] contents;<br>        <span class="hljs-built_in">uint</span> moreInfo;<br>    &#125;<br>    StructType s;<br><br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span>[] memory c) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 在 ``g`` 中存储一个对 ``s`` 的引用。</span><br>        StructType storage g = s;<br>        <span class="hljs-comment">// 也改变了 ``s.moreInfo``.</span><br>        g.moreInfo = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 指定一个拷贝，因为 ``g.contents`` 不是一个局部变量，</span><br>        <span class="hljs-comment">// 而是一个局部变量的成员。</span><br>        g.contents = c;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> setFlagPair(<span class="hljs-built_in">uint</span> index, <span class="hljs-built_in">bool</span> flagA, <span class="hljs-built_in">bool</span> flagB) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 访问一个不存在的数组索引会引发一个异常</span><br>        pairsOfFlags[index][<span class="hljs-number">0</span>] = flagA;<br>        pairsOfFlags[index][<span class="hljs-number">1</span>] = flagB;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeFlagArraySize(<span class="hljs-built_in">uint</span> newSize) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 使用push和pop是改变数组长度的唯一方法。</span><br>        <span class="hljs-keyword">if</span> (newSize &lt; pairsOfFlags.length) &#123;<br>            <span class="hljs-keyword">while</span> (pairsOfFlags.length &gt; newSize)<br>                pairsOfFlags.pop();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newSize &gt; pairsOfFlags.length) &#123;<br>            <span class="hljs-keyword">while</span> (pairsOfFlags.length &lt; newSize)<br>                pairsOfFlags.push();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> clear() <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 这些完全清除了数组</span><br>        <span class="hljs-keyword">delete</span> pairsOfFlags;<br>        <span class="hljs-keyword">delete</span> aLotOfIntegers;<br>        <span class="hljs-comment">// 这里有相同的效果</span><br>        pairsOfFlags = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>][](<span class="hljs-number">0</span>);<br>    &#125;<br><br>    bytes byteData;<br><br>    <span class="hljs-built_in">function</span> byteArrays(bytes memory data) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// 字节数组（&quot;byte&quot;）是不同的，因为它们的存储没有填充，</span><br>        <span class="hljs-comment">// 但可以与 &quot;uint8[]&quot;相同。</span><br>        byteData = data;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++)<br>            byteData.push();<br>        byteData[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>x08;<br>        <span class="hljs-keyword">delete</span> byteData[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> addFlag(<span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>] memory flag) <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        pairsOfFlags.push(flag);<br>        <span class="hljs-keyword">return</span> pairsOfFlags.length;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> createMemoryArray(<span class="hljs-built_in">uint</span> size) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (bytes memory) &#123;<br>        <span class="hljs-comment">// 使用 `new` 创建动态 memory 数组：</span><br>        <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>][] memory arrayOfPairs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>][](size);<br><br>        <span class="hljs-comment">// 内联数组总是静态大小的，如果您只使用字面常数表达式，您必须至少提供一种类型。</span><br>        arrayOfPairs[<span class="hljs-number">0</span>] = [<span class="hljs-built_in">uint</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 创建一个动态字节数组：</span><br>        bytes memory b = <span class="hljs-keyword">new</span> bytes(<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++)<br>            b[i] = bytes1(uint8(i));<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对存储数组元素的悬空引用（Dangling-References）"><a href="#对存储数组元素的悬空引用（Dangling-References）" class="headerlink" title="对存储数组元素的悬空引用（Dangling References）"></a>对存储数组元素的悬空引用（Dangling References）<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#dangling-references"></a></h4><p>当使用存储数组时，您需要注意避免悬空引用。 悬空引用是指一个指向不再存在的或已经被移动而未更新引用的内容的引用。 例如，如果您将一个数组元素的引用存储在一个局部变量中， 然后从包含数组中使用 <code>.pop()</code>，就可能发生悬空引用：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIOWtmOWCqOS4gOS4quaMh+WQkXPnmoTmnIDlkI7kuIDkuKrmlbDnu4TlhYPntKDnmoTmjIfpkojjgIIKICAgICAgICB1aW50W10gc3RvcmFnZSBwdHIgPSBzW3MubGVuZ3RoIC0gMV07CiAgICAgICAgLy8g5Yig6Zmkc+eahOacgOWQjuS4gOS4quaVsOe7hOWFg+e0oOOAggogICAgICAgIHMucG9wKCk7CiAgICAgICAgLy8g5YaZ5YWl5bey5LiN5Zyo5pWw57uE5YaF55qE5pWw57uE5YWD57Sg44CCCiAgICAgICAgcHRyLnB1c2goMHg0Mik7CiAgICAgICAgLy8g546w5Zyo5ZCRIGBgc2BgIOa3u+WKoOS4gOS4quaWsOWFg+e0oOS4jeS8mua3u+WKoOS4gOS4quepuuaVsOe7hO+8jAogICAgICAgIC8vIOiAjOaYr+S8muS6p+eUn+S4gOS4qumVv+W6puS4ujHnmoTmlbDnu4TvvIzlhYPntKDkuLogYGAweDQyYGDjgIIKICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9">open in Remix</a></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint[][] s;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">public</span> &#123;<br>        <span class="hljs-comment">// 存储一个指向s的最后一个数组元素的指针。</span><br>        uint[] storage ptr = s[s.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 删除s的最后一个数组元素。</span><br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 写入已不在数组内的数组元素。</span><br>        ptr.<span class="hljs-built_in">push</span>(<span class="hljs-number">0x42</span>);<br>        <span class="hljs-comment">// 现在向 ``s`` 添加一个新元素不会添加一个空数组，</span><br>        <span class="hljs-comment">// 而是会产生一个长度为1的数组，元素为 ``0x42``。</span><br>        s.<span class="hljs-built_in">push</span>();<br>        assert(s[s.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0x42</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ptr.push(0x42)</code> 中的写法 <strong>不会</strong> 恢复操作，尽管 <code>ptr</code> 不再指向 <code>s</code> 的一个有效元素。 由于编译器假定未使用的存储空间总是被清零， 随后的 <code>s.push()</code> 不会明确地将零写入存储空间， 所以在 <code>push()</code> 之后， <code>s</code> 的最后一个元素的长度是 <code>1</code>， 并且包含 <code>0x42</code> 作为其第一个元素。</p><p>注意，Solidity 不允许在存储中声明对值类型的引用。 这类显式的悬空引用被限制在嵌套引用类型中。然而， 当在数组赋值中使用复杂表达式时，悬空引用也会短暂发生：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8g5ZCR5a2Y5YKo5pWw57uE5o6o6YCB5LiA5Lqb5Yid5aeL5YC844CCCiAgICAgICAgcy5wdXNoKDB4MDcpOwogICAgICAgIHQucHVzaCgweDAzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgaW50ZXJuYWwgcmV0dXJucyAodWludFtdIHN0b3JhZ2UpIHsKICAgICAgICBzLnBvcCgpOwogICAgICAgIHJldHVybiB0OwogICAgfQoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIC8vIOS4i+mdouWwhummluWFiOivhOS8sCBgYHMucHVzaCgpYCDliLDkuIDkuKrntKLlvJXkuLox55qE5paw5YWD57Sg55qE5byV55So44CCCiAgICAgICAgLy8g5LmL5ZCO77yM6LCD55SoIGBgZ2BgIOW8ueWHuui/meS4quaWsOWFg+e0oO+8jAogICAgICAgIC8vIOWvvOiHtOacgOW3pui+ueeahOWFg+e7hOWFg+e0oOaIkOS4uuS4gOS4quaCrOepuueahOW8leeUqOOAggogICAgICAgIC8vIOi1i+WAvOS7jeeEtuWPkeeUn++8jOW5tuWwhuWGmeWFpSBgYHNgYCDnmoTmlbDmja7ljLrln5/kuYvlpJbjgIIKICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8g6ZqP5ZCO5a+5IGBgc2BgIOeahOaOqOmAgeWwhuaYvuekuuWJjeS4gOS4quivreWPpeWGmeWFpeeahOWAvO+8jAogICAgICAgIC8vIOWNs+WcqOi/meS4quWHveaVsOe7k+adn+aXtiBgYHNgYCDnmoTmnIDlkI7kuIDkuKrlhYPntKDlsIbmnIkgYGAweDQyYGAg55qE5YC844CCCiAgICAgICAgcy5wdXNoKCk7CiAgICAgICAgcmV0dXJuIHM7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint[] s;<br>    uint[] t;<br>    constructor() &#123;<br>        <span class="hljs-comment">// 向存储数组推送一些初始值。</span><br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-number">0x07</span>);<br>        t.<span class="hljs-built_in">push</span>(<span class="hljs-number">0x03</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">internal</span> <span class="hljs-title function_">returns</span> (<span class="hljs-params">uint[] storage</span>) &#123;<br>        s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">public</span> <span class="hljs-title function_">returns</span> (<span class="hljs-params">uint[] memory</span>) &#123;<br>        <span class="hljs-comment">// 下面将首先评估 ``s.push()` 到一个索引为1的新元素的引用。</span><br>        <span class="hljs-comment">// 之后，调用 ``g`` 弹出这个新元素，</span><br>        <span class="hljs-comment">// 导致最左边的元组元素成为一个悬空的引用。</span><br>        <span class="hljs-comment">// 赋值仍然发生，并将写入 ``s`` 的数据区域之外。</span><br>        (s.<span class="hljs-built_in">push</span>(), g()[<span class="hljs-number">0</span>]) = (<span class="hljs-number">0x42</span>, <span class="hljs-number">0x17</span>);<br>        <span class="hljs-comment">// 随后对 ``s`` 的推送将显示前一个语句写入的值，</span><br>        <span class="hljs-comment">// 即在这个函数结束时 ``s`` 的最后一个元素将有 ``0x42`` 的值。</span><br>        s.<span class="hljs-built_in">push</span>();<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每条语句只对存储进行一次赋值，并避免在赋值的左侧使用复杂的表达式，这样做总是比较安全的。</p><p>您需要特别小心处理对 <code>bytes</code> 数组元素的引用， 因为 bytes 数组的 <code>.push()</code> 操作可能会 <a href="https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#bytes-and-string">在存储中从短布局切换到长布局</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8g6L+Z5bCG5oql5ZGK5LiA5Liq6K2m5ZGKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgeCA9ICIwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkiOwoKICAgIGZ1bmN0aW9uIHRlc3QoKSBleHRlcm5hbCByZXR1cm5zKHVpbnQpIHsKICAgICAgICAoeC5wdXNoKCksIHgucHVzaCgpKSA9ICgweDAxLCAweDAyKTsKICAgICAgICByZXR1cm4geC5sZW5ndGg7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 这将报告一个警告</span><br>contract C &#123;<br>    bytes x = <span class="hljs-string">&quot;012345678901234567890123456789&quot;</span>;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span>(<span class="hljs-params">uint</span>) &#123;<br>        (x.<span class="hljs-built_in">push</span>(), x.<span class="hljs-built_in">push</span>()) = (<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>);<br>        <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">length</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，当第一个 <code>x.push()</code> 被运算时， <code>x</code> 仍然被存储在短布局中， 因此 <code>x.push()</code> 返回对 <code>x</code> 的第一个存储槽中元素的引用。 然而，第二个 <code>x.push()</code> 将字节数组切换为长布局。 现在 <code>x.push()</code> 所指的元素在数组的数据区， 而引用仍然指向它原来的位置，现在它是长度字段的一部分， 赋值将有效地扰乱 <code>x</code> 的长度。 为了安全起见，在一次赋值中最多只放大字节数组中的一个元素， 不要在同一语句中同时对数组进行索引存取。</p><p>虽然上面描述了当前版本的编译器中悬空存储引用的行为， 但任何带有悬空引用的代码都应被视为具有 <em>未定义行为</em>。 特别的是，这意味着任何未来版本的编译器都可能改变涉及悬空引用的代码的行为。</p><p>请确保避免在您的代码中出现悬空引用。</p><h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#array-slices"></a></h3><p>数组切片是对一个数组的连续部分的预览。 它们被写成 <code>x[start:end]</code>，其中 <code>start</code> 和 <code>end</code> 是表达式， 结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code>x[start]</code>， 最后一个元素是 <code>x[end - 1]</code>。</p><p>如果 <code>start</code> 大于 <code>end</code>，或者 <code>end</code> 大于数组的长度， 就会出现异常。</p><p><code>start</code> 和 <code>end</code> 都是可选的： <code>start</code> 默认为 <code>0</code>， <code>end</code> 默认为数组的长度。</p><p>数组切片没有任何成员。它们可以隐含地转换为其底层类型的数组并支持索引访问。 索引访问在底层数组中不是绝对的，而是相对于分片的开始。</p><p>数组切片没有类型名，这意味着任何变量都不能以数组切片为类型， 它们只存在于中间表达式中。</p><p>备注</p><p>到现在为止，数组切片只有calldata数组可以实现。</p><p>数组切片对于ABI解码在函数参数中传递的二级数据很有用：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiDnlLHku6PnkIbnrqHnkIbnmoTlrqLmiLflkIjnuqbnmoTlnLDlnYDvvIzljbPmnKzlkIjnuqbnmoTlnLDlnYAKICAgIGFkZHJlc3MgY2xpZW50OwoKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgY2xpZW50XykgewogICAgICAgIGNsaWVudCA9IGNsaWVudF87CiAgICB9CgogICAgLy8vIOi9rOWPkeWvuSAic2V0T3duZXIoYWRkcmVzcykiIOeahOiwg+eUqO+8jAogICAgLy8vIOivpeiwg+eUqOWcqOWvueWcsOWdgOWPguaVsOi/m+ihjOWfuuacrOmqjOivgeWQjueUseWuouaIt+err+aJp+ihjOOAggogICAgZnVuY3Rpb24gZm9yd2FyZChieXRlcyBjYWxsZGF0YSBwYXlsb2FkKSBleHRlcm5hbCB7CiAgICAgICAgYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkWzo0XSk7CiAgICAgICAgLy8g55Sx5LqO5oiq5pat6KGM5Li677yMYnl0ZXM0KHBheWxvYWQp55qE6KGo546w5piv55u45ZCM55qE44CCCiAgICAgICAgLy8gYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkKTsKICAgICAgICBpZiAoc2lnID09IGJ5dGVzNChrZWNjYWsyNTYoInNldE93bmVyKGFkZHJlc3MpIikpKSB7CiAgICAgICAgICAgIGFkZHJlc3Mgb3duZXIgPSBhYmkuZGVjb2RlKHBheWxvYWRbNDpdLCAoYWRkcmVzcykpOwogICAgICAgICAgICByZXF1aXJlKG93bmVyICE9IGFkZHJlc3MoMCksICJBZGRyZXNzIG9mIG93bmVyIGNhbm5vdCBiZSB6ZXJvLiIpOwogICAgICAgIH0KICAgICAgICAoYm9vbCBzdGF0dXMsKSA9IGNsaWVudC5kZWxlZ2F0ZWNhbGwocGF5bG9hZCk7CiAgICAgICAgcmVxdWlyZShzdGF0dXMsICJGb3J3YXJkZWQgY2FsbCBmYWlsZWQuIik7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.5</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br>contract <span class="hljs-title class_">Proxy</span> &#123;<br>    <span class="hljs-comment">/// @dev 由代理管理的客户合约的地址，即本合约的地址</span><br>    address client;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address client_</span>) &#123;<br>        client = client_;<br>    &#125;<br><br>    <span class="hljs-comment">/// 转发对 &quot;setOwner(address)&quot; 的调用，</span><br>    <span class="hljs-comment">/// 该调用在对地址参数进行基本验证后由客户端执行。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">bytes calldata payload</span>) external &#123;<br>        bytes4 sig = <span class="hljs-title function_">bytes4</span>(payload[:<span class="hljs-number">4</span>]);<br>        <span class="hljs-comment">// 由于截断行为，bytes4(payload)的表现是相同的。</span><br>        <span class="hljs-comment">// bytes4 sig = bytes4(payload);</span><br>        <span class="hljs-keyword">if</span> (sig == <span class="hljs-title function_">bytes4</span>(<span class="hljs-title function_">keccak256</span>(<span class="hljs-string">&quot;setOwner(address)&quot;</span>))) &#123;<br>            address owner = abi.<span class="hljs-title function_">decode</span>(payload[<span class="hljs-number">4</span>:], (address));<br>            <span class="hljs-built_in">require</span>(owner != <span class="hljs-title function_">address</span>(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;Address of owner cannot be zero.&quot;</span>);<br>        &#125;<br>        (bool status,) = client.<span class="hljs-title function_">delegatecall</span>(payload);<br>        <span class="hljs-built_in">require</span>(status, <span class="hljs-string">&quot;Forwarded call failed.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#structs"></a></h3><p>Solidity 提供了一种以结构形式定义新类型的方法，以下是一个结构体使用的示例：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g5a6a5LmJ5LiA5Liq5YyF5ZCr5Lik5Liq5bGe5oCn55qE5paw57G75Z6L44CCCi8vIOWcqOWQiOe6puS5i+WkluWjsOaYjuS4gOS4que7k+aehO+8jAovLyDlj6/ku6XorqnlroPooqvlpJrkuKrlkIjnuqbmiYDlhbHkuqvjgIIKLy8g5Zyo6L+Z6YeM77yM6L+Z5bm25LiN5piv55yf55qE6ZyA6KaB44CCCnN0cnVjdCBGdW5kZXIgewogICAgYWRkcmVzcyBhZGRyOwogICAgdWludCBhbW91bnQ7Cn0KCmNvbnRyYWN0IENyb3dkRnVuZGluZyB7CiAgICAvLyDnu5PmnoTkvZPkuZ/lj6/ku6XooqvlrprkuYnlnKjlkIjnuqblhoXpg6jvvIzov5nkvb/lvpflroPku6zlj6rlnKjmnKzlkIjnuqblkozmtL7nlJ/lkIjnuqbkuK3lj6/op4HjgIIKICAgIHN0cnVjdCBDYW1wYWlnbiB7CiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5OwogICAgICAgIHVpbnQgZnVuZGluZ0dvYWw7CiAgICAgICAgdWludCBudW1GdW5kZXJzOwogICAgICAgIHVpbnQgYW1vdW50OwogICAgICAgIG1hcHBpbmcodWludCA9PiBGdW5kZXIpIGZ1bmRlcnM7CiAgICB9CgogICAgdWludCBudW1DYW1wYWlnbnM7CiAgICBtYXBwaW5nKHVpbnQgPT4gQ2FtcGFpZ24pIGNhbXBhaWduczsKCiAgICBmdW5jdGlvbiBuZXdDYW1wYWlnbihhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnksIHVpbnQgZ29hbCkgcHVibGljIHJldHVybnMgKHVpbnQgY2FtcGFpZ25JRCkgewogICAgICAgIGNhbXBhaWduSUQgPSBudW1DYW1wYWlnbnMrKzsgLy8gY2FtcGFpZ25JRCDkvZzkuLrkuIDkuKrlj5jph4/ov5Tlm54KICAgICAgICAvLyDmiJHku6zkuI3og73kvb/nlKggImNhbXBhaWduc1tjYW1wYWlnbklEXSA9IENhbXBhaWduKGJlbmVmaWNpYXJ5LCBnb2FsLCAwLCAwKSIKICAgICAgICAvLyDlm6DkuLrlj7PkvqfliJvlu7rkuobkuIDkuKrlhoXlrZjnu5PmnoQgIkNhbXBhaWduIu+8jOWFtuS4reWMheWQq+S4gOS4quaYoOWwhOOAggogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICBjLmJlbmVmaWNpYXJ5ID0gYmVuZWZpY2lhcnk7CiAgICAgICAgYy5mdW5kaW5nR29hbCA9IGdvYWw7CiAgICB9CgogICAgZnVuY3Rpb24gY29udHJpYnV0ZSh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgLy8g5Lul57uZ5a6a55qE5YC85Yid5aeL5YyW77yM5Yib5bu65LiA5Liq5paw55qE5Li05pe2IG1lbW9yeSDnu5PmnoTkvZPvvIwKICAgICAgICAvLyDlubblsIblhbbmi7fotJ3liLAgc3RvcmFnZSDkuK3jgIIKICAgICAgICAvLyDms6jmhI/mgqjkuZ/lj6/ku6Xkvb/nlKggRnVuZGVyKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSkg5p2l5Yid5aeL5YyW44CCCiAgICAgICAgYy5mdW5kZXJzW2MubnVtRnVuZGVycysrXSA9IEZ1bmRlcih7YWRkcjogbXNnLnNlbmRlciwgYW1vdW50OiBtc2cudmFsdWV9KTsKICAgICAgICBjLmFtb3VudCArPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2tHb2FsUmVhY2hlZCh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyByZXR1cm5zIChib29sIHJlYWNoZWQpIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgaWYgKGMuYW1vdW50IDwgYy5mdW5kaW5nR29hbCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHVpbnQgYW1vdW50ID0gYy5hbW91bnQ7CiAgICAgICAgYy5hbW91bnQgPSAwOwogICAgICAgIGMuYmVuZWZpY2lhcnkudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.6</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// 定义一个包含两个属性的新类型。</span><br><span class="hljs-comment">// 在合约之外声明一个结构，</span><br><span class="hljs-comment">// 可以让它被多个合约所共享。</span><br><span class="hljs-comment">// 在这里，这并不是真的需要。</span><br>struct Funder &#123;<br>    address addr;<br>    <span class="hljs-keyword">uint</span> amount;<br>&#125;<br><br>contract CrowdFunding &#123;<br>    <span class="hljs-comment">// 结构体也可以被定义在合约内部，这使得它们只在本合约和派生合约中可见。</span><br>    struct Campaign &#123;<br>        address payable beneficiary;<br>        <span class="hljs-keyword">uint</span> fundingGoal;<br>        <span class="hljs-keyword">uint</span> numFunders;<br>        <span class="hljs-keyword">uint</span> amount;<br>        mapping(<span class="hljs-keyword">uint</span> =&gt; Funder) funders;<br>    &#125;<br><br>    <span class="hljs-keyword">uint</span> numCampaigns;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; Campaign) campaigns;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newCampaign</span><span class="hljs-params">(address payable beneficiary, <span class="hljs-keyword">uint</span> goal)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> campaignID)</span> </span>&#123;<br>        campaignID = numCampaigns++; <span class="hljs-comment">// campaignID 作为一个变量返回</span><br>        <span class="hljs-comment">// 我们不能使用 &quot;campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)&quot;</span><br>        <span class="hljs-comment">// 因为右侧创建了一个内存结构 &quot;Campaign&quot;，其中包含一个映射。</span><br>        Campaign storage c = campaigns[campaignID];<br>        c.beneficiary = beneficiary;<br>        c.fundingGoal = goal;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contribute</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> campaignID)</span> <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>&#123;<br>        Campaign storage c = campaigns[campaignID];<br>        <span class="hljs-comment">// 以给定的值初始化，创建一个新的临时 memory 结构体，</span><br>        <span class="hljs-comment">// 并将其拷贝到 storage 中。</span><br>        <span class="hljs-comment">// 注意您也可以使用 Funder(msg.sender, msg.value) 来初始化。</span><br>        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);<br>        c.amount += msg.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkGoalReached</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> campaignID)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span> reached)</span> </span>&#123;<br>        Campaign storage c = campaigns[campaignID];<br>        <span class="hljs-keyword">if</span> (c.amount &lt; c.fundingGoal)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">uint</span> amount = c.amount;<br>        c.amount = <span class="hljs-number">0</span>;<br>        c.beneficiary.transfer(amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的合约并没有提供众筹合约的全部功能， 但它包含了理解结构体所需的基本概念。 结构类型可以在映射和数组内使用， 它们本身可以包含映射和数组。</p><p>结构体不可能包含其自身类型的成员，尽管结构本身可以是映射成员的值类型， 或者它可以包含其类型的动态大小的数组。 这一限制是必要的，因为结构的大小必须是有限的。</p><p>注意在所有的函数中，结构类型被分配到数据位置为 <code>storage</code> 的局部变量。 这并不是拷贝结构体，而只是存储一个引用， 因此对本地变量成员的赋值实际上是写入状态。</p><p>当然，您也可以直接访问该结构的成员， 而不把它分配给本地变量，如 <code>campaigns[campaignID].amount = 0</code>。</p><p>备注</p><p>在 Solidity 0.7.0 之前，包含仅有存储类型（例如映射）的成员的内存结构是允许的， 像上面例子中的 <code>campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)</code> 这样的赋值是可以的， 只是会默默地跳过这些成员。</p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#mapping-types"></a></h2><p>映射类型使用语法 <code>mapping(KeyType KeyName? =&gt; ValueType ValueName?)</code>， 映射类型的变量使用语法 <code>mapping(KeyType KeyName? =&gt; ValueType ValueName?) VariableName</code> 声明。 <code>KeyType</code> 可以是任何内置的值类型， <code>bytes</code>， <code>string</code>，或任何合约或枚举类型。 其他用户定义的或复杂的类型，如映射，结构体或数组类型是不允许的。 <code>ValueType</code> 可以是任何类型，包括映射，数组和结构体。 <code>KeyName</code> 和 <code>ValueName</code> 是可选的（所以 <code>mapping(KeyType =&gt; ValueType)</code> 也可以使用）， 可以是任何有效的标识符，而不是一个类型。</p><p>您可以把映射想象成 <a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>， 它实际上被初始化了，使每一个可能的键都存在， 并将其映射到字节形式全是零的值，一个类型的 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value">默认值</a>。 相似性到此为止，键数据不存储在映射中，而是它的 <code>keccak256</code> 哈希值被用来查询。</p><p>正因为如此，映射没有长度，也没有被设置的键或值的概念， 因此，如果没有关于分配的键的额外信息，就不能被删除（见 <a href="https://docs.soliditylang.org/zh-cn/latest/security-considerations.html#clearing-mappings">清除映射</a>）。</p><p>映射只能有一个 <code>storage</code> 的数据位置，因此允许用于状态变量， 可作为函数中的存储引用类型，或作为库函数的参数。 但它们不能被用作公开可见的合约函数的参数或返回参数。 这些限制对于包含映射的数组和结构也是如此。</p><p>您可以把映射类型的状态变量标记为 <code>public</code>， Solidity 会为您创建一个 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">getter</a> 函数。 <code>KeyType</code> 成为 getter 函数的参数，名称为 <code>KeyName</code> （如果指定）。 如果 <code>ValueType</code> 是一个值类型或一个结构，getter 返回 <code>ValueType</code>， 名称为 <code>ValueName</code> （如果指定）。 如果 <code>ValueType</code> 是一个数组或映射，getter 对每个 <code>KeyType</code> 递归出一个参数。</p><p>在下面的例子中， <code>MappingExample</code> 合约定义了一个公共的 <code>balances</code> 映射， 键类型是 <code>address</code>，值类型是 <code>uint</code>，将一个Ethereum地址映射到一个无符号整数值。 由于 <code>uint</code> 是一个值类型，getter 返回一个与该类型相匹配的值， 您可以在 <code>MappingUser</code> 合约中看到它返回指定地址对应的值。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract MappingExample &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> balances;<br><br>    <span class="hljs-function">function <span class="hljs-title">update</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newBalance</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        balances[msg.sender] = newBalance;<br>    &#125;<br>&#125;<br><br>contract MappingUser &#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        MappingExample m = <span class="hljs-keyword">new</span> MappingExample();<br>        m.update(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> m.balances(address(<span class="hljs-keyword">this</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的例子是一个简化版本的 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20 代币</a>。 <code>_allowances</code> 是一个映射类型在另一个映射类型中的例子。</p><p>在下面的例子中，为映射提供了可选的 <code>KeyName</code> 和 <code>ValueName</code>。 它不影响任何合约的功能或字节码， 它只是为映射的 getter 在 ABI 中设置输入和输出的 <code>name</code> 字段。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTg7Cgpjb250cmFjdCBNYXBwaW5nRXhhbXBsZVdpdGhOYW1lcyB7CiAgICBtYXBwaW5nKGFkZHJlc3MgdXNlciA9PiB1aW50IGJhbGFuY2UpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.18</span>;<br><br>contract MappingExampleWithNames &#123;<br>    mapping(address user =&gt; <span class="hljs-built_in">uint</span> balance) <span class="hljs-keyword">public</span> balances;<br><br>    <span class="hljs-built_in">function</span> update(<span class="hljs-built_in">uint</span> newBalance) <span class="hljs-keyword">public</span> &#123;<br>        balances[msg.sender] = newBalance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的例子使用 <code>_allowances</code> 来记录其他人可以从你的账户中提取的金额。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludDI1NikgcHJpdmF0ZSBfYmFsYW5jZXM7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gbWFwcGluZyhhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract MappingExample &#123;<br><br>    mapping(address =&gt; uint256) <span class="hljs-keyword">private</span> _balances;<br>    mapping(address =&gt; mapping(address =&gt; uint256)) <span class="hljs-keyword">private</span> _allowances;<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allowance</span><span class="hljs-params">(address owner, address spender)</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _allowances[owner][spender];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(address sender, address recipient, uint256 amount)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">require</span>(_allowances[sender][msg.sender] &gt;= amount, <span class="hljs-string">&quot;ERC20: Allowance not high enough.&quot;</span>);<br>        _allowances[sender][msg.sender] -= amount;<br>        _transfer(sender, recipient, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">approve</span><span class="hljs-params">(address spender, uint256 amount)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">require</span>(spender != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;ERC20: approve to the zero address&quot;</span>);<br><br>        _allowances[msg.sender][spender] = amount;<br>        emit Approval(msg.sender, spender, amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transfer</span><span class="hljs-params">(address sender, address recipient, uint256 amount)</span> <span class="hljs-title">internal</span> </span>&#123;<br>        <span class="hljs-keyword">require</span>(sender != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;ERC20: transfer from the zero address&quot;</span>);<br>        <span class="hljs-keyword">require</span>(recipient != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;ERC20: transfer to the zero address&quot;</span>);<br>        <span class="hljs-keyword">require</span>(_balances[sender] &gt;= amount, <span class="hljs-string">&quot;ERC20: Not enough funds.&quot;</span>);<br><br>        _balances[sender] -= amount;<br>        _balances[recipient] += amount;<br>        emit Transfer(sender, recipient, amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归映射"><a href="#递归映射" class="headerlink" title="递归映射"></a>递归映射<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#iterable-mappings"></a></h3><p>您不能对映射进行递归调用，也就是说，您不能列举它们的键。 不过，可以在它们上层实现一个数据结构，并对其进行递归。例如， 下面的代码实现了一个 <code>IterableMapping</code> 库， 然后 <code>User</code> 合约将数据添加到该库中， <code>sum</code> 函数对所有的值进行递归调用去累加这些值。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8g5aaC5L2V5L2/55SoCmNvbnRyYWN0IFVzZXIgewogICAgLy8g5Y+q5piv5LiA5Liq5L+d5a2Y5oiR5Lus5pWw5o2u55qE57uT5p6E5L2T44CCCiAgICBpdG1hcCBkYXRhOwogICAgLy8g5a+55pWw5o2u57G75Z6L5bqU55So5bqT5Ye95pWw44CCCiAgICB1c2luZyBJdGVyYWJsZU1hcHBpbmcgZm9yIGl0bWFwOwoKICAgIC8vIOaPkuWFpeS4gOS6m+aVsOaNrgogICAgZnVuY3Rpb24gaW5zZXJ0KHVpbnQgaywgdWludCB2KSBwdWJsaWMgcmV0dXJucyAodWludCBzaXplKSB7CiAgICAgICAgLy8g6L+Z5bCG6LCD55SoIEl0ZXJhYmxlTWFwcGluZy5pbnNlcnQoZGF0YSwgaywgdikKICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyDmiJHku6zku43nhLblj6/ku6Xorr/pl67nu5PmnoTkuK3nmoTmiJDlkZjvvIwKICAgICAgICAvLyDkvYbmiJHku6zlupTor6Xms6jmhI/kuI3opoHkubHliqjku5bku6zjgIIKICAgICAgICByZXR1cm4gZGF0YS5zaXplOwogICAgfQoKICAgIC8vIOiuoeeul+aJgOacieWtmOWCqOaVsOaNrueahOaAu+WSjOOAggogICAgZnVuY3Rpb24gc3VtKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCBzKSB7CiAgICAgICAgZm9yICgKICAgICAgICAgICAgSXRlcmF0b3IgaSA9IGRhdGEuaXRlcmF0ZVN0YXJ0KCk7CiAgICAgICAgICAgIGRhdGEuaXRlcmF0ZVZhbGlkKGkpOwogICAgICAgICAgICBpID0gZGF0YS5pdGVyYXRlTmV4dChpKQogICAgICAgICkgewogICAgICAgICAgICAoLCB1aW50IHZhbHVlKSA9IGRhdGEuaXRlcmF0ZUdldChpKTsKICAgICAgICAgICAgcyArPSB2YWx1ZTsKICAgICAgICB9CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.8</span>;<br><br>struct IndexValue &#123; <span class="hljs-keyword">uint</span> keyIndex; <span class="hljs-keyword">uint</span> value; &#125;<br>struct KeyFlag &#123; <span class="hljs-keyword">uint</span> key; <span class="hljs-keyword">bool</span> deleted; &#125;<br><br>struct itmap &#123;<br>    mapping(<span class="hljs-keyword">uint</span> =&gt; IndexValue) data;<br>    KeyFlag[] keys;<br>    <span class="hljs-keyword">uint</span> size;<br>&#125;<br><br>type Iterator is <span class="hljs-keyword">uint</span>;<br><br>library IterableMapping &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> key, <span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span> replaced)</span> </span>&#123;<br>        <span class="hljs-keyword">uint</span> keyIndex = <span class="hljs-keyword">self</span>.data[key].keyIndex;<br>        <span class="hljs-keyword">self</span>.data[key].value = value;<br>        <span class="hljs-keyword">if</span> (keyIndex &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            keyIndex = <span class="hljs-keyword">self</span>.keys.length;<br>            <span class="hljs-keyword">self</span>.keys.push();<br>            <span class="hljs-keyword">self</span>.data[key].keyIndex = keyIndex + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">self</span>.keys[keyIndex].key = key;<br>            <span class="hljs-keyword">self</span>.size++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> key)</span> <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span> success)</span> </span>&#123;<br>        <span class="hljs-keyword">uint</span> keyIndex = <span class="hljs-keyword">self</span>.data[key].keyIndex;<br>        <span class="hljs-keyword">if</span> (keyIndex == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        delete <span class="hljs-keyword">self</span>.data[key];<br>        <span class="hljs-keyword">self</span>.keys[keyIndex - <span class="hljs-number">1</span>].deleted = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">self</span>.size --;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> key)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.data[key].keyIndex &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterateStart</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(Iterator)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> iteratorSkipDeleted(<span class="hljs-keyword">self</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterateValid</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, Iterator iterator)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Iterator.unwrap(iterator) &lt; <span class="hljs-keyword">self</span>.keys.length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterateNext</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, Iterator iterator)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(Iterator)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> iteratorSkipDeleted(<span class="hljs-keyword">self</span>, Iterator.unwrap(iterator) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterateGet</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, Iterator iterator)</span> <span class="hljs-title">internal</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> key, <span class="hljs-keyword">uint</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">uint</span> keyIndex = Iterator.unwrap(iterator);<br>        key = <span class="hljs-keyword">self</span>.keys[keyIndex].key;<br>        value = <span class="hljs-keyword">self</span>.data[key].value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iteratorSkipDeleted</span><span class="hljs-params">(itmap storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> keyIndex)</span> <span class="hljs-title">private</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(Iterator)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (keyIndex &lt; <span class="hljs-keyword">self</span>.keys.length &amp;&amp; <span class="hljs-keyword">self</span>.keys[keyIndex].deleted)<br>            keyIndex++;<br>        <span class="hljs-keyword">return</span> Iterator.wrap(keyIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如何使用</span><br>contract User &#123;<br>    <span class="hljs-comment">// 只是一个保存我们数据的结构体。</span><br>    itmap data;<br>    <span class="hljs-comment">// 对数据类型应用库函数。</span><br>    using IterableMapping <span class="hljs-keyword">for</span> itmap;<br><br>    <span class="hljs-comment">// 插入一些数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> k, <span class="hljs-keyword">uint</span> v)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> size)</span> </span>&#123;<br>        <span class="hljs-comment">// 这将调用 IterableMapping.insert(data, k, v)</span><br>        data.insert(k, v);<br>        <span class="hljs-comment">// 我们仍然可以访问结构中的成员，</span><br>        <span class="hljs-comment">// 但我们应该注意不要乱动他们。</span><br>        <span class="hljs-keyword">return</span> data.size;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算所有存储数据的总和。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<br>            Iterator i = data.iterateStart();<br>            data.iterateValid(i);<br>            i = data.iterateNext(i)<br>        ) &#123;<br>            (, <span class="hljs-keyword">uint</span> value) = data.iterateGet(i);<br>            s += value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-28"></a></h2><p>即使两个操作数的类型不一样，也可以应用算术和位操作数。 例如，您可以计算 <code>y = x + z</code>，其中 <code>x</code> 是 <code>uint8</code>， <code>z</code> 的类型为 <code>int32</code>。 在这种情况下，下面的机制将被用来确定计算操作的类型（这在溢出的情况下很重要）和操作结果的类型：</p><ol><li>如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，</li><li>如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，</li><li>否则的话，该操作不被允许。</li></ol><p>如果其中一个操作数是 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#rational-literals">字面常数</a>， 它首先被转换为其 “移动类型（mobile type）”，也就是能容纳该值的最小类型 （相同位宽的无符号类型被认为比有符号类型 “小”）。 如果两者都是字面常数，那么运算的精度实际上是无限的， 因为表达式被转换到任何必要的精度，所以当结果被用于非字面类型时，没有任何损失。</p><p>操作符的结果类型与操作的类型相同，除了比较操作符，其结果总是 <code>bool</code>。</p><p>运算符 <code>**</code> （幂运算）， <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 使用左边操作数的类型进行运算和以其作为结果。</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id39"></a></h3><p>三元运算符用于形式为 <code>&lt;条件表达式&gt; ? &lt;true条件表达式&gt; : &lt;false条件表达式&gt;</code>。 它根据主要的 <code>&lt;条件表达式&gt;</code> 的评估结果，计算后两个给定表达式中的一个。 如果 <code>&lt;条件表达式&gt;</code> 评估为 <code>true</code>，那么 <code>&lt;true条件表达式&gt;</code> 将被计算，否则 <code>&lt;false条件表达式&gt;</code> 被被计算。</p><p>三元运算符的结果没有有理数类型，即使它的操作数都是有理数字。 结果类型是由两个操作数的类型决定的，方法同上，如果需要的话，首先转换为它们的可移动计算的类型。</p><p>因此， <code>255 + (true ? 1 : 0)</code> 将由于算术溢出而恢复计算。 原因是 <code>(true ? 1 : 0)</code> 是 <code>uint8</code> 类型，这迫使加法也在 <code>uint8</code> 中进行， 而256超出了这个类型允许的范围。</p><p>另一个结果是，像 <code>1.5 + 1.5</code> 这样的表达式是有效的，但 <code>1.5 + (true ? 1.5 : 2.5)</code> 却无效。 这是因为前者是一个以无限精度计算的有理表达式，只有它的最终值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。</p><h3 id="复数和增量-减量运算符"><a href="#复数和增量-减量运算符" class="headerlink" title="复数和增量/减量运算符"></a>复数和增量/减量运算符<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-29"></a></h3><p>如果 <code>a</code> 是一个LValue（即是一个变量或者是可以被分配的东西）， 下列运算符可以作为速记：</p><p><code>a += e</code> 相当于 <code>a = a + e</code>，运算符 <code>-=</code>， <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>|=</code>， <code>&amp;=</code>， <code>^=</code>， <code>&lt;&lt;=</code> 和 <code>&gt;&gt;=</code> 都有相应的定义。 <code>a++</code> 和 <code>a--</code> 相当于 <code>a += 1</code> / <code>a -= 1</code> 但是表达式本身仍然是以前的值 <code>a</code>。 相比之下， <code>--a</code> 和 <code>++a</code> 对 <code>a</code> 有同样的作用，但返回改变后的值。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#delete"></a></h3><p><code>delete a</code> 为该类型分配初始值 <code>a</code>。例如，对于整数来说，它相当于 <code>a = 0</code>， 但是它也可以用于数组，它指定一个长度为0的动态数组或者一个相同长度的静态数组， 所有元素都设置为初始值。 <code>delete a[x]</code> 删除数组中索引为 <code>x</code> 的元素， 并保留所有其他元素和数组的长度不动。这特别意味着它在数组中留下一个缺口。 如果您打算删除项目，一个 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#mapping-types">映射类型</a> 可能是一个更好的选择。</p><p>对于结构体，则将结构体中的所有属性重置。换句话说，在 <code>delete a</code> 之后， <code>a</code> 的值与 <code>a</code> 在没有赋值的情况下被声明是一样的，但有以下注意事项：</p><p><code>delete</code> 对映射类型没有影响（因为映射的键可能是任意的，通常是未知的）。 因此，如果您删除一个结构体，它将重置所有不是映射类型的成员， 同时也会递归到这些成员，除非它们是映射。 然而，单个键和它们所映射的内容可以被删除。 如果 <code>a</code> 是一个映射，那么 <code>delete a[x]</code> 将删除存储在 <code>x</code> 的值。</p><p>值得注意的是， <code>delete a</code> 的行为实际上是对 <code>a</code> 的赋值， 也就是说，它在 <code>a</code> 中存储了一个新的对象。 当 <code>a</code> 是引用变量时，这种区别是明显的。 它只会重置 <code>a</code> 本身，而不是它之前引用的值。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIOWwhiB4IOiuvuS4uiAw77yM5bm25LiN5b2x5ZONZGF0YeWPmOmHjwogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyDlsIYgZGF0YSDorr7kuLogMO+8jOW5tuS4jeW9seWTjSB4CiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IGRhdGFBcnJheTsKICAgICAgICBkZWxldGUgZGF0YUFycmF5OyAvLyDlsIYgZGF0YUFycmF5Lmxlbmd0aCDorr7kuLogMO+8jOS9hueUseS6jiB1aW50W10g5piv5LiA5Liq5aSN5p2C55qE5a+56LGh77yMCiAgICAgICAgLy8geSDkuZ/lsIblj5fliLDlvbHlk43vvIzlroPmmK/kuIDkuKrlrZjlgqjkvY3nva7mmK8gc3RvcmFnZSDnmoTlr7nosaHnmoTliKvlkI3jgIIKICAgICAgICAvLyDlj6bkuIDmlrnpnaLvvJoiZGVsZXRlIHkiIOaYr+mdnuazleeahO+8jOW8leeUqOS6hiBzdG9yYWdlIOWvueixoeeahOWxgOmDqOWPmOmHj+WPquiDveeUseW3suacieeahCBzdG9yYWdlIOWvueixoei1i+WAvOOAggogICAgICAgIGFzc2VydCh5Lmxlbmd0aCA9PSAwKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract DeleteExample &#123;<br>    <span class="hljs-built_in">uint</span> data;<br>    <span class="hljs-built_in">uint</span>[] dataArray;<br><br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-built_in">uint</span> x = data;<br>        <span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 将 x 设为 0，并不影响data变量</span><br>        <span class="hljs-keyword">delete</span> data; <span class="hljs-comment">// 将 data 设为 0，并不影响 x</span><br>        <span class="hljs-built_in">uint</span>[] storage y = dataArray;<br>        <span class="hljs-keyword">delete</span> dataArray; <span class="hljs-comment">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，</span><br>        <span class="hljs-comment">// y 也将受到影响，它是一个存储位置是 storage 的对象的别名。</span><br>        <span class="hljs-comment">// 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span><br>        <span class="hljs-keyword">assert</span>(y.length == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符的优先顺序"><a href="#运算符的优先顺序" class="headerlink" title="运算符的优先顺序"></a>运算符的优先顺序<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#order"></a></h3><p>以下是按评估顺序列出的操作符优先级。</p><div class="table-container"><table><thead><tr><th>优先级</th><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td><em>1</em></td><td>后置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>创建类型实例</td><td><code>new &lt;类型名&gt;</code></td></tr><tr><td></td><td>数组元素</td><td><code>&lt;数组&gt;[&lt;索引&gt;]</code></td></tr><tr><td></td><td>访问成员</td><td><code>&lt;对象&gt;.&lt;成员名&gt;</code></td></tr><tr><td></td><td>函数调用</td><td><code>&lt;函数&gt;(&lt;参数...&gt;)</code></td></tr><tr><td></td><td>小括号</td><td><code>(&lt;表达式&gt;)</code></td></tr><tr><td><em>2</em></td><td>前置自增和自减</td><td><code>++</code>， <code>--</code></td></tr><tr><td></td><td>一元运算减</td><td><code>-</code></td></tr><tr><td></td><td>一元操作符</td><td><code>delete</code></td></tr><tr><td></td><td>逻辑非</td><td><code>!</code></td></tr><tr><td></td><td>按位非</td><td><code>~</code></td></tr><tr><td><em>3</em></td><td>乘方</td><td><code>**</code></td></tr><tr><td><em>4</em></td><td>乘、除和模运算</td><td><code>*</code>， <code>/</code>， <code>%</code></td></tr><tr><td><em>5</em></td><td>算术加和减</td><td><code>+</code>， <code>-</code></td></tr><tr><td><em>6</em></td><td>移位操作符</td><td><code>&lt;&lt;</code>， <code>&gt;&gt;</code></td></tr><tr><td><em>7</em></td><td>按位与</td><td><code>&amp;</code></td></tr><tr><td><em>8</em></td><td>按位异或</td><td><code>^</code></td></tr><tr><td><em>9</em></td><td>按位或</td><td>`</td><td>`</td></tr><tr><td><em>10</em></td><td>非等操作符</td><td><code>&lt;</code>， <code>&gt;</code>， <code>&lt;=</code>， <code>&gt;=</code></td></tr><tr><td><em>11</em></td><td>等于操作符</td><td><code>==</code>， <code>!=</code></td></tr><tr><td><em>12</em></td><td>逻辑与</td><td><code>&amp;&amp;</code></td></tr><tr><td><em>13</em></td><td>逻辑或</td><td><code>==</code></td></tr><tr><td><em>14</em></td><td>三元操作符</td><td><code>&lt;判断条件&gt; ? &lt;如果为真时执行的表达式&gt; : &lt;如果为假时执行的表达式&gt;</code></td></tr><tr><td></td><td>赋值操作符</td><td><code>=</code>， `</td><td>=<code>，</code>^=<code>，</code>&amp;=<code>，</code>&lt;&lt;=<code>，</code>&gt;&gt;=<code>，</code>+=<code>，</code>-=<code>，</code>*=<code>，</code>/=<code>，</code>%=`</td></tr><tr><td><em>15</em></td><td>逗号</td><td><code>,</code></td></tr></tbody></table></div><h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types-conversion-elementary-types"></a></h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id44"></a></h3><p>在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时， 编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义， 并且不会丢失信息，那么值-类型之间的隐式转换是可能的。</p><p>例如， <code>uint8</code> 可以转换为 <code>uint16</code>， <code>int128</code> 可以转换为 <code>int256</code>， 但是 <code>int8</code> 不能转换为 <code>uint256</code>，因为 <code>uint256</code> 不能容纳 <code>-1</code> 这样的值。</p><p>如果一个运算符被应用于不同的类型， 编译器会尝试将其中一个操作数隐含地转换为另一个的类型（对于赋值也是如此）。 这意味着操作总是以其中一个操作数的类型进行。</p><p>关于哪些隐式转换是可能的，请参考关于类型本身的章节。</p><p>在下面的例子中， <code>y</code> 和 <code>z</code>，即加法的操作数，没有相同的类型， 但是 <code>uint8</code> 可以隐式转换为 <code>uint16</code>，反之则不行。正因为如此， <code>y</code> 被转换为 <code>z</code> 的类型，然后在 <code>uint16</code> 类型中进行加法。 结果表达式 <code>y + z</code> 的类型是 <code>uint16</code>。 因为它被分配到一个 <code>uint32</code> 类型的变量中，所以在加法后又进行了一次隐式转换。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7">open in Remix</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint8</span> y;<br><span class="hljs-built_in">uint16</span> z;<br><span class="hljs-built_in">uint32</span> x = y + z;<br></code></pre></td></tr></table></figure><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id45"></a></h3><p>如果编译器不允许隐式转换，但您确信转换会成功， 有时可以进行显式类型转换。 这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性， 所以一定要测试结果是否是您想要的和期望的!</p><p>以下面的例子为例，将一个负的 <code>int</code> 转换为 <code>uint</code>：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int  y <span class="hljs-operator">=</span> -<span class="hljs-number">3</span><span class="hljs-comment">;</span><br>uint x <span class="hljs-operator">=</span> uint(y)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在这个代码片断的最后， <code>x</code> 变成 <code>0xfffff..fd</code> 的值（64个十六进制字符）， 这在256位的二进制补码中表示是-3。</p><p>如果一个整数被明确地转换为一个较小的类型，高阶位就会被切断：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiDnjrDlnKjkvJrmmK8gMHg1Njc4">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint32 a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x12345678<span class="hljs-comment">;</span><br>uint16 b <span class="hljs-operator">=</span> uint16(a)<span class="hljs-comment">; // b 现在会是 0x5678</span><br></code></pre></td></tr></table></figure><p>如果一个整数被明确地转换为一个更大的类型，它将在左边被填充（即在高阶的一端）。 转换的结果将与原整数比较相等：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDAwMDAxMjM0CmFzc2VydChhID09IGIpOw==">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint16 a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1234<span class="hljs-comment">;</span><br>uint32 b <span class="hljs-operator">=</span> uint32(a)<span class="hljs-comment">; // b 现在会是 0x00001234</span><br>assert(a <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>固定大小的字节类型在转换过程中的行为是不同的。 它们可以被认为是单个字节的序列，转换到一个较小的类型将切断序列：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEy">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bytes2 a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1234<span class="hljs-comment">;</span><br>bytes1 b <span class="hljs-operator">=</span> bytes1(a)<span class="hljs-comment">; // b 现在会是 0x12</span><br></code></pre></td></tr></table></figure><p>如果一个固定大小的字节类型被明确地转换为一个更大的类型，它将在右边被填充。 访问固定索引的字节将导致转换前后的数值相同（如果索引仍在范围内）：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEyMzQwMDAwCmFzc2VydChhWzBdID09IGJbMF0pOwphc3NlcnQoYVsxXSA9PSBiWzFdKTs=">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bytes2 a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1234<span class="hljs-comment">;</span><br>bytes4 b <span class="hljs-operator">=</span> bytes4(a)<span class="hljs-comment">; // b 现在会是 0x12340000</span><br>assert(a[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b[<span class="hljs-number">0</span>])<span class="hljs-comment">;</span><br>assert(a[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b[<span class="hljs-number">1</span>])<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>于整数和固定大小的字节数组在截断或填充时表现不同， 只有在整数和固定大小的字节数组具有相同大小的情况下，才允许在两者之间进行显式转换。 如果您想在不同大小的整数和固定大小的字节数组之间进行转换，您必须使用中间转换， 使所需的截断和填充规则明确：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIOWwhuS8muaYryAweDAwMDAxMjM0CnVpbnQzMiBjID0gdWludDMyKGJ5dGVzNChhKSk7IC8vIGMg5bCG5Lya5pivIDB4MTIzNDAwMDAKdWludDggZCA9IHVpbnQ4KHVpbnQxNihhKSk7IC8vIGQg5bCG5Lya5pivIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUg5bCG5Lya5pivIDB4MTI=">open in Remix</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">bytes2 a = <span class="hljs-number">0x1234</span>;<br><span class="hljs-built_in">uint32</span> b = <span class="hljs-built_in">uint16</span>(a); <span class="hljs-comment">// b 将会是 0x00001234</span><br><span class="hljs-built_in">uint32</span> c = <span class="hljs-built_in">uint32</span>(bytes4(a)); <span class="hljs-comment">// c 将会是 0x12340000</span><br><span class="hljs-built_in">uint8</span> d = <span class="hljs-built_in">uint8</span>(<span class="hljs-built_in">uint16</span>(a)); <span class="hljs-comment">// d 将会是 0x34</span><br><span class="hljs-built_in">uint8</span> e = <span class="hljs-built_in">uint8</span>(bytes1(a)); <span class="hljs-comment">// e 将会是 0x12</span><br></code></pre></td></tr></table></figure><p><code>bytes</code> 数组和 <code>bytes</code> calldata 切片可以明确转换为固定字节类型（ <code>bytes1</code> /…/ <code>bytes32</code>）。 如果数组比目标的固定字节类型长，在末端会发生截断的情况。如果数组比目标类型短，它将在末尾被填充零。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIOWmguaenG3nmoTplb/luqblpKfkuo4xNu+8jOWwhuWPkeeUn+aIquaWreOAggogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8g5Y+z6L656L+b6KGM5aGr5YWF77yM5omA5Lul57uT5p6c5pivICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyDlj5HnlJ/miKrmlq0sIGIxIOebuOW9k+S6jiAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIOWQjOagt+eUqDDov5vooYzloavlhYUKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ==">open in Remix</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.5</span>;<br><br>contract C &#123;<br>    <span class="hljs-type">bytes</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefgh&quot;</span>;<br>    function <span class="hljs-title function_">f</span><span class="hljs-params">(bytes calldata c, bytes memory m)</span> <span class="hljs-keyword">public</span> view <span class="hljs-title function_">returns</span> <span class="hljs-params">(bytes16, bytes3)</span> &#123;<br>        require(c.length == <span class="hljs-number">16</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">bytes16</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> bytes16(m);  <span class="hljs-comment">// 如果m的长度大于16，将发生截断。</span><br>        b = bytes16(s);  <span class="hljs-comment">// 右边进行填充，所以结果是 &quot;abcdefgh\0\0\0\0\0\0\0\0&quot;</span><br>        <span class="hljs-type">bytes3</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> bytes3(s); <span class="hljs-comment">// 发生截断, b1 相当于 &quot;abc&quot;</span><br>        b = bytes16(c[:<span class="hljs-number">8</span>]);  <span class="hljs-comment">// 同样用0进行填充</span><br>        <span class="hljs-keyword">return</span> (b, b1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字面常数和基本类型之间的转换"><a href="#字面常数和基本类型之间的转换" class="headerlink" title="字面常数和基本类型之间的转换"></a>字面常数和基本类型之间的转换<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types-conversion-literals"></a></h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#id47"></a></h3><p>十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=dWludDggYSA9IDEyOyAvLyDlj6/ooYwKdWludDMyIGIgPSAxMjM0OyAvLyDlj6/ooYwKdWludDE2IGMgPSAweDEyMzQ1NjsgLy8g5oql6ZSZLCDlm6DkuLrov5nlsIbkvJrmiKrmlq3miJAgMHgzNDU2">open in Remix</a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint8 a <span class="hljs-operator">=</span> <span class="hljs-number">12</span><span class="hljs-comment">; // 可行</span><br>uint32 b <span class="hljs-operator">=</span> <span class="hljs-number">1234</span><span class="hljs-comment">; // 可行</span><br>uint16 c <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x123456<span class="hljs-comment">; // 报错, 因为这将会截断成 0x3456</span><br></code></pre></td></tr></table></figure><p>备注</p><p>在0.8.0版本之前，任何十进制或十六进制的数字字面常数都可以显式转换为整数类型。 从0.8.0开始，这种显式转换和隐式转换一样严格，也就是说，只有当字面意义符合所产生的范围时，才允许转换。</p><h3 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-34"></a></h3><p>十进制数字字面常数不能被隐含地转换为固定大小的字节数组。 十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。 但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8g5LiN5YWB6K64CmJ5dGVzMiBiID0gMHgxMjsgLy8g5LiN5YWB6K64CmJ5dGVzMiBjID0gMHgxMjM7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IDB4MTIzNDsgLy8g5Y+v6KGMCmJ5dGVzMiBlID0gMHgwMDEyOyAvLyDlj6/ooYwKYnl0ZXM0IGYgPSAwOyAvLyDlj6/ooYwKYnl0ZXM0IGcgPSAweDA7IC8vIOWPr+ihjA==">open in Remix</a></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bytes2 </span>a = <span class="hljs-number">54321</span><span class="hljs-comment">; // 不允许</span><br><span class="hljs-keyword">bytes2 </span><span class="hljs-keyword">b </span>= <span class="hljs-number">0x12</span><span class="hljs-comment">; // 不允许</span><br><span class="hljs-keyword">bytes2 </span>c = <span class="hljs-number">0x123</span><span class="hljs-comment">; // 不允许</span><br><span class="hljs-keyword">bytes2 </span>d = <span class="hljs-number">0x1234</span><span class="hljs-comment">; // 可行</span><br><span class="hljs-keyword">bytes2 </span>e = <span class="hljs-number">0x0012</span><span class="hljs-comment">; // 可行</span><br><span class="hljs-keyword">bytes4 </span>f = <span class="hljs-number">0</span><span class="hljs-comment">; // 可行</span><br><span class="hljs-keyword">bytes4 </span>g = <span class="hljs-number">0x0</span><span class="hljs-comment">; // 可行</span><br></code></pre></td></tr></table></figure><p>字符串和十六进制字符串字面常数可以被隐含地转换为固定大小的字节数组， 如果它们的字符数与字节类型的大小相匹配：</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIOWPr+ihjApieXRlczIgYiA9ICJ4eSI7IC8vIOWPr+ihjApieXRlczIgYyA9IGhleCIxMiI7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IGhleCIxMjMiOyAvLyDkuI3lhYHorrgKYnl0ZXMyIGUgPSAieCI7IC8vIOS4jeWFgeiuuApieXRlczIgZiA9ICJ4eXoiOyAvLyDkuI3lhYHorrg=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d">bytes2 a = he<span class="hljs-string">x&quot;1234&quot;</span>; <span class="hljs-comment">// 可行</span><br>bytes2 b = <span class="hljs-string">&quot;xy&quot;</span>; <span class="hljs-comment">// 可行</span><br>bytes2 c = he<span class="hljs-string">x&quot;12&quot;</span>; <span class="hljs-comment">// 不允许</span><br>bytes2 d = he<span class="hljs-string">x&quot;123&quot;</span>; <span class="hljs-comment">// 不允许</span><br>bytes2 e = <span class="hljs-string">&quot;x&quot;</span>; <span class="hljs-comment">// 不允许</span><br>bytes2 f = <span class="hljs-string">&quot;xyz&quot;</span>; <span class="hljs-comment">// 不允许</span><br></code></pre></td></tr></table></figure><h3 id="地址类型-1"><a href="#地址类型-1" class="headerlink" title="地址类型"></a>地址类型<a href="https://docs.soliditylang.org/zh-cn/latest/types.html#index-35"></a></h3><p>正如在 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals">地址字面量（Address Literals）</a> 中所描述的那样，正确大小并通过校验测试的十六进制字是 <code>address</code> 类型。 其他字面常数不能隐含地转换为 <code>address</code> 类型。</p><p>只允许从 <code>bytes20</code> 和 <code>uint160</code> 显式转换到 <code>address</code>。</p><p><code>address a</code> 可以通过 <code>payable(a)</code> 显式转换为 <code>address payable</code>。</p><p>备注</p><p>在 0.8.0 版本之前，可以显式地从任何整数类型（任何大小，有符号或无符号）转换为 <code>address</code> 或 <code>address payable</code> 类型。 从 0.8.0 开始，只允许从 <code>uint160</code> 转换。<a href="https://server.ethicalads.io/proxy/click/8916/0197f493-8e40-7791-933b-f2fb8297bac6/">https://server.ethicalads.io/proxy/click/8916/0197f493-8e40-7791-933b-f2fb8297bac6/</a>)</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合约结构语法</title>
    <link href="/2025/07/05/%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/07/05/%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="合约结构"><a href="#合约结构" class="headerlink" title="合约结构"></a>合约结构<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#contract-structure"></a></h1><p>在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-state-variables">状态变量</a>， <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-functions">函数</a>， <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-function-modifiers">函数修饰器</a>， <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-events">事件</a>， <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-errors">错误</a>， <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-struct-types">结构类型</a> 和 <a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-enum-types">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><p>还有一些特殊种类的合约，叫做 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries">库合约</a> 和 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#interfaces">接口合约</a>。</p><p>在关于 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts">合约</a> 的部分包含比本节更多的细节，它的作用是提供一个快速的概述。</p><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-state-variables"></a></h2><p>状态变量是指其值被永久地存储在合约存储中的变量。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlU3RvcmFnZSB7CiAgICB1aW50IHN0b3JlZERhdGE7IC8vIOeKtuaAgeWPmOmHjwogICAgLy8gLi4uCn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract SimpleStorage &#123;<br>    <span class="hljs-built_in">uint</span> storedData; <span class="hljs-comment">// 状态变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有效的状态变量类型请参阅 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#types">类型</a> 章节， 对状态变量可见性的可能选择请参阅 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">可见性和 getter 函数</a>。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-functions"></a></h2><p>函数是代码的可执行单位。 通常在合约内定义函数，但它们也可以被定义在合约之外。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7IC8vIOWHveaVsAogICAgICAgIC8vIC4uLgogICAgfQp9CgovLyDlrprkuYnlnKjlkIjnuqbkuYvlpJbnmoTovoXliqnlh73mlbAKZnVuY3Rpb24gaGVscGVyKHVpbnQgeCkgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICByZXR1cm4geCAqIDI7Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.7</span><span class="hljs-number">.1</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-built_in">function</span> bid() <span class="hljs-keyword">public</span> payable &#123; <span class="hljs-comment">// 函数</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义在合约之外的辅助函数</span><br><span class="hljs-built_in">function</span> helper(<span class="hljs-built_in">uint</span> x) <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#function-calls">函数调用</a> 可以发生在内部或外部， 并且对其他合约有不同程度的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters">可见性</a>。 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#functions">函数</a> 接受参数并返回变量，以便在它们之间传递参数和值。</p><h2 id="函数修饰器"><a href="#函数修饰器" class="headerlink" title="函数修饰器"></a>函数修饰器<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-function-modifiers"></a></h2><p>函数修饰器可以被用来以声明的方式修改函数的语义(见合约部分的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifiers">函数修饰器</a>)。</p><p>重写，也就是具有同一个修饰器的名字但有不同的参数，是不可能的。</p><p>与函数一样，修饰器也可以被 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#modifier-overriding">重写</a>。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IFB1cmNoYXNlIHsKICAgIGFkZHJlc3MgcHVibGljIHNlbGxlcjsKCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgeyAvLyDkv67ppbDlmagKICAgICAgICByZXF1aXJlKAogICAgICAgICAgICBtc2cuc2VuZGVyID09IHNlbGxlciwKICAgICAgICAgICAgIk9ubHkgc2VsbGVyIGNhbiBjYWxsIHRoaXMuIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBhYm9ydCgpIHB1YmxpYyB2aWV3IG9ubHlTZWxsZXIgeyAvLyDkv67ppbDlmajnmoTkvb/nlKgKICAgICAgICAvLyAuLi4KICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    address <span class="hljs-keyword">public</span> seller;<br><br>    <span class="hljs-function">modifier <span class="hljs-title">onlySeller</span>()</span> &#123; <span class="hljs-comment">// 修饰器</span><br>        require(<br>            msg.sender == seller,<br>            <span class="hljs-string">&quot;Only seller can call this.&quot;</span><br>        );<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">abort</span>() <span class="hljs-keyword">public</span> view onlySeller</span> &#123; <span class="hljs-comment">// 修饰器的使用</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-events"></a></h2><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjI7CgpldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7IC8vIOS6i+S7tgoKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gLi4uCiAgICAgICAgZW1pdCBIaWdoZXN0QmlkSW5jcmVhc2VkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7IC8vIOinpuWPkeS6i+S7tgogICAgfQp9">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.22</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">address bidder, <span class="hljs-built_in">uint</span> amount</span>)</span>; <span class="hljs-comment">// 事件</span><br><br>contract SimpleAuction &#123;<br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">emit <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">msg.sender, msg.<span class="hljs-keyword">value</span></span>)</span>; <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#events">事件</a>。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-errors"></a></h2><p>错误(类型)允许您为失败情况定义描述性的名称和数据。 错误(类型)可以在 <a href="https://docs.soliditylang.org/zh-cn/latest/control-structures.html#revert-statement">回滚声明</a> 中使用。 与字符串描述相比，错误(类型)要便宜得多，并允许您对额外的数据进行编码。 您可以使用 NatSpec 格式来向用户描述错误。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDmsqHmnInotrPlpJ/nmoTotYTph5HnlKjkuo7ovazotKbjgILopoHmsYIgYHJlcXVlc3RlZGDjgIIKLy8vIOS9huWPquaciSBgYXZhaWxhYmxlYCDlj6/nlKjjgIIKZXJyb3IgTm90RW5vdWdoRnVuZHModWludCByZXF1ZXN0ZWQsIHVpbnQgYXZhaWxhYmxlKTsKCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlczsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIHVpbnQgYmFsYW5jZSA9IGJhbGFuY2VzW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChiYWxhbmNlIDwgYW1vdW50KQogICAgICAgICAgICByZXZlcnQgTm90RW5vdWdoRnVuZHMoYW1vdW50LCBiYWxhbmNlKTsKICAgICAgICBiYWxhbmNlc1ttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXNbdG9dICs9IGFtb3VudDsKICAgICAgICAvLyAuLi4KICAgIH0KfQ==">open in Remix</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br>pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.4</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 没有足够的资金用于转账。要求 `requested`。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 但只有 `available` 可用。</span><br><span class="hljs-function">error <span class="hljs-title">NotEnoughFunds</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> requested, <span class="hljs-built_in">uint</span> available</span>)</span>;<br><br>contract Token &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) balances;<br>    <span class="hljs-function">function <span class="hljs-title">transfer</span>(<span class="hljs-params">address to, <span class="hljs-built_in">uint</span> amount</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-built_in">uint</span> balance = balances[msg.sender];<br>        <span class="hljs-keyword">if</span> (balance &lt; amount)<br>            <span class="hljs-function">revert <span class="hljs-title">NotEnoughFunds</span>(<span class="hljs-params">amount, balance</span>)</span>;<br>        balances[msg.sender] -= amount;<br>        balances[to] += amount;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多信息请参阅合约章节中的 <a href="https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors">错误和恢复语句</a>。</p><h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-struct-types"></a></h2><p>结构类型是可以将几个变量分组的自定义类型（参阅类型章节中的 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#structs">结构体</a>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQmFsbG90IHsKICAgIHN0cnVjdCBWb3RlciB7IC8vIOe7k+aehAogICAgICAgIHVpbnQgd2VpZ2h0OwogICAgICAgIGJvb2wgdm90ZWQ7CiAgICAgICAgYWRkcmVzcyBkZWxlZ2F0ZTsKICAgICAgICB1aW50IHZvdGU7CiAgICB9Cn0=">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Ballot &#123;<br>    <span class="hljs-keyword">struct</span> Voter &#123; <span class="hljs-comment">// 结构</span><br>        <span class="hljs-built_in">uint</span> weight;<br>        <span class="hljs-built_in">bool</span> voted;<br>        address <span class="hljs-built_in">delegate</span>;<br>        <span class="hljs-built_in">uint</span> vote;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型<a href="https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#structure-enum-types"></a></h2><p>枚举可用来创建由一定数量的’常量值’构成的自定义类型（参阅类型章节中的 <a href="https://docs.soliditylang.org/zh-cn/latest/types.html#enums">枚举类型</a>）。</p><p><a href="https://remix.ethereum.org/?#language=solidity&amp;version=0.8.24&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgUHVyY2hhc2UgewogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgSW5hY3RpdmUgfSAvLyDmnprkuL4KfQ==">open in Remix</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: GPL-3.0</span><br><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.0</span> &lt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    <span class="hljs-keyword">enum</span> State &#123; Created, Locked, Inactive &#125; <span class="hljs-comment">// 枚举</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链智能合约语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州科贸区块链智能合约教程-食品溯源</title>
    <link href="/2025/07/03/%E5%B9%BF%E5%B7%9E%E7%A7%91%E8%B4%B8%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-1/"/>
    <url>/2025/07/03/%E5%B9%BF%E5%B7%9E%E7%A7%91%E8%B4%B8%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%95%99%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<p>源码</p><p> <a href="https://zhengcookie.github.io/file/区块链/智能合约/FoodTrace/Distributor.sol">Distributor.sol</a> </p><p> <a href="https://zhengcookie.github.io/file/区块链/智能合约/FoodTrace/FoodInfoItem.sol">FoodInfoItem.sol</a>  </p><p><a href="https://zhengcookie.github.io//file/区块链/智能合约/FoodTrace/Producer.sol">Producer.sol</a> </p><p><a href="https://zhengcookie.github.io/file/区块链/智能合约/FoodTrace/Retailer.sol">Retailer.sol</a>  </p><p><a href="https://zhengcookie.github.io/file/区块链/智能合约/FoodTrace/Roles.sol">Roles.sol</a> </p><p><a href="https://zhengcookie.github.io/file/区块链/智能合约/FoodTrace/Trace.sol">Trace.sol</a> </p><p>智能合约功能需求文档:</p><ol><li><p>具备合约用户管理功能，包括创建用户以及查询用户信息的功能，与其相关联的需要具备用户权限功能。</p></li><li><p>具备生产订单管理功能，包括创建与查询订单功能，在创建生产订单功能中限制该功能只能具有生产权限的人员使用，并且加入订单创建时需要与产业链的总订单信息，从而与产业链的其他业务关联。</p></li><li><p>具备分销订单管理功能，包括创建与查询订单功能，在创建收购订单功能中限制该功能只能具有分销权限的人员使用，并且加入订单</p></li></ol><h1 id="BsYGX">经销商</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.25</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Roles.sol&quot;</span>;<br><br><span class="hljs-comment">//经销商</span><br><br>contract Distributor &#123;<br>    using Roles <span class="hljs-keyword">for</span> Roles.Role;<br><br>    event <span class="hljs-title function_">DistributorAdded</span><span class="hljs-params">(address indexed account)</span>;<br>    event <span class="hljs-title function_">DistributorRemoved</span><span class="hljs-params">(address indexed account)</span>;<br><br>    Roles.Role <span class="hljs-keyword">private</span> _distributors;<br><br>    constructor(address distributor) <span class="hljs-keyword">public</span> &#123;<br>        _addDistributor(distributor);<br>    &#125;<br><br>    modifier <span class="hljs-title function_">onlyDistributor</span><span class="hljs-params">()</span> &#123;<br>        require(<br>            isDistributor(msg.sender),<br>            <span class="hljs-string">&quot;DistributorRole: caller does not have the Distributor role&quot;</span><br>        );<br>        _;<br>    &#125;<br><br>    function <span class="hljs-title function_">isDistributor</span><span class="hljs-params">(address account)</span> <span class="hljs-keyword">public</span> view <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span> &#123;<br>        <span class="hljs-keyword">return</span> _distributors.has(account);<br>    &#125;<br><br>    function <span class="hljs-title function_">addDistributor</span><span class="hljs-params">(address account)</span> <span class="hljs-keyword">public</span> onlyDistributor &#123;<br>        _addDistributor(account);<br>    &#125;<br><br>    function <span class="hljs-title function_">renounceDistributor</span><span class="hljs-params">()</span> <span class="hljs-keyword">public</span> &#123;<br>        _removeDistributor(msg.sender);<br>    &#125;<br><br>    function <span class="hljs-title function_">_addDistributor</span><span class="hljs-params">(address account)</span> internal &#123;<br>        _distributors.add(account);<br>        emit <span class="hljs-title function_">DistributorAdded</span><span class="hljs-params">(account)</span>;<br>    &#125;<br><br>    function <span class="hljs-title function_">_removeDistributor</span><span class="hljs-params">(address account)</span> internal &#123;<br>        _distributors.remove(account);<br>        emit <span class="hljs-title function_">DistributorRemoved</span><span class="hljs-params">(account)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段Solidity代码定义了一个名为<code>Distributor</code>的智能合约，该合约主要用于管理具有“经销商”角色的账户。以下是代码的详细解析：</p><h3 id="VnCyS">导入依赖</h3><ul><li><code>import &quot;./Roles.sol&quot;;</code>：这行导入了另一个名为<code>Roles</code>的合约，假设这个合约提供了一些关于角色管理的功能，比如添加、移除和检查某个地址是否拥有特定的角色。</li></ul><h3 id="s6lMe">合约声明</h3><ul><li><code>contract Distributor &#123; ... &#125;</code>：定义了一个新的合约<code>Distributor</code>。</li></ul><h3 id="hNR7o">使用库</h3><ul><li><code>using Roles for Roles.Role;</code>：这句表示将<code>Roles</code>库的方法直接应用到<code>Roles.Role</code>类型上，使得可以更简洁地使用这些方法（例如直接调用<code>_distributors.add(account)</code>）。</li></ul><h3 id="fllmQ">事件</h3><ul><li><code>event DistributorAdded(address indexed account);</code> 和 <code>event DistributorRemoved(address indexed account);</code>：这两个事件分别在成功添加或移除一个经销商时被触发，其中<code>indexed</code>关键字意味着可以在日志中快速查找与特定账户相关的事件。</li></ul><h3 id="v3Hnq">私有变量</h3><ul><li><code>Roles.Role private _distributors;</code>：这是一个私有的角色列表，用来存储所有经销商的地址。</li></ul><h3 id="MWuyd">构造函数</h3><ul><li><code>constructor(address distributor) public &#123; _addDistributor(distributor); &#125;</code>：当创建此合同时，需要指定一个初始的经销商，并自动将其加入到经销商名单中。</li></ul><h3 id="rXX62">修饰符</h3><ul><li><code>modifier onlyDistributor() &#123; ... &#125;</code>：这是一个自定义的访问控制修饰符，确保只有当前是经销商的账号才能执行某些操作。如果不是经销商，则会抛出错误信息。</li></ul><h3 id="vcrj3">公共函数</h3><ul><li><code>function isDistributor(address account) public view returns (bool) &#123; ... &#125;</code>：允许任何人查询给定地址是否为经销商。</li><li><code>function addDistributor(address account) public onlyDistributor &#123; ... &#125;</code>：允许现有经销商添加新的经销商。注意这里使用了<code>onlyDistributor</code>修饰符来限制访问权限。</li><li><code>function renounceDistributor() public &#123; ... &#125;</code>：允许任何经销商放弃自己的经销商身份。</li></ul><h3 id="yp53H">内部函数</h3><ul><li><code>_addDistributor(address account) internal &#123; ... &#125;</code> 和 <code>_removeDistributor(address account) internal &#123; ... &#125;</code>：这两个内部函数分别用于向经销商列表中添加或移除地址，并且在这两个动作完成后都会发出相应的事件通知。</li></ul><h3 id="Rvqqb">总结</h3><p>整体来看，这个<code>Distributor</code>合约实现了一个简单的角色管理系统，专注于管理经销商的身份认证。它通过引入外部的<code>Roles</code>库简化了角色管理逻辑，同时也提供了必要的功能来维护一个动态更新的经销商列表。这样的设计常见于需要区分不同用户权限的应用场景，如供应链管理、会员制服务等。</p><h1 id="fJ5Sz">食品信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java">pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.5</span><span class="hljs-number">.0</span>;<br>pragma experimental ABIEncoderV2;<br><br>contract FoodInfoItem &#123;<br>    string _currentTraceName;<br>    string _name;<br>    address _owner;<br>    uint8 _quality;<br>    uint8 _status;<br>    string[] _traceName;<br>    uint256[] _timestamp;<br>    address[] _traceAddress;<br>    uint8[] _traceQuality;<br><br>    <span class="hljs-comment">//生产食物</span><br>    constructor(<br>        string name,<br>        string traceName,<br>        uint8 quality,<br>        address producer<br>    ) <span class="hljs-keyword">public</span> &#123;<br>        _currentTraceName = traceName;<br>        _name = name;<br>        _owner = msg.sender;<br>        _quality = quality;<br>        _status = <span class="hljs-number">0</span>;<br>        _traceName.push(traceName);<br>        _timestamp.push(now);<br>        _traceAddress.push(producer);<br>        _traceQuality.push(quality);<br>    &#125;<br><br>    function <span class="hljs-title function_">addTraceInfoByDistributor</span><span class="hljs-params">(</span><br><span class="hljs-params">        string traceName,</span><br><span class="hljs-params">        address distributor,</span><br><span class="hljs-params">        uint8 quality</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span> &#123;<br>        require(_status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;status must be producing&quot;</span>);<br>        require(_owner == msg.sender, <span class="hljs-string">&quot;only trace contract can invoke&quot;</span>);<br>        _timestamp.push(now);<br>        _traceName.push(traceName);<br>        _currentTraceName = traceName;<br>        _traceAddress.push(distributor);<br>        _quality = quality;<br>        _traceQuality.push(_quality);<br>        _status = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    function <span class="hljs-title function_">addTraceInfoByRetailer</span><span class="hljs-params">(</span><br><span class="hljs-params">        string traceName,</span><br><span class="hljs-params">        address retailer,</span><br><span class="hljs-params">        uint8 quality</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span> &#123;<br>        <span class="hljs-comment">/* 【9】请在此注释后作答，勿删除此注释*/</span><br>        <span class="hljs-comment">//补充食品分销方法</span><br>        require(_status == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;status must be distributor&quot;</span>);<br>        require(_owner == msg.sender, <span class="hljs-string">&quot;only trace contract can invoke&quot;</span>);<br>        _timestamp.push(now);<br>        _traceName.push(traceName);<br>        _currentTraceName = traceName;<br>        _traceAddress.push(retailer);<br>        _quality = quality;<br>        _traceQuality.push(_quality);<br>        _status = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>     <br>    &#125;<br><br>    function <span class="hljs-title function_">getTraceInfo</span><span class="hljs-params">()</span><br>        <span class="hljs-keyword">public</span><br>        constant<br>        <span class="hljs-title function_">returns</span> <span class="hljs-params">(</span><br><span class="hljs-params">            uint256[],</span><br><span class="hljs-params">            string[],</span><br><span class="hljs-params">            address[],</span><br><span class="hljs-params">            uint8[]</span><br><span class="hljs-params">        )</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (_timestamp, _traceName, _traceAddress, _traceQuality);<br>    &#125;<br><br>    function <span class="hljs-title function_">getFood</span><span class="hljs-params">()</span><br>        <span class="hljs-keyword">public</span><br>        constant<br>        <span class="hljs-title function_">returns</span> <span class="hljs-params">(</span><br><span class="hljs-params">            uint256,</span><br><span class="hljs-params">            string,</span><br><span class="hljs-params">            string,</span><br><span class="hljs-params">            string,</span><br><span class="hljs-params">            address,</span><br><span class="hljs-params">            uint8</span><br><span class="hljs-params">        )</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (<br>            _timestamp[<span class="hljs-number">0</span>],<br>            _traceName[<span class="hljs-number">0</span>],<br>            _name,<br>            _currentTraceName,<br>            _traceAddress[<span class="hljs-number">0</span>],<br>            _quality<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段Solidity代码定义了一个名为<code>FoodInfoItem</code>的智能合约，用于追踪食品从生产到分销再到零售的过程。以下是对合约中各个部分的详细解析：</p><h3 id="LMdE5">版本声明和特性启用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity &gt;=0.4.22 &lt;0.5.0;<br>pragma experimental ABIEncoderV2;<br></code></pre></td></tr></table></figure><ul><li>第一行声明了合约支持的Solidity版本范围，合约需要编译器版本在0.4.22和0.5.0之间。</li><li>第二行启用了<code>ABIEncoderV2</code>实验特性，这允许结构体和数组的返回。</li></ul><h3 id="dhvJT">合约定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">contract FoodInfoItem &#123;<br></code></pre></td></tr></table></figure><ul><li>这里定义了一个名为<code>FoodInfoItem</code>的新合约。</li></ul><h3 id="WnZkq">状态变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">string _currentTraceName;<br>string _name;<br>address _owner;<br>uint8 _quality;<br>uint8 _status;<br>string[] _traceName;<br>uint256[] _timestamp;<br>address[] _traceAddress;<br>uint8[] _traceQuality;<br></code></pre></td></tr></table></figure><ul><li>这些是合约的私有状态变量，用于存储食品信息，包括名称、所有者、质量、状态、追踪过程中的名称、时间戳、地址和质量。</li></ul><h3 id="vGMng">构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">constructor(<br>    string name,<br>    string traceName,<br>    uint8 quality,<br>    address producer<br>) <span class="hljs-keyword">public</span> &#123;<br>    <span class="hljs-comment">// 初始化状态变量...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数在创建合约实例时执行，用于初始化状态变量。</li></ul><h3 id="cpo6g">添加追踪信息的方法（由分销商调用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">addTraceInfoByDistributor</span><span class="hljs-params">(</span><br><span class="hljs-params">    string traceName,</span><br><span class="hljs-params">    address distributor,</span><br><span class="hljs-params">    uint8 quality</span><br><span class="hljs-params">)</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span> &#123;<br>    <span class="hljs-comment">// 添加追踪信息...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该方法允许分销商添加食品追踪信息，并更新状态变量。</li></ul><h3 id="Uqtnx">添加追踪信息的方法（由零售商调用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">addTraceInfoByRetailer</span><span class="hljs-params">(</span><br><span class="hljs-params">    string traceName,</span><br><span class="hljs-params">    address retailer,</span><br><span class="hljs-params">    uint8 quality</span><br><span class="hljs-params">)</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span> &#123;<br>    <span class="hljs-comment">// 补充食品分销方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该方法允许零售商添加食品追踪信息，并更新状态变量。</li></ul><h3 id="jT0jN">获取追踪信息的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">getTraceInfo</span><span class="hljs-params">()</span><br>    <span class="hljs-keyword">public</span><br>    constant<br>    <span class="hljs-title function_">returns</span> <span class="hljs-params">(</span><br><span class="hljs-params">        uint256[],</span><br><span class="hljs-params">        string[],</span><br><span class="hljs-params">        address[],</span><br><span class="hljs-params">        uint8[]</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// 返回追踪信息...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该方法返回食品的完整追踪信息。</li></ul><h3 id="vNWca">获取食品信息的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">getFood</span><span class="hljs-params">()</span><br>    <span class="hljs-keyword">public</span><br>    constant<br>    <span class="hljs-title function_">returns</span> <span class="hljs-params">(</span><br><span class="hljs-params">        uint256,</span><br><span class="hljs-params">        string,</span><br><span class="hljs-params">        string,</span><br><span class="hljs-params">        string,</span><br><span class="hljs-params">        address,</span><br><span class="hljs-params">        uint8</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// 返回食品的初始信息...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该方法返回食品的初始信息，如生产时的时间戳、追踪名称、食品名称、当前追踪名称、生产者地址和质量。</li></ul><h3 id="E4CQL">注意事项</h3><ul><li>合约中使用了<code>now</code>，它在Solidity 0.5.0之后被替换为<code>block.timestamp</code>，用于获取当前区块的时间戳。</li><li><code>require</code>语句用于验证调用条件，确保合约状态和调用者权限的正确性。</li></ul><p>这个合约是一个基本的食品安全追踪系统，它允许追踪食品从生产到分销再到零售的每一个步骤。通过区块链技术，可以确保这些信息的不可篡改性和透明性。</p><h1 id="P513C">角色库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.25</span>;<br>library Roles &#123;<br>    struct Role &#123;<br>        mapping(address =&gt; bool) bearer;<br>    &#125;<br><br>    function <span class="hljs-title function_">add</span><span class="hljs-params">(Role storage role, address account)</span> internal &#123;<br>        require(!has(role,account),<span class="hljs-string">&quot;Role: has a account！&quot;</span>);<br>        role.bearer[account] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    function <span class="hljs-title function_">remove</span><span class="hljs-params">(Role storage role, address account)</span> internal &#123;<br>        require(has(role,account),<span class="hljs-string">&quot;Role: has not a account！&quot;</span>);<br>        role.bearer[account] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    function <span class="hljs-title function_">has</span><span class="hljs-params">(Role storage role, address account)</span><br>        internal<br>        view<br>        <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span><br>    &#123;<br>        require(account != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;Role: has a zero address&quot;</span>);<br>        <span class="hljs-keyword">return</span> role.bearer[account];<br>    &#125;<br>      <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这段Solidity代码定义了一个名为<code>Roles</code>的库，它包含了一个用于管理角色的简单数据结构和一些用于操作这些角色的函数。以下是对这段代码的详细解析：</p><h3 id="z9Y4U">库定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">library Roles &#123;<br></code></pre></td></tr></table></figure><ul><li>这里定义了一个名为<code>Roles</code>的库，库在Solidity中是一种可以重用的代码方式，它可以被其他合约调用。</li></ul><h3 id="azj4P">角色结构体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">struct Role &#123;<br>    mapping(address =&gt; bool) bearer;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Role</code>是一个结构体，它包含了一个映射（mapping），该映射将地址映射到布尔值。这里的<code>bearer</code>映射用于记录拥有特定角色的账户。</li></ul><h3 id="BBLst">添加角色函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">add</span><span class="hljs-params">(Role storage role, address account)</span> internal &#123;<br>    require(!has(role, account), <span class="hljs-string">&quot;Role: has a account！&quot;</span>);<br>    role.bearer[account] = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>add</code>函数用于向给定的角色（<code>role</code>）中添加一个账户（<code>account</code>）。如果账户已经拥有角色，则会抛出错误。<code>internal</code>关键字意味着这个函数只能在当前库或继承了这个库的合约内部调用。</li></ul><h3 id="P48Or">移除角色函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">remove</span><span class="hljs-params">(Role storage role, address account)</span> internal &#123;<br>    require(has(role, account), <span class="hljs-string">&quot;Role: has not a account！&quot;</span>);<br>    role.bearer[account] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>remove</code>函数用于从给定的角色中移除一个账户。如果账户没有这个角色，则会抛出错误。</li></ul><h3 id="cGDw8">检查角色函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">has</span><span class="hljs-params">(Role storage role, address account)</span><br>    internal<br>    view<br>    <span class="hljs-title function_">returns</span> <span class="hljs-params">(bool)</span><br>&#123;<br>    require(account != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;Role: has a zero address&quot;</span>);<br>    <span class="hljs-keyword">return</span> role.bearer[account];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>has</code>函数用于检查一个账户是否拥有特定的角色。它返回一个布尔值，指示账户是否具有该角色。同时，它会检查账户地址是否为零地址，如果是，则抛出错误。</li></ul><h3 id="LeixZ">注意事项</h3><ul><li><code>require</code>语句用于确保函数调用的条件被满足，如果没有，则回滚交易。</li><li><code>internal</code>关键字意味着函数只能在内部调用，外部无法直接通过合约接口调用。</li><li><code>view</code>关键字表示该函数不会改变合约的状态。</li></ul><p>这个库可以被其他合约用来管理不同的角色，例如，一个去中心化应用（DApp）可能会使用这个库来管理管理员、用户、审核员等不同的角色，为不同的角色赋予不同的权限。这样的设计使得权限管理变得更加模块化和可复用。</p><h1 id="pQcqH">食品安全追踪</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java">pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.7</span><span class="hljs-number">.0</span>;<br>pragma experimental ABIEncoderV2;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./FoodInfoItem.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Distributor.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Producer.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Retailer.sol&quot;</span>;<br><br><br><span class="hljs-comment">//食品工厂合约，负责具体食品溯源信息的生成</span><br>contract Trace is Producer, Distributor, Retailer&#123;<br><br>        mapping (uint256 =&gt; address)  foods;<span class="hljs-comment">//食品溯源id到具体食品溯源合约的映射表</span><br>        uint[]  foodList;<br><br>        <span class="hljs-comment">//构造函数</span><br>        constructor(address producer, address distributor, address retailer) <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(producer)</span> <br>Distributor(distributor) <br>Retailer(retailer)&#123;<br><br>        &#125;<br>        <span class="hljs-comment">//生成食品溯源信息接口</span><br>        <span class="hljs-comment">//只有Producer能调用</span><br>        <span class="hljs-comment">//name 食品名称</span><br>        <span class="hljs-comment">//traceNumber 食品溯源id</span><br>        <span class="hljs-comment">//traceName 当前用户名称</span><br>    <span class="hljs-comment">//quality 当前食品质量</span><br>        function <span class="hljs-title function_">newFood</span><span class="hljs-params">(string name, uint256 traceNumber, string traceName, uint8 quality)</span> <br><span class="hljs-keyword">public</span> onlyProducer <span class="hljs-title function_">returns</span><span class="hljs-params">(address)</span><br>        &#123;<br>            require(foods[traceNumber] == address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;traceNumber already exist&quot;</span>);<br>            <span class="hljs-type">FoodInfoItem</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoodInfoItem</span>(name, traceName, quality, msg.sender);<br>            foods[traceNumber] = food;<br>            foodList.push(traceNumber);<br>            <span class="hljs-keyword">return</span> food;<br>        &#125;<br><br>        <span class="hljs-comment">//食品分销过程中增加溯源信息的接口</span><br>        <span class="hljs-comment">//只有Distributor能调用</span><br>        <span class="hljs-comment">//traceNumber 食品溯源id</span><br>        <span class="hljs-comment">//traceName 当前用户名称</span><br>        <span class="hljs-comment">//quality 当前食品质量</span><br>        function <span class="hljs-title function_">addTraceInfoByDistributor</span><span class="hljs-params">(uint256 traceNumber, string traceName, uint8 quality)</span> <br><span class="hljs-keyword">public</span> onlyDistributor <span class="hljs-title function_">returns</span><span class="hljs-params">(bool)</span> &#123;<br>            <span class="hljs-comment">/* 【8】请在此注释后作答，勿删除此注释*/</span><br>            <span class="hljs-comment">// 补充完整食品分销过程增加溯源信息的接口</span><br>          require(foods[traceNumber] != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;traceNumber does not exist&quot;</span>);<br>            <span class="hljs-keyword">return</span> FoodInfoItem(foods[traceNumber]).addTraceInfoByDistributor(traceName, msg.sender, quality);<br>           <br>        &#125;<br><br>        <span class="hljs-comment">//食品出售过程中增加溯源信息的接口</span><br>        <span class="hljs-comment">//只有Retailer能调用</span><br>        <span class="hljs-comment">//traceNumber 食品溯源id</span><br>        <span class="hljs-comment">//traceName 当前用户名称</span><br>        <span class="hljs-comment">//quality 当前食品质量</span><br>        function <span class="hljs-title function_">addTraceInfoByRetailer</span><span class="hljs-params">(uint256 traceNumber, string traceName, uint8 quality)</span> <br><span class="hljs-keyword">public</span> onlyRetailer <span class="hljs-title function_">returns</span><span class="hljs-params">(bool)</span> &#123;<br>            require(foods[traceNumber] != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;traceNumber does not exist&quot;</span>);<br>            <span class="hljs-keyword">return</span> FoodInfoItem(foods[traceNumber]).addTraceInfoByRetailer(traceName, msg.sender, quality);<br>        &#125;<br><br>        <span class="hljs-comment">//获取食品溯源信息接口</span><br>        <span class="hljs-comment">//string[] 保存食品流转过程中各个阶段的相关信息</span><br>        <span class="hljs-comment">//address[] 保存食品流转过程各个阶段的用户地址信息（和用户一一对应）</span><br>        <span class="hljs-comment">//uint8[] 保存食品流转过程中各个阶段的状态变化</span><br>        function <span class="hljs-title function_">getTraceInfo</span><span class="hljs-params">(uint256 traceNumber)</span> <span class="hljs-keyword">public</span> constant <span class="hljs-title function_">returns</span><span class="hljs-params">(uint[], string[], address[], uint8[])</span> &#123;<br>            <span class="hljs-comment">/* 【12】请在此注释后作答，勿删除此注释*/</span><br>            require(foods[traceNumber] != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;traceNumber does not exist&quot;</span>);<br>            <span class="hljs-keyword">return</span> FoodInfoItem(foods[traceNumber]).getTraceInfo();<br>        &#125;<br><br>        function <span class="hljs-title function_">getFood</span><span class="hljs-params">(uint256 traceNumber)</span> <span class="hljs-keyword">public</span> constant <span class="hljs-title function_">returns</span><span class="hljs-params">(uint, string, string, string, address, uint8)</span> &#123;<br>            <span class="hljs-comment">/* 【9】请在此注释后作答，勿删除此注释*/</span><br>            <span class="hljs-comment">//补充食品信息获取接口</span><br>            require(foods[traceNumber] != address(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;traceNumber does not exist&quot;</span>);<br>            <span class="hljs-keyword">return</span> FoodInfoItem(foods[traceNumber]).getFood();<br>         <br>        &#125;<br><br>        function <span class="hljs-title function_">getAllFood</span><span class="hljs-params">()</span> <span class="hljs-keyword">public</span> constant <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint[])</span> &#123;<br>            <span class="hljs-keyword">return</span> foodList;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段Solidity代码定义了一个名为<code>Trace</code>的智能合约，该合约继承了<code>Producer</code>、<code>Distributor</code>和<code>Retailer</code>三个接口（或合约），并实现了一个食品安全追踪系统。以下是该合约的详细解析：</p><h3 id="esbNV">合约导入和版本声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.7</span><span class="hljs-number">.0</span>;<br>pragma experimental ABIEncoderV2;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./FoodInfoItem.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Distributor.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Producer.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Retailer.sol&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>声明了合约支持的Solidity版本范围，并启用了<code>ABIEncoderV2</code>实验特性。</li><li>导入了<code>FoodInfoItem</code>、<code>Distributor</code>、<code>Producer</code>和<code>Retailer</code>合约，这些合约可能包含了与食品安全追踪相关的接口和功能。</li></ul><h3 id="sflM7">合约定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">contract Trace is Producer, Distributor, Retailer &#123;<br></code></pre></td></tr></table></figure><ul><li>定义了一个名为<code>Trace</code>的合约，该合约继承了<code>Producer</code>、<code>Distributor</code>和<code>Retailer</code>，这意味着<code>Trace</code>合约具有这三个合约的所有功能。</li></ul><h3 id="Z0hWn">状态变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mapping (uint256 =&gt; address) foods;<br>uint[] foodList;<br></code></pre></td></tr></table></figure><ul><li><code>foods</code>是一个映射，将食品溯源ID映射到具体的<code>FoodInfoItem</code>合约地址。</li><li><code>foodList</code>是一个数组，存储了所有的食品溯源ID。</li></ul><h3 id="EdNOl">构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">constructor(address producer, address distributor, address retailer)<br>    <span class="hljs-keyword">public</span><br>    <span class="hljs-title function_">Producer</span><span class="hljs-params">(producer)</span><br>    Distributor(distributor)<br>    Retailer(retailer) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数接收生产者、分销商和零售商的地址，并调用相应的基础合约构造函数。</li></ul><h3 id="SGaJE">生成食品溯源信息接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">newFood</span><span class="hljs-params">(string name, uint256 traceNumber, string traceName, uint8 quality)</span><br>    <span class="hljs-keyword">public</span><br>    onlyProducer<br>    <span class="hljs-title function_">returns</span><span class="hljs-params">(address)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数允许生产者创建新的食品溯源信息，并返回新创建的<code>FoodInfoItem</code>合约地址。</li></ul><h3 id="zYFbD">食品分销过程中增加溯源信息的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">addTraceInfoByDistributor</span><span class="hljs-params">(uint256 traceNumber, string traceName, uint8 quality)</span><br>    <span class="hljs-keyword">public</span><br>    onlyDistributor<br>    <span class="hljs-title function_">returns</span><span class="hljs-params">(bool)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数允许分销商为指定的食品溯源ID添加分销信息。</li></ul><h3 id="AlnU4">食品出售过程中增加溯源信息的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">addTraceInfoByRetailer</span><span class="hljs-params">(uint256 traceNumber, string traceName, uint8 quality)</span><br>    <span class="hljs-keyword">public</span><br>    onlyRetailer<br>    <span class="hljs-title function_">returns</span><span class="hljs-params">(bool)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数允许零售商为指定的食品溯源ID添加零售信息。</li></ul><h3 id="tSCpV">获取食品溯源信息接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">getTraceInfo</span><span class="hljs-params">(uint256 traceNumber)</span><br>    <span class="hljs-keyword">public</span><br>    constant<br>    <span class="hljs-title function_">returns</span><span class="hljs-params">(uint[], string[], address[], uint8[])</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数返回指定食品溯源ID的完整追踪信息。</li></ul><h3 id="QT2SZ">获取食品信息的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">getFood</span><span class="hljs-params">(uint256 traceNumber)</span><br>    <span class="hljs-keyword">public</span><br>    constant<br>    <span class="hljs-title function_">returns</span><span class="hljs-params">(uint, string, string, string, address, uint8)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数返回指定食品溯源ID的食品初始信息。</li></ul><h3 id="wXVaD">获取所有食品溯源ID</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">function <span class="hljs-title function_">getAllFood</span><span class="hljs-params">()</span> <span class="hljs-keyword">public</span> constant <span class="hljs-title function_">returns</span> <span class="hljs-params">(uint[])</span> &#123;<br>    <span class="hljs-keyword">return</span> foodList;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数返回所有食品溯源ID的列表。</li></ul><h3 id="YggQ6">注意事项</h3><ul><li>合约中使用了<code>onlyProducer</code>、<code>onlyDistributor</code>和<code>onlyRetailer</code>这些修饰符，它们应该在继承的合约中定义，以确保只有对应角色的地址能够调用特定的函数。</li><li><code>require</code>语句用于验证食品溯源ID的存在性和唯一性。</li></ul><p>这个<code>Trace</code>合约通过整合生产者、分销商和零售商的功能，提供了一个完整的食品安全追踪解决方案。它通过区块链技术保证了食品信息的不篡改性，增加了整个食品供应链的透明度。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链赛题智能合约</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是区块链?</title>
    <link href="/2025/07/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2025/07/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>【网上精品】</p><p>【【不看后悔系列】6分钟，用人话讲清楚区块链！-哔哩哔哩】 <a href="https://b23.tv/ptt6EZg">https://b23.tv/ptt6EZg</a></p><p>【5分钟搞懂“区块链”！看完妈妈再也不用担心我被骗了！ &lt;举人说16&gt;】 <a href="https://www.bilibili.com/video/BV1QE411h7uH/?share_source=copy_web">https://www.bilibili.com/video/BV1QE411h7uH/?share_source=copy_web</a></p><p>【本人录制】</p><p>【小白谈区块链是什么】 <a href="https://www.bilibili.com/video/BV1pLuRzPE3D/?share_source=copy_web&amp;vd_source=5cd0518c8247d6b502b53235ae5f014c">https://www.bilibili.com/video/BV1pLuRzPE3D/?share_source=copy_web&amp;vd_source=5cd0518c8247d6b502b53235ae5f014c</a></p><h1 id="专业说法"><a href="#专业说法" class="headerlink" title="专业说法"></a>专业说法</h1><h2 id="账本技术【前提】"><a href="#账本技术【前提】" class="headerlink" title="账本技术【前提】"></a>账本技术【前提】</h2><h3 id="1-集中式账本-中心化，通过单个节点存储账本"><a href="#1-集中式账本-中心化，通过单个节点存储账本" class="headerlink" title="1.集中式账本: 中心化，通过单个节点存储账本"></a>1.集中式账本: 中心化，通过单个节点存储账本</h3><h4 id="时代-场景"><a href="#时代-场景" class="headerlink" title="时代    场景"></a>时代    场景</h4><p>古代    店铺记账</p><p>现代    交易平台</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>保密、效率、安全</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>风险集中</p><h3 id="2-分布式账本-去中心化，通过多节点传播存储账本"><a href="#2-分布式账本-去中心化，通过多节点传播存储账本" class="headerlink" title="2.分布式账本:去中心化，通过多节点传播存储账本"></a>2.分布式账本:去中心化，通过多节点传播存储账本</h3><h4 id="时代-场景-1"><a href="#时代-场景-1" class="headerlink" title="时代                     场景"></a>时代                     场景</h4><p>古代【雏形】            大商号分号各自记账、定期对账【效率低】</p><p>现代【完善】            交易平台and第三方记账</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>可追溯、不可篡改，透明可验证</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>隐私性、安全性、数据确定延迟性。</p><h2 id="什么是区块链？"><a href="#什么是区块链？" class="headerlink" title="什么是区块链？"></a>什么是区块链？</h2><p>区块链是一种创新的分布式账本技术，通过区块、链、记账者、共识机制、分布式账本和P2P网络的协同作用，实现安全、透明和去中心化的交易记录。以下是区块链的核心要素及其作用：</p><ol><li><strong>区块</strong>：每个区块包含多笔交易记录，形成一个独立的交易容器。新区块的创建需要包含前一区块的哈希值，确保链式结构的连续性。</li><li><strong>链</strong>：通过哈希指针连接相邻区块，形成不可篡改的链式结构。每个区块的哈希值被记录在下一个区块中，确保数据完整性和安全性。</li><li><strong>记账者（矿工/验证者）</strong>：负责验证和打包交易，获得手续费和系统奖励。他们的工作激励了网络的运行和维护。</li><li><strong>共识机制</strong>：如工作量证明（PoW）和权益证明（PoS），确保网络中所有节点对交易达成一致，防止双重支付和恶意攻击。</li><li><strong>分布式账本</strong>：所有节点共享完整的账本副本，确保数据去中心化，避免单点故障，提高抗审查能力。</li><li><strong>P2P网络</strong>：节点间直接通信，无中央服务器，增强网络的健壮性和安全性。<br>区块链的特点包括不可篡改、公开透明、可靠和去中心化，这些特性使其在金融、供应链管理等领域具有广泛应用潜力。尽管在技术细节上还有待深入，但其基本结构和机制已经清晰。</li></ol><h1 id="通俗说法"><a href="#通俗说法" class="headerlink" title="通俗说法"></a>通俗说法</h1><p>区块:    每次交易打包的账本</p><p>链:    通过顺序，将俩个相邻的账本联系起来，上一次的账本交易的数据就是下一次账本的初始数据，下一次的账本交易的数据就是下下一次账本的初始数据</p><p>记账者:  用于记录账本，获取手续费与系统奖励</p><p>共识机制：按照顺序，选出记账者</p><p>分布式账本: 区块链采用去中心化[非集中账本]</p><p>p2p网络路由：每个节点都有同步的账本</p><p>区块链，就是节点共同维护的交易账本，具有不可随意篡改，公开透明，账目可靠和去中心化的特点。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/07/03/hello-world/"/>
    <url>/2025/07/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>ruoyi-web-vue3-ts</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>ruoyi-web-vue3-ts</p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[/* source/css/progress.css */#reading-progress {    position: fixed;    left: 0;    top: 0;    height: 3px;    width: 0;    background: linear-gradient(90deg, #42a5f5, #7e57c2);    z-index: 2147483647;    /* 保证在最上层 */    transition: width .15s ease-out;}body.has-progressbar {    padding-top: 0;}.post-reading-meta {    font-size: .92rem;    color: #666;    margin: 8px 0 14px}.post-reading-meta span {    background: #f6f6f6;    border-radius: 6px;    padding: 4px 8px}]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>link</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[// source/js/reading-progress.js(function() {    const bar = document.createElement('div');    bar.id = 'reading-progress';    document.body.appendChild(bar);    document.body.classList.add('has-progressbar');    const set = () => {        const doc = document.documentElement;        const scrolled = (doc.scrollTop || document.body.scrollTop);        const height = (doc.scrollHeight - doc.clientHeight);        const percent = height > 0 ? (scrolled / height) * 100 : 0;        bar.style.width = percent + '%';    };    window.addEventListener('scroll', set, { passive: true });    window.addEventListener('resize', set);    document.addEventListener('DOMContentLoaded', set);    set();})();]]></content>
    
  </entry>
  
  
  
</search>
